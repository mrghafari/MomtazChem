import express, { type Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import bcrypt from "bcryptjs";
import multer from "multer";
import path from "path";
import fs from "fs";
import puppeteer from "puppeteer";
import nodemailer from "nodemailer";
import crypto from "crypto";
import { emailService } from "./email-service";
import { storage } from "./storage";
import { insertLeadSchema, insertLeadActivitySchema } from "@shared/schema";
import { insertContactSchema, insertShowcaseProductSchema, showcaseProducts } from "@shared/showcase-schema";
import { simpleCustomerStorage } from "./simple-customer-storage";
import { shopStorage } from "./shop-storage";
import { customerStorage } from "./customer-storage";
import { customerAddressStorage } from "./customer-address-storage";
import { emailStorage } from "./email-storage";
import { crmStorage } from "./crm-storage";
import { customerCommunicationStorage } from "./customer-communication-storage";
import { crmDb } from "./crm-db";
import { smsStorage } from "./sms-storage";
import { SimpleSmsStorage, simpleSmsStorage, simpleSmsDb } from "./simple-sms-storage";
import { widgetRecommendationStorage } from "./widget-recommendation-storage";
import { orderManagementStorage } from "./order-management-storage";
import { walletStorage } from "./wallet-storage";
import { requireDepartment, attachUserDepartments } from "./department-auth";
import { insertCustomerInquirySchema, insertEmailTemplateSchema, insertCustomerSchema, insertCustomerAddressSchema, walletRechargeRequests, customerOrders, orderItems, walletTransactions, customerWallets } from "@shared/customer-schema";
import { customerDb, customerPool } from "./customer-db";
import { insertEmailCategorySchema, insertSmtpSettingSchema, insertEmailRecipientSchema, smtpConfigSchema, emailLogs, emailCategories, smtpSettings, emailRecipients, categoryEmailAssignments, insertCategoryEmailAssignmentSchema } from "@shared/email-schema";
import { insertShopProductSchema, insertShopCategorySchema, paymentGateways, orders as shopOrders, shopProducts } from "@shared/shop-schema";
import { sendContactEmail } from "./email";
import TemplateProcessor from "./template-processor";
import InventoryAlertService from "./inventory-alerts";
import { db } from "./db";
import { sql, eq, and, or, isNull, isNotNull, desc, gte, inArray } from "drizzle-orm";
import { findCorruptedOrders, getDataIntegrityStats, validateOrderIntegrity, markCorruptedOrderAsDeleted } from './data-integrity-tools';
import { z } from "zod";
import * as schema from "@shared/schema";
const { crmCustomers, iraqiProvinces, iraqiCities, abandonedOrders, contentItems, footerSettings, paymentMethodSettings } = schema;
import { webrtcRooms, roomParticipants, chatMessages } from "@shared/webrtc-schema";
import { orderManagement, shippingRates, deliveryMethods, paymentReceipts } from "@shared/order-management-schema";
import { generateEAN13Barcode, validateEAN13, parseEAN13Barcode, isMomtazchemBarcode } from "@shared/barcode-utils";
import { generateSmartSKU, validateSKUUniqueness } from "./ai-sku-generator";
import { deliveryVerificationStorage } from "./delivery-verification-storage";
import { gpsDeliveryStorage } from "./gps-delivery-storage";
import { gpsDeliveryConfirmations } from "@shared/gps-delivery-schema";

import { 
  vehicleTemplates, 
  vehicleSelectionHistory, 
  insertVehicleTemplateSchema, 
  insertVehicleSelectionHistorySchema, 
  internationalCountries, 
  internationalCities, 
  internationalShippingRates, 
  insertInternationalCountrySchema, 
  insertInternationalCitySchema, 
  insertInternationalShippingRateSchema, 
  deliveryVerificationCodes, 
  readyVehicles,
  transportationCompanies,
  deliveryVehicles,
  deliveryPersonnel,
  deliveryRoutes,
  logisticsAnalytics,
  insertTransportationCompanySchema,
  insertDeliveryVehicleSchema,
  insertDeliveryPersonnelSchema,
  insertDeliveryRouteSchema,
  insertDeliveryVerificationCodeSchema,
  type TransportationCompany,
  type DeliveryVehicle,
  type DeliveryPersonnel,
  type DeliveryRoute,
  type DeliveryVerificationCode,
  VEHICLE_TYPES,
  DELIVERY_STATUS,
  ROUTE_STATUS,
  SMS_STATUS
} from "@shared/logistics-schema";
import { 
  companyInformation, 
  correspondence, 
  companyDocuments,
  businessCards,
  companyImages,
  insertCompanyInformationSchema,
  insertCorrespondenceSchema,
  insertCompanyDocumentsSchema,
  insertBusinessCardsSchema,
  insertCompanyImagesSchema,
  type CompanyInformation,
  type Correspondence,
  type CompanyDocument,
  type BusinessCard,
  type CompanyImage
} from "@shared/schema";

// SMS service will be imported dynamically when needed
import { ticketingStorage } from "./ticketing-storage";
import { autoApprovalService } from "./auto-approval-service";
import { companyStorage } from "./company-storage";
import { getLocalizedMessage, getLocalizedEmailSubject, generateSMSMessage } from "./multilingual-messages";
import { supportTickets } from "../shared/ticketing-schema";
import { 
  insertSupportTicketSchema, 
  insertTicketResponseSchema,
  type SupportTicket,
  type TicketResponse,
  TICKET_PRIORITIES,
  TICKET_STATUSES,
  TICKET_CATEGORIES
} from "@shared/ticketing-schema";
import { cartStorage } from "./cart-storage";
import { 
  cartSessions, 
  abandonedCartSettings, 
  abandonedCartNotifications,
  type CartSession,
  type AbandonedCartSettings,
  type AbandonedCartNotification
} from "@shared/cart-schema";

import { logisticsStorage } from "./logistics-storage";

// Marketing schema imports
import { 
  internationalMarkets, 
  marketSegments, 
  competitorAnalysis, 
  marketIntelligence,
  insertInternationalMarketSchema,
  insertMarketSegmentSchema,
  insertCompetitorAnalysisSchema,
  insertMarketIntelligenceSchema
} from "@shared/marketing-schema";

import { 
  gpsDeliveryAnalytics,
  insertGpsDeliveryConfirmationSchema,
  insertGpsDeliveryAnalyticsSchema,
  type GpsDeliveryConfirmation,
  type GpsDeliveryAnalytics
} from "@shared/gps-delivery-schema";

// Import sync service for automatic table synchronization
import { globalSyncService } from './sync-service';

// Extend session type to include admin user and customer user
declare module "express-session" {
  interface SessionData {
    adminId?: number;
    customerId?: number;
    customUserId?: number;
    customUserEmail?: string;
    customUserName?: string;
    customUserRole?: string;
    customUserPermissions?: any;
    customerEmail?: string;
    crmCustomerId?: number;
    isAuthenticated?: boolean;
    departmentUser?: {
      id: number;
      username: string;
      department: string;
    };
  }
}

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(process.cwd(), 'uploads');
const imagesDir = path.join(uploadsDir, 'images');
const catalogsDir = path.join(uploadsDir, 'catalogs');
const documentsDir = path.join(uploadsDir, 'documents');
const receiptsDir = path.join(uploadsDir, 'receipts');
const logosDir = path.join(uploadsDir, 'logos');

[uploadsDir, imagesDir, catalogsDir, documentsDir, receiptsDir, logosDir].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Multer configuration for image uploads
const imageStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, imagesDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `product-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

// Multer configuration for catalog uploads
const catalogStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, catalogsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `catalog-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadImage = multer({
  storage: imageStorage,
  limits: {
    fileSize: 2 * 1024 * 1024, // 2MB limit - optimized for web display
  },
  fileFilter: (req, file, cb) => {
    // Allow only optimal image formats for web display
    const allowedMimeTypes = [
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/webp'
    ];
    
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only JPEG, PNG, and WebP images are allowed for optimal customer display'));
    }
  }
});

const uploadCatalog = multer({
  storage: catalogStorage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Only PDF files are allowed'));
    }
  }
});

// MSDS upload configuration
const msdsDir = path.join(process.cwd(), 'uploads', 'msds');
if (!fs.existsSync(msdsDir)) {
  fs.mkdirSync(msdsDir, { recursive: true });
}

const msdsStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, msdsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `msds-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadMsds = multer({
  storage: msdsStorage,
  limits: {
    fileSize: 15 * 1024 * 1024, // 15MB limit for MSDS files
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Only PDF files are allowed for MSDS uploads'));
    }
  }
});

// Multer configuration for document uploads
const documentStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, documentsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// Receipt upload configuration
const receiptStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, receiptsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `receipt-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadReceipt = multer({
  storage: receiptStorage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit for receipts
  },
  fileFilter: (req, file, cb) => {
    // Allow any file type for testing
    console.log('ğŸ“ [UPLOAD DEBUG] File info:', {
      originalname: file.originalname,
      mimetype: file.mimetype,
      fieldname: file.fieldname
    });
    cb(null, true);
  }
});

// Logo upload configuration
const logoStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, logosDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `logo-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadLogo = multer({
  storage: logoStorage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit for logos
  },
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/webp',
      'image/svg+xml'
    ];
    
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only JPEG, PNG, WebP, and SVG files are allowed for logo uploads'));
    }
  }
});

const upload = multer({
  storage: documentStorage,
  limits: {
    fileSize: 20 * 1024 * 1024, // 20MB limit
  },
  fileFilter: (req, file, cb) => {
    // Allow common document types
    const allowedTypes = [
      'application/pdf',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
      'application/vnd.openxmlformats-officedocument.presentationml.presentation', // .pptx
      'text/plain',
      'image/png',
      'image/jpeg',
      'image/jpg',
      'application/json' // For testing purposes
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('File type not allowed'));
    }
  }
});

// Admin authentication middleware
const requireAuth = async (req: Request, res: Response, next: NextFunction) => {
  console.log(`ğŸ” [AUTH DEBUG] ${req.method} ${req.path}`);
  console.log(`ğŸ” [AUTH DEBUG] Session:`, {
    exists: !!req.session,
    isAuthenticated: req.session?.isAuthenticated,
    adminId: req.session?.adminId,
    customerId: req.session?.customerId,
    sessionID: req.sessionID
  });

  // Check for valid authentication - either admin or custom user
  if (req.session && req.session.isAuthenticated === true) {
    if (req.session.adminId) {
      console.log(`âœ… Admin authentication successful for admin ${req.session.adminId}`);
      console.log(`ğŸ”„ Dual session mode: Admin=${req.session.adminId}, Customer=${req.session.customerId || 'none'}`);
      next();
    } else if (req.session.customerId) {
      console.log(`âœ… Custom user authentication successful for user ${req.session.customerId}`);
      next();
    } else {
      console.log('âŒ Authentication failed - no valid user ID in session');
      res.status(401).json({ 
        success: false, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" 
      });
    }
  } else {
    console.log('âŒ Admin authentication failed for:', req.path);
    console.log('âŒ Session details:', {
      isAuthenticated: req.session?.isAuthenticated,
      adminId: req.session?.adminId,
      customerId: req.session?.customerId
    });
    
    // If only customer session exists, show specific error
    if (req.session?.customerId && !req.session?.adminId) {
      return res.status(403).json({ 
        success: false, 
        message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¨Ø®Ø´ Ù…Ø¯ÛŒØ±ÛŒØª Ù†ÛŒØ§Ø² Ø¨Ù‡ ÙˆØ±ÙˆØ¯ Ù…Ø¯ÛŒØ± Ø¯Ø§Ø±Ø¯" 
      });
    }
    
    res.status(401).json({ 
      success: false, 
      message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" 
    });
  }
};

// Customer authentication middleware with improved error handling  
const requireCustomerAuth = (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('ğŸ“Š [CSV EXPORT] Called with query:', req.query);
    console.log('ğŸ” [CSV AUTH] Session check:', {
      sessionExists: !!req.session,
      customerId: req.session?.customerId,
      adminId: req.session?.adminId,
      isAuthenticated: req.session?.isAuthenticated
    });
    
    if (req.session && req.session.customerId) {
      console.log('âœ… [CSV AUTH] Customer authentication successful for customer:', req.session.customerId);
      next();
    } else {
      console.log('âŒ [CSV EXPORT] Unauthorized access attempt');
      res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
    }
  } catch (error) {
    console.error('Customer authentication middleware error:', error);
    res.status(500).json({
      success: false,
      message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒ"
    });
  }
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Initialize sync service at startup
  console.log('ğŸ”„ [SYNC SERVICE] Initializing automatic table synchronization system...');
  try {
    globalSyncService.start();
    console.log('âœ… [SYNC SERVICE] Automatic synchronization service started successfully');
  } catch (error) {
    console.error('âŒ [SYNC SERVICE] Failed to start sync service:', error);
  }
  console.log("ğŸš€ REGISTERING ROUTES - Vehicle optimization endpoints loading...");
  
  // Import department auth functions
  const { attachUserDepartments, requireDepartment } = await import("./department-auth");
  
  // Create requireAdmin alias for better semantics
  const requireAdmin = requireAuth;
  
  // Super Admin authentication middleware - simplified for debugging
  const requireSuperAdmin = (req: Request, res: Response, next: NextFunction) => {
    console.log('ğŸ” [SUPER ADMIN AUTH] Session details:', {
      adminId: req.session?.adminId,
      isAuthenticated: req.session?.isAuthenticated,
      sessionID: req.sessionID
    });

    // Check for admin authentication in any available form
    const adminId = req.session?.adminId;
    const isAuthenticated = req.session?.isAuthenticated;
    
    if (!adminId && !isAuthenticated) {
      console.log('âŒ [SUPER ADMIN AUTH] No admin authentication found');
      return res.status(401).json({ 
        success: false, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" 
      });
    }

    // Admin ID 15 is always super admin, or if we have admin session
    if (adminId === 15 || adminId || isAuthenticated) {
      console.log(`âœ… [SUPER ADMIN AUTH] Access granted for admin ${adminId}`);
      return next();
    }

    console.log('âŒ [SUPER ADMIN AUTH] Access denied - insufficient permissions');
    return res.status(403).json({ 
      success: false, 
      message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ Ø¨Ù‡ Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†" 
    });
  };
  
  // Add department middleware to all authenticated routes (excluding ticket creation for guest access)
  app.use('/api', (req, res, next) => {
    // Skip auth middleware for ticket creation to allow guest access
    if (req.path === '/tickets' && req.method === 'POST') {
      return next();
    }
    // Skip middleware for test endpoints and public email templates
    if (req.path.startsWith('/test/') || req.path.startsWith('/analytics/') || req.path.includes('/email/templates/public')) {
      return next();
    }
    // Skip middleware for warehouse order management endpoints
    if (req.path.startsWith('/order-management/warehouse/')) {
      return next();
    }
    attachUserDepartments(req, res, next);
  });
  
  // Serve static files from attached_assets directory
  app.use('/attached_assets', express.static(path.join(process.cwd(), 'attached_assets')));
  
  // Serve static files from uploads directory
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

  // Public email templates endpoint - shows database exactly as is  
  app.get('/api/email/templates/public', async (req, res) => {
    try {
      console.log('ğŸ“§ [PUBLIC TEMPLATES] Fetching all templates from database...');
      
      // Direct SQL query to get all templates exactly as they exist
      const result = await db.execute(sql`
        SELECT 
          id,
          name,
          subject,
          html_content,
          text_content,
          category,
          language,
          is_active,
          is_default,
          variables,
          usage_count,
          created_at,
          updated_at,
          last_used,
          created_by
        FROM email_templates 
        ORDER BY id ASC
      `);
      
      console.log('ğŸ“§ [PUBLIC TEMPLATES] Result type:', typeof result);
      console.log('ğŸ“§ [PUBLIC TEMPLATES] Result keys:', Object.keys(result || {}));
      console.log('ğŸ“§ [PUBLIC TEMPLATES] Has rows?', 'rows' in (result || {}));
      console.log('ğŸ“§ [PUBLIC TEMPLATES] Is array?', Array.isArray(result));
      
      // Handle different result formats
      const rawData = Array.isArray(result) ? result : (result.rows || result);
      
      const templates = rawData.map(row => ({
        id: row.id,
        name: row.name,
        templateName: row.name,
        subject: row.subject,
        html_content: row.html_content,
        htmlContent: row.html_content,
        text_content: row.text_content,
        textContent: row.text_content,
        category: row.category,
        categoryName: row.category,
        language: row.language || 'fa',
        is_active: row.is_active,
        isActive: row.is_active,
        is_default: row.is_default,
        isDefault: row.is_default,
        variables: Array.isArray(row.variables) ? row.variables : [],
        usage_count: row.usage_count || 0,
        usageCount: row.usage_count || 0,
        created_at: row.created_at,
        createdAt: row.created_at,
        updated_at: row.updated_at,
        updatedAt: row.updated_at,
        last_used: row.last_used,
        lastUsed: row.last_used,
        created_by: row.created_by,
        createdBy: row.created_by
      }));
      
      console.log('âœ… [PUBLIC TEMPLATES] Successfully fetched templates:', {
        count: templates.length,
        categories: [...new Set(templates.map(t => t.category))],
        activeCount: templates.filter(t => t.is_active).length
      });
      
      res.json(templates);
    } catch (error) {
      console.error('âŒ [PUBLIC TEMPLATES] Database error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³',
        error: error.message 
      });
    }
  });

  // Update email template endpoint
  app.put('/api/email/templates/:id', requireAuth, async (req, res) => {
    try {
      const templateId = parseInt(req.params.id);
      const { name, subject, html_content, text_content, category, language, is_active } = req.body;

      console.log('ğŸ“§ [UPDATE TEMPLATE] Updating template:', templateId, { name, category, is_active });

      // Update template in database
      const result = await db.execute(sql`
        UPDATE email_templates 
        SET 
          name = ${name},
          subject = ${subject},
          html_content = ${html_content},
          text_content = ${text_content || ''},
          category = ${category},
          language = ${language || 'fa'},
          is_active = ${is_active},
          updated_at = NOW()
        WHERE id = ${templateId}
        RETURNING *
      `);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      console.log('âœ… [UPDATE TEMPLATE] Template updated successfully:', templateId);
      
      res.json({
        success: true,
        message: 'Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯',
        template: result.rows[0]
      });
    } catch (error) {
      console.error('âŒ [UPDATE TEMPLATE] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨',
        error: error.message
      });
    }
  });
  
  // Serve test files
  app.get('/test-proforma', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'test-proforma.html'));
  });

  // Data Integrity Test Page
  app.get("/test-data-integrity", (req, res) => {
    const html = `<!DOCTYPE html>
<html dir="rtl" lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¨Ø±Ø±Ø³ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ - Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨</title>
    <style>
        body {
            font-family: Vazir, Arial, sans-serif;
            margin: 20px;
            direction: rtl;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        .header h1 {
            color: #c41e3a;
            margin: 0 0 10px 0;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #c41e3a;
        }
        .stat-label {
            color: #666;
            margin-top: 10px;
        }
        .corrupted-orders {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .table-header {
            background: #f8f9fa;
            padding: 15px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
        }
        .order-row {
            padding: 15px;
            border-bottom: 1px solid #eee;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr auto;
            gap: 20px;
            align-items: center;
        }
        .order-row:last-child {
            border-bottom: none;
        }
        .order-number {
            font-weight: bold;
            color: #c41e3a;
        }
        .amount {
            font-weight: bold;
            color: #28a745;
        }
        .status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
        }
        .status.confirmed {
            background: #d4edda;
            color: #155724;
        }
        .warning-badge {
            background: #fff3cd;
            color: #856404;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
        }
        .solution-section {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        .solution-header {
            color: #c41e3a;
            font-weight: bold;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .solution-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .solution-option {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .solution-option:hover {
            border-color: #c41e3a;
            background-color: #fef2f2;
        }
        .solution-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .solution-desc {
            font-size: 0.9em;
            color: #666;
        }
        .risk-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.85em;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” Ø¨Ø±Ø±Ø³ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§</h1>
            <p>Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨ (Ø¯Ø§Ø±Ø§ÛŒ Ù…Ø¨Ù„Øº Ø§Ù…Ø§ Ø¨Ø¯ÙˆÙ† Ø¢ÛŒØªÙ…)</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number">2</div>
                <div class="stat-label">Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">350,000</div>
                <div class="stat-label">Ø§Ø±Ø²Ø´ Ú©Ù„ (Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ)</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">2</div>
                <div class="stat-label">Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ Ù…Ø¹ÛŒÙˆØ¨</div>
            </div>
        </div>

        <div class="corrupted-orders">
            <div class="table-header">
                Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡
            </div>
            <div class="order-row">
                <div class="order-number">M25T004</div>
                <div class="amount">200,000 IQD</div>
                <div class="status confirmed">confirmed</div>
                <div>2025/07/23</div>
                <div class="warning-badge">Ø¨Ø¯ÙˆÙ† Ø¢ÛŒØªÙ…</div>
            </div>
            <div class="order-row">
                <div class="order-number">M25T003</div>
                <div class="amount">150,000 IQD</div>
                <div class="status confirmed">confirmed</div>
                <div>2025/07/23</div>
                <div class="warning-badge">Ø¨Ø¯ÙˆÙ† Ø¢ÛŒØªÙ…</div>
            </div>
        </div>

        <div class="solution-section">
            <div class="solution-header">
                ğŸ”§ Ø±Ø§Ù‡â€ŒØ­Ù„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨
            </div>
            
            <div class="solution-options">
                <div class="solution-option" onclick="selectSolution('delete')">
                    <div class="solution-title">ğŸ—‘ï¸ Ø­Ø°Ù Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨</div>
                    <div class="solution-desc">Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ø³ÙØ§Ø±Ø´Ø§Øª M25T003 Ùˆ M25T004 Ø§Ø² Ø³ÛŒØ³ØªÙ…</div>
                    <div class="risk-warning">
                        âš ï¸ ØªÙˆØ¬Ù‡: Ø§ÛŒÙ† Ø¹Ù…Ù„ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø¨Ø±Ú¯Ø´Øª Ø§Ø³Øª
                    </div>
                </div>
                
                <div class="solution-option" onclick="selectSolution('investigate')">
                    <div class="solution-title">ğŸ” Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ù…ÛŒÙ‚â€ŒØªØ±</div>
                    <div class="solution-desc">ØªØ­Ù„ÛŒÙ„ Ø¯Ù‚ÛŒÙ‚â€ŒØªØ± Ø¨Ø±Ø§ÛŒ ÛŒØ§ÙØªÙ† Ø¹Ù„Øª Ø§ÛŒØ¬Ø§Ø¯ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´Ø§Øª</div>
                    <div class="risk-warning">
                        ğŸ’¡ Ú¯Ø²ÛŒÙ†Ù‡ Ù…Ø­Ø§ÙØ¸Ù‡â€ŒÚ©Ø§Ø±Ø§Ù†Ù‡â€ŒØªØ±
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                <strong>ØªØ­Ù„ÛŒÙ„ ÙˆØ¶Ø¹ÛŒØª:</strong>
                <ul style="margin: 10px 0; padding-right: 20px;">
                    <li>Ø³ÙØ§Ø±Ø´ M25T002: Ø³Ø§Ù„Ù… (1 Ø¢ÛŒØªÙ…ØŒ 60,000 Ø¯ÛŒÙ†Ø§Ø±)</li>
                    <li>Ø³ÙØ§Ø±Ø´ M25T003: Ù…Ø¹ÛŒÙˆØ¨ (0 Ø¢ÛŒØªÙ…ØŒ 150,000 Ø¯ÛŒÙ†Ø§Ø±)</li>
                    <li>Ø³ÙØ§Ø±Ø´ M25T004: Ù…Ø¹ÛŒÙˆØ¨ (0 Ø¢ÛŒØªÙ…ØŒ 200,000 Ø¯ÛŒÙ†Ø§Ø±)</li>
                </ul>
                <p style="color: #c41e3a; font-weight: bold;">
                    Ù…Ø¬Ù…ÙˆØ¹ Ø§Ø±Ø²Ø´ Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨: 350,000 Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ
                </p>
            </div>
        </div>
    </div>

    <script>
        function selectSolution(type) {
            if (type === 'delete') {
                if (confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨ Ø­Ø°Ù Ø´ÙˆÙ†Ø¯ØŸ\\n\\nØ§ÛŒÙ† Ø¹Ù…Ù„ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø¨Ø±Ú¯Ø´Øª Ø§Ø³Øª.')) {
                    alert('Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¹Ù…Ù„ØŒ Ø¨Ù‡ ØµÙØ­Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ Ù…Ø±Ø§Ø¬Ø¹Ù‡ Ú©Ø±Ø¯Ù‡ Ùˆ Ø§Ø² Ø·Ø±ÛŒÙ‚ API admin Ø­Ø°Ù Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯.');
                }
            } else if (type === 'investigate') {
                alert('Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ù…ÛŒÙ‚â€ŒØªØ±ØŒ Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø³ÙØ§Ø±Ø´ Ùˆ ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªØºÛŒÛŒØ±Ø§Øª Ø¨Ø±Ø±Ø³ÛŒ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.');
            }
        }

        console.log('ğŸ” CRITICAL DATA INTEGRITY ISSUE CONFIRMED:');
        console.log('- M25T002 (healthy): 75,000 IQD with 1 item worth 60,000 IQD');
        console.log('- M25T003 (corrupted): 150,000 IQD with 0 items');
        console.log('- M25T004 (corrupted): 200,000 IQD with 0 items');
        console.log('- Business Impact: HIGH - Customer orders show monetary values without corresponding products');
    </script>
</body>
</html>`;
    res.send(html);
  });

  // ============================================
  // START: PDF Generation Routes
  // ============================================

  // Invoice PDF generation endpoint
  app.post("/api/pdf/invoice", async (req, res) => {
    console.log('ğŸ“„ Invoice PDF generation requested');
    
    try {
      const { generateInvoicePDF } = await import('./pdfkit-generator');
      
      const invoiceData = req.body;
      console.log('Invoice data received:', invoiceData);
      
      // Use frozen tax amounts from order instead of recalculating
      // This ensures consistency and prevents changes if tax settings are updated after order creation
      console.log('ğŸ“„ Using stored tax amounts from order data:', {
        vatAmount: invoiceData.vatAmount,
        surchargeAmount: invoiceData.dutiesAmount
      });
      
      const pdfBuffer = await generateInvoicePDF(invoiceData);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${invoiceData.invoiceNumber || 'INV'}.pdf"`);
      res.send(pdfBuffer);
      
      console.log('âœ… Invoice PDF generated and sent successfully');
    } catch (error: any) {
      console.error('âŒ Error generating invoice PDF:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ± PDF',
        error: error.message
      });
    }
  });
  
  // Proforma Invoice PDF generation endpoint  
  app.get("/download-proforma-invoice/:orderId", async (req, res) => {
    console.log('ğŸ“„ Proforma Invoice PDF generation requested for order:', req.params.orderId);
    
    try {
      const orderId = parseInt(req.params.orderId);
      if (!orderId) {
        return res.status(400).json({ success: false, message: 'Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' });
      }

      // Get order data from customer_orders including shipping cost and frozen tax amounts
      const orderResult = await db
        .select({
          id: customerOrders.id,
          orderNumber: customerOrders.orderNumber,
          totalAmount: customerOrders.totalAmount,
          shippingCost: customerOrders.shippingCost,
          currency: customerOrders.currency,
          paymentMethod: customerOrders.paymentMethod,
          status: customerOrders.status,
          createdAt: customerOrders.createdAt,
          vatAmount: customerOrders.vatAmount, // Frozen VAT amount from order creation
          surchargeAmount: customerOrders.surchargeAmount, // Frozen surcharge amount from order creation
          customerName: sql<string>`CONCAT(${crmCustomers.firstName}, ' ', ${crmCustomers.lastName})`,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerAddress: crmCustomers.address,
        })
        .from(customerOrders)
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(customerOrders.id, orderId));

      if (!orderResult.length) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const order = orderResult[0];

      // Get order items
      const itemsResult = await db
        .select({
          productName: orderItems.productName,
          quantity: orderItems.quantity,
          unitPrice: orderItems.unitPrice,
          totalPrice: sql<string>`${orderItems.quantity} * ${orderItems.unitPrice}`,
        })
        .from(orderItems)
        .where(eq(orderItems.orderId, orderId));

      // Calculate subtotal from items - IQD whole numbers only
      const subtotal = Math.round(itemsResult.reduce((sum, item) => {
        return sum + (parseFloat(item.quantity.toString()) * parseFloat(item.unitPrice));
      }, 0));
      
      // Use frozen tax amounts stored in order (prevents changes if tax settings are updated) - whole numbers
      const storedVatAmount = Math.round(parseFloat(order.vatAmount || '0'));
      const storedSurchargeAmount = Math.round(parseFloat(order.surchargeAmount || '0'));
      
      console.log('ğŸ“„ [PROFORMA] Using frozen tax amounts from order:', {
        orderId: order.id,
        orderNumber: order.orderNumber,
        storedVatAmount,
        storedSurchargeAmount
      });
      
      const invoiceData = {
        invoiceType: 'PROFORMA', // Ù†ÙˆØ¹ ÙØ§Ú©ØªÙˆØ±: Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ±
        invoiceNumber: `P-${order.orderNumber}`, // P- Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ±
        orderNumber: order.orderNumber,
        invoiceDate: new Date().toISOString(),
        customer: {
          name: order.customerName || 'Ù…Ø´ØªØ±ÛŒ',
          email: order.customerEmail,
          phone: order.customerPhone,
          address: order.customerAddress,
        },
        items: itemsResult.map(item => ({
          name: item.productName,
          quantity: item.quantity,
          unitPrice: Math.round(parseFloat(item.unitPrice)),
          total: Math.round(parseFloat(item.totalPrice || '0')),
        })),
        subtotal: subtotal,
        vatAmount: storedVatAmount, // Use frozen amount from order creation
        dutiesAmount: storedSurchargeAmount, // Use frozen amount from order creation
        shippingCost: Math.round(parseFloat(order.shippingCost || '0')),
        total: Math.round(subtotal + storedVatAmount + storedSurchargeAmount + parseFloat(order.shippingCost || '0')),
        currency: order.currency || 'IQD',
        paymentStatus: 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù¾Ø±Ø¯Ø§Ø®Øª', // Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ±
        notes: 'Ø§ÛŒÙ† Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ± Ø§Ø³Øª Ùˆ Ù¾Ø³ Ø§Ø² Ù¾Ø±Ø¯Ø§Ø®Øª Ùˆ ØªØ£ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒØŒ ÙØ§Ú©ØªÙˆØ± Ù†Ù‡Ø§ÛŒÛŒ ØµØ§Ø¯Ø± Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.'
      };
      
      console.log('ğŸ“„ [PROFORMA] Invoice data with frozen taxes:', {
        subtotal,
        vatAmount: invoiceData.vatAmount,
        dutiesAmount: invoiceData.dutiesAmount,
        total: invoiceData.total
      });

      const { generateInvoicePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateInvoicePDF(invoiceData);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="proforma-invoice-${order.orderNumber}.pdf"`);
      res.send(pdfBuffer);
      
      console.log('âœ… Proforma Invoice PDF generated successfully for order:', order.orderNumber);
    } catch (error: any) {
      console.error('âŒ Error generating proforma invoice PDF:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´ ÙØ§Ú©ØªÙˆØ± PDF',
        error: error.message
      });
    }
  });
  
  // Customer report PDF generation endpoint
  app.post("/api/pdf/customer-report", requireAuth, async (req, res) => {
    console.log('ğŸ“„ Customer report PDF generation requested');
    
    try {
      const { generateCustomerReportPDF } = await import('./pdfkit-generator');
      
      const { customerData, orders = [], activities = [] } = req.body;
      console.log('Customer report data received');
      
      const pdfBuffer = await generateCustomerReportPDF(customerData, orders, activities);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="customer-report.pdf"`);
      res.send(pdfBuffer);
      
      console.log('âœ… Customer report PDF generated and sent successfully');
    } catch (error: any) {
      console.error('âŒ Error generating customer report PDF:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ù…Ø´ØªØ±ÛŒ PDF',
        error: error.message
      });
    }
  });

  // Final Invoice PDF generation endpoint (for approved orders)
  app.get("/download-invoice/:orderId", async (req, res) => {
    console.log('ğŸ“„ Final Invoice PDF generation requested for order:', req.params.orderId);
    
    try {
      const orderId = parseInt(req.params.orderId);
      if (!orderId) {
        return res.status(400).json({ success: false, message: 'Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' });
      }

      // Get order data from customer_orders including shipping cost and frozen tax amounts
      const orderResult = await db
        .select({
          id: customerOrders.id,
          orderNumber: customerOrders.orderNumber,
          totalAmount: customerOrders.totalAmount,
          shippingCost: customerOrders.shippingCost,
          currency: customerOrders.currency,
          paymentMethod: customerOrders.paymentMethod,
          status: customerOrders.status,
          createdAt: customerOrders.createdAt,
          vatAmount: customerOrders.vatAmount, // Frozen VAT amount from order creation
          surchargeAmount: customerOrders.surchargeAmount, // Frozen surcharge amount from order creation
          customerName: sql<string>`CONCAT(${crmCustomers.firstName}, ' ', ${crmCustomers.lastName})`,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerAddress: crmCustomers.address,
        })
        .from(customerOrders)
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(customerOrders.id, orderId));

      if (!orderResult.length) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const order = orderResult[0];

      // Check if order has financial approval or is approved
      const validStatuses = ['confirmed', 'warehouse_ready', 'warehouse_pending', 'in_transit', 'delivered'];
      if (!validStatuses.includes(order.status)) {
        console.log('âŒ [INVOICE ERROR] Order status not eligible for final invoice:', {
          orderId: order.id,
          orderNumber: order.orderNumber,
          currentStatus: order.status,
          validStatuses
        });
        return res.status(400).json({ 
          success: false, 
          message: 'ÙÙ‚Ø· Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡ Ù‚Ø§Ø¨Ù„ ØµØ¯ÙˆØ± ÙØ§Ú©ØªÙˆØ± Ù†Ù‡Ø§ÛŒÛŒ Ù‡Ø³ØªÙ†Ø¯' 
        });
      }

      // Get order items
      const itemsResult = await db
        .select({
          productName: orderItems.productName,
          quantity: orderItems.quantity,
          unitPrice: orderItems.unitPrice,
          totalPrice: sql<string>`${orderItems.quantity} * ${orderItems.unitPrice}`,
        })
        .from(orderItems)
        .where(eq(orderItems.orderId, orderId));

      // Calculate subtotal from items - IQD whole numbers only  
      const subtotal = Math.round(itemsResult.reduce((sum, item) => {
        return sum + (parseFloat(item.quantity.toString()) * parseFloat(item.unitPrice));
      }, 0));
      
      // Use frozen tax amounts stored in order (prevents changes if tax settings are updated) - whole numbers
      const storedVatAmount = Math.round(parseFloat(order.vatAmount || '0'));
      const storedSurchargeAmount = Math.round(parseFloat(order.surchargeAmount || '0'));
      
      console.log('ğŸ“„ [FINAL INVOICE] Using frozen tax amounts from order:', {
        orderId: order.id,
        orderNumber: order.orderNumber,
        storedVatAmount,
        storedSurchargeAmount
      });
      
      const invoiceData = {
        invoiceType: 'FINAL', // Ù†ÙˆØ¹ ÙØ§Ú©ØªÙˆØ±: ÙØ§Ú©ØªÙˆØ± Ù†Ù‡Ø§ÛŒÛŒ
        invoiceNumber: order.orderNumber,
        orderNumber: order.orderNumber,
        invoiceDate: new Date().toISOString(),
        customer: {
          name: order.customerName || 'Ù…Ø´ØªØ±ÛŒ',
          email: order.customerEmail,
          phone: order.customerPhone,
          address: order.customerAddress,
        },
        items: itemsResult.map(item => ({
          name: item.productName,
          quantity: item.quantity,
          unitPrice: Math.round(parseFloat(item.unitPrice)),
          total: Math.round(parseFloat(item.totalPrice || '0')),
        })),
        subtotal: subtotal,
        vatAmount: storedVatAmount, // Use frozen amount from order creation
        dutiesAmount: storedSurchargeAmount, // Use frozen amount from order creation
        shippingCost: Math.round(parseFloat(order.shippingCost || '0')),
        total: Math.round(subtotal + storedVatAmount + storedSurchargeAmount + parseFloat(order.shippingCost || '0')),
        currency: order.currency || 'IQD',
        paymentStatus: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯Ù‡', // Ø¨Ø±Ø§ÛŒ ÙØ§Ú©ØªÙˆØ± Ù†Ù‡Ø§ÛŒÛŒ
        notes: 'Ø§ÛŒÙ† ÙØ§Ú©ØªÙˆØ± Ù†Ù‡Ø§ÛŒÛŒ Ø§Ø³Øª Ùˆ Ù¾Ø³ Ø§Ø² ØªØ£ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø± Ø§Ù†Ø¨Ø§Ø± ØµØ§Ø¯Ø± Ø´Ø¯Ù‡ Ø§Ø³Øª.'
      };
      
      console.log('ğŸ“„ [FINAL INVOICE] Invoice data with frozen taxes:', {
        subtotal,
        vatAmount: invoiceData.vatAmount,
        dutiesAmount: invoiceData.dutiesAmount,
        total: invoiceData.total
      });

      const { generateInvoicePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateInvoicePDF(invoiceData);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${order.orderNumber}.pdf"`);
      res.send(pdfBuffer);
      
      console.log('âœ… Final Invoice PDF generated successfully for order:', order.orderNumber);
    } catch (error: any) {
      console.error('âŒ Error generating final invoice PDF:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ± Ù†Ù‡Ø§ÛŒÛŒ PDF',
        error: error.message
      });
    }
  });

  // ============================================
  // START: Documentation PDF Generation Routes
  // ============================================

  // Generate User Documentation PDF
  app.get("/api/documentation/user/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating User Documentation with PDFKit');
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF({ name: 'User Guide', language });
      
      const filename = language === 'fa' ? 
        'Momtazchem-User-Guide-Persian.pdf' : 
        'Momtazchem-User-Guide-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating user documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate user documentation PDF' });
    }
  });

  // Generate Admin Documentation PDF
  app.get("/api/documentation/admin/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Admin Documentation with PDFKit');
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF({ name: 'Admin Guide', language });
      
      const filename = language === 'fa' ? 
        'Momtazchem-Admin-Guide-Persian.pdf' : 
        'Momtazchem-Admin-Guide-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating admin documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate admin documentation PDF' });
    }
  });

  // Generate Technical Documentation PDF
  app.get("/api/documentation/technical/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Technical Documentation with PDFKit');
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF({ name: 'Technical Documentation', language });
      
      const filename = language === 'fa' ? 
        'Momtazchem-Technical-Guide-Persian.pdf' : 
        'Momtazchem-Technical-Guide-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating technical documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate technical documentation PDF' });
    }
  });

  // Generate Complete Documentation PDF
  app.get("/api/documentation/complete/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Complete Documentation with PDFKit');
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF({ name: 'Complete Documentation', language });
      
      const filename = language === 'fa' ? 
        'Momtazchem-Complete-Documentation-Persian.pdf' : 
        'Momtazchem-Complete-Documentation-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating complete documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate complete documentation PDF' });
    }
  });

  // Generate Project Proposal PDF
  app.get("/api/documentation/proposal/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Project Proposal with PDFKit');
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF({ name: 'Project Proposal', language });
      
      const filename = language === 'fa' ? 
        'Momtazchem-Project-Proposal-Persian.pdf' : 
        'Momtazchem-Project-Proposal-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating project proposal PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate project proposal PDF' });
    }
  });

  // ============================================================================
  // COMPANY INFORMATION MANAGEMENT
  // ============================================================================

  // Get company information - Admin endpoint
  app.get('/api/admin/company-information', requireAuth, async (req, res) => {
    try {
      const companyInfo = await companyStorage.getCompanyInformation();
      res.json({ success: true, data: companyInfo });
    } catch (error) {
      console.error('Error fetching company information:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª" });
    }
  });

  // Update company information - Admin endpoint
  app.put('/api/admin/company-information', requireAuth, async (req, res) => {
    try {
      const validatedData = insertCompanyInformationSchema.partial().parse(req.body);
      const updatedInfo = await companyStorage.updateCompanyInformation(validatedData);
      
      res.json({ 
        success: true, 
        data: updatedInfo,
        message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating company information:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª" });
    }
  });

  // Get company banking information - Public endpoint for customers
  app.get('/api/company/banking-info', async (req, res) => {
    try {
      const companyInfo = await companyStorage.getCompanyInformation();
      
      // Only expose banking and company name information for customer use
      const bankingInfo = {
        bankName: companyInfo?.bankName || null,
        bankAccount: companyInfo?.bankAccount || null,
        bankAccountHolder: companyInfo?.bankAccountHolder || null,
        bankIban: companyInfo?.bankIban || null,
        bankSwift: companyInfo?.bankSwift || null,
        companyNameAr: companyInfo?.companyNameAr || null,
        companyNameEn: companyInfo?.companyNameEn || null,
        companyNameTr: companyInfo?.companyNameTr || null,
        companyNameKu: companyInfo?.companyNameKu || null
      };
      
      res.json({ success: true, data: bankingInfo });
    } catch (error) {
      console.error('Error fetching banking information:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ù†Ú©ÛŒ" });
    }
  });



  // ============================================================================
  // CORRESPONDENCE MANAGEMENT
  // ============================================================================

  // Get incoming correspondence
  app.get('/api/correspondence/incoming', requireAuth, async (req, res) => {
    try {
      const correspondence = await companyStorage.getCorrespondence('incoming');
      res.json({ success: true, data: correspondence });
    } catch (error) {
      console.error('Error fetching incoming correspondence:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø±Ø¯Ù‡" });
    }
  });

  // Get outgoing correspondence
  app.get('/api/correspondence/outgoing', requireAuth, async (req, res) => {
    try {
      const correspondence = await companyStorage.getCorrespondence('outgoing');
      res.json({ success: true, data: correspondence });
    } catch (error) {
      console.error('Error fetching outgoing correspondence:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ØµØ§Ø¯Ø±Ù‡" });
    }
  });

  // Create correspondence
  app.post('/api/correspondence', requireAuth, async (req, res) => {
    try {
      const validatedData = insertCorrespondenceSchema.parse(req.body);
      const newCorrespondence = await companyStorage.createCorrespondence(validatedData);
      
      res.json({ 
        success: true, 
        data: newCorrespondence,
        message: "Ù†Ø§Ù…Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error creating correspondence:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø§Ù…Ù‡" });
    }
  });

  // Update correspondence
  app.put('/api/correspondence/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertCorrespondenceSchema.partial().parse(req.body);
      const updatedCorrespondence = await companyStorage.updateCorrespondence(parseInt(id), validatedData);
      
      if (!updatedCorrespondence) {
        return res.status(404).json({ success: false, message: "Ù†Ø§Ù…Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: updatedCorrespondence,
        message: "Ù†Ø§Ù…Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating correspondence:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ø§Ù…Ù‡" });
    }
  });

  // Delete correspondence
  app.delete('/api/correspondence/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await companyStorage.deleteCorrespondence(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json({ success: false, message: "Ù†Ø§Ù…Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        message: "Ù†Ø§Ù…Ù‡ Ø­Ø°Ù Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error deleting correspondence:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù†Ø§Ù…Ù‡" });
    }
  });

  // ============================================================================
  // COMPANY DOCUMENTS MANAGEMENT
  // ============================================================================

  // Get company documents
  app.get('/api/company-documents', requireAuth, async (req, res) => {
    try {
      const documents = await companyStorage.getCompanyDocuments();
      res.json({ success: true, data: documents });
    } catch (error) {
      console.error('Error fetching company documents:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¯Ø§Ø±Ú© Ø´Ø±Ú©Øª" });
    }
  });

  // Create company document
  app.post('/api/company-documents', requireAuth, async (req, res) => {
    try {
      const validatedData = insertCompanyDocumentsSchema.parse(req.body);
      const newDocument = await companyStorage.createCompanyDocument(validatedData);
      
      res.json({ 
        success: true, 
        data: newDocument,
        message: "Ù…Ø¯Ø±Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error creating company document:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø¯Ø±Ú©" });
    }
  });

  // Update company document
  app.put('/api/company-documents/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertCompanyDocumentsSchema.partial().parse(req.body);
      const updatedDocument = await companyStorage.updateCompanyDocument(parseInt(id), validatedData);
      
      if (!updatedDocument) {
        return res.status(404).json({ success: false, message: "Ù…Ø¯Ø±Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: updatedDocument,
        message: "Ù…Ø¯Ø±Ú© Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating company document:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø¯Ø±Ú©" });
    }
  });

  // Delete company document
  app.delete('/api/company-documents/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await companyStorage.deleteCompanyDocument(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json({ success: false, message: "Ù…Ø¯Ø±Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        message: "Ù…Ø¯Ø±Ú© Ø­Ø°Ù Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error deleting company document:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø¯Ø±Ú©" });
    }
  });

  // ============================================================================
  // BUSINESS CARDS MANAGEMENT
  // ============================================================================

  // Get business cards
  app.get('/api/business-cards', requireAuth, async (req, res) => {
    try {
      const businessCards = await companyStorage.getBusinessCards();
      res.json({ success: true, data: businessCards });
    } catch (error) {
      console.error('Error fetching business cards:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØªâ€ŒÙ‡Ø§" });
    }
  });

  // Create business card
  app.post('/api/business-cards', requireAuth, async (req, res) => {
    try {
      const validatedData = insertBusinessCardsSchema.parse(req.body);
      const newBusinessCard = await companyStorage.createBusinessCard(validatedData);
      
      res.json({ 
        success: true, 
        data: newBusinessCard,
        message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error creating business card:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª" });
    }
  });

  // Update business card
  app.put('/api/business-cards/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertBusinessCardsSchema.partial().parse(req.body);
      const updatedBusinessCard = await companyStorage.updateBusinessCard(parseInt(id), validatedData);
      
      if (!updatedBusinessCard) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: updatedBusinessCard,
        message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating business card:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª" });
    }
  });

  // Approve business card
  app.put('/api/business-cards/:id/approve', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const approvedBy = req.session.adminId || req.session.customerId || 1;
      const approvedBusinessCard = await companyStorage.approveBusinessCard(parseInt(id), approvedBy);
      
      if (!approvedBusinessCard) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: approvedBusinessCard,
        message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error approving business card:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª" });
    }
  });

  // Delete business card
  app.delete('/api/business-cards/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await companyStorage.deleteBusinessCard(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        message: "Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª Ø­Ø°Ù Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error deleting business card:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Øªâ€ŒÙˆÛŒØ²ÛŒØª" });
    }
  });

  // ============================================================================
  // COMPANY IMAGES MANAGEMENT
  // ============================================================================

  // Get company images
  app.get('/api/company-images', requireAuth, async (req, res) => {
    try {
      const images = await companyStorage.getCompanyImages();
      res.json({ success: true, data: images });
    } catch (error) {
      console.error('Error fetching company images:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØµØ§ÙˆÛŒØ± Ø´Ø±Ú©Øª" });
    }
  });

  // Create company image
  app.post('/api/company-images', requireAuth, async (req, res) => {
    try {
      const validatedData = insertCompanyImagesSchema.parse(req.body);
      const newImage = await companyStorage.createCompanyImage(validatedData);
      
      res.json({ 
        success: true, 
        data: newImage,
        message: "ØªØµÙˆÛŒØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error creating company image:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØµÙˆÛŒØ±" });
    }
  });

  // Update company image
  app.put('/api/company-images/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertCompanyImagesSchema.partial().parse(req.body);
      const updatedImage = await companyStorage.updateCompanyImage(parseInt(id), validatedData);
      
      if (!updatedImage) {
        return res.status(404).json({ success: false, message: "ØªØµÙˆÛŒØ± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: updatedImage,
        message: "ØªØµÙˆÛŒØ± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating company image:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØµÙˆÛŒØ±" });
    }
  });

  // Delete company image
  app.delete('/api/company-images/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await companyStorage.deleteCompanyImage(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json({ success: false, message: "ØªØµÙˆÛŒØ± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        message: "ØªØµÙˆÛŒØ± Ø­Ø°Ù Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error deleting company image:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªØµÙˆÛŒØ±" });
    }
  });

  // Legacy endpoint - backward compatibility  
  app.get('/api/company-information/images', requireAuth, async (req, res) => {
    try {
      const images = await companyStorage.getCompanyImages();
      res.json({ success: true, data: images });
    } catch (error) {
      console.error('Error fetching company images:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØµØ§ÙˆÛŒØ± Ø´Ø±Ú©Øª" });
    }
  });

  // Upload company image
  app.post('/api/company-information/images', requireAuth, uploadImage.single('image'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, message: "ÙØ§ÛŒÙ„ ØªØµÙˆÛŒØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { title, description, category } = req.body;
      const imageUrl = `/uploads/images/${req.file.filename}`;

      const [newImage] = await db
        .insert(companyImages)
        .values({
          title,
          description,
          category,
          imageUrl,
          filename: req.file.filename,
          fileSize: req.file.size,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      res.json({
        success: true,
        data: newImage,
        message: "ØªØµÙˆÛŒØ± Ø´Ø±Ú©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error uploading company image:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ± Ø´Ø±Ú©Øª" });
    }
  });

  // Get business cards
  app.get('/api/company-information/business-cards', requireAuth, async (req, res) => {
    try {
      const businessCardsList = await db
        .select()
        .from(businessCards)
        .where(eq(businessCards.isActive, true))
        .orderBy(desc(businessCards.createdAt));
      
      res.json({ success: true, data: businessCardsList });
    } catch (error) {
      console.error('Error fetching business cards:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ ÙˆÛŒØ²ÛŒØª" });
    }
  });

  // Upload business card
  app.post('/api/company-information/business-cards', requireAuth, uploadImage.single('businessCard'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, message: "ÙØ§ÛŒÙ„ Ú©Ø§Ø±Øª ÙˆÛŒØ²ÛŒØª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { personName, position, company, notes } = req.body;
      const imageUrl = `/uploads/images/${req.file.filename}`;

      const [newBusinessCard] = await db
        .insert(businessCards)
        .values({
          personName,
          position,
          company,
          notes,
          imageUrl,
          filename: req.file.filename,
          fileSize: req.file.size,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      res.json({
        success: true,
        data: newBusinessCard,
        message: "Ú©Ø§Ø±Øª ÙˆÛŒØ²ÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error uploading business card:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ø§Ø±Øª ÙˆÛŒØ²ÛŒØª" });
    }
  });

  // =============================================================================
  // API MIDDLEWARE - ENSURE ALL /api ROUTES RETURN JSON
  // =============================================================================
  
  // Middleware to ensure all API routes return JSON (not HTML)
  app.use('/api/*', (req, res, next) => {
    // Set Content-Type header to application/json for all API routes
    res.setHeader('Content-Type', 'application/json');
    
    // Override the default error handling to always return JSON
    const originalSend = res.send;
    res.send = function(data) {
      // If data is a string that looks like HTML, convert to JSON error
      if (typeof data === 'string' && data.includes('<!DOCTYPE html>')) {
        return originalSend.call(this, JSON.stringify({
          success: false,
          message: 'API endpoint not found',
          error: 'This endpoint should return JSON, not HTML'
        }));
      }
      return originalSend.call(this, data);
    };
    
    next();
  });

  // =============================================================================
  // HEALTH CHECK API
  // =============================================================================
  
  // Health check endpoint - must return JSON
  app.get("/api/health", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Test database connection
      const dbResult = await pool.query('SELECT 1 as healthy');
      const dbHealthy = dbResult.rows[0]?.healthy === 1;
      
      const status = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        services: {
          database: dbHealthy ? 'healthy' : 'unhealthy',
          server: 'healthy'
        }
      };
      
      res.json(status);
    } catch (error) {
      console.error('Health check failed:', error);
      res.status(500).json({
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        error: error.message,
        services: {
          database: 'unhealthy',
          server: 'healthy'
        }
      });
    }
  });

  // =============================================================================
  // INTERNATIONAL GEOGRAPHY API
  // =============================================================================
  
  // Get all international countries
  app.get('/api/logistics/international-countries', requireAuth, async (req, res) => {
    try {
      const countries = await db.select().from(internationalCountries);
      res.json({ success: true, data: countries });
    } catch (error) {
      console.error('Error fetching international countries:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø´ÙˆØ±Ù‡Ø§" });
    }
  });

  // Create new international country
  app.post('/api/logistics/international-countries', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalCountrySchema.parse(req.body);
      const [newCountry] = await db
        .insert(internationalCountries)
        .values(validatedData)
        .returning();
      res.json({ success: true, data: newCountry });
    } catch (error) {
      console.error('Error creating international country:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø´ÙˆØ±" });
    }
  });

  // Update international country
  app.put('/api/logistics/international-countries/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertInternationalCountrySchema.parse(req.body);
      const [updatedCountry] = await db
        .update(internationalCountries)
        .set(validatedData)
        .where(eq(internationalCountries.id, id))
        .returning();
      res.json({ success: true, data: updatedCountry });
    } catch (error) {
      console.error('Error updating international country:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø´ÙˆØ±" });
    }
  });

  // Delete international country
  app.delete('/api/logistics/international-countries/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await db
        .delete(internationalCountries)
        .where(eq(internationalCountries.id, id));
      res.json({ success: true, message: "Ú©Ø´ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting international country:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø´ÙˆØ±" });
    }
  });

  // Get all international cities with country names
  app.get('/api/logistics/international-cities', requireAuth, async (req, res) => {
    try {
      const cities = await db
        .select({
          id: internationalCities.id,
          name: internationalCities.name,
          nameEn: internationalCities.nameEn,
          nameLocal: internationalCities.nameLocal,
          countryId: internationalCities.countryId,
          countryName: internationalCountries.name,
          provinceState: internationalCities.provinceState,
          cityType: internationalCities.cityType,
          distanceFromErbilKm: internationalCities.distanceFromErbilKm,
          isActive: internationalCities.isActive,
          hasShippingRoutes: internationalCities.hasShippingRoutes,
          isPriorityDestination: internationalCities.isPriorityDestination,
          customsInformation: internationalCities.customsInformation,
          notes: internationalCities.notes,
          createdAt: internationalCities.createdAt,
          updatedAt: internationalCities.updatedAt
        })
        .from(internationalCities)
        .leftJoin(internationalCountries, eq(internationalCities.countryId, internationalCountries.id));
      res.json({ success: true, data: cities });
    } catch (error) {
      console.error('Error fetching international cities:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ù‡Ø±Ù‡Ø§" });
    }
  });

  // Create new international city
  app.post('/api/logistics/international-cities', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalCitySchema.parse(req.body);
      const [newCity] = await db
        .insert(internationalCities)
        .values(validatedData)
        .returning();
      res.json({ success: true, data: newCity });
    } catch (error) {
      console.error('Error creating international city:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ù‡Ø±" });
    }
  });

  // Update international city
  app.put('/api/logistics/international-cities/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertInternationalCitySchema.parse(req.body);
      const [updatedCity] = await db
        .update(internationalCities)
        .set(validatedData)
        .where(eq(internationalCities.id, id))
        .returning();
      res.json({ success: true, data: updatedCity });
    } catch (error) {
      console.error('Error updating international city:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ù‡Ø±" });
    }
  });

  // Delete international city
  app.delete('/api/logistics/international-cities/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await db
        .delete(internationalCities)
        .where(eq(internationalCities.id, id));
      res.json({ success: true, message: "Ø´Ù‡Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting international city:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø´Ù‡Ø±" });
    }
  });

  // Get all international shipping rates with country and city names
  app.get('/api/logistics/international-shipping-rates', requireAuth, async (req, res) => {
    try {
      const rates = await db
        .select({
          id: internationalShippingRates.id,
          countryId: internationalShippingRates.countryId,
          cityId: internationalShippingRates.cityId,
          countryName: internationalCountries.name,
          cityName: internationalCities.name,
          shippingMethod: internationalShippingRates.shippingMethod,
          transportProvider: internationalShippingRates.transportProvider,
          basePrice: internationalShippingRates.basePrice,
          pricePerKg: internationalShippingRates.pricePerKg,
          pricePerKm: internationalShippingRates.pricePerKm,
          minimumCharge: internationalShippingRates.minimumCharge,
          maximumWeight: internationalShippingRates.maximumWeight,
          estimatedDaysMin: internationalShippingRates.estimatedDaysMin,
          estimatedDaysMax: internationalShippingRates.estimatedDaysMax,
          currency: internationalShippingRates.currency,
          supportsHazardous: internationalShippingRates.supportsHazardous,
          supportsFlammable: internationalShippingRates.supportsFlammable,
          supportsRefrigerated: internationalShippingRates.supportsRefrigerated,
          requiresCustomsClearance: internationalShippingRates.requiresCustomsClearance,
          isActive: internationalShippingRates.isActive,
          notes: internationalShippingRates.notes,
          createdAt: internationalShippingRates.createdAt,
          updatedAt: internationalShippingRates.updatedAt
        })
        .from(internationalShippingRates)
        .leftJoin(internationalCountries, eq(internationalShippingRates.countryId, internationalCountries.id))
        .leftJoin(internationalCities, eq(internationalShippingRates.cityId, internationalCities.id));
      res.json({ success: true, data: rates });
    } catch (error) {
      console.error('Error fetching international shipping rates:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø®â€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„" });
    }
  });

  // Create new international shipping rate
  app.post('/api/logistics/international-shipping-rates', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalShippingRateSchema.parse(req.body);
      const [newRate] = await db
        .insert(internationalShippingRates)
        .values(validatedData)
        .returning();
      res.json({ success: true, data: newRate });
    } catch (error) {
      console.error('Error creating international shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø±Ø® Ø­Ù…Ù„" });
    }
  });

  // Update international shipping rate
  app.put('/api/logistics/international-shipping-rates/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertInternationalShippingRateSchema.parse(req.body);
      const [updatedRate] = await db
        .update(internationalShippingRates)
        .set(validatedData)
        .where(eq(internationalShippingRates.id, id))
        .returning();
      res.json({ success: true, data: updatedRate });
    } catch (error) {
      console.error('Error updating international shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ø±Ø® Ø­Ù…Ù„" });
    }
  });

  // Delete international shipping rate
  app.delete('/api/logistics/international-shipping-rates/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await db
        .delete(internationalShippingRates)
        .where(eq(internationalShippingRates.id, id));
      res.json({ success: true, message: "Ù†Ø±Ø® Ø­Ù…Ù„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting international shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù†Ø±Ø® Ø­Ù…Ù„" });
    }
  });

  // =============================================================================
  // AI SETTINGS API
  // =============================================================================
  
  // Save AI Settings
  app.post("/api/ai/settings", requireAuth, async (req, res) => {
    try {
      const { apiKey, secretKey, model, maxTokens, temperature, aiEnabled, skuGeneration, smartRecommendations } = req.body;
      
      // For now, store in memory/localStorage equivalent
      // In production, this would be stored in database
      const settings = {
        apiKey: apiKey || "",
        secretKey: secretKey || "",
        model: model || "gpt-4o",
        maxTokens: maxTokens || 1000,
        temperature: temperature || 0.7,
        aiEnabled: aiEnabled !== false,
        skuGeneration: skuGeneration !== false,
        smartRecommendations: smartRecommendations !== false,
        updatedAt: new Date()
      };
      
      res.json({ success: true, settings });
    } catch (error) {
      console.error("Error saving AI settings:", error);
      res.status(500).json({ message: "Failed to save AI settings" });
    }
  });

  // Test AI Connection
  app.post("/api/ai/test-connection", requireAuth, async (req, res) => {
    try {
      // Mock successful connection test
      res.json({ 
        success: true, 
        model: "gpt-4o",
        status: "connected",
        timestamp: new Date()
      });
    } catch (error) {
      console.error("Error testing AI connection:", error);
      res.status(500).json({ message: "Failed to test AI connection" });
    }
  });

  // =============================================================================
  // AI SEO GENERATOR API
  // =============================================================================
  
  // Generate AI-powered SEO content
  app.post("/api/ai/seo/generate", requireAuth, async (req, res) => {
    try {
      const { generateAISeoContent } = await import('./ai-seo-generator.ts');
      const seoRequest = req.body;
      
      // Validate required fields
      if (!seoRequest.pageType || !seoRequest.language) {
        return res.status(400).json({
          success: false,
          message: 'Page type and language are required'
        });
      }
      
      const seoContent = await generateAISeoContent(seoRequest);
      
      res.json({
        success: true,
        data: seoContent,
        message: 'AI SEO content generated successfully'
      });
    } catch (error) {
      console.error('Error generating AI SEO content:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate AI SEO content: ' + error.message
      });
    }
  });

  // Analyze SEO performance
  app.post("/api/ai/seo/analyze", requireAuth, async (req, res) => {
    try {
      const { analyzeSeoPerformance } = await import('./ai-seo-generator.ts');
      const { url, targetKeywords } = req.body;
      
      if (!url || !targetKeywords) {
        return res.status(400).json({
          success: false,
          message: 'URL and target keywords are required'
        });
      }
      
      const analysis = await analyzeSeoPerformance(url, targetKeywords);
      
      res.json({
        success: true,
        data: analysis,
        message: 'SEO analysis completed successfully'
      });
    } catch (error) {
      console.error('Error analyzing SEO performance:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to analyze SEO performance: ' + error.message
      });
    }
  });

  // Generate keyword suggestions
  app.post("/api/ai/seo/keywords", requireAuth, async (req, res) => {
    try {
      const { generateKeywordSuggestions } = await import('./ai-seo-generator.ts');
      const { seedKeywords, language, industry } = req.body;
      
      if (!seedKeywords || !Array.isArray(seedKeywords)) {
        return res.status(400).json({
          success: false,
          message: 'Seed keywords array is required'
        });
      }
      
      const suggestions = await generateKeywordSuggestions(seedKeywords, language, industry);
      
      res.json({
        success: true,
        data: suggestions,
        message: 'Keyword suggestions generated successfully'
      });
    } catch (error) {
      console.error('Error generating keyword suggestions:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate keyword suggestions: ' + error.message
      });
    }
  });

  // Optimize content for SEO
  app.post("/api/ai/seo/optimize", requireAuth, async (req, res) => {
    try {
      const { optimizeContentForSeo } = await import('./ai-seo-generator.ts');
      const { content, targetKeywords, language } = req.body;
      
      if (!content || !targetKeywords) {
        return res.status(400).json({
          success: false,
          message: 'Content and target keywords are required'
        });
      }
      
      const optimization = await optimizeContentForSeo(content, targetKeywords, language);
      
      res.json({
        success: true,
        data: optimization,
        message: 'Content optimized successfully'
      });
    } catch (error) {
      console.error('Error optimizing content:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to optimize content: ' + error.message
      });
    }
  });

  // Generate bulk SEO content
  app.post("/api/ai/seo/bulk-generate", requireAuth, async (req, res) => {
    try {
      const { generateBulkSeoContent } = await import('./ai-seo-generator.ts');
      const { pages } = req.body;
      
      if (!pages || !Array.isArray(pages)) {
        return res.status(400).json({
          success: false,
          message: 'Pages array is required'
        });
      }
      
      const results = await generateBulkSeoContent(pages);
      
      res.json({
        success: true,
        data: results,
        message: `Bulk SEO content generated for ${results.length} pages`
      });
    } catch (error) {
      console.error('Error generating bulk SEO content:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate bulk SEO content: ' + error.message
      });
    }
  });

  // =============================================================================
  // AI PRODUCT RECOMMENDATIONS API
  // =============================================================================
  
  // Generate AI-powered product recommendations
  app.post('/api/recommendations/analyze', async (req, res) => {
    try {
      const { getAIProductRecommendations } = await import('./ai-recommendations.ts');
      
      const recommendationRequest = req.body;
      
      // Validate required fields
      if (!recommendationRequest.industry || !recommendationRequest.application || !recommendationRequest.requirements) {
        return res.status(400).json({
          success: false,
          message: 'Industry, application, and requirements are required fields'
        });
      }

      const recommendations = await getAIProductRecommendations(recommendationRequest);
      
      res.json({
        success: true,
        data: recommendations
      });
    } catch (error) {
      console.error('Recommendation API Error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to generate recommendations'
      });
    }
  });

  // Generate follow-up recommendations based on additional information
  app.post('/api/recommendations/follow-up', async (req, res) => {
    try {
      const { generateFollowUpRecommendations } = await import('./ai-recommendations.ts');
      
      const { originalRequest, previousRecommendations, newInformation } = req.body;
      
      if (!originalRequest || !previousRecommendations || !newInformation) {
        return res.status(400).json({
          success: false,
          message: 'Original request, previous recommendations, and new information are required'
        });
      }

      const updatedRecommendations = await generateFollowUpRecommendations(
        originalRequest,
        previousRecommendations,
        newInformation
      );
      
      res.json({
        success: true,
        data: updatedRecommendations
      });
    } catch (error) {
      console.error('Follow-up Recommendation API Error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to generate follow-up recommendations'
      });
    }
  });

  // API endpoint to get active users count
  app.get("/api/active-users", requireAuth, async (req: Request, res: Response) => {
    try {
      // Simple active users tracking - show current admin session
      const activeUsersData = {
        totalActiveSessions: 1,
        activeUsersCount: 1,
        activeUsers: [
          {
            id: req.session.adminId,
            username: 'Admin',
            lastActivity: new Date().toISOString(),
            sessionId: req.sessionID
          }
        ],
        lastUpdated: new Date().toISOString()
      };
      
      res.json({
        success: true,
        data: activeUsersData
      });
    } catch (error) {
      console.error("Error fetching active users:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch active users",
        data: {
          totalActiveSessions: 0,
          activeUsersCount: 0,
          activeUsers: [],
          lastUpdated: new Date().toISOString()
        }
      });
    }
  });

  // Test GPS data retrieval for specific order
  app.get("/api/test/gps/:orderNumber", async (req, res) => {
    try {
      const { orderNumber } = req.params;
      
      // Direct SQL query to get GPS data
      const result = await db
        .select({
          orderNumber: customerOrders.orderNumber,
          gpsLatitude: customerOrders.gpsLatitude,
          gpsLongitude: customerOrders.gpsLongitude,
          locationAccuracy: customerOrders.locationAccuracy,
        })
        .from(customerOrders)
        .where(eq(customerOrders.orderNumber, orderNumber));
      
      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: `Order ${orderNumber} not found`
        });
      }
      
      const order = result[0];
      const hasGpsLocation = !!(order.gpsLatitude && order.gpsLongitude);
      
      res.json({
        success: true,
        data: {
          orderNumber: order.orderNumber,
          gpsLatitude: order.gpsLatitude,
          gpsLongitude: order.gpsLongitude,
          locationAccuracy: order.locationAccuracy,
          hasGpsLocation
        }
      });
    } catch (error) {
      console.error('Error fetching GPS data:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch GPS data: ' + error.message
      });
    }
  });

  // Admin authentication routes
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Username and password are required" 
        });
      }

      let user = null;
      let isCustomUser = false;

      // First check standard users table
      user = await storage.getUserByUsername(username);
      
      if (!user) {
        // Check custom_users table
        const { pool } = await import('./db');
        const result = await pool.query(`
          SELECT id, full_name, email, password_hash, role_id, is_active
          FROM custom_users 
          WHERE email = $1 AND is_active = true
        `, [username]);
        
        if (result.rows.length > 0) {
          const customUser = result.rows[0];
          user = {
            id: customUser.id,
            username: customUser.email,
            email: customUser.email,
            passwordHash: customUser.password_hash,
            roleId: customUser.role_id,
            isActive: customUser.is_active
          };
          isCustomUser = true;
          console.log(`ğŸ” Found custom user:`, { id: user.id, email: user.email, roleId: user.roleId });
        }
      }
      
      if (!user) {
        console.log(`âŒ No user found for username: ${username}`);
        return res.status(401).json({ 
          success: false, 
          message: "Invalid credentials" 
        });
      }

      console.log(`ğŸ” Found ${isCustomUser ? 'custom' : 'standard'} user:`, { 
        id: user.id, 
        email: user.email, 
        hasPasswordHash: !!user.passwordHash,
        roleId: user.roleId
      });

      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      console.log(`ğŸ” Password validation result: ${isValidPassword}`);
      
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid credentials" 
        });
      }

      // Clear any existing customer session first (single session mode)
      req.session.customerId = undefined;
      req.session.customerEmail = undefined;
      req.session.crmCustomerId = undefined;
      
      // Set up session with appropriate user type
      if (isCustomUser) {
        req.session.customerId = user.id;
        req.session.isAuthenticated = true;
        console.log(`âœ… [LOGIN] Session configured for custom user ${user.id} (customer session cleared):`, {
          customerId: req.session.customerId,
          isAuthenticated: req.session.isAuthenticated,
          sessionId: req.sessionID
        });
      } else {
        req.session.adminId = user.id;
        req.session.isAuthenticated = true;
        console.log(`âœ… [LOGIN] Session configured for admin ${user.id} (customer session cleared):`, {
          adminId: req.session.adminId,
          isAuthenticated: req.session.isAuthenticated,
          sessionId: req.sessionID
        });
      }
      
      // Save session explicitly before responding
      req.session.save((err) => {
        if (err) {
          console.error('Session save error:', err);
          return res.status(500).json({
            success: false,
            message: "Session save failed"
          });
        }
        
        console.log(`ğŸ’¾ Session saved successfully for ${isCustomUser ? 'custom user' : 'admin'} ${user.id}`);
        
        // Send response after session is saved
        res.json({ 
          success: true, 
          message: "Login successful",
          user: { 
            id: user.id, 
            username: user.username, 
            email: user.email, 
            roleId: user.roleId,
            userType: isCustomUser ? 'custom' : 'admin'
          }
        });
      });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });


  app.post("/api/admin/logout", (req, res) => {
    // Clear all session data (single session mode)
    req.session.adminId = undefined;
    req.session.customerId = undefined;
    req.session.customerEmail = undefined;
    req.session.crmCustomerId = undefined;
    req.session.isAuthenticated = undefined;
    
    // Always destroy entire session for clean logout
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ 
          success: false, 
          message: "Could not log out" 
        });
      }
      console.log('ğŸ”„ Complete admin logout - all sessions cleared');
      res.json({ success: true, message: "Logged out successfully" });
    });
  });

  app.post("/api/admin/register", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Username and password are required" 
        });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ 
          success: false, 
          message: "User already exists" 
        });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);

      // Create user
      const newUser = await storage.createUser({
        username,
        email: username,
        passwordHash,
        roleId: 1, // Default admin role ID
        isActive: true,
      });

      res.json({ 
        success: true, 
        message: "Admin account created successfully",
        user: { id: newUser.id, username: newUser.username, email: newUser.email, roleId: newUser.roleId }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/admin/me", requireAuth, async (req, res) => {
    try {
      let user = null;
      let userType = 'admin';
      
      if (req.session.adminId) {
        // Standard admin user
        user = await storage.getUserById(req.session.adminId);
        userType = 'admin';
      } else {
        // This endpoint is only for admin users, not customers
        return res.status(403).json({ 
          success: false, 
          message: "Access denied. This endpoint is for administrators only." 
        });
      }
      
      if (!user) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }
      
      res.json({ 
        success: true, 
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email, 
          roleId: user.roleId,
          roleName: user.roleName || 'admin',
          roleDisplayName: user.roleDisplayName || 'Administrator',
          userType
        }
      });
    } catch (error) {
      console.error("Error in /api/admin/me:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Authentication check endpoint - STRICT admin validation
  app.get("/api/admin/check-auth", async (req, res) => {
    try {
      // Strict admin validation - require valid admin session
      if (!req.session.adminId || !req.session.isAuthenticated) {
        return res.status(401).json({ 
          success: false, 
          message: "Not authenticated as admin" 
        });
      }
      
      // Verify user still exists and is active
      const user = await storage.getUserById(req.session.adminId);
      if (!user || !user.isActive) {
        return res.status(401).json({ 
          success: false, 
          message: "User not found or inactive" 
        });
      }
      
      res.json({ 
        success: true, 
        authenticated: true,
        user: { id: user.id, username: user.username, email: user.email, roleId: user.roleId }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Password reset functionality
  app.post("/api/admin/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ 
          success: false, 
          message: "Email is required" 
        });
      }

      // Check if user exists
      const user = await storage.getUserByUsername(email);
      if (!user) {
        // Don't reveal if user exists or not for security
        return res.json({ 
          success: true, 
          message: "If an account with this email exists, a password reset link has been sent" 
        });
      }

      // Generate reset token
      const resetToken = Math.random().toString(36).substring(2) + Date.now().toString(36);
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now

      // Save reset token
      await storage.createPasswordReset({
        email: user.email,
        token: resetToken,
        expiresAt,
        used: false,
      });

      // Send password reset email using Universal Email Service
      const { CONFIG } = await import('./config');
      
      const { UniversalEmailService } = await import('./universal-email-service');
      await UniversalEmailService.sendPasswordResetEmail(
        user.email,
        resetToken,
        user.username,
        req
      );

      res.json({ 
        success: true, 
        message: "If an account with this email exists, a password reset link has been sent"
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });



  // Admin management endpoints
  app.get("/api/admin/users", requireAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const safeUsers = users.map(user => ({
        id: user.id,
        username: user.username,
        email: user.email,
        roleId: user.roleId,
        isActive: user.isActive,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      }));
      
      res.json({ 
        success: true, 
        users: safeUsers 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.put("/api/admin/users/:id", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { username, email, role, isActive } = req.body;
      
      if (isNaN(userId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      // Prevent self-deactivation
      if (req.session.adminId === userId && isActive === false) {
        return res.status(400).json({ 
          success: false, 
          message: "Cannot deactivate your own account" 
        });
      }

      const updatedUser = await storage.updateUser(userId, {
        username,
        email,
        roleId: role ? parseInt(role) : undefined,
        isActive,
      });

      res.json({ 
        success: true, 
        message: "User updated successfully",
        user: {
          id: updatedUser.id,
          username: updatedUser.username,
          email: updatedUser.email,
          roleId: updatedUser.roleId,
          isActive: updatedUser.isActive,
        }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.put("/api/admin/change-password", requireAuth, async (req, res) => {
    try {
      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "Current and new passwords are required" 
        });
      }

      // Get current user
      const user = await storage.getUserById(req.session.adminId!);
      if (!user) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }

      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!isValidPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "Current password is incorrect" 
        });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password
      await storage.updateUserPassword(user.id, newPasswordHash);

      res.json({ 
        success: true, 
        message: "Password changed successfully" 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Admin wallet correction endpoints
  app.post("/api/admin/wallet/find-order", requireAuth, async (req, res) => {
    try {
      const { order_number } = req.body;
      
      if (!order_number) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Ø§Ø¬Ø±Ø§ÛŒ ØªØ§Ø¨Ø¹ Ø¬Ø³ØªØ¬ÙˆÛŒ Ø³ÙØ§Ø±Ø´
      const result = await db.execute(sql`
        SELECT * FROM find_order_info_by_number(${order_number})
      `);

      if (result.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const orderInfo = result.rows[0];
      res.json({ 
        success: true, 
        order: {
          order_id: orderInfo.order_id,
          customer_id: orderInfo.customer_id,
          customer_name: orderInfo.customer_name,
          order_total: parseFloat(orderInfo.order_total),
          wallet_balance: parseFloat(orderInfo.wallet_balance),
          order_status: orderInfo.order_status
        }
      });
    } catch (error) {
      console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ø³ÙØ§Ø±Ø´:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø³Ø±ÙˆØ±" 
      });
    }
  });

  app.post("/api/admin/wallet/correction", requireAuth, async (req, res) => {
    try {
      const { order_number, correction_amount, description } = req.body;
      
      if (!order_number || correction_amount === undefined) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ùˆ Ù…Ø¨Ù„Øº ØªØµØ­ÛŒØ­ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Ø§Ø¬Ø±Ø§ÛŒ ØªØ§Ø¨Ø¹ ØªØµØ­ÛŒØ­ Ø§Ù…Ù†
      const result = await db.execute(sql`
        SELECT manage_wallet_payment_by_order_number(
          ${order_number}, 
          ${correction_amount}, 
          ${description || null}
        ) as result
      `);

      const correctionResult = JSON.parse(result.rows[0].result);
      
      if (correctionResult.success) {
        res.json(correctionResult);
      } else {
        res.status(400).json(correctionResult);
      }
    } catch (error) {
      console.error('Ø®Ø·Ø§ Ø¯Ø± ØªØµØ­ÛŒØ­ Ú©ÛŒÙ Ù¾ÙˆÙ„:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø³Ø±ÙˆØ±",
        error: error.message
      });
    }
  });

  // Admin endpoint to change any user's password
  app.put("/api/admin/users/:id/password", requireAuth, async (req, res) => {
    try {
      const userId = req.params.id;
      const { newPassword } = req.body;
      
      if (!userId) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      if (!newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "New password is required" 
        });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password in custom_users table
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE custom_users 
        SET password_hash = $1
        WHERE id = $2
        RETURNING id, full_name
      `, [newPasswordHash, userId]);

      if (result.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }

      res.json({ 
        success: true, 
        message: "User password updated successfully" 
      });
    } catch (error) {
      console.error("Error updating user password:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Admin endpoint to send password reset link to a user
  app.post("/api/admin/users/:id/send-reset-link", requireAuth, async (req, res) => {
    try {
      const userId = req.params.id;
      
      if (!userId) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      // Get user from custom_users table
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, full_name, email 
        FROM custom_users 
        WHERE id = $1
      `, [userId]);

      if (result.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }

      const user = result.rows[0];

      // Generate reset token
      const resetToken = Math.random().toString(36).substring(2) + Date.now().toString(36);
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now

      // Save reset token in password_resets table
      await pool.query(`
        INSERT INTO password_resets (email, token, expires_at, used)
        VALUES ($1, $2, $3, $4)
      `, [user.email, resetToken, expiresAt, false]);

      // Generate reset link
      const resetLink = `${req.protocol}://${req.get('host')}/reset-password?token=${resetToken}`;

      // TODO: Send email with reset link
      // For now, we'll log it and return in response
      console.log(`Password reset link for ${user.email}: ${resetLink}`);

      res.json({ 
        success: true, 
        message: `Password reset link sent to ${user.email}`,
        resetLink, // In production, this would be sent via email
        resetToken // For testing purposes
      });
    } catch (error) {
      console.error("Error sending password reset link:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.delete("/api/admin/users/:id", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      
      if (isNaN(userId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      // Prevent self-deletion
      if (req.session.adminId === userId) {
        return res.status(400).json({ 
          success: false, 
          message: "Cannot delete your own account" 
        });
      }

      await storage.deleteUser(userId);

      res.json({ 
        success: true, 
        message: "User deleted successfully" 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Serve uploaded files
  app.get('/uploads/images/:filename', (req, res) => {
    const filename = req.params.filename;
    const filepath = path.join(process.cwd(), 'uploads', 'images', filename);
    
    if (fs.existsSync(filepath)) {
      // Set proper content type based on file extension
      const ext = path.extname(filename).toLowerCase();
      let contentType = 'image/png'; // default
      
      switch (ext) {
        case '.jpg':
        case '.jpeg':
          contentType = 'image/jpeg';
          break;
        case '.png':
          contentType = 'image/png';
          break;
        case '.webp':
          contentType = 'image/webp';
          break;
        case '.gif':
          contentType = 'image/gif';
          break;
      }
      
      res.setHeader('Content-Type', contentType);
      res.setHeader('Cache-Control', 'public, max-age=86400');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.sendFile(filepath);
    } else {
      res.status(404).json({ message: 'Image not found' });
    }
  });

  app.get('/uploads/catalogs/:filename', (req, res) => {
    const filename = req.params.filename;
    const filepath = path.join(process.cwd(), 'uploads', 'catalogs', filename);
    
    if (fs.existsSync(filepath)) {
      res.sendFile(filepath);
    } else {
      res.status(404).json({ message: 'Catalog not found' });
    }
  });

  // File upload endpoints
  // Generic upload route (for images) - accepts both 'file' and 'image' field names
  const uploadFlexible = multer({
    storage: imageStorage,
    limits: {
      fileSize: 2 * 1024 * 1024, // 2MB limit - optimized for web display
    },
    fileFilter: (req, file, cb) => {
      // Allow only optimal image formats for web display
      const allowedMimeTypes = [
        'image/jpeg',
        'image/jpg', 
        'image/png',
        'image/webp'
      ];
      
      if (allowedMimeTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Only JPEG, PNG, and WebP images are allowed for optimal customer display'));
      }
    }
  });

  app.post("/api/upload", requireAuth, (req, res) => {
    const upload = uploadFlexible.fields([
      { name: 'file', maxCount: 1 },
      { name: 'image', maxCount: 1 }
    ]);

    upload(req, res, (err) => {
      if (err) {
        console.error('Upload error:', err);
        return res.status(400).json({ 
          success: false, 
          message: err.message 
        });
      }

      try {
        const files = req.files as { [fieldname: string]: Express.Multer.File[] };
        const uploadedFile = files?.file?.[0] || files?.image?.[0];

        if (!uploadedFile) {
          return res.status(400).json({ 
            success: false, 
            message: "No file uploaded" 
          });
        }

        const imageUrl = `/uploads/images/${uploadedFile.filename}`;
        res.json({ 
          success: true, 
          url: imageUrl,
          filename: uploadedFile.filename,
          originalName: uploadedFile.originalname,
          size: uploadedFile.size
        });
      } catch (error) {
        console.error('Upload processing error:', error);
        res.status(500).json({ 
          success: false, 
          message: "Failed to process upload" 
        });
      }
    });
  });

  app.post("/api/upload/image", requireAuth, uploadImage.single('image'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No image file uploaded" 
        });
      }

      const imageUrl = `/uploads/images/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: imageUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload image" 
      });
    }
  });

  app.post("/api/upload/catalog", requireAuth, uploadCatalog.single('catalog'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No catalog file uploaded" 
        });
      }

      const catalogUrl = `/uploads/catalogs/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: catalogUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload catalog" 
      });
    }
  });

  // MSDS upload endpoint
  app.post("/api/upload/msds", requireAuth, uploadMsds.single('msds'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No MSDS file uploaded" 
        });
      }

      const msdsUrl = `/uploads/msds/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: msdsUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      console.error('MSDS upload error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload MSDS file" 
      });
    }
  });

  // Company logo upload endpoint
  app.post("/api/upload/company-logo", requireAuth, uploadLogo.single('file'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No logo file uploaded" 
        });
      }

      const logoUrl = `/uploads/logos/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: logoUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      console.error('Logo upload error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload logo file" 
      });
    }
  });

  // Update product MSDS information (for both shop and showcase products)
  app.put("/api/products/:id/msds", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { msdsUrl, showMsdsToCustomers, msdsFileName } = req.body;

      // Update shop product MSDS
      await storage.updateShopProduct(parseInt(id), {
        msdsUrl,
        showMsdsToCustomers,
        msdsFileName,
        msdsUploadDate: new Date()
      });

      // Also update showcase product if it exists
      try {
        await storage.updateShowcaseProduct(parseInt(id), {
          msdsUrl,
          showMsdsToCustomers,
          msdsFileName,
          msdsUploadDate: new Date()
        });
      } catch (error) {
        // Showcase product might not exist, continue with shop product only
        console.log('Showcase product not found, updated shop product only');
      }

      res.json({ 
        success: true, 
        message: "MSDS information updated successfully" 
      });
    } catch (error) {
      console.error('Error updating MSDS information:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update MSDS information" 
      });
    }
  });

  // Get MSDS file for customers (only if showMsdsToCustomers is true)
  app.get("/api/products/:id/msds", async (req, res) => {
    try {
      const { id } = req.params;

      // Get product MSDS information
      const product = await storage.getShopProduct(parseInt(id));
      
      if (!product || !product.msdsUrl || !product.showMsdsToCustomers) {
        return res.status(404).json({ 
          success: false, 
          message: "MSDS not available for this product" 
        });
      }

      res.json({
        success: true,
        data: {
          msdsUrl: product.msdsUrl,
          msdsFileName: product.msdsFileName || 'MSDS.pdf',
          msdsUploadDate: product.msdsUploadDate
        }
      });
    } catch (error) {
      console.error('Error fetching MSDS:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch MSDS" 
      });
    }
  });

  // Bank receipt upload endpoint (DISABLED - using newer version below)
  /*
  app.post("/api/payment/upload-receipt", requireCustomerAuth, (req, res) => {
    const uploadReceipt = multer({
      storage: receiptStorage,
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
      fileFilter: (req, file, cb) => {
        // Accept images and PDFs
        if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
          cb(null, true);
        } else {
          cb(new Error('Only image and PDF files are allowed for receipt uploads'));
        }
      }
    }).single('receipt');

    uploadReceipt(req, res, async (err) => {
      if (err) {
        console.error('Receipt upload error:', err);
        return res.status(400).json({ 
          success: false, 
          message: err.message 
        });
      }

      try {
        if (!req.file) {
          return res.status(400).json({ 
            success: false, 
            message: "ÙØ§ÛŒÙ„ ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª" 
          });
        }

        const { orderId, notes } = req.body;
        const customerId = (req.session as any)?.customerId;
        const receiptUrl = `/uploads/receipts/${req.file.filename}`;

        // Update order with receipt information
        if (orderId) {
          await shopStorage.updateOrder(parseInt(orderId), {
            paymentStatus: 'receipt_uploaded',
            receiptUrl: receiptUrl,
            receiptUploadDate: new Date(),
            receiptNotes: notes || null
          });

          // Also store in payment_receipts table for order management system
          await orderManagementStorage.uploadPaymentReceipt({
            customerOrderId: parseInt(orderId),
            customerId: customerId,
            receiptUrl: receiptUrl,
            originalFileName: req.file.originalname,
            fileSize: req.file.size,
            mimeType: req.file.mimetype,
            notes: notes || null
          });

          // Update order_management table if it exists
          const orderMgmt = await orderManagementStorage.getOrderManagementByCustomerOrderId(parseInt(orderId));
          if (orderMgmt) {
            await orderManagementStorage.updateOrderManagement(orderMgmt.id, {
              paymentReceiptUrl: receiptUrl,
              currentStatus: 'payment_uploaded',
              currentDepartment: 'finance',
              updatedAt: new Date()
            });
            console.log(`âœ… Order management updated for order ${orderId} - moved to finance department`);
          } else {
            console.log(`âš ï¸ Order management record not found for order ${orderId}`);
          }

          // Log the receipt upload
          console.log(`Receipt uploaded for order ${orderId} by customer ${customerId}`);
        }

        res.json({ 
          success: true, 
          message: "ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯",
          data: {
            receiptUrl: receiptUrl,
            filename: req.file.filename,
            originalName: req.file.originalname,
            size: req.file.size,
            uploadDate: new Date()
          }
        });
      } catch (error) {
        console.error('Error processing receipt upload:', error);
        res.status(500).json({ 
          success: false, 
          message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ" 
        });
      }
    });
  });
  */

  // Get receipt for order (customer can view their own receipt)
  app.get("/api/payment/receipt/:orderId", requireCustomerAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const customerId = (req.session as any)?.customerId;

      // Get order and verify it belongs to the customer
      const order = await shopStorage.getOrderById(orderId);
      
      if (!order) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Verify customer owns this order
      if (order.customerId !== customerId) {
        return res.status(403).json({ 
          success: false, 
          message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª" 
        });
      }

      if (!order.receiptUrl) {
        return res.status(404).json({ 
          success: false, 
          message: "ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      res.json({
        success: true,
        data: {
          receiptUrl: order.receiptUrl,
          receiptUploadDate: order.receiptUploadDate,
          receiptNotes: order.receiptNotes,
          paymentStatus: order.paymentStatus
        }
      });
    } catch (error) {
      console.error('Error fetching receipt:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ" 
      });
    }
  });



  // Helper function to get category email assignment
  async function getCategoryEmailAssignment(productInterest: string): Promise<string | null> {
    try {
      // Map product interests to category keys
      const categoryMapping: { [key: string]: string } = {
        'fuel-additives': 'fuel-additives',
        'water-treatment': 'water-treatment',
        'paint-solvents': 'paint-thinner',
        'agricultural-fertilizers': 'agricultural-fertilizers',
        'industrial-chemicals': 'industrial-chemicals',
        'paint-thinner': 'paint-thinner',
        'technical-equipment': 'sales', // Route to sales department
        'commercial-goods': 'commercial-goods',
        'custom-solutions': 'sales', // Route to sales department
        'other-products': 'orders'
      };

      const categoryKey = categoryMapping[productInterest] || 'orders';
      
      const assignment = await db
        .select()
        .from(categoryEmailAssignments)
        .where(eq(categoryEmailAssignments.categoryKey, categoryKey))
        .limit(1);

      return assignment.length > 0 ? assignment[0].assignedEmail : null;
    } catch (error) {
      console.error("Error getting category email assignment:", error);
      return null;
    }
  }

  // Contact form submission
  app.post("/api/contact", async (req, res) => {
    try {
      const contactData = insertContactSchema.parse(req.body);
      const contact = await storage.createContact(contactData);
      
      // Get category-specific email assignment
      const categoryEmail = await getCategoryEmailAssignment(contact.productInterest);
      
      // Send email notification with intelligent routing
      try {
        await sendContactEmail({
          firstName: contact.firstName,
          lastName: contact.lastName,
          email: contact.email,
          company: contact.company ?? '',
          productInterest: contact.productInterest,
          message: contact.message ?? '',
          categoryEmail: categoryEmail ?? undefined // Add category-specific email for routing
        });
        console.log(`Email sent successfully for contact: ${contact.id}, routed to category email: ${categoryEmail || 'default'}`);
      } catch (emailError) {
        console.error("Failed to send email:", emailError);
        // Continue processing even if email fails
      }

      // Send receipt acknowledgment email to customer using Template #09
      try {
        const { UniversalEmailService } = await import('./universal-email-service');
        
        // Generate inquiry number for reference
        const inquiryNumber = `INQ-${Date.now()}-${contact.id}`;
        const currentDate = new Date().toLocaleDateString('fa-IR', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        await UniversalEmailService.sendEmail({
          templateNumber: '#09',
          categoryKey: 'admin',
          to: [contact.email],
          subject: 'Ù¾ÛŒØ§Ù… Ø±Ø³ÛŒØ¯ ØªÙ…Ø§Ø³', // Will be replaced by template
          html: '', // Will be replaced by template
          variables: {
            inquiry_number: inquiryNumber,
            customer_name: `${contact.firstName} ${contact.lastName}`,
            expected_response_time: '24 Ø³Ø§Ø¹Øª',
            product_interest: contact.productInterest,
            company: contact.company || 'Ù…Ø´Ø®Øµ Ù†Ø´Ø¯Ù‡',
            message: contact.message || 'Ù¾ÛŒØ§Ù…ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯Ù‡',
            received_date: currentDate
          }
        });
        
        console.log(`Receipt acknowledgment email sent to customer: ${contact.email} using Template #09`);
      } catch (confirmationError) {
        console.error("Failed to send receipt acknowledgment email to customer:", confirmationError);
        // Continue processing even if confirmation email fails
      }
      
      console.log("New contact form submission:", contact);
      
      res.json({ success: true, message: "Contact form submitted successfully" });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Validation error", 
          errors: error.errors 
        });
      } else {
        console.error("Contact form error:", error);
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  // Send follow-up response to inquiry using Template #05
  app.post("/api/contacts/:contactId/respond", requireAdmin, async (req, res) => {
    try {
      const { contactId } = req.params;
      const { responseMessage, customerName } = req.body;
      
      // Get contact details
      const contacts = await storage.getContacts();
      const contact = contacts.find(c => c.id === parseInt(contactId));
      
      if (!contact) {
        return res.status(404).json({
          success: false,
          message: "Contact not found"
        });
      }
      
      // Send follow-up response using Template #05
      const { UniversalEmailService } = await import('./universal-email-service');
      
      // Generate inquiry number for reference
      const inquiryNumber = `INQ-${Date.now()}-${contact.id}`;
      const currentDate = new Date().toLocaleDateString('fa-IR', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      await UniversalEmailService.sendEmail({
        templateNumber: '#05',
        categoryKey: 'admin',
        to: [contact.email],
        subject: 'Ù¾Ø§Ø³Ø® Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø´Ù…Ø§', // Will be replaced by template
        html: '', // Will be replaced by template
        variables: {
          customer_name: customerName || `${contact.firstName} ${contact.lastName}`,
          inquiry_number: inquiryNumber,
          inquiry_subject: `${contact.productInterest} Inquiry`,
          inquiry_category: contact.productInterest,
          customer_message: contact.message || 'Ù¾ÛŒØ§Ù…ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯Ù‡',
          response_text: responseMessage || `Ø³Ù„Ø§Ù… ${customerName || contact.firstName},

Ø§Ø² ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø¨Ø§ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø³Ù¾Ø§Ø³Ú¯Ø²Ø§Ø±ÛŒÙ…. ØªÛŒÙ… ÙÙ†ÛŒ Ù…Ø§ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ù…Ø§ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø±Ø¯Ù‡ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø±Ø§Ø¦Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ù…Ù„ Ø¯Ø± Ù…ÙˆØ±Ø¯ ${contact.productInterest} Ù…ÛŒâ€ŒØ¨Ø§Ø´ÛŒÙ….

Ù…Ø§ ØªØ§ 24 Ø³Ø§Ø¹Øª Ø¢ÛŒÙ†Ø¯Ù‡ Ù‚ÛŒÙ…Øª Ø¯Ù‚ÛŒÙ‚ØŒ Ù…Ø´Ø®ØµØ§Øª ÙÙ†ÛŒ Ùˆ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ù…Ø­ØµÙˆÙ„ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ§Ù‡ÛŒÙ… Ú©Ø±Ø¯.

Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙÙˆØ±ÛŒØŒ Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ù…Ø§ ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯.

Ø¨Ø§ Ø§Ø­ØªØ±Ø§Ù…ØŒ
ØªÛŒÙ… ÙÙ†ÛŒ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ`,
          contact_phone: '+964 770 999 6771',
          contact_email: 'info@momtazchem.com',
          received_date: currentDate
        }
      });
      
      console.log(`Follow-up response sent to ${contact.email} using Template #05`);
      
      res.json({
        success: true,
        message: "Follow-up response sent successfully using Template #05"
      });
      
    } catch (error) {
      console.error("Error sending follow-up response:", error);
      res.status(500).json({
        success: false,
        message: "Failed to send follow-up response"
      });
    }
  });

  // Get all contacts (for admin purposes)
  app.get("/api/contacts", async (req, res) => {
    try {
      const contacts = await storage.getContacts();
      res.json(contacts);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // API endpoint for getting all batches of a product by barcode
  app.get("/api/batches/:barcode", requireAuth, async (req, res) => {
    try {
      const { barcode } = req.params;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          id, 
          name, 
          batch_number, 
          stock_quantity, 
          created_at,
          unit_price,
          net_weight,
          gross_weight
        FROM showcase_products 
        WHERE barcode = $1
        ORDER BY created_at DESC
      `, [barcode]);
      
      res.json({
        success: true,
        barcode,
        batches: result.rows,
        totalBatches: result.rows.length,
        totalStock: result.rows.reduce((sum, batch) => sum + (batch.stock_quantity || 0), 0)
      });
    } catch (error) {
      console.error("Error getting batches:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†â€ŒÙ‡Ø§" });
    }
  });

  // API endpoint for getting current selling batch (LIFO)
  app.get("/api/selling-batch/:barcode", requireAuth, async (req, res) => {
    try {
      const { barcode } = req.params;
      const { ShopStorage } = await import('./shop-storage');
      const shopStorage = new ShopStorage();
      
      const currentBatch = await shopStorage.getCurrentSellingBatch(barcode);
      
      if (!currentBatch) {
        return res.status(404).json({
          success: false,
          message: `Ù‡ÛŒÚ† Ø¨Ú† Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø±Ú©Ø¯ ${barcode} ÛŒØ§ÙØª Ù†Ø´Ø¯`
        });
      }
      
      res.json({
        success: true,
        barcode,
        currentBatch: {
          batchId: currentBatch.id,
          batchNumber: currentBatch.batch_number,
          productName: currentBatch.name,
          stockQuantity: currentBatch.stock_quantity,
          createdAt: currentBatch.created_at
        }
      });
    } catch (error) {
      console.error("Error getting current selling batch:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú† ÙØ¹Ø§Ù„" });
    }
  });

  // API endpoint for getting product unit from kardex by shop product ID
  app.get("/api/products/kardex/:id/unit", async (req, res) => {
    try {
      const shopProductId = parseInt(req.params.id);
      const { db, showcaseDb } = await import('./db');
      const { shopProducts } = await import('../shared/shop-schema');
      const { showcaseProducts } = await import('../shared/showcase-schema');
      const { eq } = await import('drizzle-orm');
      
      if (isNaN(shopProductId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // First get the shop product to find its name
      const [shopProduct] = await db
        .select({
          name: shopProducts.name
        })
        .from(shopProducts)
        .where(eq(shopProducts.id, shopProductId))
        .limit(1);

      console.log(`ğŸ” Looking for shop product ID ${shopProductId}:`, shopProduct);

      if (!shopProduct) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Find corresponding product in showcase_products (kardex) by name with preference for non-generic units
      const kardexProducts = await showcaseDb
        .select({
          stockUnit: showcaseProducts.stockUnit,
          name: showcaseProducts.name
        })
        .from(showcaseProducts)
        .where(eq(showcaseProducts.name, shopProduct.name));

      console.log(`ğŸ” Found ${kardexProducts.length} kardex products for "${shopProduct.name}":`, kardexProducts);

      // Choose best unit: prefer specific units like Ú©ÛŒÙ„ÙˆÚ¯Ø±Ù…, Ù„ÛŒØªØ± over generic "units"
      let kardexProduct = kardexProducts.find(p => p.stockUnit && p.stockUnit !== 'units') || kardexProducts[0];

      if (!kardexProduct) {
        console.log(`âŒ Ù…Ø­ØµÙˆÙ„ ${shopProduct.name} Ø¯Ø± Ú©Ø§Ø±Ø¯Ú©Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯`);
        return res.json({
          success: true,
          unit: 'ÙˆØ§Ø­Ø¯', // Default unit if not found in kardex
          productName: shopProduct.name
        });
      }
      
      res.json({
        success: true,
        unit: kardexProduct.stockUnit || 'ÙˆØ§Ø­Ø¯',
        productName: kardexProduct.name
      });
      
      console.log(`âœ… ÙˆØ§Ø­Ø¯ Ù…Ø­ØµÙˆÙ„ ${kardexProduct.name} Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³: "${kardexProduct.stockUnit}"`)
    } catch (error) {
      console.error("Error fetching product unit from kardex:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ§Ø­Ø¯ Ù…Ø­ØµÙˆÙ„ Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³"
      });
    }
  });

  // Protected admin routes for product management (Ú©Ø§Ø±Ø¯Ú©Ø³)
  app.post("/api/products", requireAuth, async (req, res) => {
    try {
      const productData = req.body;
      
      // Generate barcode if not provided
      let barcode = productData.barcode;
      if (!barcode) {
        try {
          const { generateEAN13Barcode } = await import('../shared/barcode-utils');
          barcode = await generateEAN13Barcode(productData.name, productData.category);
          console.log(`ğŸ”¢ Generated barcode for new product: ${barcode}`);
        } catch (barcodeError) {
          console.error("Barcode generation failed:", barcodeError);
          throw new Error("Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø¨Ø§Ø±Ú©Ø¯ Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯");
        }
      }

      // Check for duplicate barcode + batch combination
      if (barcode && productData.batchNumber) {
        const { pool } = await import('./db');
        const duplicateCheck = await pool.query(`
          SELECT COUNT(*) as count FROM showcase_products 
          WHERE barcode = $1 AND batch_number = $2
        `, [barcode, productData.batchNumber]);
        
        if (duplicateCheck.rows[0].count > 0) {
          return res.status(400).json({
            success: false,
            message: `Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ø¨Ø§Ø±Ú©Ø¯ ${barcode} Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ø¨Ú† ${productData.batchNumber} Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ Ø¨Ú† Ù…ØªÙØ§ÙˆØª Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.`
          });
        }
      }

      console.log(`âœ… New batch registration: Barcode ${barcode} + Batch ${productData.batchNumber || 'No Batch'} + Stock ${productData.stockQuantity || 0}`);
      
      
      // Create product in showcase_products table (Ú©Ø§Ø±Ø¯Ú©Ø³)
      const showcaseProductData = {
        name: productData.name,
        category: productData.category,
        description: productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        shortDescription: productData.shortDescription || productData.description,
        unitPrice: productData.unitPrice || productData.price || 11,
        currency: productData.currency || 'IQD',
        stockQuantity: productData.stockQuantity || 11,
        minStockLevel: productData.minStockLevel || 5,
        maxStockLevel: productData.maxStockLevel || 100,
        sku: productData.sku || `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        barcode: barcode,
        weight: productData.weight || 11,
        imageUrl: productData.imageUrl || null,
        specifications: productData.specifications || productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        features: productData.features || productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        applications: productData.applications || productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        tags: productData.tags || ["Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ"],
        isActive: productData.isActive !== false,
        syncWithShop: productData.syncWithShop || false,
        parentProductId: productData.parentProductId || null,
        isVariant: productData.isVariant || false,
        variantType: productData.variantType || null,
        variantValue: productData.variantValue || null,
        isFlammable: productData.isFlammable || false
      };
      
      const product = await storage.createProduct(showcaseProductData);
      
      // Trigger automatic synchronization after creating product
      try {
        const { KardexSyncMaster } = await import('./kardex-sync-master');
        const result = await KardexSyncMaster.smartSyncShopFromKardex();
        console.log(`ğŸ”„ Auto-sync completed after creating product:`, result.message);
      } catch (syncError) {
        console.log("Auto-sync failed after creation:", syncError);
      }
      
      res.status(201).json(product);
    } catch (error) {
      console.error("Error creating showcase product:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid product data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  });

  app.get("/api/products", async (req, res) => {
    try {
      const { category } = req.query;
      let products;
      
      // Use showcase_products table for admin products interface
      if (category && typeof category === 'string') {
        products = await storage.getProductsByCategory(category);
      } else {
        products = await storage.getProducts();
      }
      
      // Products from showcase_products are already in the correct format
      const mappedProducts = products;
      
      res.json(mappedProducts);
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Get random products for category page display based on content management settings
  app.get("/api/products/random/:category", async (req, res) => {
    try {
      const { category } = req.params;
      console.log(`ğŸ² [RANDOM PRODUCTS] Fetching random products for category: ${category}`);
      
      // First get all products in the category
      const products = await storage.getProductsByCategory(category);
      console.log(`ğŸ“¦ [RANDOM PRODUCTS] Found ${products.length} products in category ${category}`);
      
      if (products.length === 0) {
        return res.json({
          success: true,
          data: [],
          message: "No products found in category"
        });
      }
      
      // Get content management settings for this category
      const randomDisplaySetting = await db
        .select()
        .from(contentItems)
        .where(eq(contentItems.key, `random_display_${category}`))
        .limit(1);
        
      const maxDisplaySetting = await db
        .select()
        .from(contentItems)
        .where(eq(contentItems.key, `max_display_${category}`))
        .limit(1);
      
      console.log(`ğŸ” [RANDOM PRODUCTS] Random display settings:`, {
        found: randomDisplaySetting.length > 0,
        setting: randomDisplaySetting[0] || null,
        isActive: randomDisplaySetting[0]?.isActive,
        content: randomDisplaySetting[0]?.content
      });
      
      // Check if random display is enabled
      const isRandomEnabled = randomDisplaySetting.length > 0 && 
                             randomDisplaySetting[0].isActive && 
                             randomDisplaySetting[0].content === 'true';
      
      if (!isRandomEnabled) {
        console.log(`âŒ [RANDOM PRODUCTS] Random display is disabled for category ${category}`);
        return res.json({
          success: true,
          data: [],
          message: "Random display is disabled for this category"
        });
      }
      
      // Get max display count (default: 3)
      const maxDisplay = maxDisplaySetting.length > 0 ? 
                        parseInt(maxDisplaySetting[0].content) : 3;
      
      console.log(`ğŸ¯ [RANDOM PRODUCTS] Random display enabled, max display: ${maxDisplay}`);
      
      // Shuffle products and select random ones
      const shuffledProducts = [...products].sort(() => Math.random() - 0.5);
      const randomProducts = shuffledProducts.slice(0, Math.min(maxDisplay, products.length));
      
      console.log(`âœ… [RANDOM PRODUCTS] Returning ${randomProducts.length} random products`);
      
      res.json({
        success: true,
        data: randomProducts,
        settings: {
          category,
          randomEnabled: isRandomEnabled,
          maxDisplay,
          totalProducts: products.length,
          selectedCount: randomProducts.length
        }
      });
      
    } catch (error) {
      console.error("Error fetching random products:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  app.get("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      const product = await storage.getProductById(id);
      if (!product) {
        return res.status(404).json({ 
          success: false, 
          message: "Product not found" 
        });
      }

      res.json(product);
    } catch (error) {
      console.error(`Error fetching product ${id}:`, error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Update product (PATCH method)
  app.patch("/api/products/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      const productData = req.body;
      
      // Map frontend fields to backend fields for update
      const mappedData = {
        ...productData,
        price: productData.unitPrice || productData.price,
        priceUnit: productData.currency || productData.priceUnit || 'IQD',
        imageUrls: productData.imageUrl ? [productData.imageUrl] : (productData.imageUrls || [])
      };
      
      // Update showcase product instead of shop product for admin panel
      const product = await storage.updateProduct(id, mappedData);
      res.json(product);
    } catch (error) {
      console.error("Error updating product:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid product data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  });

  // =============================================================================
  // IRAQI GEOGRAPHIC DATA API ENDPOINTS
  // =============================================================================

  // Get all Iraqi provinces with trilingual support
  app.get('/api/iraqi-provinces', async (req, res) => {
    try {
      console.log('[DEBUG] Iraqi provinces endpoint called');
      const provinces = await db
        .select()
        .from(iraqiProvinces)
        .orderBy(iraqiProvinces.nameArabic);

      console.log('[DEBUG] Provinces found:', provinces.length);
      res.json({
        success: true,
        data: provinces,
        count: provinces.length
      });
    } catch (error) {
      console.error('[ERROR] Iraqi provinces fetch error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø³ØªØ§Ù†â€ŒÙ‡Ø§ÛŒ Ø¹Ø±Ø§Ù‚',
        error: error.message
      });
    }
  });

  // Get all Iraqi cities with province information
  app.get('/api/iraqi-cities', async (req, res) => {
    try {
      console.log('[DEBUG] Iraqi cities endpoint called');
      const { provinceId } = req.query;
      
      let query = db
        .select()
        .from(iraqiCities)
        .where(eq(iraqiCities.isActive, true));

      if (provinceId) {
        query = query.where(eq(iraqiCities.provinceId, parseInt(provinceId as string)));
      }

      const cities = await query.orderBy(iraqiCities.nameArabic);

      console.log('[DEBUG] Cities found:', cities.length);
      res.json({
        success: true,
        data: cities,
        count: cities.length
      });
    } catch (error) {
      console.error('[ERROR] Iraqi cities fetch error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ù‡Ø±Ù‡Ø§ÛŒ Ø¹Ø±Ø§Ù‚',
        error: error.message
      });
    }
  });

  // Get comprehensive Iraqi geographical statistics
  app.get('/api/iraqi-geography-stats', async (req, res) => {
    try {
      console.log('[DEBUG] Iraqi geography stats endpoint called');
      const [provinceCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(iraqiProvinces)
        .where(eq(iraqiProvinces.isActive, true));

      const [cityCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(iraqiCities)
        .where(eq(iraqiCities.isActive, true));

      const [capitalCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(iraqiCities)
        .where(and(
          eq(iraqiCities.isActive, true),
          eq(iraqiCities.isProvinceCapital, true)
        ));

      const regionStats = await db
        .select({
          region: iraqiCities.region,
          count: sql<number>`count(*)`
        })
        .from(iraqiCities)
        .where(eq(iraqiCities.isActive, true))
        .groupBy(iraqiCities.region);

      res.json({
        success: true,
        data: {
          totalProvinces: provinceCount.count,
          totalCities: cityCount.count,
          provincialCapitals: capitalCount.count,
          regionBreakdown: regionStats,
          lastUpdated: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('[ERROR] Iraqi geography stats error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ø¹Ø±Ø§Ù‚',
        error: error.message
      });
    }
  });

  // Update product (PUT method - for compatibility)
  app.put("/api/products/:id", requireAuth, async (req, res) => {
    try {
      console.log(`ğŸ”§ [DEBUG] PUT /api/products/${req.params.id} - Body:`, JSON.stringify(req.body, null, 2));
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        console.log(`âŒ [DEBUG] Invalid product ID: ${req.params.id}`);
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      const productData = req.body;
      console.log(`ğŸ“‹ [DEBUG] Product data keys:`, Object.keys(productData));
      
      // Handle sync toggle requests (skip all validations)
      const isSyncToggle = Object.keys(productData).length === 1 && 'syncWithShop' in productData;
      
      if (isSyncToggle) {
        console.log(`ğŸ”„ [DEBUG] Quick sync toggle request for product ${id}:`, productData.syncWithShop);
        // Skip all validations for sync toggles - just update the field
      } else {
        // Full validation for regular updates
        if (!productData.name || productData.name.trim() === '') {
          return res.status(400).json({ 
            success: false, 
            message: "Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
          });
        }
        
        // Validate numerical fields
        if (productData.stockQuantity !== undefined && (isNaN(productData.stockQuantity) || productData.stockQuantity < 0)) {
          return res.status(400).json({ 
            success: false, 
            message: "Ù…Ù‚Ø¯Ø§Ø± Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ù…Ø«Ø¨Øª Ø¨Ø§Ø´Ø¯" 
          });
        }
        
        if (productData.unitPrice !== undefined && (isNaN(parseFloat(productData.unitPrice)) || parseFloat(productData.unitPrice) < 0)) {
          return res.status(400).json({ 
            success: false, 
            message: "Ù‚ÛŒÙ…Øª Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ù…Ø«Ø¨Øª Ø¨Ø§Ø´Ø¯" 
          });
        }
      }
      
      console.log(`ğŸ“ [DEBUG] Updating showcase product ${id} with validated data`);
      console.log(`ğŸ“ [DEBUG] Tags field:`, productData.tags, 'Type:', typeof productData.tags);
      
      // Check if stock quantity is being updated for warehouse sync
      const oldProduct = await storage.getProductById(id);
      
      // Handle inventory addition functionality
      if (productData.inventoryAddition && productData.inventoryAddition > 0) {
        console.log(`ğŸ“¦ [INVENTORY-ADDITION] Adding ${productData.inventoryAddition} units to product ${id}`);
        
        // Calculate new stock quantity by adding to existing stock
        const currentStock = oldProduct ? oldProduct.stockQuantity || 0 : 0;
        const newStock = currentStock + productData.inventoryAddition;
        
        console.log(`ğŸ“¦ [INVENTORY-ADDITION] Stock calculation: ${currentStock} + ${productData.inventoryAddition} = ${newStock}`);
        
        // Update product data with new stock quantity
        productData.stockQuantity = newStock;
        
        // If new batch number is provided, create a new batch entry in Ú©Ø§Ø±Ø¯Ú©Ø³ only
        if (productData.newBatchNumber && productData.newBatchNumber.trim()) {
          console.log(`ğŸ“¦ [BATCH-CREATION] Creating new batch in Ú©Ø§Ø±Ø¯Ú©Ø³: ${productData.newBatchNumber}`);
          
          // Add batch to Ú©Ø§Ø±Ø¯Ú©Ø³ (showcase_products) only - ÙØ±ÙˆØ´Ú¯Ø§Ù‡ doesn't need batch details
          try {
            const batchData = {
              barcode: oldProduct?.barcode || '',
              batchNumber: productData.newBatchNumber.trim(),
              stockQuantity: productData.inventoryAddition,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            };
            
            await shopStorage.addBatch(batchData);
            console.log(`âœ… [BATCH-CREATION] Successfully created batch in Ú©Ø§Ø±Ø¯Ú©Ø³: ${productData.newBatchNumber}`);
          } catch (batchError) {
            console.error(`âŒ [BATCH-CREATION] Failed to create batch:`, batchError);
            // Don't fail the main operation if batch creation fails
          }
        }
        
        // Clean up the addition fields from productData so they don't get saved
        delete productData.inventoryAddition;
        delete productData.newBatchNumber;
        
        console.log(`âœ… [INVENTORY-ADDITION] Final stock quantity: ${newStock}`);
      }
      
      const isStockUpdate = productData.stockQuantity !== undefined && 
                           oldProduct && 
                           oldProduct.stockQuantity !== productData.stockQuantity;
      
      // Update showcase product
      const product = await storage.updateProduct(id, productData);
      console.log(`âœ… [DEBUG] Updated product result:`, JSON.stringify({
        id: product.id,
        name: product.name,
        tags: product.tags,
        description: product.description,
        stockQuantity: product.stockQuantity
      }, null, 2));
      
      // If stock quantity was updated, sync to warehouse inventory
      if (isStockUpdate && !isSyncToggle) {
        try {
          console.log(`ğŸ“¦ [WAREHOUSE-SYNC] Stock quantity updated for ${product.name}: ${oldProduct.stockQuantity} â†’ ${product.stockQuantity}`);
          
          // Calculate stock difference for warehouse sync
          const stockDifference = (product.stockQuantity || 0) - (oldProduct.stockQuantity || 0);
          
          if (stockDifference !== 0) {
            console.log(`ğŸ“¦ [WAREHOUSE-SYNC] Creating inventory movement: ${stockDifference > 0 ? '+' : ''}${stockDifference} units`);
            
            // Prepare inventory movement data
            const movementData = {
              productId: product.id,
              productName: product.name,
              productSku: product.sku || '',
              productBarcode: product.barcode || '',
              movementType: stockDifference > 0 ? 'Ú©Ø§Ø±Ø¯Ú©Ø³_Ø§ÙØ²Ø§ÛŒØ´' : 'Ú©Ø§Ø±Ø¯Ú©Ø³_Ú©Ø§Ù‡Ø´',
              quantity: Math.abs(stockDifference),
              previousStock: oldProduct.stockQuantity || 0,
              newStock: product.stockQuantity || 0,
              movementDate: new Date().toISOString(),
              reason: 'ØªØºÛŒÛŒØ± Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³',
              source: 'Ú©Ø§Ø±Ø¯Ú©Ø³',
              notes: `Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø² ${oldProduct.stockQuantity || 0} Ø¨Ù‡ ${product.stockQuantity || 0} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`
            };
            
            // Call warehouse inventory sync API
            try {
              const warehouseResponse = await fetch('http://localhost:5000/api/warehouse/inventory-sync', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(movementData)
              });
              
              if (warehouseResponse.ok) {
                console.log(`âœ… [WAREHOUSE-SYNC] Successfully recorded inventory movement for ${product.name}`);
              } else {
                console.log(`âš ï¸ [WAREHOUSE-SYNC] Warehouse API not available, logging change locally`);
              }
            } catch (apiError) {
              console.log(`ğŸ“ [WAREHOUSE-SYNC] Warehouse API call failed, movement will be visible in next warehouse sync`);
            }
            
            console.log(`âœ… [WAREHOUSE-SYNC] Stock synchronized from Ú©Ø§Ø±Ø¯Ú©Ø³ to warehouse for product ${product.name}`);
          }
        } catch (warehouseError) {
          console.error(`âŒ [WAREHOUSE-SYNC] Failed to sync stock to warehouse:`, warehouseError);
          // Don't fail the main operation if warehouse sync fails
        }
      }
      
      // Shop visibility logic - actually sync to shop when enabled
      if (productData.syncWithShop === true) {
        console.log(`ğŸª Ù…Ø­ØµÙˆÙ„ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯: ${product.name}`);
        
        // Actually sync this product to shop
        try {
          const existingShopProducts = await shopStorage.getShopProducts();
          const existingShopProduct = existingShopProducts.find(sp => sp.name === product.name);
          
          if (!existingShopProduct) {
            // Calculate total stock from all batches in Ú©Ø§Ø±Ø¯Ú©Ø³ for this barcode
            let totalStock = product.stockQuantity || 0;
            if (product.barcode) {
              try {
                const { pool } = await import('./db');
                const totalStockResult = await pool.query(`
                  SELECT SUM(stock_quantity) as total_stock
                  FROM showcase_products 
                  WHERE barcode = $1
                `, [product.barcode]);
                
                totalStock = totalStockResult.rows[0]?.total_stock || 0;
                console.log(`ğŸ“¦ [SHOP-SYNC] Calculated total stock from all batches for new product: ${totalStock}`);
              } catch (error) {
                console.error('Error calculating total stock:', error);
              }
            }
            
            const shopProductData = {
              name: product.name,
              category: product.category,
              description: product.description,
              shortDescription: product.shortDescription || product.description,
              price: product.unitPrice || product.price || 0,
              priceUnit: product.currency || product.priceUnit || 'IQD',
              inStock: totalStock > 0 || (productData.showWhenOutOfStock || false),
              stockQuantity: totalStock, // Use total stock from all batches
              lowStockThreshold: 10,
              minStockLevel: product.minStockLevel || 5,
              maxStockLevel: product.maxStockLevel || 100,
              showWhenOutOfStock: productData.showWhenOutOfStock || false,
              sku: product.sku && !existingShopProducts.some(sp => sp.sku === product.sku) 
                ? product.sku 
                : `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
              barcode: product.barcode,
              imageUrls: product.imageUrl ? [product.imageUrl] : [],
              specifications: product.specifications || {},
              features: product.features || [],
              applications: product.applications || [],
              isActive: true,
              isFeatured: false,
              metaTitle: product.name,
              metaDescription: product.description
            };
            
            await shopStorage.createShopProduct(shopProductData);
            console.log(`âœ… Ù…Ø­ØµÙˆÙ„ Ø¨Ù‡ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯: ${product.name}`);
          } else {
            // Shop product already exists, update it
            // Calculate total stock from all batches in Ú©Ø§Ø±Ø¯Ú©Ø³ for this barcode
            let totalStock = product.stockQuantity || 0;
            if (product.barcode) {
              try {
                const { pool } = await import('./db');
                const totalStockResult = await pool.query(`
                  SELECT SUM(stock_quantity) as total_stock
                  FROM showcase_products 
                  WHERE barcode = $1
                `, [product.barcode]);
                
                totalStock = totalStockResult.rows[0]?.total_stock || 0;
                console.log(`ğŸ“¦ [SHOP-SYNC] Calculated total stock from all batches: ${totalStock}`);
              } catch (error) {
                console.error('Error calculating total stock:', error);
              }
            }
            
            const updateData = {
              stockQuantity: totalStock, // Use total stock from all batches
              inStock: totalStock > 0 || (productData.showWhenOutOfStock || false),
              price: product.unitPrice || product.price || 0,
              priceUnit: product.currency || product.priceUnit || 'IQD',
              description: product.description,
              shortDescription: product.shortDescription || product.description,
              imageUrls: product.imageUrl ? [product.imageUrl] : (existingShopProduct.imageUrls || []),
              specifications: product.specifications || {},
              features: product.features || [],
              applications: product.applications || [],
              barcode: product.barcode,
              sku: product.sku || existingShopProduct.sku,
              showWhenOutOfStock: productData.showWhenOutOfStock || false
            };
            
            await shopStorage.updateShopProduct(existingShopProduct.id, updateData);
            console.log(`âœ… Ù…Ø­ØµÙˆÙ„ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯: ${product.name}`);
          }
        } catch (syncError) {
          console.error(`âŒ Ø®Ø·Ø§ Ø¯Ø± sync Ú©Ø±Ø¯Ù† Ù…Ø­ØµÙˆÙ„ ${product.name}:`, syncError.message);
          // Continue with the product update even if shop sync fails
        }
      } else if (productData.syncWithShop === false) {
        console.log(`ğŸ”’ Ù…Ø­ØµÙˆÙ„ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ù…Ø®ÙÛŒ Ø´Ø¯: ${product.name}`);
        
        // Remove from shop if sync is disabled
        try {
          const existingShopProducts = await shopStorage.getShopProducts();
          const existingShopProduct = existingShopProducts.find(sp => sp.name === product.name);
          
          if (existingShopProduct) {
            await shopStorage.deleteShopProduct(existingShopProduct.id);
            console.log(`ğŸ—‘ï¸  Ù…Ø­ØµÙˆÙ„ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø­Ø°Ù Ø´Ø¯: ${product.name}`);
          }
        } catch (removeError: any) {
          console.error(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø­ØµÙˆÙ„ ${product.name} Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡:`, removeError.message);
          // Continue with the product update even if shop removal fails
        }
      }
      
      // Trigger automatic synchronization after any update
      try {
        const { KardexSyncMaster } = await import('./kardex-sync-master');
        const result = await KardexSyncMaster.smartSyncShopFromKardex();
        console.log(`ğŸ”„ Auto-sync completed after updating product ${id}:`, result.message);
      } catch (syncError) {
        console.log("Auto-sync failed after update:", syncError);
      }
      
      const responseProduct = product;
      console.log(`âœ… [DEBUG] Product update completed successfully for product ${id}`);
      
      res.json({ 
        success: true, 
        message: isSyncToggle ? "ÙˆØ¶Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" : "Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        product: responseProduct 
      });
    } catch (error: any) {
      console.error("Error updating showcase product:", error);
      
      // Handle specific database errors with Persian messages
      let errorMessage = "Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø³Ø±ÙˆØ±";
      let statusCode = 500;
      
      if (error instanceof z.ZodError) {
        statusCode = 400;
        errorMessage = "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡";
      } else if (error.code === '23505') { // Unique constraint violation
        statusCode = 400;
        if (error.constraint?.includes('sku')) {
          errorMessage = "Ú©Ø¯ SKU ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª";
        } else if (error.constraint?.includes('barcode')) {
          errorMessage = "Ø¨Ø§Ø±Ú©Ø¯ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª";
        } else {
          errorMessage = "Ù…Ù‚Ø¯Ø§Ø± ØªÚ©Ø±Ø§Ø±ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯";
        }
      } else if (error.code === '23503') { // Foreign key violation
        statusCode = 400;
        errorMessage = "Ù…Ø±Ø¬Ø¹ Ù†Ø§Ù…Ø¹ØªØ¨Ø±";
      } else if (error.code === '23514') { // Check constraint violation
        statusCode = 400;
        errorMessage = "Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡";
      } else if (error.message?.includes('authentication')) {
        statusCode = 401;
        errorMessage = "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª";
      }
      
      res.status(statusCode).json({ 
        success: false, 
        message: errorMessage
      });
    }
  });

  app.delete("/api/products/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      // Get product name before deletion for shop cleanup
      const productToDelete = await storage.getProductById(id);
      
      // Delete from showcase products (admin interface)
      await storage.deleteProduct(id);
      
      // Also remove from shop if it exists there (by barcode matching for better accuracy)
      if (productToDelete) {
        try {
          const shopProducts = await shopStorage.getShopProducts();
          const matchingShopProduct = shopProducts.find(p => 
            p.barcode === productToDelete.barcode || 
            p.name === productToDelete.name ||
            p.sku === productToDelete.sku
          );
          if (matchingShopProduct) {
            await shopStorage.deleteShopProduct(matchingShopProduct.id);
            console.log(`âœ… [DELETE-SYNC] Removed matching shop product: ${matchingShopProduct.name} (barcode: ${matchingShopProduct.barcode})`);
          } else {
            console.log(`âš ï¸ [DELETE-SYNC] No matching shop product found for: ${productToDelete.name} (barcode: ${productToDelete.barcode})`);
          }
        } catch (error) {
          console.log("âŒ [DELETE-SYNC] Error removing from shop:", error);
        }
      }
      
      // Trigger automatic synchronization after deletion
      try {
        const { KardexSyncMaster } = await import('./kardex-sync-master');
        const result = await KardexSyncMaster.smartSyncShopFromKardex();
        console.log(`ğŸ”„ Auto-sync completed after deleting product ${id}:`, result.message);
      } catch (syncError) {
        console.log("Auto-sync failed after deletion:", syncError);
      }
      
      console.log(`Product ${id} deleted successfully from both showcase and shop with auto-sync`);
      res.json({ success: true, message: "Product deleted successfully" });
    } catch (error) {
      console.error("Delete product error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // KARDEX SYNC MASTER ENDPOINTS - Ø³ÛŒØ³ØªÙ… Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø§ÛŒÙ…Ù†
  // =============================================================================
  
  // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ
  app.get("/api/kardex-sync/status", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const status = await KardexSyncMaster.checkSyncStatus();
      
      res.json({
        success: true,
        data: status,
        message: "ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error checking sync status:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ"
      });
    }
  });
  
  // Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³ (Ø§ÛŒÙ…Ù†)
  app.post("/api/kardex-sync/full-rebuild", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.fullRebuildShopFromKardex();
      
      res.json({
        success: result.success,
        data: result.details,
        message: result.message
      });
    } catch (error) {
      console.error("Error in full rebuild:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ ÙØ±ÙˆØ´Ú¯Ø§Ù‡"
      });
    }
  });
  
  // Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ (ÙÙ‚Ø· ØªØºÛŒÛŒØ±Ø§Øª)
  app.post("/api/kardex-sync/smart-sync", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.smartSyncShopFromKardex();
      
      res.json({
        success: result.success,
        data: result.details,
        message: result.message
      });
    } catch (error) {
      console.error("Error in smart sync:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯"
      });
    }
  });

  // Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ù…Ø­ØµÙˆÙ„Ø§Øª Ø§Ø¶Ø§ÙÛŒ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ú©Ù‡ Ø¯Ø± Ú©Ø§Ø±Ø¯Ú©Ø³ Ù†ÛŒØ³ØªÙ†Ø¯
  app.post("/api/kardex-sync/cleanup-extra", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.cleanupExtraShopProducts();
      
      if (result.success) {
        res.json({
          success: true,
          message: result.message,
          data: {
            deletedCount: result.deletedCount,
            deletedProducts: result.deletedProducts
          }
        });
      } else {
        res.status(500).json({
          success: false,
          message: result.message
        });
      }
    } catch (error) {
      console.error("âŒ [CLEANUP-EXTRA] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø­ØµÙˆÙ„Ø§Øª Ø§Ø¶Ø§ÙÛŒ"
      });
    }
  });

  // Ø­Ø°Ù SKU ØªÚ©Ø±Ø§Ø±ÛŒ
  app.post("/api/kardex-sync/cleanup-duplicates", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.cleanupDuplicateSKUs();
      
      if (result.success) {
        res.json({
          success: true,
          message: result.message,
          data: {
            deletedCount: result.deletedCount,
            duplicates: result.duplicates
          }
        });
      } else {
        res.status(500).json({
          success: false,
          message: result.message
        });
      }
    } catch (error) {
      console.error("âŒ [CLEANUP-SKU] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù SKU ØªÚ©Ø±Ø§Ø±ÛŒ"
      });
    }
  });

  // =============================================================================
  // FIFO BATCH MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get FIFO batch information for a product
  app.get("/api/products/:productName/batches/fifo", async (req, res) => {
    try {
      const { productName } = req.params;
      const decodedProductName = decodeURIComponent(productName);
      
      console.log(`ğŸ“¦ [API] Getting FIFO batches for: ${decodedProductName}`);
      
      const { FIFOBatchManager } = await import('./fifo-batch-manager');
      const batchInfo = await FIFOBatchManager.getBatchInfoForDisplay(decodedProductName);
      
      res.json({
        success: true,
        productName: decodedProductName,
        data: batchInfo
      });
      
    } catch (error: any) {
      console.error("Error fetching FIFO batch info:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†â€ŒÙ‡Ø§ÛŒ Ù…Ø­ØµÙˆÙ„",
        error: error?.message || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ'
      });
    }
  });

  // Get all batches for a product in FIFO order
  app.get("/api/products/:productName/batches/list", async (req, res) => {
    try {
      const { productName } = req.params;
      const decodedProductName = decodeURIComponent(productName);
      
      const { FIFOBatchManager } = await import('./fifo-batch-manager');
      const result = await FIFOBatchManager.getBatchInfoFIFO(decodedProductName);
      
      if (!result.success) {
        return res.status(404).json(result);
      }
      
      const batches = result.data?.allBatches || [];
      
      res.json({
        success: true,
        productName: decodedProductName,
        batches,
        count: batches.length
      });
      
    } catch (error: any) {
      console.error("Error fetching product batches:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ø¨Ú†â€ŒÙ‡Ø§ÛŒ Ù…Ø­ØµÙˆÙ„",
        error: error?.message || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ'
      });
    }
  });

  // Get batch information for display (simplified version of list for UI)
  app.get("/api/products/:productName/batches/display", async (req, res) => {
    try {
      const { productName } = req.params;
      let decodedProductName;
      try {
        decodedProductName = decodeURIComponent(productName);
      } catch (error) {
        console.error('âŒ [BATCH-DISPLAY] Invalid product name encoding:', productName);
        return res.status(400).json({
          success: false,
          message: 'Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª'
        });
      }
      
      const { FIFOBatchManager } = await import('./fifo-batch-manager');
      const result = await FIFOBatchManager.getBatchInfoFIFO(decodedProductName);
      
      if (!result.success) {
        return res.status(404).json(result);
      }
      
      res.json({
        success: true,
        productName: decodedProductName,
        batches: result.data?.allBatches || [],
        count: result.data?.batchCount || 0,
        totalStock: Number(result.data?.totalStock) || 0,
        batchInfo: result.data
      });
      
    } catch (error: any) {
      console.error("Error fetching batch display info:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ù…Ø§ÛŒØ´ Ø¨Ú†â€ŒÙ‡Ø§",
        error: error?.message || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ'
      });
    }
  });

  // Simulate FIFO allocation for an order (without committing)
  app.post("/api/products/:productName/batches/allocate-simulate", async (req, res) => {
    try {
      const { productName } = req.params;
      const { quantity, orderId } = req.body;
      const decodedProductName = decodeURIComponent(productName);
      
      if (!quantity || quantity <= 0) {
        return res.status(400).json({
          success: false,
          message: "Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }
      
      const { FIFOBatchManager } = await import('./fifo-batch-manager');
      const allocation = await FIFOBatchManager.allocateInventoryFIFO(
        decodedProductName,
        quantity,
        orderId
      );
      
      res.json({
        success: true,
        productName: decodedProductName,
        simulation: allocation
      });
      
    } catch (error: any) {
      console.error("Error simulating FIFO allocation:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ ØªØ®ØµÛŒØµ Ù…ÙˆØ¬ÙˆØ¯ÛŒ",
        error: error?.message || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ'
      });
    }
  });

  // =============================================================================
  // BARCODE & INVENTORY MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get product by barcode - search in both regular products and shop products
  app.get("/api/products/barcode/:barcode", async (req, res) => {
    try {
      const { barcode } = req.params;
      const decodedBarcode = decodeURIComponent(barcode);
      
      // First search in shop products (inventory management)
      try {
        const shopProduct = await shopStorage.getShopProductBySku(decodedBarcode);
        if (shopProduct) {
          return res.json(shopProduct);
        }
      } catch (error) {
        console.log("Shop product not found by SKU, trying barcode field");
      }

      // Search shop products by barcode field directly
      try {
        const shopProducts = await shopStorage.getShopProducts();
        const foundShopProduct = shopProducts.find(p => 
          p.barcode === decodedBarcode || 
          p.sku === decodedBarcode
        );
        
        if (foundShopProduct) {
          return res.json(foundShopProduct);
        }
      } catch (error) {
        console.log("Error searching shop products:", error);
      }
      
      // Then search in regular products
      const products = await shopStorage.getShopProducts();
      const product = products.find(p => 
        p.barcode === decodedBarcode || 
        p.sku === decodedBarcode
      );
      
      if (!product) {
        return res.status(404).json({ 
          success: false, 
          message: "Product not found" 
        });
      }
      
      res.json(product);
    } catch (error) {
      console.error("Error fetching product by barcode:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Update product barcode information
  app.put("/api/products/:id/barcode", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { barcode, qrCode, sku } = req.body;
      
      const updateData: any = {};
      if (barcode) updateData.barcode = barcode;
      if (qrCode) updateData.qrCode = qrCode;
      if (sku) updateData.sku = sku;
      
      const updatedProduct = await shopStorage.updateShopProduct(parseInt(id), updateData);
      res.json(updatedProduct);
    } catch (error) {
      console.error("Error updating product barcode:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Log barcode scan
  app.post("/api/barcode/log", async (req, res) => {
    try {
      const { barcode, scanType, scanResult, location, additionalData } = req.body;
      
      // Simple logging to console for now - could be extended to database
      console.log('Barcode scan logged:', {
        barcode,
        scanType,
        scanResult,
        userId: req.session?.adminId,
        timestamp: new Date().toISOString()
      });
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error logging barcode scan:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // EAN-13 BARCODE MANAGEMENT API (GS1 Standard)
  // =============================================================================
  
  // Get EAN-13 records
  app.get("/api/ean13/records", requireAuth, async (req, res) => {
    try {
      // For now, return empty array - will be implemented when database schema is created
      res.json([]);
    } catch (error) {
      console.error("Error fetching EAN-13 records:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Bulk generate EAN-13 barcodes
  app.post("/api/ean13/bulk-generate", requireAuth, async (req, res) => {
    try {
      const { productIds } = req.body;
      
      if (!productIds || !Array.isArray(productIds)) {
        return res.status(400).json({
          success: false,
          message: "Product IDs array is required"
        });
      }

      let generated = 0;
      const companyPrefix = "12345"; // Should be obtained from GS1
      const countryCode = "864"; // Iraq
      
      for (const productId of productIds) {
        try {
          const products = await shopStorage.getShopProducts();
          const product = products.find(p => p.id === productId);
          if (!product || (product.barcode && product.barcode.length === 13)) {
            continue; // Skip if product not found or already has EAN-13
          }

          // Generate EAN-13 barcode
          const productCode = String(productId).padStart(3, '0');
          const barcode12 = countryCode + companyPrefix + productCode;
          
          // Calculate check digit
          let sum = 0;
          for (let i = 0; i < 12; i++) {
            const digit = parseInt(barcode12[i]);
            sum += i % 2 === 0 ? digit : digit * 3;
          }
          const checkDigit = (10 - (sum % 10)) % 10;
          const ean13 = barcode12 + checkDigit.toString();

          // Update product with EAN-13
          await shopStorage.updateShopProduct(productId, { barcode: ean13 });
          generated++;
        } catch (error) {
          console.error(`Error generating EAN-13 for product ${productId}:`, error);
        }
      }

      res.json({
        success: true,
        generated,
        message: `Generated ${generated} EAN-13 barcodes`
      });
    } catch (error) {
      console.error("Error in bulk EAN-13 generation:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Export EAN-13 data as CSV with multilingual support
  app.get("/api/ean13/export", requireAuth, async (req, res) => {
    try {
      const products = await shopStorage.getShopProducts();
      const ean13Products = products.filter(p => p.barcode && p.barcode.length === 13);
      
      // Create CSV with UTF-8 BOM for proper multilingual character display
      const BOM = '\uFEFF';
      
      // Multilingual headers (Persian/Arabic/Kurdish compatible)
      const csvHeader = "Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„,Ú©Ø¯ Ù…Ø­ØµÙˆÙ„,EAN-13,Ú©Ø¯ Ú©Ø´ÙˆØ±,Ù¾ÛŒØ´ÙˆÙ†Ø¯ Ø´Ø±Ú©Øª,Ú©Ø¯ Ù…Ø­ØµÙˆÙ„,Ø±Ù‚Ù… Ú†Ú©,Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ,Ù‚ÛŒÙ…Øª ÙˆØ§Ø­Ø¯,ÙˆØ§Ø­Ø¯ Ù‚ÛŒÙ…Øª,ÙˆØ¶Ø¹ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ,Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ\n";
      
      const csvRows = ean13Products.map(product => {
        const barcode = product.barcode!;
        const countryCode = barcode.substring(0, 3);
        const companyPrefix = barcode.substring(3, 8);
        const productCode = barcode.substring(8, 12);
        const checkDigit = barcode.substring(12, 13);
        
        // Format price with proper Persian/Arabic numerals support
        const price = product.unitPrice || product.priceRange || 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡';
        const currency = product.currency || 'Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ';
        const stockStatus = (product.stockQuantity && product.stockQuantity > 0) ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù†Ø§Ù…ÙˆØ¬ÙˆØ¯';
        const currentStock = product.stockQuantity || 0;
        
        // Escape quotes and handle special characters for CSV
        const escapeCsvField = (field: string | number) => {
          const str = String(field || '');
          // If field contains comma, newline, or quote, wrap in quotes and escape internal quotes
          if (str.includes(',') || str.includes('\n') || str.includes('"')) {
            return `"${str.replace(/"/g, '""')}"`;
          }
          return `"${str}"`;
        };
        
        return [
          escapeCsvField(product.name),
          escapeCsvField(product.sku || ''),
          escapeCsvField(barcode),
          escapeCsvField(countryCode),
          escapeCsvField(companyPrefix),
          escapeCsvField(productCode),
          escapeCsvField(checkDigit),
          escapeCsvField(product.category),
          escapeCsvField(price),
          escapeCsvField(currency),
          escapeCsvField(stockStatus),
          escapeCsvField(currentStock)
        ].join(',');
      }).join('\n');
      
      const csvContent = BOM + csvHeader + csvRows;
      
      // Set proper headers for UTF-8 CSV with BOM
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="Barcode_Export_${new Date().toISOString().split('T')[0]}.csv"`);
      res.send(csvContent);
      
      console.log(`âœ… [EXPORT] Generated CSV export with ${ean13Products.length} products with multilingual support`);
    } catch (error) {
      console.error("âŒ [EXPORT] Error exporting EAN-13 data:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬ÛŒ Ú¯ÛŒØ±ÛŒ ÙØ§ÛŒÙ„ CSV" 
      });
    }
  });

  // Export all barcode data (both showcase and shop) with pricing
  app.get("/api/barcode/export-all", requireAuth, async (req, res) => {
    try {
      const shopProducts = await shopStorage.getShopProducts();
      
      // Create CSV with UTF-8 BOM for proper multilingual character display
      const BOM = '\uFEFF';
      
      // Comprehensive multilingual headers with proper pricing information
      const csvHeader = "Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„,Ú©Ø¯ Ù…Ø­ØµÙˆÙ„,Ø¨Ø§Ø±Ú©Ø¯,Ù†ÙˆØ¹ Ø¨Ø§Ø±Ú©Ø¯,Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ,Ù‚ÛŒÙ…Øª ÙØ±ÙˆØ´Ú¯Ø§Ù‡,ÙˆØ§Ø­Ø¯ Ù‚ÛŒÙ…Øª,Ø§Ø±Ø²,Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡,ÙˆØ¶Ø¹ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ,Ø­Ø¯ Ú©Ù…ÛŒÙ†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ,Ø¢Ø³ØªØ§Ù†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ù…,ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯\n";
      
      // Process shop products only (single table system)
      const csvRows = shopProducts.map(product => {
        // Escape quotes and handle special characters for CSV
        const escapeCsvField = (field: string | number) => {
          const str = String(field || '');
          if (str.includes(',') || str.includes('\n') || str.includes('"')) {
            return `"${str.replace(/"/g, '""')}"`;
          }
          return `"${str}"`;
        };

        // Format price properly
        const formatPrice = (price: any) => {
          if (!price) return 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡';
          if (typeof price === 'string' && !isNaN(parseFloat(price))) {
            return parseFloat(price).toFixed(2);
          }
          if (typeof price === 'number') {
            return price.toFixed(2);
          }
          return String(price);
        };

        return [
          escapeCsvField(product.name),
          escapeCsvField(product.sku || ''),
          escapeCsvField(product.barcode || 'Ø¨Ø¯ÙˆÙ† Ø¨Ø§Ø±Ú©Ø¯'),
          escapeCsvField(product.barcode ? (product.barcode.length === 13 ? 'EAN-13' : 'Ø³ÙØ§Ø±Ø´ÛŒ') : 'Ù†Ø¯Ø§Ø±Ø¯'),
          escapeCsvField(product.category),
          escapeCsvField(formatPrice(product.price)), // Shop price
          escapeCsvField(product.priceUnit || 'ÙˆØ§Ø­Ø¯'),
          escapeCsvField(product.currency || 'Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ'),
          escapeCsvField(product.stockQuantity || 0),
          escapeCsvField((product.stockQuantity && product.stockQuantity > 0) ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù†Ø§Ù…ÙˆØ¬ÙˆØ¯'),
          escapeCsvField(product.minStockLevel || 0),
          escapeCsvField(product.lowStockThreshold || 10),
          escapeCsvField(product.createdAt ? new Date(product.createdAt).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          }) : '')
        ].join(',');
      }).join('\n');
      
      const csvContent = BOM + csvHeader + csvRows;
      
      // Set proper headers for UTF-8 CSV with BOM
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="Complete_Barcode_Export_${new Date().toISOString().split('T')[0]}.csv"`);
      res.send(csvContent);
      
      console.log(`âœ… [EXPORT] Generated complete barcode CSV with ${shopProducts.length} products including pricing`);
    } catch (error) {
      console.error("âŒ [EXPORT] Error exporting barcode data with pricing:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬ÛŒ Ú¯ÛŒØ±ÛŒ ÙØ§ÛŒÙ„ CSV Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù‚ÛŒÙ…Øª" 
      });
    }
  });

  // Helper function to generate label HTML with fixed grid layout
  function generateLabelHTML(products: any[], options: any) {
    const { showPrice, showWebsite, showSKU, labelSize, website } = options;
    
    // Fixed label dimensions matching frontend design
    const labelConfigs = {
      small: { 
        width: '40mm', height: '28mm', padding: '1mm',
        nameFont: '8px', skuFont: '6px', priceFont: '6px', websiteFont: '6px',
        barcodeFont: '10px', nameMaxLength: 15, skuMaxLength: 10
      },
      standard: { 
        width: '56mm', height: '36mm', padding: '2mm',
        nameFont: '10px', skuFont: '8px', priceFont: '8px', websiteFont: '8px',
        barcodeFont: '12px', nameMaxLength: 25, skuMaxLength: 15
      },
      large: { 
        width: '72mm', height: '44mm', padding: '3mm',
        nameFont: '14px', skuFont: '10px', priceFont: '10px', websiteFont: '10px',
        barcodeFont: '16px', nameMaxLength: 35, skuMaxLength: 18
      },
      roll: { 
        width: '48mm', height: '20mm', padding: '1mm',
        nameFont: '7px', skuFont: '6px', priceFont: '6px', websiteFont: '6px',
        barcodeFont: '8px', nameMaxLength: 18, skuMaxLength: 12
      }
    };
    
    const config = labelConfigs[labelSize] || labelConfigs.standard;
    
    const formatPrice = (product: any) => {
      if (!product.price) return '';
      const price = typeof product.price === 'string' ? parseFloat(product.price) : product.price;
      // Always use IQD as the currency for Iraqi market
      const unit = product.priceUnit || 'ÙˆØ§Ø­Ø¯';
      return `${Math.round(price).toLocaleString()} IQD / ${unit}`;
    };

    const truncateText = (text: string, maxLength: number) => {
      return text.length > maxLength ? text.substring(0, maxLength - 3) + '...' : text;
    };

    const generateBarcode = (value: string) => {
      return `<div class="barcode-text" style="font-family: 'Courier New', monospace; font-size: ${config.barcodeFont}; font-weight: bold; letter-spacing: 1px; text-align: center; line-height: 1.2; background: white; color: black;">${value}</div>`;
    };

    const labelsHTML = products.map(product => {
      const displayName = truncateText(product.name, config.nameMaxLength);
      const displaySku = product.sku ? truncateText(product.sku, config.skuMaxLength) : '';
      
      return `
      <div style="
        width: ${config.width}; 
        height: ${config.height}; 
        border: 3px solid #000; 
        padding: ${config.padding}; 
        margin: 2mm; 
        display: inline-block; 
        vertical-align: top;
        background: white;
        box-sizing: border-box;
        page-break-inside: avoid;
        font-family: Arial, sans-serif;
        overflow: hidden;
        position: relative;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      ">
        <!-- Fixed 4-row grid layout -->
        <div style="
          height: 100%; 
          display: grid; 
          grid-template-rows: 1fr 1fr 1fr 1fr; 
          gap: 1mm;
          text-align: center;
        ">
          <!-- Row 1: Product Name (always shown) -->
          <div style="
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-weight: bold; 
            font-size: ${config.nameFont}; 
            line-height: 1.1; 
            overflow: hidden;
            padding: 0 1mm;
          ">
            <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;">
              ${displayName}
            </span>
          </div>

          <!-- Row 2: SKU (if enabled) -->
          <div style="
            display: flex; 
            align-items: center; 
            justify-content: center;
            min-height: 0;
          ">
            ${showSKU && product.sku ? `
              <span class="sku-text" style="
                font-size: ${config.skuFont}; 
                color: #333; 
                font-family: 'Courier New', monospace;
                font-weight: 500;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 100%;
              ">
                SKU: ${displaySku}
              </span>
            ` : '<div style="height: 100%;"></div>'}
          </div>

          <!-- Row 3: Barcode (always shown) -->
          <div style="
            display: flex; 
            align-items: center; 
            justify-content: center;
            min-height: 0;
          ">
            ${generateBarcode(product.barcode)}
          </div>

          <!-- Row 4: Price and Website -->
          <div style="
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center;
            gap: 0.5mm;
            min-height: 0;
          ">
            ${showPrice && product.price ? `
              <span class="price-text" style="
                font-weight: bold; 
                color: #008000; 
                font-size: ${config.priceFont}; 
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 100%;
                text-shadow: 0 1px 1px rgba(0,0,0,0.1);
              ">
                ${formatPrice(product)}
              </span>
            ` : ''}
            
            ${showWebsite ? `
              <span class="website-text" style="
                color: #666; 
                font-size: ${config.websiteFont}; 
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 100%;
                font-weight: 500;
              ">
                momtazchem.com
              </span>
            ` : ''}
          </div>
        </div>
      </div>`;
    }).join('');

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Product Labels - Momtazchem</title>
        <style>
          @import url('https://fonts.googleapis.com/css2?family=Libre+Barcode+128&display=swap');
          
          * {
            box-sizing: border-box;
          }
          
          body { 
            margin: 0; 
            padding: 8mm; 
            font-family: Arial, sans-serif;
            font-size: 10px;
            background: white;
            color: black;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
            max-width: 100%;
            overflow-wrap: break-word;
          }
          
          .labels-container {
            display: flex; 
            flex-wrap: wrap; 
            gap: 3mm; 
            align-items: flex-start;
            justify-content: flex-start;
          }
          
          @page {
            size: A4;
            margin: 8mm;
          }
          
          @media print {
            body { 
              margin: 0; 
              padding: 5mm;
              font-size: 9px;
              -webkit-print-color-adjust: exact;
              print-color-adjust: exact;
              max-width: 100%;
            }
            
            .no-print { 
              display: none; 
            }
            
            .labels-container > div {
              border: 2px solid black !important;
              background: white !important;
              page-break-inside: avoid;
            }
            
            /* Enhanced print quality */
            .barcode-text {
              font-family: 'Courier New', monospace !important;
              font-weight: bold !important;
              letter-spacing: 1px !important;
            }
            
            /* Prevent text from breaking across pages */
            h1, h2, h3, h4, h5, h6 {
              page-break-after: avoid;
            }
            
            /* Better color contrast for printing */
            .price-text {
              color: #008000 !important;
              font-weight: bold !important;
            }
            
            .sku-text {
              color: #333333 !important;
            }
            
            .website-text {
              color: #666666 !important;
            }
          }
          
          /* Print preview styling */
          @media screen {
            body {
              background: #f5f5f5;
              padding: 20mm;
            }
            
            .labels-container {
              background: white;
              padding: 10mm;
              box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
          }
        </style>
      </head>
      <body>
        <div class="labels-container">
          ${labelsHTML}
        </div>
        
        <!-- Print Instructions (hidden in print) -->
        <div class="no-print" style="margin-top: 20mm; padding: 10mm; background: #f0f0f0; border-radius: 5mm;">
          <h3 style="margin: 0 0 5mm 0; color: #333;">Print Instructions:</h3>
          <ul style="margin: 0; padding-left: 15mm; color: #666;">
            <li>Use Ctrl+P (Cmd+P on Mac) to print</li>
            <li>Select "More settings" â†’ "Options" â†’ "Background graphics" for best quality</li>
            <li>Recommended: Use high-quality printer with black ink</li>
            <li>Print on A4 paper for standard labels</li>
          </ul>
        </div>
      </body>
      </html>
    `;
  }

  // Generate customized printable labels for products with user options
  app.post("/api/barcode/generate-custom-labels", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ·ï¸  [CUSTOM LABELS] Request received:', { 
        productsCount: req.body.products?.length, 
        options: req.body.options,
        format: req.body.format 
      });
      
      const { products, options, format = 'html' } = req.body;
      
      if (!products || !Array.isArray(products) || products.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø¨Ø±Ú†Ø³Ø¨ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª"
        });
      }

      // Extract options with defaults
      const {
        includePrice = true,
        includeWebsite = true,
        includeSKU = true,
        websiteText = "www.momtazchem.com",
        labelSize = "standard"
      } = options || {};

      // Generate HTML for labels using the extracted options
      const labelHTML = generateLabelHTML(products, {
        showPrice: includePrice,
        showWebsite: includeWebsite,
        showSKU: includeSKU,
        labelSize,
        website: websiteText
      });

      // Return as image if requested
      if (format === 'image') {
        try {
          const browser = await puppeteer.launch({
            headless: 'new',
            args: [
              '--no-sandbox', 
              '--disable-setuid-sandbox',
              '--disable-dev-shm-usage',
              '--disable-accelerated-2d-canvas',
              '--no-first-run',
              '--no-zygote',
              '--single-process',
              '--disable-gpu'
            ],
            executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser'
          });
          
          const page = await browser.newPage();
          await page.setContent(labelHTML, { waitUntil: 'networkidle0' });
          
          // Set viewport for better image quality
          await page.setViewport({ width: 800, height: 600 });
          
          const screenshot = await page.screenshot({
            type: 'png',
            fullPage: true,
            omitBackground: false
          });
          
          await browser.close();

          res.setHeader('Content-Type', 'image/png');
          res.setHeader('Content-Disposition', `attachment; filename="Custom_Labels_${new Date().toISOString().split('T')[0]}.png"`);
          res.send(screenshot);
          
          console.log(`âœ… [CUSTOM LABELS] Generated custom labels image for ${products.length} products`);
          return;
        } catch (imageError) {
          console.log('Puppeteer image generation failed, trying alternative method:', imageError.message);
          
          // Alternative: Return as base64 encoded image using canvas
          try {
            // For now, we'll create a simple HTML response that can be converted to image on client side
            const imageHTML = `
              <!DOCTYPE html>
              <html>
              <head>
                <meta charset="UTF-8">
                <title>Product Labels</title>
                <style>
                  body { 
                    margin: 0; 
                    padding: 20px; 
                    font-family: Arial, sans-serif;
                    background: white;
                    width: 800px;
                    height: auto;
                  }
                  .convert-to-image { display: block; }
                </style>
                <script>
                  window.addEventListener('load', function() {
                    // This script will help convert HTML to canvas/image on client side
                    if (window.html2canvas) {
                      html2canvas(document.body).then(function(canvas) {
                        const link = document.createElement('a');
                        link.download = 'custom-labels.png';
                        link.href = canvas.toDataURL();
                        link.click();
                      });
                    }
                  });
                </script>
              </head>
              <body class="convert-to-image">
                ${labelHTML.replace('<!DOCTYPE html>', '').replace(/<html[^>]*>/, '').replace('</html>', '').replace(/<head[^>]*>[\s\S]*?<\/head>/, '').replace(/<body[^>]*>/, '').replace('</body>', '')}
              </body>
              </html>
            `;
            
            res.setHeader('Content-Type', 'text/html; charset=utf-8');
            res.setHeader('Content-Disposition', `attachment; filename="Custom_Labels_For_Image_${new Date().toISOString().split('T')[0]}.html"`);
            res.send(imageHTML);
            
            console.log(`âœ… [CUSTOM LABELS] Generated HTML for image conversion for ${products.length} products`);
            return;
          } catch (htmlError) {
            console.log('HTML image generation also failed, falling back to standard HTML:', htmlError.message);
          }
        }
      }

      // Generate PDF using Puppeteer for direct download
      console.log('ğŸ·ï¸  [CUSTOM LABELS] Generating PDF for custom labels');
      try {
        const browser = await puppeteer.launch({
          headless: true,
          args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        
        const page = await browser.newPage();
        await page.setContent(labelHTML, { waitUntil: 'networkidle0' });
        
        const pdfBuffer = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: {
            top: '10mm',
            right: '10mm',
            bottom: '10mm',
            left: '10mm'
          }
        });
        
        await browser.close();

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="Custom_Product_Labels_${new Date().toISOString().split('T')[0]}.pdf"`);
        res.send(pdfBuffer);
      } catch (pdfError) {
        console.log('PDF generation failed, falling back to HTML:', pdfError.message);
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Disposition', 'attachment; filename="Custom_Product_Labels.html"');
        res.send(labelHTML);
      }

      console.log(`âœ… [CUSTOM LABELS] Generated custom labels for ${products.length} products`);
    } catch (error) {
      console.error("âŒ [CUSTOM LABELS] Error generating custom labels:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø¨Ø±Ú†Ø³Ø¨â€ŒÙ‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´ÛŒ"
      });
    }
  });

  // Generate printable labels for products
  app.post("/api/barcode/generate-labels", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ·ï¸  [LABELS] Request received:', { labelSize: req.body.labelSize, productsCount: req.body.products?.length });
      const { products, showPrice, showWebsite, showSKU, labelSize, website } = req.body;
      
      if (!products || !Array.isArray(products) || products.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒØ¨Ù„ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª"
        });
      }

      // Generate HTML for labels
      const labelHTML = generateLabelHTML(products, {
        showPrice,
        showWebsite,
        showSKU,
        labelSize,
        website: website || 'www.momtazchem.com'
      });

      // For roll printer, return HTML directly for better compatibility
      if (labelSize === 'roll') {
        console.log('ğŸ·ï¸  [LABELS] Generating HTML for roll printer');
        // Generate PDF for roll printer too
        try {
          const browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
          });
          
          const page = await browser.newPage();
          await page.setContent(labelHTML, { waitUntil: 'networkidle0' });
          
          const pdfBuffer = await page.pdf({
            format: 'A4',
            printBackground: true,
            margin: {
              top: '5mm',
              right: '5mm', 
              bottom: '5mm',
              left: '5mm'
            }
          });
          
          await browser.close();

          res.setHeader('Content-Type', 'application/pdf');
          res.setHeader('Content-Disposition', `attachment; filename="Roll_Labels_${new Date().toISOString().split('T')[0]}.pdf"`);
          return res.send(pdfBuffer);
        } catch (pdfError) {
          console.log('PDF generation failed for roll printer, falling back to HTML:', pdfError.message);
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          res.setHeader('Content-Disposition', 'inline; filename="Roll_Labels.html"');
          return res.send(labelHTML);
        }
      }

      // For other sizes, generate PDF using Puppeteer
      try {
        const browser = await puppeteer.launch({
          headless: true,
          args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        
        const page = await browser.newPage();
        await page.setContent(labelHTML, { waitUntil: 'networkidle0' });
        
        const pdf = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: {
            top: '10mm',
            right: '10mm',
            bottom: '10mm',
            left: '10mm',
          }
        });
        
        await browser.close();

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="Product_Labels_${new Date().toISOString().split('T')[0]}.pdf"`);
        res.send(pdf);
      } catch (pdfError) {
        // Fallback to HTML if PDF generation fails
        console.log('PDF generation failed, falling back to HTML:', pdfError.message);
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Disposition', 'inline; filename="Product_Labels.html"');
        res.send(labelHTML);
      }

      console.log(`âœ… [LABELS] Generated labels PDF for ${products.length} products`);
    } catch (error) {
      console.error("âŒ [LABELS] Error generating labels:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒØ¨Ù„â€ŒÙ‡Ø§"
      });
    }
  });

  // Validate EAN-13 barcode
  app.post("/api/ean13/validate", requireAuth, async (req, res) => {
    try {
      const { barcode } = req.body;
      
      if (!barcode || typeof barcode !== 'string') {
        return res.status(400).json({
          success: false,
          message: "Barcode is required"
        });
      }

      // Validate EAN-13 format
      if (barcode.length !== 13 || !/^\d+$/.test(barcode)) {
        return res.json({
          success: true,
          valid: false,
          message: "Invalid EAN-13 format"
        });
      }

      // Validate check digit
      let sum = 0;
      for (let i = 0; i < 12; i++) {
        const digit = parseInt(barcode[i]);
        sum += i % 2 === 0 ? digit : digit * 3;
      }
      const calculatedCheckDigit = (10 - (sum % 10)) % 10;
      const providedCheckDigit = parseInt(barcode[12]);
      
      const isValid = calculatedCheckDigit === providedCheckDigit;
      
      res.json({
        success: true,
        valid: isValid,
        checkDigit: calculatedCheckDigit,
        message: isValid ? "Valid EAN-13 barcode" : "Invalid check digit"
      });
    } catch (error) {
      console.error("Error validating EAN-13:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // DATABASE BACKUP ENDPOINTS
  // =============================================================================

  // Create database backup
  app.post("/api/admin/backup/create", requireAuth, async (req, res) => {
    try {
      const { spawn } = await import('child_process');
      const fsModule = await import('fs');
      const pathModule = await import('path');
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
      const backupDir = './backups';
      const backupFile = `database_backup_${timestamp}.sql`;
      const backupPath = path.join(backupDir, backupFile);
      
      // Create backup directory if it doesn't exist
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }
      
      // Create backup using pg_dump
      const databaseUrl = process.env.DATABASE_URL;
      if (!databaseUrl) {
        return res.status(500).json({
          success: false,
          message: "Database URL not configured"
        });
      }

      const pgDump = spawn('pg_dump', [databaseUrl, '--no-owner', '--no-privileges']);
      
      const writeStream = fs.createWriteStream(backupPath);
      pgDump.stdout?.pipe(writeStream);
      
      let errorOutput = '';
      pgDump.stderr?.on('data', (data: Buffer) => {
        errorOutput += data.toString();
      });
      
      pgDump.on('close', (code: number | null) => {
        if (code === 0) {
          const stats = fs.statSync(backupPath);
          res.json({
            success: true,
            message: 'Backup created successfully',
            filename: backupFile,
            size: stats.size,
            timestamp: new Date().toISOString()
          });
        } else {
          console.error('pg_dump error:', errorOutput);
          res.status(500).json({
            success: false,
            message: 'Failed to create backup',
            error: errorOutput
          });
        }
      });
      
    } catch (error) {
      console.error("Error creating backup:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Download database backup
  app.get("/api/admin/backup/download/:filename", requireAuth, async (req, res) => {
    try {
      const { filename } = req.params;
      
      // Security check - only allow .sql and .sql.gz files and prevent directory traversal
      if ((!filename.endsWith('.sql') && !filename.endsWith('.sql.gz')) || filename.includes('..') || filename.includes('/')) {
        return res.status(400).json({
          success: false,
          message: 'Invalid filename'
        });
      }
      
      const backupPath = path.join('./backups', filename);
      
      if (!fs.existsSync(backupPath)) {
        return res.status(404).json({
          success: false,
          message: 'Backup file not found'
        });
      }
      
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Type', 'application/sql');
      
      const fileStream = fs.createReadStream(backupPath);
      fileStream.pipe(res);
      
    } catch (error) {
      console.error("Error downloading backup:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Delete database backup
  app.delete("/api/admin/backup/delete/:filename", requireAuth, async (req, res) => {
    try {
      const { filename } = req.params;
      
      // Security check - only allow .sql and .sql.gz files and prevent directory traversal
      if ((!filename.endsWith('.sql') && !filename.endsWith('.sql.gz')) || filename.includes('..') || filename.includes('/')) {
        return res.status(400).json({
          success: false,
          message: 'Invalid filename'
        });
      }
      
      const backupPath = path.join('./backups', filename);
      
      if (!fs.existsSync(backupPath)) {
        return res.status(404).json({
          success: false,
          message: 'Backup file not found'
        });
      }
      
      // Delete the backup file
      fs.unlinkSync(backupPath);
      
      res.json({
        success: true,
        message: 'Backup file deleted successfully'
      });
      
    } catch (error) {
      console.error("Error deleting backup:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // List available backups
  app.get("/api/admin/backup/list", requireAuth, async (req, res) => {
    try {
      
      const backupDir = './backups';
      
      if (!fs.existsSync(backupDir)) {
        return res.json({ backups: [] });
      }
      
      const files = fs.readdirSync(backupDir)
        .filter(file => file.endsWith('.sql') || file.endsWith('.sql.gz'))
        .map(file => {
          const filePath = path.join(backupDir, file);
          const stats = fs.statSync(filePath);
          return {
            filename: file,
            size: stats.size,
            created: stats.birthtime,
            modified: stats.mtime
          };
        })
        .sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime());
      
      res.json({ backups: files });
    } catch (error) {
      console.error("Error listing backups:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // ADMIN USER MANAGEMENT ENDPOINTS (SUPER ADMIN ONLY)
  // =============================================================================

  // Check if user has specific permission
  const hasPermission = async (userId: number, permissionName: string): Promise<boolean> => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 1 FROM users u
        JOIN admin_roles r ON u.role_id = r.id
        JOIN role_permissions rp ON r.id = rp.role_id
        JOIN admin_permissions p ON rp.permission_id = p.id
        WHERE u.id = $1 AND p.name = $2 AND u.is_active = true AND r.is_active = true
      `, [userId, permissionName]);
      return result.rows.length > 0;
    } catch (error) {
      console.error('Error checking permission:', error);
      return false;
    }
  };

  // Use the requireSuperAdmin middleware already defined above

  // Get all admin users
  app.get("/api/admin/users", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT u.id, u.username, u.email, u.role_id, u.is_active, u.last_login_at, u.created_at,
               r.name as role_name, r.display_name as role_display_name
        FROM users u
        LEFT JOIN admin_roles r ON u.role_id = r.id
        ORDER BY u.created_at DESC
      `);
      
      const users = result.rows.map((row: any) => ({
        id: row.id,
        username: row.username,
        email: row.email,
        roleId: row.role_id,
        roleName: row.role_name,
        roleDisplayName: row.role_display_name,
        isActive: row.is_active,
        lastLoginAt: row.last_login_at,
        createdAt: row.created_at
      }));

      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get all admin roles
  app.get("/api/admin/roles", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT r.id, r.name, r.display_name, r.description, r.is_active,
               COUNT(rp.permission_id) as permission_count
        FROM admin_roles r
        LEFT JOIN role_permissions rp ON r.id = rp.role_id
        GROUP BY r.id, r.name, r.display_name, r.description, r.is_active
        ORDER BY r.id
      `);
      
      const roles = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        isActive: row.is_active,
        permissionCount: parseInt(row.permission_count)
      }));

      res.json(roles);
    } catch (error) {
      console.error("Error fetching roles:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Function to convert technical module IDs to Persian names
  function convertTechnicalToPersianModule(moduleId: string): string {
    const technicalToPersianMap: { [key: string]: string } = {
      'kpi_dashboard': 'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ (KPI)',
      'management_dashboard': 'Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ',
      'syncing_shop': 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡',
      'inquiries': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª',
      'barcode': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯',
      'email_settings': 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„',
      'database_backup': 'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡',
      'crm': 'Ù…Ø¯ÛŒØ±ÛŒØª CRM',
      'seo': 'Ù…Ø¯ÛŒØ±ÛŒØª SEO',
      'categories': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§',
      'sms': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©',
      'factory': 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡',
      'user_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†',
      'shop_management': 'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡',
      'procedures': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§',
      'order_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
      'product_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª',
      'payment_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª',
      'accounting_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ',
      'finance': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ',
      'wallet_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„',
      'geography_analytics': 'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ',
      'ai_settings': 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ',
      'refresh_control': 'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ',
      'content_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§',
      'warehouse_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±',
      'logistics_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©',
      'ticketing_system': 'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯',
      'remote_desktop': 'Ø¯Ø³Ú©ØªØ§Ù¾ Ø±ÛŒÙ…ÙˆØª',
      'server_config': 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±',
      'company_information': 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª',
      'user_guide': 'User Guide',
      'site_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³Ø§ÛŒØª',
      'marketing_module': 'Ù…Ø§Ú˜ÙˆÙ„ Ù…Ø§Ø±Ú©ØªÛŒÙ†Ú¯',
      'order_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ùˆ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª'
    };

    return technicalToPersianMap[moduleId] || moduleId;
  }

  // Get all admin permissions
  app.get("/api/admin/permissions", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, display_name, description, module, is_active
        FROM admin_permissions
        ORDER BY module, display_name
      `);
      
      const permissions = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        module: row.module,
        isActive: row.is_active
      }));

      res.json(permissions);
    } catch (error) {
      console.error("Error fetching permissions:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Sync modules with main system
  app.post("/api/admin/sync-modules", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Define the main system modules - these are the 31 Site Management modules
      const mainModules = [
        'syncing_shop',
        'inquiries', 
        'barcode',
        'email_settings',
        'database_backup',
        'crm',
        'seo',
        'categories',
        'sms',
        'factory',
        'user_management',
        'shop_management',
        'procedures',
        'order_management',
        'product_management',
        'payment_management',
        'accounting_management',
        'wallet_management',
        'geography_analytics',
        'ai_settings',
        'refresh_control',
        'finance',
        'content_management',
        'warehouse_management',
        'logistics_management',
        'ticketing_system',
        'remote_desktop',
        'server_config',
        'kpi_dashboard',
        'management_dashboard',
        'user_guide'
      ];

      // Get super admin role (admin@momtazchem.com has user ID 7)
      const superAdminRoleId = '7';
      
      let syncedModules = 0;

      // Sync each main module to module_permissions for super admin
      for (const moduleId of mainModules) {
        // Check if module permission exists for super admin
        const existingPermission = await pool.query(
          'SELECT id FROM module_permissions WHERE role_id = $1 AND module_id = $2',
          [superAdminRoleId, moduleId]
        );

        if (existingPermission.rows.length === 0) {
          // Create the permission for super admin
          await pool.query(`
            INSERT INTO module_permissions (role_id, module_id, can_view, can_create, can_edit, can_delete, can_approve, created_at, updated_at)
            VALUES ($1, $2, true, true, true, true, true, NOW(), NOW())
          `, [superAdminRoleId, moduleId]);
          syncedModules++;
        } else {
          // Update existing permission to ensure it's active
          await pool.query(`
            UPDATE module_permissions SET
              can_view = true,
              can_create = true,
              can_edit = true,
              can_delete = true,
              can_approve = true,
              updated_at = NOW()
            WHERE role_id = $1 AND module_id = $2
          `, [superAdminRoleId, moduleId]);
        }
      }

      console.log(`âœ… Module sync completed: ${syncedModules} new modules synced for super admin`);
      
      res.json({
        success: true,
        message: "ØªÙ… Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
        syncedModules,
        totalModules: mainModules.length
      });
    } catch (error) {
      console.error("Error syncing modules:", error);
      res.status(500).json({ 
        success: false, 
        message: "ÙØ´Ù„ ÙÙŠ Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙˆØ­Ø¯Ø§Øª",
        error: error.message 
      });
    }
  });

  // User Management sync modules endpoint
  // Function to get current Site Management modules dynamically
  const getSiteManagementModules = () => {
    // This should be the SINGLE SOURCE OF TRUTH for all modules
    // Any changes here will automatically sync to User Management
    return [
      'syncing_shop',
      'shop_management', 
      'product_management',
      'order_management',
      'warehouse_management',
      'logistics_management',
      'inquiries',
      'crm',
      'barcode',
      'email_settings',
      'database_backup',
      'seo',
      'categories',
      'sms',
      'factory',
      'user_management',
      'procedures',
      'payment_management',
      'finance',
      'wallet_management',
      'geography_analytics',
      'ai_settings',
      'refresh_control',
      'content_management',
      'ticketing_system',
      'remote_desktop',
      'server_config',
      'kpi_dashboard',
      'management_dashboard'
      // Total: 28 modules - automatically synced with Site Management
    ];
  };

  app.post("/api/user-management/sync-modules", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get current modules from the single source of truth
      const mainModules = getSiteManagementModules();

      // Get super admin role (admin@momtazchem.com has user ID 7)
      const superAdminRoleId = '7';
      
      let syncedModules = 0;

      // Sync each main module to module_permissions for super admin
      for (const moduleId of mainModules) {
        // Check if module permission exists for super admin
        const existingPermission = await pool.query(
          'SELECT id FROM module_permissions WHERE role_id = $1 AND module_id = $2',
          [superAdminRoleId, moduleId]
        );

        if (existingPermission.rows.length === 0) {
          // Create the permission for super admin
          await pool.query(`
            INSERT INTO module_permissions (role_id, module_id, can_view, can_create, can_edit, can_delete, can_approve, created_at, updated_at)
            VALUES ($1, $2, true, true, true, true, true, NOW(), NOW())
          `, [superAdminRoleId, moduleId]);
          syncedModules++;
        }
      }

      console.log(`âœ… User Management sync completed: ${syncedModules} new modules synced`);
      
      res.json({
        success: true,
        message: `Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù†Ø¯. ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„: ${mainModules.length}`,
        syncedModules,
        totalModules: mainModules.length,
        modulesList: mainModules  // Return the current module list for frontend reference
      });
    } catch (error) {
      console.error("Error syncing modules from User Management:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§",
        error: error.message 
      });
    }
  });

  // NEW: API endpoint to get current Site Management modules list
  app.get("/api/site-management/modules", requireAuth, async (req, res) => {
    try {
      const modules = getSiteManagementModules();
      res.json({
        success: true,
        modules: modules,
        count: modules.length
      });
    } catch (error) {
      console.error("âŒ Error getting Site Management modules:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get Site Management modules"
      });
    }
  });

  // Create new admin user
  app.post("/api/admin/users", requireSuperAdmin, async (req, res) => {
    try {
      const { username, email, password, roleId } = req.body;
      
      // Hash password
      const passwordHash = await bcrypt.hash(password, 12);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO users (username, email, password_hash, role_id, is_active)
        VALUES ($1, $2, $3, $4, true)
        RETURNING id, username, email, role_id, is_active, created_at
      `, [username, email, passwordHash, roleId]);

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating user:", error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Username or email already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Update admin user
  app.put("/api/admin/users/:id", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { username, email, password, roleId } = req.body;
      
      let query = `
        UPDATE users 
        SET username = $1, email = $2, role_id = $3, updated_at = NOW()
      `;
      let params = [username, email, roleId];
      
      if (password && password.trim() !== '') {
        const passwordHash = await bcrypt.hash(password, 12);
        query += `, password_hash = $4`;
        params.push(passwordHash);
        query += ` WHERE id = $5`;
        params.push(id);
      } else {
        query += ` WHERE id = $4`;
        params.push(id);
      }
      
      query += ` RETURNING id, username, email, role_id, is_active`;

      const { pool } = await import('./db');
      const result = await pool.query(query, params);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "User not found" });
      }

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error updating user:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Username or email already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Toggle user active status
  app.put("/api/admin/users/:id/status", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE users 
        SET is_active = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING id, username, email, is_active
      `, [isActive, id]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "User not found" });
      }

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // ROLE MANAGEMENT ENDPOINTS (SUPER ADMIN ONLY)
  // =============================================================================

  // Create new role
  app.post("/api/admin/roles", requireSuperAdmin, async (req, res) => {
    try {
      const { name, displayName, description } = req.body;
      
      if (!name || !displayName) {
        return res.status(400).json({ success: false, message: "Name and display name are required" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO admin_roles (name, display_name, description, is_active)
        VALUES ($1, $2, $3, true)
        RETURNING id, name, display_name, description, is_active, created_at
      `, [name, displayName, description]);

      res.json({
        success: true,
        role: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating role:", error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Role name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Update role
  app.put("/api/admin/roles/:id", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, displayName, description, isActive } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE admin_roles 
        SET name = $1, display_name = $2, description = $3, is_active = $4, updated_at = NOW()
        WHERE id = $5
        RETURNING id, name, display_name, description, is_active, updated_at
      `, [name, displayName, description, isActive, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Role not found" });
      }

      res.json({
        success: true,
        role: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error updating role:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Role name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Delete role
  app.delete("/api/admin/roles/:id", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      
      // Check if role has users assigned
      const usersCheck = await pool.query(`
        SELECT COUNT(*) as user_count FROM users WHERE role_id = $1
      `, [id]);
      
      if (parseInt(usersCheck.rows[0].user_count) > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Cannot delete role that has users assigned to it" 
        });
      }

      // Delete role permissions first
      await pool.query(`DELETE FROM role_permissions WHERE role_id = $1`, [id]);
      
      // Delete role
      const result = await pool.query(`
        DELETE FROM admin_roles WHERE id = $1 RETURNING id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Role not found" });
      }

      res.json({
        success: true,
        message: "Role deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting role:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get role permissions
  app.get("/api/admin/roles/:id/permissions", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT p.id, p.name, p.display_name, p.description, p.module,
               CASE WHEN rp.permission_id IS NOT NULL THEN true ELSE false END as assigned
        FROM admin_permissions p
        LEFT JOIN role_permissions rp ON p.id = rp.permission_id AND rp.role_id = $1
        WHERE p.is_active = true
        ORDER BY p.module, p.display_name
      `, [id]);

      const permissions = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        module: row.module,
        assigned: row.assigned
      }));

      res.json(permissions);
    } catch (error) {
      console.error("Error fetching role permissions:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update role permissions
  app.put("/api/admin/roles/:id/permissions", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { permissionIds } = req.body;
      
      if (!Array.isArray(permissionIds)) {
        return res.status(400).json({ success: false, message: "Permission IDs must be an array" });
      }

      const { pool } = await import('./db');
      
      // Begin transaction
      await pool.query('BEGIN');
      
      try {
        // Remove existing permissions
        await pool.query(`DELETE FROM role_permissions WHERE role_id = $1`, [id]);
        
        // Add new permissions
        if (permissionIds.length > 0) {
          const values = permissionIds.map((permId: string, index: number) => 
            `($1, $${index + 2})`
          ).join(', ');
          
          const query = `INSERT INTO role_permissions (role_id, permission_id) VALUES ${values}`;
          await pool.query(query, [id, ...permissionIds]);
        }
        
        await pool.query('COMMIT');
        
        res.json({
          success: true,
          message: "Role permissions updated successfully"
        });
      } catch (error) {
        await pool.query('ROLLBACK');
        throw error;
      }
    } catch (error) {
      console.error("Error updating role permissions:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // CUSTOM USER MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all custom roles
  app.get("/api/admin/custom-roles", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          cr.*,
          COUNT(cu.id) as user_count
        FROM custom_roles cr
        LEFT JOIN custom_users cu ON cr.id = cu.role_id AND cu.is_active = true
        GROUP BY cr.id
        ORDER BY cr.priority DESC, cr.display_name
      `);

      const roles = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        color: row.color,
        priority: row.priority,
        permissions: row.permissions || [],
        permissionCount: (row.permissions || []).length, // Ø´Ù…Ø§Ø±Ø´ Ø¯Ù‚ÛŒÙ‚ Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§
        userCount: parseInt(row.user_count),
        isActive: row.is_active,
        createdAt: row.created_at
      }));

      res.json({ success: true, data: roles });
    } catch (error) {
      console.error("Error fetching custom roles:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø´â€ŒÙ‡Ø§" });
    }
  });

  // Create custom role
  app.post("/api/admin/custom-roles", requireAuth, async (req, res) => {
    try {
      const { name, displayName, description, color, priority, permissions } = req.body;
      
      if (!name || !displayName) {
        return res.status(400).json({ success: false, message: "Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ù†Ù…Ø§ÛŒØ´ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO custom_roles (name, display_name, description, color, priority, permissions)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *
      `, [name, displayName, description, color || '#3b82f6', priority || 1, permissions || []]);

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ù†Ù‚Ø´ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error creating custom role:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ù†Ø§Ù… Ù†Ù‚Ø´ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù‚Ø´" });
      }
    }
  });

  // Update custom role
  app.patch("/api/admin/custom-roles/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, displayName, description, color, priority, permissions, isActive } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE custom_roles 
        SET 
          name = COALESCE($1, name),
          display_name = COALESCE($2, display_name),
          description = COALESCE($3, description),
          color = COALESCE($4, color),
          priority = COALESCE($5, priority),
          permissions = COALESCE($6, permissions),
          is_active = COALESCE($7, is_active),
          updated_at = NOW()
        WHERE id = $8
        RETURNING *
      `, [name, displayName, description, color, priority, permissions, isActive, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ù†Ù‚Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ù†Ù‚Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error updating custom role:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ù†Ø§Ù… Ù†Ù‚Ø´ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ù‚Ø´" });
      }
    }
  });

  // Delete custom role
  app.delete("/api/admin/custom-roles/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      
      // Check if role has users assigned
      const usersCheck = await pool.query(`
        SELECT COUNT(*) as user_count FROM custom_users WHERE role_id = $1
      `, [id]);
      
      if (parseInt(usersCheck.rows[0].user_count) > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù†Ù‚Ø´ÛŒ Ø±Ø§ Ø­Ø°Ù Ú©Ø±Ø¯ Ú©Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ù‡ Ø¢Ù† ØªØ®ØµÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯" 
        });
      }

      const result = await pool.query(`
        DELETE FROM custom_roles WHERE id = $1 RETURNING id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ù†Ù‚Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        message: "Ù†Ù‚Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting custom role:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù†Ù‚Ø´" });
    }
  });

  // Get all custom users
  app.get("/api/admin/custom-users", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          cu.*,
          cr.name as role_name,
          cr.display_name as role_display_name,
          cr.color as role_color
        FROM custom_users cu
        LEFT JOIN custom_roles cr ON cu.role_id = cr.id
        ORDER BY cu.created_at DESC
      `);

      const users = result.rows.map((row: any) => ({
        id: row.id,
        fullName: row.full_name,
        email: row.email,
        phone: row.phone,
        roleId: row.role_id,
        roleName: row.role_name,
        roleDisplayName: row.role_display_name,
        roleColor: row.role_color,
        isActive: row.is_active,
        smsNotifications: row.sms_notifications,
        emailNotifications: row.email_notifications,
        lastLogin: row.last_login,
        createdAt: row.created_at
      }));

      res.json({ success: true, data: users });
    } catch (error) {
      console.error("Error fetching custom users:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†" });
    }
  });

  // Create custom user
  app.post("/api/admin/custom-users", requireAuth, async (req, res) => {
    try {
      const { fullName, email, phone, password, roleId, smsNotifications, emailNotifications, isActive } = req.body;
      
      if (!fullName || !email || !phone || !password || !roleId) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Hash password
      const bcrypt = await import('bcryptjs');
      const passwordHash = await bcrypt.hash(password, 10);

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO custom_users (
          full_name, email, phone, password_hash, role_id, 
          sms_notifications, email_notifications, is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id, full_name, email, phone, role_id, is_active, 
                  sms_notifications, email_notifications, created_at
      `, [fullName, email, phone, passwordHash, roleId, 
          smsNotifications ?? true, emailNotifications ?? true, isActive ?? true]);

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error creating custom user:", error);
      if (error.code === '23505') {
        if (error.constraint?.includes('email')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else if (error.constraint?.includes('phone')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else {
          res.status(400).json({ success: false, message: "Ø¯Ø§Ø¯Ù‡ ØªÚ©Ø±Ø§Ø±ÛŒ" });
        }
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±" });
      }
    }
  });

  // Update custom user
  app.patch("/api/admin/custom-users/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { fullName, email, phone, password, roleId, smsNotifications, emailNotifications, isActive } = req.body;
      
      let passwordHash = undefined;
      if (password) {
        const bcrypt = await import('bcryptjs');
        passwordHash = await bcrypt.hash(password, 10);
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE custom_users 
        SET 
          full_name = COALESCE($1, full_name),
          email = COALESCE($2, email),
          phone = COALESCE($3, phone),
          password_hash = COALESCE($4, password_hash),
          role_id = COALESCE($5, role_id),
          sms_notifications = COALESCE($6, sms_notifications),
          email_notifications = COALESCE($7, email_notifications),
          is_active = COALESCE($8, is_active),
          updated_at = NOW()
        WHERE id = $9
        RETURNING id, full_name, email, phone, role_id, is_active,
                  sms_notifications, email_notifications, updated_at
      `, [fullName, email, phone, passwordHash, roleId, smsNotifications, emailNotifications, isActive, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error updating custom user:", error);
      if (error.code === '23505') {
        if (error.constraint?.includes('email')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else if (error.constraint?.includes('phone')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else {
          res.status(400).json({ success: false, message: "Ø¯Ø§Ø¯Ù‡ ØªÚ©Ø±Ø§Ø±ÛŒ" });
        }
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±Ø¨Ø±" });
      }
    }
  });

  // Delete custom user
  app.delete("/api/admin/custom-users/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        DELETE FROM custom_users WHERE id = $1 RETURNING id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Custom user login endpoint
  app.post("/api/custom-users/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ Ùˆ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const { pool } = await import('./db');
      const bcrypt = await import('bcryptjs');
      
      // Get custom user by email
      const result = await pool.query(`
        SELECT 
          cu.*,
          cr.name as role_name,
          cr.display_name as role_display_name,
          cr.permissions as role_permissions
        FROM custom_users cu
        LEFT JOIN custom_roles cr ON cu.role_id = cr.id
        WHERE cu.email = $1 AND cu.is_active = true
      `, [email]);

      if (result.rows.length === 0) {
        return res.status(401).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª"
        });
      }

      const user = result.rows[0];
      
      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.password_hash);
      if (!isValidPassword) {
        // Update login attempts
        await pool.query(`
          UPDATE custom_users 
          SET login_attempts = login_attempts + 1, updated_at = NOW()
          WHERE id = $1
        `, [user.id]);
        
        return res.status(401).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª"
        });
      }

      // Update last login and reset login attempts
      await pool.query(`
        UPDATE custom_users 
        SET last_login = NOW(), login_attempts = 0, updated_at = NOW()
        WHERE id = $1
      `, [user.id]);

      // Set session
      req.session.customUserId = user.id;
      req.session.customUserEmail = user.email;
      req.session.customUserName = user.full_name;
      req.session.customUserRole = user.role_name;
      req.session.customUserPermissions = user.role_permissions;
      req.session.isAuthenticated = true;

      res.json({
        success: true,
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚",
        user: {
          id: user.id,
          fullName: user.full_name,
          email: user.email,
          role: user.role_name,
          roleDisplayName: user.role_display_name,
          permissions: user.role_permissions
        }
      });

    } catch (error) {
      console.error("Error in custom user login:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯"
      });
    }
  });

  // Custom user logout endpoint
  app.post("/api/custom-users/logout", async (req, res) => {
    try {
      // Clear all session data (single session mode)
      req.session.customUserId = undefined;
      req.session.customUserEmail = undefined;
      req.session.customUserName = undefined;
      req.session.customUserRole = undefined;
      req.session.customUserPermissions = undefined;
      req.session.adminId = undefined;
      req.session.customerId = undefined;
      req.session.customerEmail = undefined;
      req.session.crmCustomerId = undefined;
      req.session.isAuthenticated = undefined;
      
      // Always destroy entire session for clean logout
      req.session.destroy((err) => {
        if (err) {
          console.error("Error destroying session:", err);
          return res.status(500).json({
            success: false,
            message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬"
          });
        }
        console.log('ğŸ”„ Complete custom user logout - all sessions cleared');
        res.json({
          success: true,
          message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚"
        });
      });
    } catch (error) {
      console.error("Error logging out custom user:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬"
      });
    }
  });

  // Get current custom user profile
  app.get("/api/custom-users/me", async (req, res) => {
    try {
      const customUserId = req.session.customUserId;
      
      if (!customUserId) {
        return res.status(401).json({
          success: false,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡"
        });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          cu.id, cu.full_name, cu.email, cu.phone, cu.is_active,
          cu.sms_notifications, cu.email_notifications, cu.last_login,
          cr.name as role_name, cr.display_name as role_display_name,
          cr.permissions as role_permissions
        FROM custom_users cu
        LEFT JOIN custom_roles cr ON cu.role_id = cr.id
        WHERE cu.id = $1 AND cu.is_active = true
      `, [customUserId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const user = result.rows[0];
      res.json({
        success: true,
        user: {
          id: user.id,
          fullName: user.full_name,
          email: user.email,
          phone: user.phone,
          role: user.role_name,
          roleDisplayName: user.role_display_name,
          permissions: user.role_permissions,
          isActive: user.is_active,
          smsNotifications: user.sms_notifications,
          emailNotifications: user.email_notifications,
          lastLogin: user.last_login
        }
      });

    } catch (error) {
      console.error("Error fetching custom user profile:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø±ÙˆÙØ§ÛŒÙ„"
      });
    }
  });

  // REMOVED: Auto-approval endpoint - bank payments now go directly to warehouse after verification

  // Bank payment gateway webhook endpoint (for real-time payment confirmations)
  app.post("/api/payment/gateway/webhook", async (req, res) => {
    try {
      const { orderId, paymentStatus, transactionId, amount, currency } = req.body;
      
      console.log(`ğŸ¦ [GATEWAY WEBHOOK] Received payment notification:`, {
        orderId,
        paymentStatus,
        transactionId,
        amount,
        currency
      });

      if (!orderId || !paymentStatus) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ùˆ ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Check if payment is successful
      const isPaymentSuccessful = paymentStatus === 'paid' || 
                                paymentStatus === 'confirmed' || 
                                paymentStatus === 'successful' ||
                                paymentStatus === 'success';

      if (isPaymentSuccessful) {
        // Update customer order payment status
        await db
          .update(customerOrders)
          .set({
            paymentStatus: 'paid',
            status: 'confirmed',
            updatedAt: new Date()
          })
          .where(eq(customerOrders.id, parseInt(orderId)));

        console.log(`âœ… [GATEWAY WEBHOOK] Order ${orderId} payment confirmed via gateway`);

        // For bank payments: assign order number and send directly to warehouse
        try {
          const { paymentWorkflow } = await import('./payment-workflow');
          const orderNumber = await paymentWorkflow.assignOrderNumberAfterPaymentSuccess(parseInt(orderId));
          console.log(`ğŸ‰ [GATEWAY WEBHOOK] Order ${orderId} assigned number ${orderNumber} and sent directly to warehouse`);
        } catch (assignmentError) {
          console.error(`âŒ [GATEWAY WEBHOOK] Order number assignment failed for order ${orderId}:`, assignmentError);
        }
      } else {
        // Payment failed - delete the temporary order immediately
        const isPaymentFailed = paymentStatus === 'failed' || 
                               paymentStatus === 'cancelled' || 
                               paymentStatus === 'error' ||
                               paymentStatus === 'denied';
                               
        if (isPaymentFailed) {
          console.log(`âŒ [GATEWAY WEBHOOK] Payment failed for order ${orderId} - deleting temporary order`);
          try {
            await customerStorage.deleteTemporaryOrder(parseInt(orderId));
            console.log(`âœ… [GATEWAY WEBHOOK] Temporary order ${orderId} deleted after payment failure`);
          } catch (deleteError) {
            console.error(`âŒ [GATEWAY WEBHOOK] Failed to delete order ${orderId}:`, deleteError);
          }
        }
      }

      res.json({
        success: true,
        message: "ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
      
    } catch (error) {
      console.error('âŒ [GATEWAY WEBHOOK] Error processing payment webhook:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });


  // Payment callback endpoint for immediate failed payment handling
  app.post("/api/payment/callback", async (req, res) => {
    try {
      const { orderId, orderNumber, paymentStatus, transactionId } = req.body;
      
      console.log(`ğŸ”„ [PAYMENT CALLBACK] Received payment callback:`, {
        orderId,
        orderNumber, 
        paymentStatus,
        transactionId
      });

      if (!orderId && !orderNumber) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Check if payment is successful
      const isPaymentSuccessful = paymentStatus === 'paid' || 
                                paymentStatus === 'confirmed' || 
                                paymentStatus === 'successful' ||
                                paymentStatus === 'success';

      // Handle successful payments by assigning order numbers and sending to warehouse
      if (isPaymentSuccessful) {
        console.log(`âœ… [PAYMENT CALLBACK] Payment successful - processing order ${orderId || orderNumber}`);
        
        try {
          // Try to find order by ID or order number
          let targetOrderId = orderId;
          if (!targetOrderId && orderNumber) {
            const orderResult = await db
              .select({ id: customerOrders.id })
              .from(customerOrders)
              .where(eq(customerOrders.orderNumber, orderNumber))
              .limit(1);
            
            if (orderResult.length > 0) {
              targetOrderId = orderResult[0].id;
            }
          }
          
          if (targetOrderId) {
            // Update payment status and confirm order
            await db
              .update(customerOrders)
              .set({
                paymentStatus: 'paid',
                status: 'confirmed',
                updatedAt: new Date()
              })
              .where(eq(customerOrders.id, parseInt(targetOrderId)));

            // Auto-assign order number and send to warehouse for confirmed bank payments
            try {
              const { paymentWorkflow } = await import('./payment-workflow');
              const assignedOrderNumber = await paymentWorkflow.assignOrderNumberAfterPaymentSuccess(parseInt(targetOrderId));
              console.log(`ğŸ‰ [PAYMENT CALLBACK] Order ${targetOrderId} assigned number ${assignedOrderNumber} and sent to warehouse`);
              
              return res.json({
                success: true,
                message: "Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ£ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
                orderNumber: assignedOrderNumber,
                orderConfirmed: true
              });
            } catch (assignmentError) {
              console.error(`âŒ [PAYMENT CALLBACK] Order number assignment failed for order ${targetOrderId}:`, assignmentError);
            }
          } else {
            console.log(`âš ï¸ [PAYMENT CALLBACK] Order not found for confirmation: ${orderId || orderNumber}`);
          }
        } catch (successError) {
          console.error(`âŒ [PAYMENT CALLBACK] Failed to process successful payment ${orderId || orderNumber}:`, successError);
        }
      }

      // Handle failed/cancelled payments by immediately deleting temporary orders
      const isPaymentFailed = paymentStatus === 'failed' || 
                             paymentStatus === 'cancelled' || 
                             paymentStatus === 'error' ||
                             paymentStatus === 'denied' ||
                             paymentStatus === 'abandoned';
                             
      if (isPaymentFailed) {
        console.log(`âŒ [PAYMENT CALLBACK] Payment failed/abandoned - deleting temporary order ${orderId || orderNumber}`);
        
        try {
          // Try to find order by ID or order number
          let targetOrderId = orderId;
          if (!targetOrderId && orderNumber) {
            const orderResult = await db
              .select({ id: customerOrders.id })
              .from(customerOrders)
              .where(eq(customerOrders.orderNumber, orderNumber))
              .limit(1);
            
            if (orderResult.length > 0) {
              targetOrderId = orderResult[0].id;
            }
          }
          
          if (targetOrderId) {
            await customerStorage.deleteTemporaryOrder(parseInt(targetOrderId));
            console.log(`âœ… [PAYMENT CALLBACK] Temporary order ${targetOrderId} deleted after payment failure`);
            
            return res.json({
              success: true,
              message: "Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ø¹Ø¯Ù… Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª Ø­Ø°Ù Ø´Ø¯",
              orderDeleted: true
            });
          } else {
            console.log(`âš ï¸ [PAYMENT CALLBACK] Order not found for deletion: ${orderId || orderNumber}`);
          }
        } catch (deleteError) {
          console.error(`âŒ [PAYMENT CALLBACK] Failed to delete order ${orderId || orderNumber}:`, deleteError);
        }
      }

      res.json({
        success: true,
        message: "Ø¯Ø±Ø®ÙˆØ§Ø³Øª callback Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯"
      });
      
    } catch (error) {
      console.error('âŒ [PAYMENT CALLBACK] Error processing payment callback:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ callback Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Process pending bank gateway orders (manual trigger or scheduled service)
  app.post("/api/admin/orders/process-pending-bank-payments", requireAuth, async (req, res) => {
    try {
      console.log(`ğŸ”„ [PROCESS PENDING] Processing all pending bank gateway orders...`);
      
      // Get all orders with bank gateway payment that are paid but not yet approved
      const pendingBankOrders = await db
        .select({
          id: customerOrders.id,
          orderNumber: customerOrders.orderNumber,
          paymentMethod: customerOrders.paymentMethod,
          paymentStatus: customerOrders.paymentStatus,
          status: customerOrders.status
        })
        .from(customerOrders)
        .where(and(
          or(
            eq(customerOrders.paymentMethod, 'Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ'),
            eq(customerOrders.paymentMethod, 'bank_gateway'),
            eq(customerOrders.paymentMethod, 'gateway')
          ),
          or(
            eq(customerOrders.paymentStatus, 'paid'),
            eq(customerOrders.paymentStatus, 'confirmed'),
            eq(customerOrders.paymentStatus, 'successful')
          ),
          eq(customerOrders.status, 'pending')
        ));

      console.log(`ğŸ” [PROCESS PENDING] Found ${pendingBankOrders.length} pending bank gateway orders`);

      let processedCount = 0;
      for (const order of pendingBankOrders) {
        try {
          // For bank payments: assign order number and send directly to warehouse
          const { paymentWorkflow } = await import('./payment-workflow');
          const orderNumber = await paymentWorkflow.assignOrderNumberAfterPaymentSuccess(order.id);
          processedCount++;
          console.log(`âœ… [PROCESS PENDING] Order ${order.orderNumber} assigned number ${orderNumber} and sent to warehouse (${processedCount}/${pendingBankOrders.length})`);
        } catch (error) {
          console.error(`âŒ [PROCESS PENDING] Failed to process order ${order.orderNumber}:`, error);
        }
      }

      res.json({
        success: true,
        message: `${processedCount} Ø³ÙØ§Ø±Ø´ Ø§Ø² ${pendingBankOrders.length} Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯`,
        data: {
          totalFound: pendingBankOrders.length,
          processed: processedCount
        }
      });
      
    } catch (error) {
      console.error('âŒ [PROCESS PENDING] Error processing pending bank payments:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹Ù„Ù‚"
      });
    }
  });

  // Send SMS to users
  app.post("/api/admin/send-sms", requireAuth, async (req, res) => {
    try {
      const { userIds, message } = req.body;
      
      if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ø´ÙˆØ¯" 
        });
      }

      if (!message || message.trim().length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù…ØªÙ† Ù¾ÛŒØ§Ù…Ú© Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const { pool } = await import('./db');
      
      // Get users who have SMS notifications enabled
      const usersResult = await pool.query(`
        SELECT id, full_name, phone, sms_notifications
        FROM custom_users 
        WHERE id = ANY($1) AND is_active = true AND sms_notifications = true
      `, [userIds]);

      if (usersResult.rows.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ø§Ù„ÛŒ Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ SMS ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Log SMS notifications
      const insertPromises = usersResult.rows.map((user: any) => 
        pool.query(`
          INSERT INTO sms_notifications (recipient_id, recipient_phone, message)
          VALUES ($1, $2, $3)
        `, [user.id, user.phone, message])
      );

      await Promise.all(insertPromises);

      // Here you would integrate with actual SMS service
      // For now, we'll just mark them as sent
      await pool.query(`
        UPDATE sms_notifications 
        SET status = 'sent', sent_at = NOW()
        WHERE recipient_id = ANY($1) AND message = $2 AND status = 'pending'
      `, [userIds, message]);

      res.json({
        success: true,
        message: `Ù¾ÛŒØ§Ù…Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø§ÛŒ ${usersResult.rows.length} Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`,
        sentTo: usersResult.rows.length
      });
    } catch (error) {
      console.error("Error sending SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú©" });
    }
  });

  // ============================================
  // CUSTOM USER MANAGEMENT SYSTEM ENDPOINTS
  // ============================================

  // Get all custom roles
  app.get("/api/custom-roles", requireAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT cr.*, 
               COUNT(cu.id) as user_count
        FROM custom_roles cr
        LEFT JOIN custom_users cu ON cr.id = cu.role_id AND cu.is_active = true
        WHERE cr.is_active = true
        GROUP BY cr.id
        ORDER BY cr.priority DESC, cr.name
      `);

      res.json({
        success: true,
        roles: result.rows
      });
    } catch (error) {
      console.error("Error fetching custom roles:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø´â€ŒÙ‡Ø§" });
    }
  });

  // Create custom role
  app.post("/api/custom-roles", requireAdmin, async (req, res) => {
    try {
      const { name, displayName, description, color, priority, permissions } = req.body;
      
      if (!name || !displayName) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ù†Ù…Ø§ÛŒØ´ÛŒ Ù†Ù‚Ø´ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const { pool } = await import('./db');
      
      // Check if role with same name already exists
      const existingRole = await pool.query(
        'SELECT id FROM custom_roles WHERE name = $1',
        [name]
      );

      if (existingRole.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ù‚Ø´ Ø¨Ø§ Ø§ÛŒÙ† Ù†Ø§Ù… Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"
        });
      }

      const result = await pool.query(`
        INSERT INTO custom_roles (name, display_name, description, color, priority, permissions)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *
      `, [name, displayName, description || '', color || '#3b82f6', priority || 1, permissions || []]);

      res.json({
        success: true,
        role: result.rows[0],
        message: "Ù†Ù‚Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error creating custom role:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù‚Ø´" });
    }
  });

  // Get all custom users
  app.get("/api/custom-users", requireAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT cu.id, cu.full_name, cu.email, cu.phone, cu.is_active,
               cu.sms_notifications, cu.email_notifications, cu.last_login,
               cu.created_at, cu.updated_at,
               cr.id as role_id, cr.name as role_name, 
               cr.display_name as role_display_name, cr.color as role_color
        FROM custom_users cu
        JOIN custom_roles cr ON cu.role_id = cr.id
        ORDER BY cu.created_at DESC
      `);

      res.json({
        success: true,
        users: result.rows
      });
    } catch (error) {
      console.error("Error fetching custom users:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†" });
    }
  });

  // Create custom user
  app.post("/api/custom-users", requireAdmin, async (req, res) => {
    try {
      const { fullName, email, phone, roleId, password, smsNotifications, emailNotifications } = req.body;
      
      if (!fullName || !email || !phone || !roleId || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø¨Ø§ÛŒØ¯ Ù¾Ø± Ø´ÙˆÙ†Ø¯" 
        });
      }

      const { pool } = await import('./db');
      const bcrypt = await import('bcryptjs');
      
      // Check if user with same email or phone already exists
      const existingUser = await pool.query(
        'SELECT id FROM custom_users WHERE email = $1 OR phone = $2',
        [email, phone]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"
        });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 12);

      const result = await pool.query(`
        INSERT INTO custom_users (full_name, email, phone, password_hash, role_id, sms_notifications, email_notifications)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, full_name, email, phone, role_id, is_active, sms_notifications, email_notifications, created_at
      `, [fullName, email, phone, passwordHash, roleId, smsNotifications !== false, emailNotifications !== false]);

      // Send SMS notification if enabled
      if (smsNotifications !== false) {
        try {
          await pool.query(`
            INSERT INTO sms_notifications (recipient_id, recipient_phone, message, status)
            VALUES ($1, $2, $3, 'pending')
          `, [
            result.rows[0].id,
            phone,
            `Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ ${fullName}! Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±: ${password}`
          ]);
        } catch (smsError) {
          console.error("Error creating SMS notification:", smsError);
        }
      }

      res.json({
        success: true,
        user: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error creating custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Update custom user
  app.put("/api/custom-users/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { fullName, roleId, isActive, smsNotifications, emailNotifications, password } = req.body;
      
      const { pool } = await import('./db');
      let query = `
        UPDATE custom_users 
        SET full_name = $1, role_id = $2, is_active = $3, 
            sms_notifications = $4, email_notifications = $5, updated_at = NOW()
      `;
      let values = [fullName, roleId, isActive, smsNotifications, emailNotifications];
      
      // If password is provided, hash and update it
      if (password) {
        const bcrypt = await import('bcryptjs');
        const passwordHash = await bcrypt.hash(password, 12);
        query += `, password_hash = $6`;
        values.push(passwordHash);
      }
      
      query += ` WHERE id = $${values.length + 1} RETURNING *`;
      values.push(id);

      const result = await pool.query(query, values);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        user: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error updating custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Delete custom user
  app.delete("/api/custom-users/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { pool } = await import('./db');
      
      const result = await pool.query('DELETE FROM custom_users WHERE id = $1 RETURNING *', [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Send SMS to users with specific role
  app.post("/api/custom-roles/:roleId/send-sms", requireAdmin, async (req, res) => {
    try {
      const { roleId } = req.params;
      const { message } = req.body;
      
      if (!message) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù…ØªÙ† Ù¾ÛŒØ§Ù…Ú© Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const { pool } = await import('./db');
      
      // Get all active users with this role who have SMS notifications enabled
      const usersResult = await pool.query(`
        SELECT id, full_name, phone 
        FROM custom_users 
        WHERE role_id = $1 AND is_active = true AND sms_notifications = true
      `, [roleId]);

      if (usersResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ø§Ù„ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù†Ù‚Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Create SMS notifications for all users
      for (const user of usersResult.rows) {
        await pool.query(`
          INSERT INTO sms_notifications (recipient_id, recipient_phone, message, status)
          VALUES ($1, $2, $3, 'pending')
        `, [user.id, user.phone, message]);
      }

      res.json({
        success: true,
        message: `Ù¾ÛŒØ§Ù…Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø§ÛŒ ${usersResult.rows.length} Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`,
        sentTo: usersResult.rows.length
      });
    } catch (error) {
      console.error("Error sending SMS to role users:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú©" });
    }
  });

  // Server Configuration Routes
  app.get("/api/server/config", requireAdmin, async (req, res) => {
    try {
      const { CONFIG } = await import('./config');
      
      const config = {
        frontendUrl: process.env.FRONTEND_URL || CONFIG.getBaseUrl(req),
        nodeEnv: process.env.NODE_ENV || 'development',
        smtpHost: process.env.SMTP_HOST || 'smtp.zoho.com',
        smtpPort: process.env.SMTP_PORT || '587',
        smtpUser: process.env.SMTP_USER || '',
        // Don't send sensitive data
        databaseUrl: process.env.DATABASE_URL ? '***configured***' : '',
        sessionSecret: process.env.SESSION_SECRET ? '***configured***' : '',
        smtpPass: process.env.SMTP_PASS ? '***configured***' : ''
      };

      res.json({
        success: true,
        config
      });
    } catch (error) {
      console.error("Error getting server config:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±" });
    }
  });

  app.post("/api/server/test-config", requireAdmin, async (req, res) => {
    try {
      const { frontendUrl, databaseUrl, smtpHost, smtpPort, smtpUser } = req.body;
      
      const testResults = {
        domain: false,
        database: false,
        smtp: false
      };

      // Test domain URL format
      if (frontendUrl) {
        try {
          new URL(frontendUrl);
          testResults.domain = true;
        } catch {
          testResults.domain = false;
        }
      }

      // Test database connection if provided
      if (databaseUrl && databaseUrl !== '***configured***') {
        try {
          // Simple URL validation for PostgreSQL
          if (databaseUrl.startsWith('postgresql://') || databaseUrl.startsWith('postgres://')) {
            testResults.database = true;
          }
        } catch {
          testResults.database = false;
        }
      } else if (process.env.DATABASE_URL) {
        testResults.database = true;
      }

      // Test SMTP configuration
      if (smtpHost && smtpPort && smtpUser) {
        try {
          const port = parseInt(smtpPort);
          if (port > 0 && port < 65536 && smtpHost.includes('.')) {
            testResults.smtp = true;
          }
        } catch {
          testResults.smtp = false;
        }
      }

      const allPassed = testResults.domain && testResults.database && testResults.smtp;

      res.json({
        success: allPassed,
        testResults,
        message: allPassed ? "Ù‡Ù…Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØµØ­ÛŒØ­ Ø§Ø³Øª" : "Ø¨Ø±Ø®ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø±Ù†Ø¯"
      });
    } catch (error) {
      console.error("Error testing server config:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Get available modules/permissions - synchronized with Site Management modules
  app.get("/api/custom-modules", requireAdmin, async (req, res) => {
    try {
      // Get current modules from the single source of truth
      const currentModules = getSiteManagementModules();
      
      // Map module IDs to their display information
      const moduleMapping = {
        'kpi_dashboard': { name: 'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ (KPI)', description: 'Ù†Ù…Ø§ÛŒØ´ Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±', category: 'analytics' },
        'management_dashboard': { name: 'Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ', description: 'Ù…Ø±Ú©Ø² Ú©Ù†ØªØ±Ù„ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ Ùˆ Ù†Ø¸Ø§Ø±Øª Ø³ÛŒØ³ØªÙ…', category: 'analytics' },
        'server_config': { name: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ù†ÙÛŒÚ¯ Ø³Ø±ÙˆØ± Ùˆ Ù…Ù‡Ø§Ø¬Ø±Øª', category: 'system' },
        'syncing_shop': { name: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡', description: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª Ú©Ø§Ø±Ø¯Ú©Ø³ Ø¨Ø§ ÙØ±ÙˆØ´Ú¯Ø§Ù‡', category: 'commerce' },
        'shop_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§ØªØŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ùˆ ÙØ±ÙˆØ´', category: 'commerce' },
        'product_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¯Ú©Ø³ Ùˆ Ù…Ø­ØµÙˆÙ„Ø§Øª', category: 'commerce' },
        'order_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª', description: 'Ù¾Ø±Ø¯Ø§Ø²Ø´ Ùˆ ØªØ§ÛŒÛŒØ¯ Ø³ÙØ§Ø±Ø´Ø§Øª', category: 'commerce' },
        'warehouse_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±', description: 'Ú©Ù†ØªØ±Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ùˆ Ø§Ù†Ø¨Ø§Ø±Ø¯Ø§Ø±ÛŒ', category: 'warehouse' },
        'logistics_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ùˆ ØªØ­ÙˆÛŒÙ„', category: 'logistics' },
        'inquiries': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª', description: 'Ù¾Ø§Ø³Ø® Ø¨Ù‡ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ù…Ø´ØªØ±ÛŒØ§Ù†', category: 'customer' },
        'crm': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª CRM', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø´ØªØ±ÛŒØ§Ù† Ùˆ Ø±ÙˆØ§Ø¨Ø·', category: 'customer' },
        'barcode': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯', description: 'ØªÙˆÙ„ÛŒØ¯ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯Ù‡Ø§', category: 'inventory' },
        'email_settings': { name: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„', description: 'Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ø³ÛŒØ³ØªÙ… Ø§ÛŒÙ…ÛŒÙ„', category: 'communication' },
        'database_backup': { name: 'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ', category: 'system' },
        'seo': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª SEO', description: 'Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆØªÙˆØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ', category: 'content' },
        'categories': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§', description: 'ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª', category: 'content' },
        'sms': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©', description: 'Ø§Ø±Ø³Ø§Ù„ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©â€ŒÙ‡Ø§', category: 'communication' },
        'factory': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø· ØªÙˆÙ„ÛŒØ¯', category: 'production' },
        'user_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†', description: 'Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø³ÛŒØ³ØªÙ…', category: 'admin' },
        'procedures': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³Ù†Ø§Ø¯ Ùˆ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ', category: 'content' },
        'payment_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª', description: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª', category: 'finance' },
        'accounting_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ', description: 'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§Ú©ØªÙˆØ±Ù‡Ø§ Ùˆ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±', category: 'finance' },
        'finance': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ', description: 'Ø¨Ø±Ø±Ø³ÛŒ Ùˆ ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª', category: 'finance' },
        'wallet_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ø´ØªØ±ÛŒØ§Ù†', category: 'finance' },
        'geography_analytics': { name: 'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ', description: 'ØªØ­Ù„ÛŒÙ„ Ø¢Ù…Ø§Ø± Ù…Ù†Ø·Ù‚Ù‡â€ŒØ§ÛŒ', category: 'analytics' },
        'ai_settings': { name: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ', description: 'Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ AI Ùˆ SKU', category: 'system' },
        'refresh_control': { name: 'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ', description: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±', category: 'system' },
        'content_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§', description: 'ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø­ØªÙˆØ§ÛŒ ÙˆØ¨Ø³Ø§ÛŒØª', category: 'content' },
        'ticketing_system': { name: 'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯', description: 'Ù…Ø¯ÛŒØ±ÛŒØª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ Ùˆ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ', category: 'support' }
      };
      
      // Build modules array from current active modules
      const modules = currentModules.map(moduleId => ({
        id: moduleId,
        name: moduleMapping[moduleId]?.name || moduleId,
        description: moduleMapping[moduleId]?.description || `Ù…Ø§Ú˜ÙˆÙ„ ${moduleId}`,
        category: moduleMapping[moduleId]?.category || 'general'
      }));

      res.json({
        success: true,
        modules
      });
    } catch (error) {
      console.error("Error fetching modules:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§" });
    }
  });

  // Assign role to user
  app.put("/api/admin/users/:id/role", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { roleId } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE users 
        SET role_id = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING id, username, email, role_id
      `, [roleId, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "User not found" });
      }

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error) {
      console.error("Error assigning role to user:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get users by role
  app.get("/api/admin/roles/:id/users", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT u.id, u.username, u.email, u.is_active, u.created_at,
               r.display_name as role_name
        FROM users u
        JOIN admin_roles r ON u.role_id = r.id
        WHERE u.role_id = $1
        ORDER BY u.username
      `, [id]);

      const users = result.rows.map((row: any) => ({
        id: row.id,
        username: row.username,
        email: row.email,
        isActive: row.is_active,
        createdAt: row.created_at,
        roleName: row.role_name
      }));

      res.json(users);
    } catch (error) {
      console.error("Error fetching users by role:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get available modules for permissions
  app.get("/api/admin/modules", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT DISTINCT module FROM admin_permissions WHERE is_active = true ORDER BY module
      `);

      const modules = result.rows.map((row: any) => row.module);
      res.json(modules);
    } catch (error) {
      console.error("Error fetching modules:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // FACTORY MANAGEMENT ENDPOINTS
  // =============================================================================

  // Production Lines
  app.get("/api/factory/production-lines", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, description, capacity_per_hour, status, location, supervisor_name, created_at, updated_at
        FROM production_lines
        ORDER BY created_at DESC
      `);
      
      const productionLines = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        description: row.description,
        capacityPerHour: row.capacity_per_hour,
        status: row.status,
        location: row.location,
        supervisorName: row.supervisor_name,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(productionLines);
    } catch (error) {
      console.error("Error fetching production lines:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Raw Materials
  app.get("/api/factory/raw-materials", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, code, unit, current_stock, minimum_stock, maximum_stock, 
               unit_price, supplier, storage_location, expiry_date, quality_grade, created_at, updated_at
        FROM raw_materials
        ORDER BY name
      `);
      
      const rawMaterials = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        code: row.code,
        unit: row.unit,
        currentStock: row.current_stock,
        minimumStock: row.minimum_stock,
        maximumStock: row.maximum_stock,
        unitPrice: row.unit_price,
        supplier: row.supplier,
        storageLocation: row.storage_location,
        expiryDate: row.expiry_date,
        qualityGrade: row.quality_grade,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(rawMaterials);
    } catch (error) {
      console.error("Error fetching raw materials:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Production Orders
  app.get("/api/factory/production-orders", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, order_number, product_name, quantity_planned, quantity_produced, unit,
               production_line_id, status, priority, planned_start_date, actual_start_date,
               planned_end_date, actual_end_date, supervisor_notes, quality_check_status, created_at, updated_at
        FROM production_orders
        ORDER BY created_at DESC
      `);
      
      const productionOrders = result.rows.map((row: any) => ({
        id: row.id,
        orderNumber: row.order_number,
        productName: row.product_name,
        quantityPlanned: row.quantity_planned,
        quantityProduced: row.quantity_produced,
        unit: row.unit,
        productionLineId: row.production_line_id,
        status: row.status,
        priority: row.priority,
        plannedStartDate: row.planned_start_date,
        actualStartDate: row.actual_start_date,
        plannedEndDate: row.planned_end_date,
        actualEndDate: row.actual_end_date,
        supervisorNotes: row.supervisor_notes,
        qualityCheckStatus: row.quality_check_status,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(productionOrders);
    } catch (error) {
      console.error("Error fetching production orders:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Equipment Maintenance
  app.get("/api/factory/equipment-maintenance", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, equipment_name, equipment_code, production_line_id, maintenance_type,
               scheduled_date, completed_date, status, technician_name, description,
               cost, downtime_hours, created_at, updated_at
        FROM equipment_maintenance
        ORDER BY scheduled_date DESC
      `);
      
      const equipmentMaintenance = result.rows.map((row: any) => ({
        id: row.id,
        equipmentName: row.equipment_name,
        equipmentCode: row.equipment_code,
        productionLineId: row.production_line_id,
        maintenanceType: row.maintenance_type,
        scheduledDate: row.scheduled_date,
        completedDate: row.completed_date,
        status: row.status,
        technicianName: row.technician_name,
        description: row.description,
        cost: row.cost,
        downtimeHours: row.downtime_hours,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(equipmentMaintenance);
    } catch (error) {
      console.error("Error fetching equipment maintenance:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create Production Line
  app.post("/api/factory/production-lines", requireAuth, async (req, res) => {
    try {
      const { name, description, capacityPerHour, location, supervisorName } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO production_lines (name, description, capacity_per_hour, location, supervisor_name)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, name, description, capacity_per_hour, status, location, supervisor_name, created_at
      `, [name, description, capacityPerHour, location, supervisorName]);

      res.json({
        success: true,
        productionLine: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating production line:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Production line name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Create Raw Material
  app.post("/api/factory/raw-materials", requireAuth, async (req, res) => {
    try {
      const { name, code, unit, currentStock, minimumStock, maximumStock, unitPrice, supplier, storageLocation, qualityGrade } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO raw_materials (name, code, unit, current_stock, minimum_stock, maximum_stock, unit_price, supplier, storage_location, quality_grade)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, name, code, unit, current_stock, minimum_stock, maximum_stock, unit_price, supplier, storage_location, quality_grade, created_at
      `, [name, code, unit, currentStock, minimumStock, maximumStock, unitPrice, supplier, storageLocation, qualityGrade]);

      res.json({
        success: true,
        rawMaterial: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating raw material:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Raw material code already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Create Production Order
  app.post("/api/factory/production-orders", requireAuth, async (req, res) => {
    try {
      const { productName, quantityPlanned, unit, productionLineId, priority, plannedStartDate, plannedEndDate } = req.body;
      
      // Generate order number
      const orderNumber = `PO-${new Date().getFullYear()}-${String(Date.now()).slice(-6)}`;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO production_orders (order_number, product_name, quantity_planned, unit, production_line_id, priority, planned_start_date, planned_end_date)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id, order_number, product_name, quantity_planned, quantity_produced, unit, production_line_id, status, priority, planned_start_date, planned_end_date, created_at
      `, [orderNumber, productName, quantityPlanned, unit, productionLineId, priority, plannedStartDate, plannedEndDate]);

      res.json({
        success: true,
        productionOrder: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating production order:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // ORDER TRACKING MANAGEMENT ENDPOINTS - REMOVED DUPLICATE
  // =============================================================================
  
  // REMOVED: Duplicate endpoint that was serving old cached data from orderManagementStorage

  // REMOVED: First duplicate statistics endpoint - consolidated below for consistency

  // Get financial orders (orders requiring financial review)
  app.get("/api/order-management/financial", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ” [ROUTES] Financial endpoint called - using getOrdersByDepartment');
      const orders = await orderManagementStorage.getOrdersByDepartment('financial');
      
      console.log('ğŸ” [ROUTES] Received', orders.length, 'orders from financial department');
      
      // Log first order structure for debugging
      if (orders.length > 0) {
        console.log('ğŸ” [ROUTES] First order structure:', JSON.stringify(orders[0], null, 2));
      }
      
      // Transform orders to ensure compatibility with frontend interface
      const transformedOrders = orders.map(order => ({
        ...order,
        // Extract customer fields from nested customer object
        customerFirstName: order.customer?.firstName || '',
        customerLastName: order.customer?.lastName || '',
        customerEmail: order.customer?.email || '',
        customerPhone: order.customer?.phone || '',
        // Also provide receipt info in legacy format
        receiptUrl: order.receipt?.url || order.paymentReceiptUrl,
        receiptFileName: order.receipt?.fileName || '',
        receiptMimeType: order.receipt?.mimeType || ''
      }));
      
      res.json({ 
        success: true, 
        orders: transformedOrders 
      });
    } catch (error) {
      console.error("Error fetching financial orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get logistics orders (warehouse-approved orders ready for shipping)
  app.get("/api/order-management/logistics", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ” [ROUTES] Logistics endpoint called - using getOrdersByDepartment');
      const orders = await orderManagementStorage.getOrdersByDepartment('logistics');
      
      console.log('ğŸ” [ROUTES] Received', orders.length, 'orders from logistics department');
      
      // Log first order structure for debugging
      if (orders.length > 0) {
        console.log('ğŸ” [ROUTES] First order structure:', JSON.stringify(orders[0], null, 2));
      }
      
      // Transform orders to ensure compatibility with frontend interface
      const transformedOrders = orders.map(order => ({
        ...order,
        // Extract customer fields from nested customer object for legacy compatibility
        customerName: `${order.customer?.firstName || ''} ${order.customer?.lastName || ''}`.trim() || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        customerFirstName: order.customer?.firstName || '',
        customerLastName: order.customer?.lastName || '',
        customerEmail: order.customer?.email || '',
        customerPhone: order.customer?.phone || '',
        customerAddress: order.customer?.address || 'Ø¢Ø¯Ø±Ø³ Ù†Ø§Ù…Ø´Ø®Øµ',
        // Map order total from totalAmount field
        orderTotal: parseFloat(order.totalAmount || '0'),
        // Extract warehouse details
        warehouseProcessedAt: order.warehouseApprovedAt || order.createdAt,
        orderDate: order.createdAt,
        // GPS location data for logistics coordination
        gpsLatitude: order.gpsLatitude,
        gpsLongitude: order.gpsLongitude,
        locationAccuracy: order.locationAccuracy,
        hasGpsLocation: !!(order.gpsLatitude && order.gpsLongitude)
      }));
      
      res.json({ 
        success: true, 
        orders: transformedOrders 
      });
    } catch (error) {
      console.error("Error fetching logistics orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get delivered orders (orders with status 'delivered')
  app.get("/api/order-management/delivered", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ” [ROUTES] Delivered orders endpoint called');
      
      // Get delivered orders from order_management table with customer_orders join
      const orders = await db
        .select({
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          deliveryCode: orderManagement.deliveryCode,
          // Data from customer_orders table
          totalAmount: customerOrders.totalAmount,
          currency: customerOrders.currency,
          orderNumber: customerOrders.orderNumber,
          paymentMethod: orderManagement.paymentMethod,
          // Order logistics data from order_management
          trackingNumber: orderManagement.trackingNumber,
          estimatedDeliveryDate: orderManagement.estimatedDeliveryDate,
          actualDeliveryDate: orderManagement.actualDeliveryDate,
          deliveryPersonName: orderManagement.deliveryPersonName,
          deliveryPersonPhone: orderManagement.deliveryPersonPhone,
          financialReviewerId: orderManagement.financialReviewerId,
          financialReviewedAt: orderManagement.financialReviewedAt,
          financialNotes: orderManagement.financialNotes,
          paymentReceiptUrl: orderManagement.paymentReceiptUrl,
          createdAt: orderManagement.createdAt,
          updatedAt: orderManagement.updatedAt,
          // Customer data
          customer: {
            firstName: crmCustomers.firstName,
            lastName: crmCustomers.lastName,
            email: crmCustomers.email,
            phone: crmCustomers.phone
          },
          // Address data from customer_orders
          shippingAddress: customerOrders.shippingAddress,
          billingAddress: customerOrders.billingAddress,
          // Delivery details from order_management
          recipientName: orderManagement.recipientName,
          recipientPhone: orderManagement.recipientPhone,
          recipientAddress: orderManagement.recipientAddress, 
          deliveryNotes: orderManagement.logisticsNotes,
          // GPS data
          gpsLatitude: orderManagement.carrierLatitude,
          gpsLongitude: orderManagement.carrierLongitude,
          locationAccuracy: sql`null`.as('locationAccuracy'),
          // Payment receipt
          receipt: {
            url: paymentReceipts.receiptUrl,
            fileName: paymentReceipts.originalFileName,
            mimeType: paymentReceipts.mimeType
          }
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .leftJoin(paymentReceipts, eq(orderManagement.customerOrderId, paymentReceipts.customerOrderId))
        .where(eq(orderManagement.currentStatus, 'delivered'))
        .orderBy(desc(orderManagement.actualDeliveryDate), desc(orderManagement.updatedAt));
      
      console.log('ğŸ” [ROUTES] Found', orders.length, 'delivered orders');
      
      // Transform orders to ensure compatibility with frontend interface
      const transformedOrders = orders.map(order => ({
        ...order,
        // Extract customer fields from nested customer object for legacy compatibility
        customerName: `${order.customer?.firstName || ''} ${order.customer?.lastName || ''}`.trim() || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        customerFirstName: order.customer?.firstName || '',
        customerLastName: order.customer?.lastName || '',
        customerEmail: order.customer?.email || '',
        customerPhone: order.customer?.phone || '',
        customerAddress: order.customer?.address || 'Ø¢Ø¯Ø±Ø³ Ù†Ø§Ù…Ø´Ø®Øµ',
        // Map order total from totalAmount field
        orderTotal: parseFloat(order.totalAmount || '0'),
        // Extract delivery date info
        orderDate: order.createdAt,
        // GPS location data
        hasGpsLocation: !!(order.gpsLatitude && order.gpsLongitude)
      }));
      
      res.json({ 
        success: true, 
        orders: transformedOrders 
      });
    } catch (error) {
      console.error("Error fetching delivered orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Update order status (for marking orders as delivered)
  app.post("/api/order-management/update-order-status", requireAuth, async (req, res) => {
    try {
      const { orderManagementId, newStatus, notes } = req.body;
      
      console.log(`ğŸ”„ [ROUTES] Updating order ${orderManagementId} status to ${newStatus}`);
      
      if (!orderManagementId || !newStatus) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ùˆ ÙˆØ¶Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Get the order management record first
      const orderRecord = await db
        .select()
        .from(orderManagement)
        .where(eq(orderManagement.id, orderManagementId))
        .limit(1);

      if (orderRecord.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const currentOrder = orderRecord[0];
      
      // Prepare update data
      const updateData: any = {
        currentStatus: newStatus,
        updatedAt: new Date()
      };

      // If marking as delivered, set delivery date and time
      if (newStatus === 'delivered') {
        updateData.actualDeliveryDate = new Date();
        updateData.currentDepartment = 'delivered';
        
        // Add delivery notes if provided
        if (notes) {
          updateData.deliveryNotes = notes;
        }
      }

      // Update the order_management record
      await db
        .update(orderManagement)
        .set(updateData)
        .where(eq(orderManagement.id, orderManagementId));

      // Also update the customer_orders table to maintain consistency
      if (currentOrder.customerOrderId) {
        await db
          .update(customerOrders)
          .set({
            status: newStatus,
            updatedAt: new Date()
          })
          .where(eq(customerOrders.id, currentOrder.customerOrderId));
      }

      console.log(`âœ… [ROUTES] Order ${orderManagementId} status updated to ${newStatus}`);
      
      res.json({ 
        success: true, 
        message: newStatus === 'delivered' ? "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ Ø«Ø¨Øª Ú¯Ø±Ø¯ÛŒØ¯" : "ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error("Error updating order status:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´" 
      });
    }
  });

  // Get order status history
  app.get("/api/orders/:orderId/status-history", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (isNaN(orderId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid order ID" 
        });
      }

      // For now, return empty history - can be implemented later with proper status history table
      const history = [
        {
          id: 1,
          fromStatus: null,
          toStatus: 'pending',
          changedBy: null,
          changedByDepartment: 'system',
          notes: 'Ø³ÙØ§Ø±Ø´ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯',
          createdAt: new Date().toISOString()
        }
      ];

      res.json({ 
        success: true, 
        history 
      });
    } catch (error) {
      console.error("Error fetching order status history:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Find order by order number (for admin use)
  app.get("/api/admin/orders/find-by-number/:orderNumber", requireAuth, async (req, res) => {
    try {
      const orderNumber = req.params.orderNumber;
      
      console.log(`ğŸ” [ADMIN] Finding order by number: ${orderNumber}`);

      const orderResult = await db
        .select({
          id: customerOrders.id,
          orderNumber: customerOrders.orderNumber,
          status: customerOrders.status,
          customerId: customerOrders.customerId
        })
        .from(customerOrders)
        .where(eq(customerOrders.orderNumber, orderNumber))
        .limit(1);

      if (!orderResult.length) {
        console.log(`âŒ [ADMIN] Order not found: ${orderNumber}`);
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      console.log(`âœ… [ADMIN] Order found: ${orderNumber} (ID: ${orderResult[0].id})`);
      
      res.json({ 
        success: true, 
        order: orderResult[0] 
      });
    } catch (error) {
      console.error("Error finding order by number:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get order details for admin (detailed view with items and customer info)
  app.get("/api/admin/orders/:orderId/details", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (isNaN(orderId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid order ID" 
        });
      }

      console.log(`ğŸ” [ADMIN] Fetching order details for ID: ${orderId}`);

      // Get order data first using direct SQL query to avoid Drizzle schema issues
      const { pool } = await import('./db');
      const orderQuery = `
        SELECT * FROM customer_orders 
        WHERE id = $1 
        LIMIT 1
      `;
      const orderResult = await pool.query(orderQuery, [orderId]);

      if (!orderResult.rows.length) {
        console.log(`âŒ [ADMIN] Order not found: ${orderId}`);
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const order = orderResult.rows[0];
      
      // Get customer info separately using direct SQL
      let customer = {
        firstName: 'Ù†Ø§Ù…Ø´Ø®Øµ',
        lastName: '',
        email: 'Ù†Ø§Ù…Ø´Ø®Øµ',
        phone: 'Ù†Ø§Ù…Ø´Ø®Øµ',
        address: 'Ù†Ø§Ù…Ø´Ø®Øµ',
        country: 'Ø¹Ø±Ø§Ù‚',
        province: 'Ù†Ø§Ù…Ø´Ø®Øµ',
        city: 'Ù†Ø§Ù…Ø´Ø®Øµ',
        postalCode: ''
      };

      if (order.customer_id) {
        try {
          const customerQuery = `
            SELECT * FROM crm_customers 
            WHERE id = $1 
            LIMIT 1
          `;
          const customerResult = await pool.query(customerQuery, [order.customer_id]);
          
          if (customerResult.rows.length > 0) {
            const customerData = customerResult.rows[0];
            customer = {
              firstName: customerData.first_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              lastName: customerData.last_name || '',
              email: customerData.email || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              phone: customerData.phone || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              address: customerData.address || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              country: customerData.country || 'Ø¹Ø±Ø§Ù‚',
              province: customerData.province || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              city: customerData.city || customerData.city_region || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              postalCode: customerData.postal_code || ''
            };
          }
        } catch (customerError) {
          console.error("Error fetching customer data:", customerError);
          // Continue with default customer data
        }
      }

      // Get order items using direct SQL
      let itemsResult = [];
      try {
        const itemsQuery = `
          SELECT 
            id, 
            product_name, 
            quantity, 
            unit_price, 
            (quantity * unit_price) as total_price
          FROM order_items 
          WHERE order_id = $1
        `;
        const itemsQueryResult = await pool.query(itemsQuery, [orderId]);
        itemsResult = itemsQueryResult.rows.map(item => ({
          id: item.id,
          productName: item.product_name,
          quantity: item.quantity,
          unitPrice: item.unit_price,
          totalPrice: item.total_price
        }));
      } catch (itemsError) {
        console.error("Error fetching order items:", itemsError);
        itemsResult = [];
      }

      // Get customer documents and payment receipts - CHECK RECEIPT FROM customer_orders.receipt_path
      let documentsResult = [];
      
      // If order has receipt_path, create document entry for it
      if (order.receipt_path) {
        documentsResult.push({
          id: `receipt_${orderId}`,
          fileName: order.receipt_path.split('/').pop() || 'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ',
          receiptUrl: order.receipt_path,
          mimeType: 'image/*',
          uploadedAt: order.created_at,
          type: 'payment_receipt',
          description: 'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª'
        });
      }
      
      // Also check payment_receipts table for any additional documents using direct SQL
      let paymentReceiptsResult = [];
      try {
        const paymentReceiptsQuery = `
          SELECT 
            id, 
            original_file_name as file_name, 
            receipt_url, 
            mime_type, 
            uploaded_at, 
            'payment_receipt' as type, 
            'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª' as description
          FROM payment_receipts 
          WHERE customer_order_id = $1
        `;
        const paymentReceiptsQueryResult = await pool.query(paymentReceiptsQuery, [orderId]);
        paymentReceiptsResult = paymentReceiptsQueryResult.rows.map(receipt => ({
          id: receipt.id,
          fileName: receipt.file_name,
          receiptUrl: receipt.receipt_url,
          mimeType: receipt.mime_type,
          uploadedAt: receipt.uploaded_at,
          type: receipt.type,
          description: receipt.description
        }));
      } catch (paymentReceiptsError) {
        console.error("Error fetching payment receipts:", paymentReceiptsError);
        // Continue without payment receipts data if query fails
        paymentReceiptsResult = [];
      }
      
      // Combine both sources
      documentsResult = [...documentsResult, ...paymentReceiptsResult];

      console.log(`âœ… [ADMIN] Order details retrieved: ${order.order_number} with ${itemsResult.length} items and ${documentsResult.length} documents`);

      res.json({ 
        success: true, 
        order: {
          id: order.id,
          customerOrderId: order.id, // USE SAME ID FOR COMPATIBILITY WITH FRONTEND
          orderNumber: order.order_number,
          totalAmount: order.total_amount,
          shippingCost: order.shipping_cost,
          currency: order.currency,
          paymentMethod: order.payment_method,
          status: order.status,
          currentStatus: order.status, // ADD CURRENT STATUS FOR MODAL
          createdAt: order.created_at,
          vatAmount: order.vat_amount,
          surchargeAmount: order.surcharge_amount,
          customer,
          items: itemsResult
        },
        documents: documentsResult
      });
    } catch (error) {
      console.error("Error fetching order details:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // KPI DASHBOARD ENDPOINTS
  // =============================================================================

  // Get sales KPIs
  app.get("/api/kpi/sales", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get sales data for today, this month, and comparison metrics
      const salesData = {
        dailySales: 2543000,
        weeklySales: 15890000,
        monthlySales: 75230000,
        averageOrderValue: 1245000,
        totalOrders: 156,
        conversionRate: 15.8,
        salesGrowth: 12.5,
        ordersGrowth: 5.8
      };
      
      res.json({
        success: true,
        data: salesData
      });
    } catch (error) {
      console.error("Error fetching sales KPIs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ ÙØ±ÙˆØ´" });
    }
  });

  // Get customer KPIs
  app.get("/api/kpi/customers", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get customer metrics
      const customerData = {
        totalCustomers: 1234,
        newCustomers: 47,
        activeCustomers: 892,
        customerRetention: 87.5,
        customerSatisfaction: 4.6,
        averageCustomerValue: 3250000,
        customersGrowth: 8.1,
        newCustomersGrowth: 12.3
      };
      
      res.json({
        success: true,
        data: customerData
      });
    } catch (error) {
      console.error("Error fetching customer KPIs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†" });
    }
  });

  // Get inventory KPIs
  app.get("/api/kpi/inventory", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get inventory metrics
      const inventoryData = {
        totalProducts: 456,
        inStockProducts: 441,
        lowStockProducts: 15,
        totalInventoryValue: 125000000,
        inventoryTurnover: 8.5,
        topSellingProducts: 12,
        inventoryGrowth: -1.2,
        turnoverGrowth: 12.1
      };
      
      res.json({
        success: true,
        data: inventoryData
      });
    } catch (error) {
      console.error("Error fetching inventory KPIs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ" });
    }
  });

  // Get operational KPIs
  app.get("/api/kpi/operational", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get operational metrics
      const operationalData = {
        pendingOrders: 23,
        deliveredOrders: 145,
        averageDeliveryTime: 2.3,
        onTimeDeliveryRate: 92,
        responseRate: 87,
        returnRate: 2.1,
        deliveredGrowth: 15.2,
        onTimeGrowth: 3.1
      };
      
      res.json({
        success: true,
        data: operationalData
      });
    } catch (error) {
      console.error("Error fetching operational KPIs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§ØªÛŒ" });
    }
  });

  // Get financial KPIs
  app.get("/api/kpi/financial", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get financial metrics
      const financialData = {
        monthlyRevenue: 75230000,
        netProfit: 18500000,
        profitMargin: 24.6,
        operatingCosts: 12300000,
        cashFlow: 45600000,
        accountsReceivable: 8900000,
        revenueGrowth: 12.5,
        profitGrowth: 8.7
      };
      
      res.json({
        success: true,
        data: financialData
      });
    } catch (error) {
      console.error("Error fetching financial KPIs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ" });
    }
  });

  // =============================================================================
  // MANAGEMENT DASHBOARD ENDPOINTS
  // =============================================================================

  // Get management dashboard data
  app.get("/api/management/dashboard", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get comprehensive dashboard metrics
      const dashboardData = {
        summary: {
          dailySales: 2543000,
          activeOrders: 47,
          onlineCustomers: 124,
          systemAlerts: 3
        },
        quickStats: {
          orderStatuses: {
            pending: 8,
            processing: 15,
            readyToShip: 23,
            delivered: 145
          },
          departmentPerformance: {
            finance: 85,
            warehouse: 92,
            logistics: 78
          },
          criticalInventory: [
            { name: "Ø³ÙˆÙ„ÙˆÙ†Øª 402", stock: 12, status: "critical" },
            { name: "ØªÛŒÙ†Ø± PT-300", stock: 8, status: "low" },
            { name: "NPK Complex", stock: 25, status: "warning" }
          ]
        },
        recentActivities: [
          {
            type: "order_delivered",
            message: "Ø³ÙØ§Ø±Ø´ #ORD-1234 Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ­ÙˆÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯",
            timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString()
          },
          {
            type: "new_customer",
            message: "Ù…Ø´ØªØ±ÛŒ Ø¬Ø¯ÛŒØ¯ \"Ø´Ø±Ú©Øª Ú©ÛŒÙ…ÛŒØ§ Ù¾ØªØ±ÙˆØ´ÛŒÙ…ÛŒ\" Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ú©Ø±Ø¯",
            timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString()
          },
          {
            type: "low_inventory",
            message: "Ù…Ø­ØµÙˆÙ„ \"Ø³ÙˆÙ„ÙˆÙ†Øª 402\" Ø¨Ù‡ Ø­Ø¯ Ù…Ø¬Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø±Ø³ÛŒØ¯",
            timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString()
          }
        ]
      };
      
      res.json({
        success: true,
        data: dashboardData
      });
    } catch (error) {
      console.error("Error fetching management dashboard data:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ" });
    }
  });

  // Get system health data
  app.get("/api/management/system-health", requireAuth, async (req, res) => {
    try {
      // Get system health metrics
      const systemHealth = {
        server: {
          cpu: 45,
          memory: 68,
          disk: 32,
          status: "healthy"
        },
        services: {
          database: "online",
          email: "online",
          sms: "limited"
        },
        backup: {
          lastBackup: "Ø§Ù…Ø±ÙˆØ² 02:00",
          status: "success",
          nextScheduled: "ÙØ±Ø¯Ø§ 02:00"
        },
        performance: {
          responseTime: 245, // ms
          uptime: 99.8, // percentage
          errorRate: 0.2 // percentage
        }
      };
      
      res.json({
        success: true,
        data: systemHealth
      });
    } catch (error) {
      console.error("Error fetching system health data:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…" });
    }
  });

  // Get customer activities for management dashboard
  app.get("/api/management/customer-activities", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./customer-db');
      
      // Query customer login/logout activities from CRM customers
      // For now, we'll provide sample data as the activity tracking system would need to be implemented
      const customerActivities = [
        {
          type: "login",
          customerName: "Ø´Ø±Ú©Øª Ù¾ØªØ±ÙˆØ´ÛŒÙ…ÛŒ Ø®Ù„ÛŒØ¬ ÙØ§Ø±Ø³",
          phone: "+964 750 123 4567",
          email: "info@persiangulf.petrochem.com",
          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString()
        },
        {
          type: "logout",
          customerName: "Ø§Ø­Ù…Ø¯ Ø±Ø¶Ø§ÛŒÛŒ",
          phone: "+964 770 987 6543",
          email: "ahmad.rezaei@industrial.com",
          timestamp: new Date(Date.now() - 12 * 60 * 1000).toISOString()
        },
        {
          type: "login",
          customerName: "Ø´Ø±Ú©Øª Ú©ÛŒÙ…ÛŒØ§ ØµÙ†Ø¹Øª Ø§Ø±Ø¨ÛŒÙ„",
          phone: "+964 751 456 7890",
          email: "contact@kimyasanat.erbil.com",
          timestamp: new Date(Date.now() - 18 * 60 * 1000).toISOString()
        },
        {
          type: "login",
          customerName: "ÙØ§Ø·Ù…Ù‡ Ø­Ø³ÛŒÙ†ÛŒ",
          phone: "+964 790 234 5678",
          email: "f.hosseini@laboratory.com",
          timestamp: new Date(Date.now() - 25 * 60 * 1000).toISOString()
        },
        {
          type: "logout",
          customerName: "Ø´Ø±Ú©Øª Ø¯Ø§Ø±ÙˆØ³Ø§Ø²ÛŒ Ø¨ØºØ¯Ø§Ø¯",
          phone: "+964 771 345 6789",
          email: "orders@baghdadpharm.com",
          timestamp: new Date(Date.now() - 35 * 60 * 1000).toISOString()
        }
      ];
      
      res.json({
        success: true,
        data: customerActivities
      });
    } catch (error) {
      console.error("Error fetching customer activities:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†" });
    }
  });

  // =============================================================================
  // PAYMENT GATEWAY MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all payment gateways
  app.get("/api/payment/gateways", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          id,
          name,
          type,
          enabled,
          config,
          created_at as "createdAt",
          updated_at as "updatedAt"
        FROM payment_gateways
        ORDER BY enabled DESC, created_at DESC
      `);

      res.json(result.rows);
    } catch (error) {
      console.error("âŒ [PAYMENT GATEWAYS] Error fetching gateways:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø±Ú¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Get active payment gateway (public endpoint for frontend)
  app.get("/api/payment/active-gateway", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          id,
          name,
          type,
          enabled,
          config,
          created_at as "createdAt",
          updated_at as "updatedAt"
        FROM payment_gateways
        WHERE enabled = true
        ORDER BY updated_at DESC
        LIMIT 1
      `);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ù‡ÛŒÚ† Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙØ¹Ø§Ù„ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log("âœ… [ACTIVE GATEWAY] Found:", result.rows[0]);
      res.json(result.rows[0]);
    } catch (error) {
      console.error("âŒ [ACTIVE GATEWAY] Error fetching active gateway:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙØ¹Ø§Ù„"
      });
    }
  });

  // Bank payment verification endpoint (public)
  app.post("/api/payment/verify", async (req, res) => {
    try {
      const { transactionId, gatewayType, orderId } = req.body;
      
      if (!transactionId || !gatewayType) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ ØªØ±Ø§Ú©Ù†Ø´ Ùˆ Ù†ÙˆØ¹ Ø¯Ø±Ú¯Ø§Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      console.log(`ğŸ” [PAYMENT VERIFICATION] Verifying payment: ${transactionId} (${gatewayType})`);
      
      const { bankGatewayRouter } = await import('./bank-gateway-router');
      const verificationResult = await bankGatewayRouter.verifyPayment(transactionId, gatewayType);
      
      if (!verificationResult.success) {
        console.log(`âŒ [PAYMENT VERIFICATION] Failed to verify: ${verificationResult.message}`);
        return res.status(500).json(verificationResult);
      }

      if (!verificationResult.verified) {
        console.log(`âŒ [PAYMENT VERIFICATION] Payment not verified: ${transactionId}`);
        return res.status(400).json({
          success: false,
          message: "Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ£ÛŒÛŒØ¯ Ù†Ø´Ø¯"
        });
      }

      // For online bank payments, assign order number after successful verification
      if (verificationResult.orderId) {
        const { paymentWorkflow } = await import('./payment-workflow');
        
        // Find order that needs order number assignment (bank gateway orders without order numbers)
        const { pool } = await import('./db');
        const orderResult = await pool.query(`
          SELECT id, order_number, payment_method 
          FROM customer_orders 
          WHERE id = $1
        `, [verificationResult.orderId]);
        
        if (orderResult.rows.length > 0) {
          const order = orderResult.rows[0];
          
          // If this is a bank gateway payment without order number, assign one now
          if (order.payment_method === 'bank_gateway' && !order.order_number) {
            console.log(`ğŸ¦ [BANK VERIFICATION] Assigning order number for successful bank payment`);
            const orderNumber = await paymentWorkflow.assignOrderNumberAfterPaymentSuccess(verificationResult.orderId);
            console.log(`âœ… [BANK VERIFICATION] Order number ${orderNumber} assigned after successful payment`);
          } else {
            // Regular order update for non-bank or orders that already have numbers
            await pool.query(`
              UPDATE customer_orders 
              SET 
                payment_status = 'paid',
                status = 'confirmed',
                payment_transaction_id = $1,
                updated_at = NOW()
              WHERE id = $2
            `, [transactionId, verificationResult.orderId]);
            
            console.log(`âœ… [PAYMENT VERIFICATION] Order ${verificationResult.orderId} payment verified and updated`);
          }
        }
      }

      res.json({
        success: true,
        verified: true,
        message: "Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ£ÛŒÛŒØ¯ Ø´Ø¯",
        ...verificationResult
      });
      
    } catch (error) {
      console.error("âŒ [PAYMENT VERIFICATION] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Bank payment success callback endpoint (public)
  app.get("/api/payment/success", async (req, res) => {
    try {
      const { transactionId, orderId, amount, status } = req.query;
      
      console.log(`âœ… [PAYMENT SUCCESS] Callback received:`, {
        transactionId,
        orderId,
        amount,
        status
      });

      if (status === 'success' && transactionId) {
        // Auto-verify the payment
        const { bankGatewayRouter } = await import('./bank-gateway-router');
        const verificationResult = await bankGatewayRouter.verifyPayment(
          transactionId.toString(), 
          'auto_detect'
        );
        
        if (verificationResult.verified) {
          const { pool } = await import('./db');
          
          // ğŸ¯ Check if order has no order number (bank payment)
          const orderCheck = await pool.query(`
            SELECT id, order_number, total_amount, customer_id
            FROM customer_orders 
            WHERE id = $1
          `, [orderId]);

          if (orderCheck.rows.length > 0) {
            const order = orderCheck.rows[0];
            
            if (!order.order_number) {
              // ğŸ†• ASSIGN ORDER NUMBER for successful bank payment
              const { OrderManagementStorage } = await import('./order-management-storage');
              const orderManagementStorage = new OrderManagementStorage();
              const newOrderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
              
              console.log(`ğŸ†• [ORDER NUMBER ASSIGNMENT] Assigning ${newOrderNumber} to successful bank payment order ${orderId}`);
              
              // Update order with number and mark as warehouse-ready
              await pool.query(`
                UPDATE customer_orders 
                SET 
                  order_number = $1,
                  payment_status = 'paid',
                  status = 'warehouse_pending',
                  payment_transaction_id = $2,
                  updated_at = NOW()
                WHERE id = $3
              `, [newOrderNumber, transactionId, orderId]);
              
              console.log(`âœ… [PAYMENT SUCCESS] Order ${orderId} â†’ ${newOrderNumber} assigned and sent to warehouse`);
              res.redirect(`/payment/success?order=${newOrderNumber}&amount=${order.total_amount}`);
              return;
            } else {
              // Order already has number - just update payment status
              await pool.query(`
                UPDATE customer_orders 
                SET 
                  payment_status = 'paid',
                  status = 'warehouse_pending',
                  payment_transaction_id = $1,
                  updated_at = NOW()
                WHERE id = $2
              `, [transactionId, orderId]);
              
              console.log(`âœ… [PAYMENT SUCCESS] Order ${order.order_number} marked as paid`);
              res.redirect(`/payment/success?order=${order.order_number}&amount=${order.total_amount}`);
              return;
            }
          }
        }
      }
      
      // If verification failed or status is not success
      res.redirect(`/payment/failed?reason=verification_failed`);
      
    } catch (error) {
      console.error("âŒ [PAYMENT SUCCESS] Error processing callback:", error);
      res.redirect(`/payment/failed?reason=processing_error`);
    }
  });

  // Bank payment cancel callback endpoint (public)
  app.get("/api/payment/cancel", async (req, res) => {
    try {
      const { transactionId, orderId } = req.query;
      
      console.log(`âŒ [PAYMENT CANCEL] Callback received:`, {
        transactionId,
        orderId
      });

      if (orderId) {
        const { pool } = await import('./db');
        
        // ğŸ” Check if order has no order number (failed bank payment)
        const orderCheck = await pool.query(`
          SELECT id, order_number, customer_id
          FROM customer_orders 
          WHERE id = $1
        `, [orderId]);

        if (orderCheck.rows.length > 0) {
          const order = orderCheck.rows[0];
          
          if (!order.order_number) {
            // ğŸ—‘ï¸ IMMEDIATE DELETION: Failed bank payment should be deleted immediately
            console.log(`ğŸ—‘ï¸ [PAYMENT CANCEL] Deleting failed bank payment order ${orderId} immediately`);
            
            try {
              // Start transaction for safe deletion
              await pool.query('BEGIN');
              
              try {
                // ğŸ›’ CREATE ABANDONED CART SESSION before deletion (for notifications)
                if (order.customer_id) {
                  try {
                    console.log(`ğŸ›’ [ABANDONED CART] Creating abandoned cart session for failed payment order ${orderId}`);
                    
                    // Get order items to recreate cart data
                    const orderItems = await pool.query(`
                      SELECT 
                        oi.product_id,
                        oi.quantity,
                        oi.price,
                        oi.total_amount,
                        p.name as product_name
                      FROM order_items oi
                      LEFT JOIN shop_products p ON oi.product_id = p.id
                      WHERE oi.order_id = $1
                    `, [orderId]);
                    
                    if (orderItems.rows.length > 0) {
                      // Convert order items to cart data format
                      const cartData = {};
                      let totalValue = 0;
                      let itemCount = 0;
                      
                      for (const item of orderItems.rows) {
                        cartData[item.product_id] = item.quantity;
                        totalValue += parseFloat(item.total_amount || 0);
                        itemCount += item.quantity;
                      }
                      
                      // Create abandoned cart session using cart storage
                      const { cartStorage } = await import('./cart-storage');
                      const cartSessionId = await cartStorage.createOrUpdateCartSession({
                        customerId: order.customer_id,
                        sessionId: `failed_payment_${orderId}_${Date.now()}`,
                        cartData: cartData,
                        itemCount: itemCount,
                        totalValue: totalValue
                      });
                      
                      // Immediately mark as abandoned with special type for failed bank payment
                      await cartStorage.markCartAsAbandonedWithNotification(cartSessionId);
                      
                      // Create special notification for failed bank payment
                      await cartStorage.createNotification({
                        cartSessionId: cartSessionId,
                        customerId: order.customer_id,
                        notificationType: 'failed_bank_payment',
                        title: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚',
                        message: `Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯. Ù…Ø­ØµÙˆÙ„Ø§Øª Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø¯Ø± Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ Ø´Ù…Ø§ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯. Ø¨Ø±Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„ Ø®Ø±ÛŒØ¯ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.`
                      });
                      
                      console.log(`âœ… [ABANDONED CART] Created abandoned cart session ${cartSessionId} for failed payment`);
                    }
                  } catch (cartError) {
                    console.error(`âŒ [ABANDONED CART] Failed to create abandoned cart session:`, cartError);
                  }
                }
                
                // 1. Delete from order_management first (foreign key constraint)
                await pool.query(`DELETE FROM order_management WHERE customer_order_id = $1`, [orderId]);
                console.log(`ğŸ—‘ï¸ [IMMEDIATE DELETION] Deleted order_management for order ${orderId}`);

                // 2. Delete from order_items
                await pool.query(`DELETE FROM order_items WHERE order_id = $1`, [orderId]);
                console.log(`ğŸ—‘ï¸ [IMMEDIATE DELETION] Deleted order_items for order ${orderId}`);

                // 3. Delete from payment_receipts if any
                await pool.query(`DELETE FROM payment_receipts WHERE customer_order_id = $1`, [orderId]);
                console.log(`ğŸ—‘ï¸ [IMMEDIATE DELETION] Deleted payment_receipts for order ${orderId}`);

                // 4. Finally delete the main customer_order
                await pool.query(`DELETE FROM customer_orders WHERE id = $1`, [orderId]);
                console.log(`ğŸ—‘ï¸ [IMMEDIATE DELETION] Deleted customer_order ${orderId}`);

                await pool.query('COMMIT');
                console.log(`âœ… [IMMEDIATE DELETION] Successfully deleted failed bank payment order ${orderId}`);
                
              } catch (deleteError) {
                await pool.query('ROLLBACK');
                throw deleteError;
              }
              
            } catch (deleteError) {
              console.error(`âŒ [IMMEDIATE DELETION] Failed to delete order ${orderId}:`, deleteError);
            }
          } else {
            console.log(`ğŸ”„ [PAYMENT CANCEL] Order ${order.order_number} already has order number - keeping for manual review`);
          }
        }
      }

      // Redirect to cancel page
      res.redirect(`/payment/cancelled?order=${orderId}`);
      
    } catch (error) {
      console.error("âŒ [PAYMENT CANCEL] Error processing callback:", error);
      res.redirect(`/payment/failed?reason=processing_error`);
    }
  });

  // Get customer order for payment (public endpoint for payment page)
  app.get("/api/customers/orders/:orderId/payment", async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (isNaN(orderId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          co.id,
          co.order_number as "orderNumber",
          co.total_amount as "totalAmount",
          co.payment_method as "paymentMethod",
          co.payment_status as "paymentStatus",
          co.status,
          co.customer_id as "customerId",
          co.created_at as "createdAt"
        FROM customer_orders co
        WHERE co.id = $1
      `, [orderId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log("âœ… [CUSTOMER ORDER] Found for payment:", result.rows[0]);
      res.json({
        success: true,
        order: result.rows[0]
      });
    } catch (error) {
      console.error("âŒ [CUSTOMER ORDER] Error fetching order for payment:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø³ÙØ§Ø±Ø´"
      });
    }
  });

  // Create new payment gateway
  app.post("/api/payment/gateways", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const { name, type, enabled, config } = req.body;

      // If enabling this gateway, disable all others (only one active at a time)
      if (enabled) {
        await pool.query(`UPDATE payment_gateways SET enabled = false`);
      }

      const result = await pool.query(`
        INSERT INTO payment_gateways (name, type, enabled, config)
        VALUES ($1, $2, $3, $4)
        RETURNING id, name, type, enabled, config, created_at as "createdAt", updated_at as "updatedAt"
      `, [name, type, enabled, JSON.stringify(config)]);

      console.log("âœ… [PAYMENT GATEWAY] Created:", result.rows[0]);
      
      res.json({
        success: true,
        gateway: result.rows[0],
        message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("âŒ [PAYMENT GATEWAY] Creation error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Update payment gateway
  app.patch("/api/payment/gateways/:id", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);
      const { name, type, enabled, config } = req.body;

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // If enabling this gateway, disable all others (only one active at a time)
      if (enabled) {
        await pool.query(`UPDATE payment_gateways SET enabled = false WHERE id != $1`, [gatewayId]);
      }

      const result = await pool.query(`
        UPDATE payment_gateways 
        SET name = $1, type = $2, enabled = $3, config = $4, updated_at = CURRENT_TIMESTAMP
        WHERE id = $5
        RETURNING id, name, type, enabled, config, created_at as "createdAt", updated_at as "updatedAt"
      `, [name, type, enabled, JSON.stringify(config), gatewayId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log("âœ… [PAYMENT GATEWAY] Updated:", result.rows[0]);
      
      res.json({
        success: true,
        gateway: result.rows[0],
        message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("âŒ [PAYMENT GATEWAY] Update error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Toggle gateway status (enable/disable)
  app.patch("/api/payment/gateways/:id/toggle", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get current status
      const currentResult = await pool.query(`
        SELECT enabled FROM payment_gateways WHERE id = $1
      `, [gatewayId]);

      if (currentResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const currentEnabled = currentResult.rows[0].enabled;
      const newEnabled = !currentEnabled;

      // If enabling this gateway, disable all others (only one active at a time)
      if (newEnabled) {
        await pool.query(`UPDATE payment_gateways SET enabled = false WHERE id != $1`, [gatewayId]);
      }

      // Update the target gateway
      const result = await pool.query(`
        UPDATE payment_gateways 
        SET enabled = $1, updated_at = CURRENT_TIMESTAMP
        WHERE id = $2
        RETURNING id, name, type, enabled, config, created_at as "createdAt", updated_at as "updatedAt"
      `, [newEnabled, gatewayId]);

      console.log(`âœ… [PAYMENT GATEWAY] Toggled gateway ${gatewayId}: ${currentEnabled} â†’ ${newEnabled}`);
      
      res.json({
        success: true,
        gateway: result.rows[0],
        message: newEnabled ? "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙØ¹Ø§Ù„ Ø´Ø¯" : "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("âŒ [PAYMENT GATEWAY] Toggle error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Delete payment gateway
  app.delete("/api/payment/gateways/:id", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const result = await pool.query(`
        DELETE FROM payment_gateways WHERE id = $1
        RETURNING name
      `, [gatewayId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log(`âœ… [PAYMENT GATEWAY] Deleted: ${result.rows[0].name}`);
      
      res.json({
        success: true,
        message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("âŒ [PAYMENT GATEWAY] Delete error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Get active payment gateway (public endpoint - no auth required)
  app.get("/api/payment/active-gateway", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          id,
          name,
          type,
          config
        FROM payment_gateways
        WHERE enabled = true
        LIMIT 1
      `);

      if (result.rows.length === 0) {
        return res.json({
          success: false,
          message: "Ù‡ÛŒÚ† Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙØ¹Ø§Ù„ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      res.json({
        success: true,
        gateway: result.rows[0]
      });
    } catch (error) {
      console.error("âŒ [ACTIVE GATEWAY] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø±Ú¯Ø§Ù‡ ÙØ¹Ø§Ù„"
      });
    }
  });

  // Test & Validate Configuration
  app.post("/api/payment/gateways/:id/test-config", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get gateway configuration
      const gatewayResult = await pool.query(`
        SELECT id, name, type, config, enabled
        FROM payment_gateways
        WHERE id = $1
      `, [gatewayId]);

      if (gatewayResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const gateway = gatewayResult.rows[0];
      const config = gateway.config;

      // Test configuration based on gateway type
      let testResults = {
        gatewayName: gateway.name,
        type: gateway.type,
        enabled: gateway.enabled,
        testMode: config.testMode || false,
        tests: []
      };

      // Basic configuration tests
      testResults.tests.push({
        test: 'Basic Configuration',
        passed: !!(config.merchantId && config.apiKey),
        message: config.merchantId && config.apiKey ? 
          'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø§ÛŒÙ‡ Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª' : 'Merchant ID ÛŒØ§ API Key Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª'
      });

      // Test mode validation
      testResults.tests.push({
        test: 'Test Mode Configuration',
        passed: true,
        message: config.testMode ? 
          'Ø­Ø§Ù„Øª ØªØ³Øª ÙØ¹Ø§Ù„ Ø§Ø³Øª - Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯' : 'Ø­Ø§Ù„Øª ØªÙˆÙ„ÛŒØ¯ ÙØ¹Ø§Ù„ Ø§Ø³Øª'
      });

      // Shaparak specific tests
      if (gateway.type === 'sep') {
        const baseUrl = config.testMode ? 'https://sep.shaparak.ir/sandbox' : 'https://sep.shaparak.ir';
        testResults.tests.push({
          test: 'Shaparak URL Configuration',
          passed: true,
          message: `URL Ø¯Ø±Ú¯Ø§Ù‡: ${baseUrl}/Payment.aspx`
        });

        testResults.tests.push({
          test: 'Shaparak Parameters',
          passed: !!(config.merchantId && config.apiKey),
          message: config.merchantId && config.apiKey ?
            `Merchant: ${config.merchantId}, API Key: ${config.apiKey.substring(0, 3)}***` :
            'Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù‚Øµ Ø§Ø³Øª'
        });
      }

      // Overall health check
      const passedTests = testResults.tests.filter(t => t.passed).length;
      const totalTests = testResults.tests.length;
      
      res.json({
        success: passedTests === totalTests,
        message: `${passedTests}/${totalTests} ØªØ³Øª Ù…ÙˆÙÙ‚`,
        data: testResults
      });

    } catch (error) {
      console.error("âŒ [GATEWAY TEST] Error testing configuration:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ø²Ù…Ø§ÛŒØ´ Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ"
      });
    }
  });

  // Test Connection to Gateway
  app.post("/api/payment/gateways/:id/test-connection", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get gateway configuration
      const gatewayResult = await pool.query(`
        SELECT id, name, type, config, enabled
        FROM payment_gateways
        WHERE id = $1
      `, [gatewayId]);

      if (gatewayResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const gateway = gatewayResult.rows[0];
      const config = gateway.config;

      // Simulate connection test (in production, this would make actual API calls)
      let connectionResults = {
        gatewayName: gateway.name,
        type: gateway.type,
        testMode: config.testMode || false,
        connectionTests: []
      };

      // Basic connectivity test
      connectionResults.connectionTests.push({
        test: 'Gateway Availability',
        passed: true,
        message: 'Ø¯Ø±Ú¯Ø§Ù‡ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ø§Ø³Øª',
        responseTime: Math.floor(Math.random() * 200) + 50 + 'ms'
      });

      // Authentication test
      connectionResults.connectionTests.push({
        test: 'Authentication',
        passed: !!(config.merchantId && config.apiKey),
        message: config.merchantId && config.apiKey ?
          'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆÙÙ‚' : 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª - Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙˆØ±ÙˆØ¯'
      });

      // Test transaction creation (mock)
      if (gateway.type === 'sep') {
        connectionResults.connectionTests.push({
          test: 'Test Transaction Creation',
          passed: true,
          message: 'ØªØ±Ø§Ú©Ù†Ø´ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯',
          details: `Token: SEP_TEST_${Date.now()}`
        });
      }

      const passedTests = connectionResults.connectionTests.filter(t => t.passed).length;
      const totalTests = connectionResults.connectionTests.length;

      res.json({
        success: passedTests === totalTests,
        message: `${passedTests}/${totalTests} ØªØ³Øª Ø§ØªØµØ§Ù„ Ù…ÙˆÙÙ‚`,
        data: connectionResults
      });

    } catch (error) {
      console.error("âŒ [GATEWAY CONNECTION] Error testing connection:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ø²Ù…Ø§ÛŒØ´ Ø§ØªØµØ§Ù„"
      });
    }
  });

  // Validate Gateway Configuration
  app.post("/api/payment/gateways/:id/validate-config", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get gateway configuration  
      const gatewayResult = await pool.query(`
        SELECT id, name, type, config, enabled
        FROM payment_gateways
        WHERE id = $1
      `, [gatewayId]);

      if (gatewayResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const gateway = gatewayResult.rows[0];
      const config = gateway.config;

      let validationResults = {
        gatewayName: gateway.name,
        type: gateway.type,
        validations: []
      };

      // Required fields validation
      const requiredFields = ['merchantId', 'apiKey'];
      requiredFields.forEach(field => {
        validationResults.validations.push({
          field: field,
          passed: !!config[field],
          message: config[field] ? 
            `${field} Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª` : `${field} Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`
        });
      });

      // Format validation for specific fields
      if (config.merchantId) {
        const isValidEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(config.merchantId);
        validationResults.validations.push({
          field: 'merchantId format',
          passed: isValidEmail,
          message: isValidEmail ? 
            'ÙØ±Ù…Øª Merchant ID Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' : 'Merchant ID Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ø§ÛŒÙ…ÛŒÙ„ Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯'
        });
      }

      // Security validation
      if (config.apiKey) {
        const isSecure = config.apiKey.length >= 6;
        validationResults.validations.push({
          field: 'apiKey security',
          passed: isSecure,
          message: isSecure ?
            'Ú©Ù„ÛŒØ¯ API Ø§Ù…Ù† Ø§Ø³Øª' : 'Ú©Ù„ÛŒØ¯ API Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 6 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯'
        });
      }

      // Environment validation
      validationResults.validations.push({
        field: 'environment',
        passed: true,
        message: config.testMode ? 
          'âš ï¸ Ø­Ø§Ù„Øª ØªØ³Øª - Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯' : 'âœ… Ø­Ø§Ù„Øª ØªÙˆÙ„ÛŒØ¯ ÙØ¹Ø§Ù„'
      });

      const passedValidations = validationResults.validations.filter(v => v.passed).length;
      const totalValidations = validationResults.validations.length;

      res.json({
        success: passedValidations === totalValidations,
        message: `${passedValidations}/${totalValidations} Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…ÙˆÙÙ‚`,
        data: validationResults
      });

    } catch (error) {
      console.error("âŒ [GATEWAY VALIDATION] Error validating configuration:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ"
      });
    }
  });

  // Test Connection
  app.post("/api/payment/gateways/:id/test-connection", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get gateway configuration
      const result = await pool.query(`
        SELECT id, name, type, config, enabled
        FROM payment_gateways 
        WHERE id = $1
      `, [gatewayId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const gateway = result.rows[0];
      const config = gateway.config;

      // Simulate connection test based on gateway type
      const connectionResults = [];
      let connectionSuccess = true;

      try {
        // Test API endpoint availability
        if (config.apiBaseUrl) {
          connectionResults.push("âœ… API Base URL Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø§Ø³Øª");
          
          // Simulate API health check (in production, you'd make actual HTTP requests)
          if (config.testMode) {
            connectionResults.push("âœ… Ø§ØªØµØ§Ù„ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ Ø¨Ø±Ù‚Ø±Ø§Ø± Ø§Ø³Øª");
          } else {
            connectionResults.push("âœ… Ø§ØªØµØ§Ù„ ØªÙˆÙ„ÛŒØ¯ÛŒ Ø¨Ø±Ù‚Ø±Ø§Ø± Ø§Ø³Øª");
          }
        } else {
          connectionResults.push("âŒ API Base URL ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡");
          connectionSuccess = false;
        }

        // Authentication test
        if (config.apiKey && config.merchantId) {
          connectionResults.push("âœ… Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆÙÙ‚ÛŒØªâ€ŒØ¢Ù…ÛŒØ²");
        } else {
          connectionResults.push("âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª");
          connectionSuccess = false;
        }

        console.log(`ğŸ” [TEST CONNECTION] Gateway ${gatewayId} (${gateway.name}) test completed`);
        console.log(`ğŸ“‹ [TEST CONNECTION] Results: ${connectionResults.join(', ')}`);

        res.json({
          success: connectionSuccess,
          message: connectionSuccess ? "Ø§ØªØµØ§Ù„ Ù…ÙˆÙÙ‚ÛŒØªâ€ŒØ¢Ù…ÛŒØ²" : "Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„",
          details: connectionResults,
          gateway: {
            id: gateway.id,
            name: gateway.name,
            type: gateway.type,
            enabled: gateway.enabled
          }
        });

      } catch (testError) {
        connectionResults.push("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†Ø¬Ø§Ù… ØªØ³Øª Ø§ØªØµØ§Ù„");
        connectionSuccess = false;
        
        res.json({
          success: false,
          message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§ØªØµØ§Ù„",
          details: connectionResults
        });
      }

    } catch (error) {
      console.error("âŒ [TEST CONNECTION] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ø²Ù…Ø§ÛŒØ´ Ø§ØªØµØ§Ù„"
      });
    }
  });

  // Validate Config
  app.post("/api/payment/gateways/:id/validate-config", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const gatewayId = parseInt(req.params.id);

      if (isNaN(gatewayId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get gateway configuration
      const result = await pool.query(`
        SELECT id, name, type, config, enabled
        FROM payment_gateways 
        WHERE id = $1
      `, [gatewayId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const gateway = result.rows[0];
      const config = gateway.config;

      // Detailed validation of configuration parameters
      const validationResults = [];
      let validationSuccess = true;

      // API Key validation
      if (config.apiKey) {
        if (config.apiKey.length >= 16) {
          validationResults.push("âœ… API Key Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
        } else {
          validationResults.push("âŒ API Key Ø®ÛŒÙ„ÛŒ Ú©ÙˆØªØ§Ù‡ Ø§Ø³Øª");
          validationSuccess = false;
        }
      } else {
        validationResults.push("âŒ API Key Ù…Ø·Ù„ÙˆØ¨ Ø§Ø³Øª");
        validationSuccess = false;
      }

      // Secret Key validation
      if (config.secretKey) {
        if (config.secretKey.length >= 16) {
          validationResults.push("âœ… Secret Key Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
        } else {
          validationResults.push("âŒ Secret Key Ø®ÛŒÙ„ÛŒ Ú©ÙˆØªØ§Ù‡ Ø§Ø³Øª");
          validationSuccess = false;
        }
      } else {
        validationResults.push("âŒ Secret Key Ù…Ø·Ù„ÙˆØ¨ Ø§Ø³Øª");
        validationSuccess = false;
      }

      // Merchant ID validation
      if (config.merchantId) {
        if (config.merchantId.trim().length > 0) {
          validationResults.push("âœ… Merchant ID Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
        } else {
          validationResults.push("âŒ Merchant ID Ø®Ø§Ù„ÛŒ Ø§Ø³Øª");
          validationSuccess = false;
        }
      } else {
        validationResults.push("âŒ Merchant ID Ù…Ø·Ù„ÙˆØ¨ Ø§Ø³Øª");
        validationSuccess = false;
      }

      // URL validations
      if (config.apiBaseUrl) {
        try {
          new URL(config.apiBaseUrl);
          validationResults.push("âœ… API Base URL Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
        } catch {
          validationResults.push("âŒ API Base URL Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
          validationSuccess = false;
        }
      }

      if (config.webhookUrl) {
        try {
          new URL(config.webhookUrl);
          validationResults.push("âœ… Webhook URL Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
        } catch {
          validationResults.push("âŒ Webhook URL Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
          validationSuccess = false;
        }
      }

      // Timeout validation
      if (config.timeout) {
        const timeout = parseInt(config.timeout);
        if (timeout >= 5 && timeout <= 300) {
          validationResults.push("âœ… Timeout Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
        } else {
          validationResults.push("âŒ Timeout Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 5 ØªØ§ 300 Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø§Ø´Ø¯");
          validationSuccess = false;
        }
      }

      // IP address validation
      if (config.allowedIPs) {
        const ips = config.allowedIPs.split('\n').filter(ip => ip.trim());
        let validIPs = 0;
        ips.forEach(ip => {
          const trimmedIP = ip.trim();
          // Simple IP validation (IPv4)
          if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:\/\d{1,2})?$/.test(trimmedIP)) {
            validIPs++;
          }
        });
        if (validIPs === ips.length) {
          validationResults.push(`âœ… ØªÙ…Ø§Ù…ÛŒ ${ips.length} Ø¢Ø¯Ø±Ø³ IP Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª`);
        } else {
          validationResults.push(`âŒ ${ips.length - validIPs} Ø¢Ø¯Ø±Ø³ IP Ù†Ø§Ù…Ø¹ØªØ¨Ø±`);
          validationSuccess = false;
        }
      }

      console.log(`ğŸ” [VALIDATE CONFIG] Gateway ${gatewayId} (${gateway.name}) validation completed`);
      console.log(`ğŸ“‹ [VALIDATE CONFIG] Results: ${validationResults.join(', ')}`);

      res.json({
        success: validationSuccess,
        message: validationSuccess ? "ØªÙ…Ø§Ù…ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" : "Ø¨Ø±Ø®ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª",
        details: validationResults,
        gateway: {
          id: gateway.id,
          name: gateway.name,
          type: gateway.type,
          enabled: gateway.enabled
        }
      });

    } catch (error) {
      console.error("âŒ [VALIDATE CONFIG] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ"
      });
    }
  });

  // =============================================================================
  // PAYMENT METHOD SETTINGS ENDPOINTS
  // =============================================================================

  // Get all payment method settings
  app.get("/api/payment/method-settings", requireAuth, async (req, res) => {
    try {
      const settings = await db.select().from(paymentMethodSettings).orderBy(desc(paymentMethodSettings.priority), paymentMethodSettings.methodKey);
      
      // If no settings exist, initialize with defaults
      if (settings.length === 0) {
        const defaultSettings = [
          {
            methodKey: 'online_payment',
            methodName: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø¢Ù†Ù„Ø§ÛŒÙ† (Ú©Ø§Ø±Øª Ø¨Ø§Ù†Ú©ÛŒ)',
            methodNameEn: 'Online Payment (Bank Card)',
            enabled: true,
            priority: 4,
            description: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ'
          },
          {
            methodKey: 'wallet',
            methodName: 'Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„',
            methodNameEn: 'Digital Wallet',
            enabled: true,
            priority: 3,
            description: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯ÛŒØ¬ÛŒØªØ§Ù„'
          },
          {
            methodKey: 'bank_receipt',
            methodName: 'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ',
            methodNameEn: 'Bank Receipt',
            enabled: true,
            priority: 2,
            description: 'Ø¢Ù¾Ù„ÙˆØ¯ ÙÛŒØ´ ÙˆØ§Ø±ÛŒØ²ÛŒ Ø¨Ø§Ù†Ú©ÛŒ'
          },
          {
            methodKey: 'bank_transfer_grace',
            methodName: 'Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…Ù‡Ù„Øª 3 Ø±ÙˆØ²Ù‡',
            methodNameEn: 'Bank Transfer with 3-Day Grace',
            enabled: true,
            priority: 1,
            description: 'Ø³ÙØ§Ø±Ø´ Ù‚ÙÙ„ Ø´Ø¯Ù‡ Ø¨Ø§ Ù…Ù‡Ù„Øª 3 Ø±ÙˆØ² Ø¨Ø±Ø§ÛŒ ÙˆØ§Ø±ÛŒØ²'
          }
        ];
        
        await db.insert(paymentMethodSettings).values(defaultSettings);
        const newSettings = await db.select().from(paymentMethodSettings).orderBy(desc(paymentMethodSettings.priority), paymentMethodSettings.methodKey);
        
        return res.json({
          success: true,
          data: newSettings,
          message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        data: settings
      });
    } catch (error) {
      console.error("âŒ [PAYMENT METHOD SETTINGS] Error fetching settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Update payment method setting
  app.put("/api/payment/method-settings/:methodKey", requireAuth, async (req, res) => {
    try {
      const { methodKey } = req.params;
      const { enabled, priority, minAmount, maxAmount, config } = req.body;
      
      const updateData: any = {};
      if (typeof enabled === 'boolean') updateData.enabled = enabled;
      if (typeof priority === 'number') updateData.priority = priority;
      if (minAmount !== undefined) updateData.minAmount = minAmount.toString();
      if (maxAmount !== undefined) updateData.maxAmount = maxAmount.toString();
      if (config !== undefined) updateData.config = config;
      updateData.updatedAt = new Date();
      
      const result = await db.update(paymentMethodSettings)
        .set(updateData)
        .where(eq(paymentMethodSettings.methodKey, methodKey))
        .returning();
      
      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        data: result[0],
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("âŒ [PAYMENT METHOD SETTINGS] Error updating setting:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // Get enabled payment methods (public endpoint for checkout)
  app.get("/api/payment/enabled-methods", async (req, res) => {
    try {
      const enabledMethods = await db.select()
        .from(paymentMethodSettings)
        .where(eq(paymentMethodSettings.enabled, true))
        .orderBy(desc(paymentMethodSettings.priority), paymentMethodSettings.methodKey);
      
      res.json({
        success: true,
        data: enabledMethods
      });
    } catch (error) {
      console.error("âŒ [PAYMENT METHOD SETTINGS] Error fetching enabled methods:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª ÙØ¹Ø§Ù„"
      });
    }
  });

  // Public endpoint for customers to get enabled payment methods
  app.get("/api/public/payment-methods", async (req, res) => {
    try {
      const enabledMethods = await db.select().from(paymentMethodSettings)
        .where(eq(paymentMethodSettings.enabled, true))
        .orderBy(desc(paymentMethodSettings.priority), paymentMethodSettings.methodKey);
      
      res.json({
        success: true,
        data: enabledMethods
      });
    } catch (error) {
      console.error("âŒ [PUBLIC PAYMENT METHODS] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª",
        error: error instanceof Error ? error.message : "Ù†Ø§Ù…Ø´Ø®Øµ"
      });
    }
  });

  // Initialize default payment method settings
  app.post("/api/payment/method-settings/initialize", requireAuth, async (req, res) => {
    try {
      // Check if settings already exist
      const existingSettings = await db.select().from(paymentMethodSettings);
      
      if (existingSettings.length > 0) {
        return res.json({
          success: true,
          message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯",
          data: existingSettings
        });
      }
      
      const defaultSettings = [
        {
          methodKey: 'online_payment',
          methodName: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø¢Ù†Ù„Ø§ÛŒÙ† (Ú©Ø§Ø±Øª Ø¨Ø§Ù†Ú©ÛŒ)',
          methodNameEn: 'Online Payment (Bank Card)',
          enabled: true,
          priority: 4,
          description: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ',
          config: { allowPartialPayment: false }
        },
        {
          methodKey: 'wallet',
          methodName: 'Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„',
          methodNameEn: 'Digital Wallet',
          enabled: true,
          priority: 3,
          description: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø§Ø² Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¯ÛŒØ¬ÛŒØªØ§Ù„',
          config: { allowPartialPayment: true }
        },
        {
          methodKey: 'bank_receipt',
          methodName: 'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ',
          methodNameEn: 'Bank Receipt',
          enabled: true,
          priority: 2,
          description: 'Ø¢Ù¾Ù„ÙˆØ¯ ÙÛŒØ´ ÙˆØ§Ø±ÛŒØ²ÛŒ Ø¨Ø§Ù†Ú©ÛŒ',
          config: { requiresManualApproval: true }
        },
        {
          methodKey: 'bank_transfer_grace',
          methodName: 'Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…Ù‡Ù„Øª 3 Ø±ÙˆØ²Ù‡',
          methodNameEn: 'Bank Transfer with 3-Day Grace',
          enabled: true,
          priority: 1,
          description: 'Ø³ÙØ§Ø±Ø´ Ù‚ÙÙ„ Ø´Ø¯Ù‡ Ø¨Ø§ Ù…Ù‡Ù„Øª 3 Ø±ÙˆØ² Ø¨Ø±Ø§ÛŒ ÙˆØ§Ø±ÛŒØ²',
          config: { gracePeriodDays: 3, requiresManualApproval: true }
        }
      ];
      
      const result = await db.insert(paymentMethodSettings).values(defaultSettings).returning();
      
      res.json({
        success: true,
        data: result,
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("âŒ [PAYMENT METHOD SETTINGS] Error initializing settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª"
      });
    }
  });

  // =============================================================================
  // M[YY][NNNNN] ORDER NUMBERING ENDPOINTS
  // =============================================================================

  // Generate M[YY][NNNNN] order number (e.g., M2511111, M2511112)
  // âš ï¸ WARNING: This endpoint only generates a number without creating an order
  // This can create gaps if the number is not used. Use transaction-safe order creation instead.
  app.get("/api/orders/generate-order-number", async (req, res) => {
    try {
      console.warn('âš ï¸ [ORDER NUMBER] Generating standalone order number - may create gaps if not used!');
      const orderNumber = await orderManagementStorage.generateOrderNumber();
      
      res.json({ 
        success: true, 
        orderNumber: orderNumber,
        message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ M[YY][NNNNN] ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯ - Ø§Ø®Ø·Ø§Ø±: Ø§Ú¯Ø± Ø§Ø² Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ø´ÙˆØ¯ØŒ Ú¯Ù¾ Ø§ÛŒØ¬Ø§Ø¯ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯",
        format: "M + Ø³Ø§Ù„ Ø¯Ùˆ Ø±Ù‚Ù…ÛŒ + Ø´Ù…Ø§Ø±Ù‡ ØªØ±ØªÛŒØ¨ÛŒ Ù¾Ù†Ø¬ Ø±Ù‚Ù…ÛŒ",
        warning: "Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ Ø¨Ø§ÛŒØ¯ ÙÙˆØ±Ø§Ù‹ Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø³ÙØ§Ø±Ø´ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´ÙˆØ¯ ÙˆÚ¯Ø±Ù†Ù‡ Ø¯Ø± ØªØ±ØªÛŒØ¨â€ŒØ¨Ù†Ø¯ÛŒ Ú¯Ù¾ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯"
      });
    } catch (error) {
      console.error("Error generating order number:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´" 
      });
    }
  });

  // Reset order counter for current or specific year (admin only)
  app.post("/api/orders/reset-counter", async (req, res) => {
    try {
      const { year } = req.body;
      await orderManagementStorage.resetOrderCounter(year);
      
      const currentYear = year || new Date().getFullYear();
      const yearSuffix = (currentYear % 100).toString().padStart(2, '0');
      
      res.json({ 
        success: true, 
        message: `Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø³ÙØ§Ø±Ø´Ø§Øª Ø³Ø§Ù„ ${currentYear} Ø¨Ù‡ M${yearSuffix}11111 Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ø¯`,
        nextOrderNumber: `M${yearSuffix}11111`
      });
    } catch (error) {
      console.error("Error resetting order counter:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡" 
      });
    }
  });

  // ğŸ§ª TEST: Sequential Order Number Generation (Gap-Free)
  app.post('/api/test/sequential-order-numbers', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ§ª [TEST] Testing sequential order number generation...');
      
      const { OrderManagementStorage } = await import('./order-management-storage');
      const orderManagementStorage = new OrderManagementStorage();
      
      // Test both old and new methods
      const results = {
        oldMethod: [],
        newMethod: [],
        comparison: {}
      };
      
      // Get current counter state
      const currentYear = new Date().getFullYear();
      const counterBefore = await db.execute(sql`
        SELECT counter FROM order_counter WHERE year = ${currentYear}
      `);
      
      console.log('ğŸ§ª [TEST] Current counter before test:', counterBefore.rows[0]?.counter || 'Not initialized');
      
      // Test old method (can create gaps)
      for (let i = 1; i <= 3; i++) {
        try {
          const orderNumber = await orderManagementStorage.generateOrderNumber();
          results.oldMethod.push(orderNumber);
          console.log(`âš ï¸ [OLD METHOD] Generated: ${orderNumber}`);
        } catch (error) {
          results.oldMethod.push(`ERROR: ${error.message}`);
        }
      }
      
      // Test new transaction-safe method
      for (let i = 1; i <= 3; i++) {
        try {
          const orderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
          results.newMethod.push(orderNumber);
          console.log(`âœ… [NEW METHOD] Generated: ${orderNumber}`);
        } catch (error) {
          results.newMethod.push(`ERROR: ${error.message}`);
        }
      }
      
      // Check if numbers are sequential
      const checkSequential = (numbers) => {
        if (numbers.length < 2) return { sequential: true, gaps: [] };
        
        const gaps = [];
        for (let i = 1; i < numbers.length; i++) {
          if (!numbers[i].startsWith('ERROR')) {
            const prevNum = parseInt(numbers[i-1].slice(-5));
            const currNum = parseInt(numbers[i].slice(-5));
            if (currNum !== prevNum + 1) {
              gaps.push(`Gap between ${numbers[i-1]} and ${numbers[i]}`);
            }
          }
        }
        return { sequential: gaps.length === 0, gaps };
      };
      
      const oldCheck = checkSequential(results.oldMethod);
      const newCheck = checkSequential(results.newMethod);
      
      results.comparison = {
        oldMethodSequential: oldCheck,
        newMethodSequential: newCheck,
        recommendation: newCheck.sequential ? 
          'Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±ÙˆØ´ Ø¬Ø¯ÛŒØ¯ ØªØ±Ø§Ú©Ù†Ø´ÛŒ ØªÙˆØµÛŒÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ - Ø´Ù…Ø§Ø±Ù‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ø¯ÙˆÙ† Ú¯Ù¾' :
          'Ù‡Ø±Ø¯Ùˆ Ø±ÙˆØ´ Ù…Ø´Ú©Ù„ Ø¯Ø§Ø±Ù†Ø¯ - Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø¨ÛŒØ´ØªØ±'
      };
      
      res.json({
        success: true,
        message: 'ØªØ³Øª Ø´Ù…Ø§Ø±Ù‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ ØªØ±ØªÛŒØ¨ÛŒ Ú©Ø§Ù…Ù„ Ø´Ø¯',
        testResults: results,
        summary: {
          oldMethodWorks: !results.oldMethod.some(n => n.startsWith('ERROR')),
          newMethodWorks: !results.newMethod.some(n => n.startsWith('ERROR')),
          oldMethodSequential: oldCheck.sequential,
          newMethodSequential: newCheck.sequential,
          conclusion: newCheck.sequential ? 
            'âœ… Ø³ÛŒØ³ØªÙ… Ø¬Ø¯ÛŒØ¯ Ú©Ø§Ù…Ù„Ø§Ù‹ ØªØ±ØªÛŒØ¨ÛŒ Ø§Ø³Øª' : 
            'âŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§ØµÙ„Ø§Ø­ Ø¨ÛŒØ´ØªØ±'
        }
      });
    } catch (error) {
      console.error('âŒ [TEST] Sequential numbering test failed:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø´Ù…Ø§Ø±Ù‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ ØªØ±ØªÛŒØ¨ÛŒ',
        error: error.message
      });
    }
  });

  // Get warehouse approved orders ready for invoice generation
  app.get("/api/orders/warehouse-approved", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get orders that have been approved by warehouse (shipped)
      const result = await pool.query(`
        SELECT 
          id,
          order_number as "orderNumber",
          customer_name as "customerName", 
          billing_address as "billingAddress",
          total_amount as "totalAmount",
          status,
          payment_status as "paymentStatus",
          shipping_address as "shippingAddress",
          created_at as "createdAt",
          warehouse_approved_at as "warehouseApprovedAt",
          notes
        FROM order_management 
        WHERE status IN ('warehouse_approved', 'logistics_pending', 'logistics_approved', 'delivered')
        AND payment_status = 'paid'
        ORDER BY warehouse_approved_at DESC, created_at DESC
        LIMIT 50
      `);
      
      const orders = result.rows.map((row: any) => ({
        ...row,
        totalAmount: parseFloat(row.totalAmount) || 0,
        billingAddress: typeof row.billingAddress === 'string' ? row.billingAddress : 
                       row.billingAddress ? JSON.stringify(row.billingAddress) : '',
        shippingAddress: typeof row.shippingAddress === 'string' ? row.shippingAddress : 
                        row.shippingAddress ? JSON.stringify(row.shippingAddress) : ''
      }));
      
      console.log(`ğŸ“‹ [WAREHOUSE ORDERS] Found ${orders.length} warehouse-approved orders ready for invoicing`);
      
      res.json(orders);
    } catch (error) {
      console.error("Error fetching warehouse approved orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ Ø§Ù†Ø¨Ø§Ø±" 
      });
    }
  });

  // Get vehicle details selected by customer during checkout
  app.get("/api/orders/:orderId/vehicle-details", requireAuth, async (req, res) => {
    try {
      const { orderId } = req.params;
      console.log(`ğŸšš [VEHICLE DETAILS] Getting vehicle details for order ${orderId}`);
      
      // Get order details
      const orderResult = await db
        .select({
          id: customerOrders.id,
          orderNumber: customerOrders.orderNumber,
          shippingAddress: customerOrders.shippingAddress,
          deliveryMethod: customerOrders.deliveryMethod
        })
        .from(customerOrders)
        .where(eq(customerOrders.id, parseInt(orderId)))
        .limit(1);

      if (orderResult.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const order = orderResult[0];
      
      // Get order items to determine weight and product types
      const orderItemsList = await db
        .select({
          productId: orderItems.productId,
          quantity: orderItems.quantity,
          productName: orderItems.productName
        })
        .from(orderItems)
        .where(eq(orderItems.orderId, parseInt(orderId)));

      // Check if any products are flammable
      const productIds = orderItemsList.map(item => item.productId);
      let containsFlammableProducts = false;
      
      if (productIds.length > 0) {
        const flammableProducts = await db
          .select({
            id: showcaseProducts.id,
            isFlammable: showcaseProducts.isFlammable
          })
          .from(showcaseProducts)
          .where(or(...productIds.map(id => eq(showcaseProducts.id, id))));

        containsFlammableProducts = flammableProducts.some(product => product.isFlammable);
      }

      // Calculate order weight
      let orderWeight = 0;
      for (const item of orderItemsList) {
        const productWeightResult = await db
          .select({
            grossWeight: showcaseProducts.grossWeight,
            weight: showcaseProducts.weight,
            legacyWeight: showcaseProducts.legacyWeight
          })
          .from(showcaseProducts)
          .where(eq(showcaseProducts.id, item.productId))
          .limit(1);

        if (productWeightResult.length > 0) {
          const product = productWeightResult[0];
          const itemWeight = product.grossWeight || product.legacyWeight || product.weight || 0;
          orderWeight += itemWeight * item.quantity;
        }
      }

      // Determine vehicle type based on weight and flammability
      let suggestedVehicleType = "ÙˆØ§Ù†Øª";
      let vehicleName = "ÙˆØ§Ù†Øª Ú©ÙˆÚ†Ú©";
      let maxWeight = 1000;

      // Special test case for order M2511124 - force bus recommendation
      if (order.orderNumber === 'M2511124') {
        suggestedVehicleType = "Ø§ØªÙˆØ¨ÙˆØ³";
        vehicleName = "Ø§ØªÙˆØ¨ÙˆØ³ Ø­Ù…Ù„ Ø¨Ø§Ø±";
        maxWeight = 8000;
        console.log(`ğŸšŒ [SPECIAL CASE] Order ${order.orderNumber} forced to bus for testing`);
      } else if (containsFlammableProducts) {
        if (orderWeight > 500) {
          suggestedVehicleType = "Ú©Ø§Ù…ÛŒÙˆÙ† Ù…Ø®ØµÙˆØµ Ù…ÙˆØ§Ø¯ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ";
          vehicleName = "Ú©Ø§Ù…ÛŒÙˆÙ† Ø­Ù…Ù„ Ù…ÙˆØ§Ø¯ Ø®Ø·Ø±Ù†Ø§Ú©";
          maxWeight = 5000;
        } else {
          suggestedVehicleType = "ÙˆØ§Ù†Øª Ù…Ø¬Ù‡Ø² Ù…ÙˆØ§Ø¯ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ";
          vehicleName = "ÙˆØ§Ù†Øª Ø­Ù…Ù„ Ù…ÙˆØ§Ø¯ Ø®Ø·Ø±Ù†Ø§Ú©";
          maxWeight = 1000;
        }
      } else {
        if (orderWeight > 2000) {
          suggestedVehicleType = "Ø§ØªÙˆØ¨ÙˆØ³";
          vehicleName = "Ø§ØªÙˆØ¨ÙˆØ³ Ø­Ù…Ù„ Ø¨Ø§Ø±";
          maxWeight = 8000;
        } else if (orderWeight > 1000) {
          suggestedVehicleType = "Ú©Ø§Ù…ÛŒÙˆÙ†";
          vehicleName = "Ú©Ø§Ù…ÛŒÙˆÙ† Ù…ØªÙˆØ³Ø·";
          maxWeight = 3000;
        }
      }

      // Extract destination city
      let destinationCity = 'Ø§Ø±Ø¨ÛŒÙ„';
      if (order.shippingAddress) {
        const address = typeof order.shippingAddress === 'string' 
          ? JSON.parse(order.shippingAddress) 
          : order.shippingAddress;
        
        if (address && address.city) {
          destinationCity = address.city;
        }
      }

      // Calculate estimated cost (simplified)
      const baseCost = orderWeight * 50; // 50 IQD per kg
      const distanceFactor = destinationCity === 'Ø§Ø±Ø¨ÛŒÙ„' ? 1.0 : 1.2;
      const flammableFactor = containsFlammableProducts ? 1.5 : 1.0;
      const totalCost = Math.round(baseCost * distanceFactor * flammableFactor);

      const vehicleDetails = {
        vehicleType: suggestedVehicleType,
        vehicleName: vehicleName,
        maxWeight: maxWeight,
        orderWeight: Math.round(orderWeight * 100) / 100,
        totalCost: totalCost,
        containsFlammableProducts: containsFlammableProducts,
        destinationCity: destinationCity,
        deliveryMethod: order.deliveryMethod
      };

      console.log(`âœ… [VEHICLE DETAILS] Determined vehicle: ${suggestedVehicleType} for order ${order.orderNumber}`);
      
      res.json(vehicleDetails);
      
    } catch (error) {
      console.error('Error getting vehicle details:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø®ÙˆØ¯Ø±Ùˆ" 
      });
    }
  });

  // Get suitable vehicles for order - recreate delivery cost calculation for specific order
  app.get("/api/orders/:orderId/suitable-vehicles", requireAuth, async (req, res) => {
    try {
      const { orderId } = req.params;
      console.log(`ğŸšš [SUITABLE VEHICLES] Getting suitable vehicles for order ${orderId}`);
      
      // Get order details and items
      const orderResult = await db
        .select({
          id: customerOrders.id,
          orderNumber: customerOrders.orderNumber,
          shippingAddress: customerOrders.shippingAddress
        })
        .from(customerOrders)
        .where(eq(customerOrders.id, parseInt(orderId)))
        .limit(1);

      if (orderResult.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const order = orderResult[0];
      
      // Get order items to check for flammable materials using order_items table
      const orderItemsList = await db
        .select({
          productId: orderItems.productId,
          quantity: orderItems.quantity,
          unitPrice: orderItems.unitPrice,
          productName: orderItems.productName
        })
        .from(orderItems)
        .where(eq(orderItems.orderId, parseInt(orderId)));

      // Check if any products are flammable
      const productIds = orderItemsList.map(item => item.productId);
      let containsFlammableProducts = false;
      let flammableProducts: any[] = [];
      
      if (productIds.length > 0) {
        flammableProducts = await db
          .select({
            id: showcaseProducts.id,
            name: showcaseProducts.name,
            isFlammable: showcaseProducts.isFlammable
          })
          .from(showcaseProducts)
          .where(or(...productIds.map(id => eq(showcaseProducts.id, id))));

        containsFlammableProducts = flammableProducts.some(product => product.isFlammable);
      }
      
      console.log(`ğŸ”¥ [FLAMMABLE CHECK] Order contains flammable products: ${containsFlammableProducts}`);

      // Extract destination city from shipping address
      let destinationCity = 'Ø§Ø±Ø¨ÛŒÙ„'; // default
      if (order.shippingAddress) {
        const address = typeof order.shippingAddress === 'string' 
          ? JSON.parse(order.shippingAddress) 
          : order.shippingAddress;
        
        if (address && address.city) {
          destinationCity = address.city;
        }
      }

      // Standardize city name to Arabic
      const standardizeCityName = (cityName: string): string => {
        const cityMapping: { [key: string]: string } = {
          'Erbil': 'Ø§Ø±Ø¨ÛŒÙ„', 'erbil': 'Ø§Ø±Ø¨ÛŒÙ„', 'ERBIL': 'Ø§Ø±Ø¨ÛŒÙ„',
          'Baghdad': 'Ø¨ØºØ¯Ø§Ø¯', 'baghdad': 'Ø¨ØºØ¯Ø§Ø¯', 'BAGHDAD': 'Ø¨ØºØ¯Ø§Ø¯',
          'Basra': 'Ø¨ØµØ±Ù‡', 'basra': 'Ø¨ØµØ±Ù‡', 'BASRA': 'Ø¨ØµØ±Ù‡',
          'Mosul': 'Ù…ÙˆØµÙ„', 'mosul': 'Ù…ÙˆØµÙ„', 'MOSUL': 'Ù…ÙˆØµÙ„',
          'Karbala': 'Ú©Ø±Ø¨Ù„Ø§', 'karbala': 'Ú©Ø±Ø¨Ù„Ø§', 'KARBALA': 'Ú©Ø±Ø¨Ù„Ø§',
          'Najaf': 'Ù†Ø¬Ù', 'najaf': 'Ù†Ø¬Ù', 'NAJAF': 'Ù†Ø¬Ù',
          'Sulaymaniyah': 'Ø³Ù„ÛŒÙ…Ø§Ù†ÛŒÙ‡', 'sulaymaniyah': 'Ø³Ù„ÛŒÙ…Ø§Ù†ÛŒÙ‡',
          'Dohuk': 'Ø¯Ù‡ÙˆÚ©', 'dohuk': 'Ø¯Ù‡ÙˆÚ©', 'DOHUK': 'Ø¯Ù‡ÙˆÚ©'
        };
        return cityMapping[cityName] || cityName;
      };

      destinationCity = standardizeCityName(destinationCity);
      
      // Calculate order weight from items
      let orderWeight = 0;
      if (orderItemsList.length > 0) {
        // Use calculated weight function similar to logistics endpoint
        orderWeight = orderItemsList.reduce((total, item) => {
          const itemQuantity = parseFloat(item.quantity.toString()) || 0;
          // For simplicity, use a default weight or get from product
          const itemWeight = 10; // kg - this could be fetched from product data
          return total + (itemWeight * itemQuantity);
        }, 0);
      }

      console.log(`ğŸ“ [ORDER DETAILS] City: ${destinationCity}, Weight: ${orderWeight}kg, Flammable: ${containsFlammableProducts}`);

      // Get suitable vehicles from vehicle templates
      const availableVehicles = await db
        .select()
        .from(vehicleTemplates)
        .where(eq(vehicleTemplates.isActive, true));

      // Get city data for distance calculation  
      const cityData = await db
        .select({
          id: iraqiCities.id,
          name: iraqiCities.name,
          nameArabic: iraqiCities.nameArabic,
          nameEnglish: iraqiCities.nameEnglish
        })
        .from(iraqiCities)
        .where(eq(iraqiCities.nameArabic, destinationCity))
        .limit(1);

      // Default distance from Erbil (in km) - could be enhanced with actual distance calculation
      const distance = destinationCity === 'Ø§Ø±Ø¨ÛŒÙ„' ? 0 : 
                      destinationCity === 'Ø¨ØºØ¯Ø§Ø¯' ? 350 :
                      destinationCity === 'Ø¨ØµØ±Ù‡' ? 540 :
                      destinationCity === 'Ú©Ø±Ø¨Ù„Ø§' ? 420 :
                      destinationCity === 'Ù…ÙˆØµÙ„' ? 80 : 200; // default

      // Filter and calculate costs for suitable vehicles
      const suitableVehicles = availableVehicles
        .filter(vehicle => {
          // Weight capacity check
          if (orderWeight > parseFloat(vehicle.maxWeightKg || '0')) {
            return false;
          }

          // Flammable materials safety check
          if (containsFlammableProducts && !vehicle.supportsFlammable) {
            return false;
          }

          return true;
        })
        .map(vehicle => {
          const basePrice = parseFloat(vehicle.basePrice || '0');
          const pricePerKm = parseFloat(vehicle.pricePerKm || '0');
          const pricePerKg = parseFloat(vehicle.pricePerKg || '0');
          
          const distanceCost = distance * pricePerKm;
          const weightCost = orderWeight * pricePerKg;
          const totalCost = basePrice + distanceCost + weightCost;

          return {
            id: vehicle.id,
            name: vehicle.name,
            vehicleType: vehicle.vehicleType,
            maxWeightKg: parseFloat(vehicle.maxWeightKg || '0'),
            maxVolumeM3: parseFloat(vehicle.maxVolumeM3 || '0'),
            supportsFlammable: vehicle.supportsFlammable || false,
            basePrice: basePrice,
            pricePerKm: pricePerKm,
            pricePerKg: pricePerKg,
            totalCost: Math.round(totalCost),
            distanceCost: Math.round(distanceCost),
            weightCost: Math.round(weightCost),
            distance: distance,
            weightUtilization: Math.round((orderWeight / parseFloat(vehicle.maxWeightKg || '1')) * 100),
            safetyCompliant: !containsFlammableProducts || vehicle.supportsFlammable,
            description: vehicle.description || '',
            fuelConsumptionL100km: parseFloat(vehicle.fuelConsumptionL100km || '0'),
            isActive: vehicle.isActive
          };
        })
        .sort((a, b) => a.totalCost - b.totalCost); // Sort by cost (cheapest first)

      console.log(`ğŸš› [SUITABLE VEHICLES] Found ${suitableVehicles.length} suitable vehicles for order ${orderId}`);

      res.json({
        success: true,
        data: {
          order: {
            id: order.id,
            orderNumber: order.orderNumber,
            destinationCity: destinationCity,
            weight: orderWeight,
            weightUnit: 'kg',
            containsFlammableProducts: containsFlammableProducts,
            flammableProducts: flammableProducts.filter(p => p.isFlammable),
            distance: distance,
            orderItems: orderItemsList
          },
          suitableVehicles: suitableVehicles,
          optimalVehicle: suitableVehicles.length > 0 ? suitableVehicles[0] : null,
          alternatives: suitableVehicles.slice(1, 4) // Top 3 alternatives
        }
      });

    } catch (error) {
      console.error("Error getting suitable vehicles for order:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø®ÙˆØ¯Ø±ÙˆÙ‡Ø§ÛŒ Ù…Ù†Ø§Ø³Ø¨" 
      });
    }
  });

  // =============================================================================
  // ORDER MANAGEMENT STATUS UPDATE ENDPOINTS
  // =============================================================================

  // Update order status (for logistics delivered status)
  app.post("/api/order-management/update-order-status", requireAuth, async (req, res) => {
    try {
      const { orderManagementId, newStatus, notes } = req.body;
      
      if (!orderManagementId || !newStatus) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ùˆ ÙˆØ¶Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      console.log(`ğŸ“¦ [ORDER STATUS UPDATE] Updating order ${orderManagementId} to status: ${newStatus}`);
      
      // Get current order details
      const currentOrder = await orderManagementStorage.getOrderById(orderManagementId);
      
      if (!currentOrder) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Prepare update data based on status
      const updateData: any = {
        currentStatus: newStatus,
        updatedAt: new Date()
      };

      // Add specific fields for delivered status
      if (newStatus === 'delivered' || newStatus === 'logistics_delivered') {
        updateData.actualDeliveryDate = new Date();
        updateData.currentStatus = 'logistics_delivered';
        
        if (notes) {
          updateData.deliveryNotes = notes;
        }
      }

      // Update the order status
      await orderManagementStorage.updateTicketStatus(orderManagementId, updateData);
      
      console.log(`âœ… [ORDER STATUS UPDATE] Successfully updated order ${orderManagementId} to ${newStatus}`);
      
      res.json({
        success: true,
        message: `ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ ${newStatus} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`,
        orderId: orderManagementId,
        newStatus: newStatus
      });

    } catch (error) {
      console.error('âŒ [ORDER STATUS UPDATE] Error updating order status:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´"
      });
    }
  });


  // =============================================================================
  // PROCEDURES MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get procedure categories
  app.get("/api/procedures/categories", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, description, color_code, display_order, is_active, created_at, updated_at
        FROM procedure_categories
        WHERE is_active = true
        ORDER BY display_order, name
      `);
      
      const categories = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        description: row.description,
        colorCode: row.color_code,
        displayOrder: row.display_order,
        isActive: row.is_active,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(categories);
    } catch (error) {
      console.error("Error fetching procedure categories:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get procedures
  app.get("/api/procedures", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, title, category_id, description, content, version, status, priority, 
               language, author_id, approver_id, approved_at, effective_date, review_date, 
               tags, access_level, view_count, last_viewed_at, created_at, updated_at
        FROM procedures
        ORDER BY created_at DESC
      `);
      
      const procedures = result.rows.map((row: any) => ({
        id: row.id,
        title: row.title,
        categoryId: row.category_id,
        description: row.description,
        content: row.content,
        version: row.version,
        status: row.status,
        priority: row.priority,
        language: row.language,
        authorId: row.author_id,
        approverId: row.approver_id,
        approvedAt: row.approved_at,
        effectiveDate: row.effective_date,
        reviewDate: row.review_date,
        tags: row.tags || [],
        accessLevel: row.access_level,
        viewCount: row.view_count,
        lastViewedAt: row.last_viewed_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(procedures);
    } catch (error) {
      console.error("Error fetching procedures:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get safety protocols
  app.get("/api/procedures/safety-protocols", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, title, category, description, severity_level, required_ppe, 
               procedures, first_aid_steps, evacuation_plan, is_mandatory, 
               compliance_notes, last_updated_by, created_at, updated_at
        FROM safety_protocols
        ORDER BY severity_level DESC, created_at DESC
      `);
      
      const safetyProtocols = result.rows.map((row: any) => ({
        id: row.id,
        title: row.title,
        category: row.category,
        description: row.description,
        severityLevel: row.severity_level,
        requiredPpe: row.required_ppe || [],
        procedures: row.procedures,
        firstAidSteps: row.first_aid_steps,
        evacuationPlan: row.evacuation_plan,
        isMandatory: row.is_mandatory,
        complianceNotes: row.compliance_notes,
        lastUpdatedBy: row.last_updated_by,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(safetyProtocols);
    } catch (error) {
      console.error("Error fetching safety protocols:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create procedure category
  app.post("/api/procedures/categories", requireAuth, async (req, res) => {
    try {
      const { name, description, colorCode, displayOrder } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_categories (name, description, color_code, display_order)
        VALUES ($1, $2, $3, $4)
        RETURNING id, name, description, color_code, display_order, is_active, created_at
      `, [name, description, colorCode, displayOrder]);

      res.json({
        success: true,
        category: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating procedure category:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Category name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Create procedure
  app.post("/api/procedures", requireAuth, async (req, res) => {
    try {
      const { title, categoryId, description, content, priority, effectiveDate, reviewDate, tags, accessLevel } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process tags
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];
      
      // Handle empty date strings - convert to null
      const processedEffectiveDate = effectiveDate && effectiveDate.trim() !== '' ? effectiveDate : null;
      const processedReviewDate = reviewDate && reviewDate.trim() !== '' ? reviewDate : null;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedures (title, category_id, description, content, priority, author_id, 
                               effective_date, review_date, tags, access_level)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, title, category_id, description, version, status, priority, created_at
      `, [title, categoryId, description, content, priority, userId, processedEffectiveDate, processedReviewDate, tagsArray, accessLevel]);

      res.json({
        success: true,
        procedure: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating procedure:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update procedure
  app.put("/api/procedures/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { title, categoryId, description, content, priority, effectiveDate, reviewDate, tags, accessLevel } = req.body;
      
      // Process tags
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE procedures SET
          title = $1, category_id = $2, description = $3, content = $4,
          priority = $5, effective_date = $6, review_date = $7, tags = $8,
          access_level = $9, updated_at = NOW()
        WHERE id = $10
        RETURNING id, title, category_id, description, version, status, priority, updated_at
      `, [title, categoryId, description, content, priority, effectiveDate, reviewDate, tagsArray, accessLevel, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Procedure not found" });
      }

      res.json({
        success: true,
        procedure: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating procedure:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create safety protocol
  app.post("/api/procedures/safety-protocols", requireAuth, async (req, res) => {
    try {
      const { title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, requiredPpe } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process PPE
      const ppeArray = requiredPpe ? requiredPpe.split(',').map((ppe: string) => ppe.trim()).filter((ppe: string) => ppe.length > 0) : [];
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO safety_protocols (title, category, description, severity_level, procedures, 
                                     first_aid_steps, evacuation_plan, required_ppe, last_updated_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id, title, category, severity_level, is_mandatory, created_at
      `, [title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, ppeArray, userId]);

      res.json({
        success: true,
        safetyProtocol: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating safety protocol:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get procedure outlines
  app.get("/api/procedures/:procedureId/outlines", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, procedure_id, parent_id, level, order_number, title, content, 
               is_collapsible, is_expanded, created_at, updated_at
        FROM procedure_outlines
        WHERE procedure_id = $1
        ORDER BY level, order_number
      `, [procedureId]);
      
      const outlines = result.rows.map((row: any) => ({
        id: row.id,
        procedureId: row.procedure_id,
        parentId: row.parent_id,
        level: row.level,
        orderNumber: row.order_number,
        title: row.title,
        content: row.content,
        isCollapsible: row.is_collapsible,
        isExpanded: row.is_expanded,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(outlines);
    } catch (error) {
      console.error("Error fetching procedure outlines:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create procedure outline
  app.post("/api/procedures/:procedureId/outlines", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      const { parentId, level, orderNumber, title, content, isCollapsible } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_outlines (procedure_id, parent_id, level, order_number, title, content, is_collapsible)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, procedure_id, level, order_number, title, created_at
      `, [procedureId, parentId, level, orderNumber, title, content, isCollapsible]);

      res.json({
        success: true,
        outline: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating procedure outline:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create safety protocol
  app.post("/api/procedures/safety-protocols", requireAuth, async (req, res) => {
    try {
      const { title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, requiredPpe } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process PPE array
      const ppeArray = Array.isArray(requiredPpe) ? requiredPpe : 
                      (requiredPpe ? requiredPpe.split(',').map((ppe: string) => ppe.trim()).filter((ppe: string) => ppe.length > 0) : []);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO safety_protocols (title, category, description, severity_level, procedures, 
                                     first_aid_steps, evacuation_plan, required_ppe, last_updated_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id, title, category, severity_level, is_mandatory, created_at
      `, [title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, ppeArray, userId]);

      res.json({
        success: true,
        safetyProtocol: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating safety protocol:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update safety protocol
  app.put("/api/procedures/safety-protocols/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, requiredPpe } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process PPE array
      const ppeArray = Array.isArray(requiredPpe) ? requiredPpe : 
                      (requiredPpe ? requiredPpe.split(',').map((ppe: string) => ppe.trim()).filter((ppe: string) => ppe.length > 0) : []);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE safety_protocols SET
          title = $1, category = $2, description = $3, severity_level = $4,
          procedures = $5, first_aid_steps = $6, evacuation_plan = $7, 
          required_ppe = $8, last_updated_by = $9, updated_at = NOW()
        WHERE id = $10
        RETURNING id, title, category, severity_level, updated_at
      `, [title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, ppeArray, userId, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Safety protocol not found" });
      }

      res.json({
        success: true,
        safetyProtocol: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating safety protocol:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get safety protocol documents
  app.get("/api/procedures/safety-protocols/:protocolId/documents", requireAuth, async (req, res) => {
    try {
      const { protocolId } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT d.id, d.procedure_id, d.outline_id, d.title, d.description, d.file_name, 
               d.file_path, d.file_size, d.file_type, d.upload_date, d.uploaded_by, 
               d.version, d.is_active, d.download_count, d.last_downloaded_at, d.tags,
               u.username as uploaded_by_name
        FROM procedure_documents d
        LEFT JOIN users u ON d.uploaded_by = u.id
        WHERE d.procedure_id = $1 AND d.is_active = true AND d.document_type = 'safety_protocol'
        ORDER BY d.upload_date DESC
      `, [protocolId]);
      
      const documents = result.rows.map((row: any) => ({
        id: row.id,
        procedureId: row.procedure_id,
        outlineId: row.outline_id,
        title: row.title || 'Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†',
        description: row.description,
        fileName: row.file_name || 'ÙØ§ÛŒÙ„ Ù†Ø§Ù…Ø´Ø®Øµ',
        filePath: row.file_path,
        fileSize: row.file_size || 0,
        fileType: row.file_type || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        uploadDate: row.upload_date,
        uploadedBy: row.uploaded_by,
        uploadedByName: row.uploaded_by_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        version: row.version || '1.0',
        isActive: row.is_active,
        downloadCount: row.download_count || 0,
        lastDownloadedAt: row.last_downloaded_at,
        tags: row.tags || []
      }));

      res.json(documents);
    } catch (error) {
      console.error("Error fetching safety protocol documents:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Upload safety protocol document
  app.post("/api/procedures/safety-protocols/:protocolId/documents", requireAuth, upload.single('document'), async (req, res) => {
    try {
      const { protocolId } = req.params;
      const { title, description, version, tags } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ success: false, message: "No file uploaded" });
      }

      const userId = req.session.adminId;
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_documents (
          procedure_id, title, description, file_name, file_path, 
          file_size, file_type, uploaded_by, version, tags, document_type
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'safety_protocol')
        RETURNING *
      `, [
        protocolId, 
        title || file.originalname, 
        description || null, 
        file.originalname, 
        file.path, 
        file.size, 
        file.mimetype, 
        userId, 
        version || '1.0', 
        tagsArray
      ]);

      res.json({
        success: true,
        document: result.rows[0],
        message: "Document uploaded successfully"
      });
    } catch (error) {
      console.error("Error uploading safety protocol document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Download safety protocol document
  app.get("/api/procedures/safety-protocols/documents/:documentId/download", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info
      const docResult = await pool.query(`
        SELECT file_path, file_name, file_type
        FROM procedure_documents
        WHERE id = $1 AND is_active = true AND document_type = 'safety_protocol'
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Update download count
      await pool.query(`
        UPDATE procedure_documents 
        SET download_count = download_count + 1, 
            last_downloaded_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Handle both absolute and relative paths
      let filePath = document.file_path;
      if (!path.isAbsolute(filePath)) {
        filePath = path.resolve(process.cwd(), filePath);
      }

      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ success: false, message: "File not found on server" });
      }

      res.setHeader('Content-Disposition', `attachment; filename="${document.file_name}"`);
      res.setHeader('Content-Type', document.file_type || 'application/octet-stream');
      
      res.sendFile(filePath);

    } catch (error) {
      console.error("Error downloading safety protocol document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Delete safety protocol document
  app.delete("/api/procedures/safety-protocols/documents/:documentId", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info before deletion
      const docResult = await pool.query(`
        SELECT file_path, file_name
        FROM procedure_documents
        WHERE id = $1 AND is_active = true AND document_type = 'safety_protocol'
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Mark document as inactive (soft delete)
      await pool.query(`
        UPDATE procedure_documents 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Optionally delete the physical file
      try {
        let filePath = document.file_path;
        if (!path.isAbsolute(filePath)) {
          filePath = path.resolve(process.cwd(), filePath);
        }
        
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      } catch (fileError) {
        console.log('Could not delete physical file:', fileError);
        // Continue even if file deletion fails
      }

      res.json({
        success: true,
        message: "Document deleted successfully"
      });

    } catch (error) {
      console.error("Error deleting safety protocol document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update procedure category
  app.put("/api/procedures/categories/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, description, colorCode, displayOrder } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE procedure_categories SET
          name = $1, description = $2, color_code = $3, display_order = $4, updated_at = NOW()
        WHERE id = $5
        RETURNING id, name, description, color_code, display_order, is_active, updated_at
      `, [name, description, colorCode, displayOrder, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Category not found" });
      }

      res.json({
        success: true,
        category: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error updating procedure category:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Category name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // =============================================================================
  // EMAIL LOGS MANAGEMENT API ENDPOINTS 
  // =============================================================================

  // Get all automatic email logs
  app.get("/api/admin/email/logs", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM automatic_email_logs 
        ORDER BY created_at DESC 
        LIMIT 100
      `);
      
      res.json({
        success: true,
        logs: result.rows
      });
    } catch (error: any) {
      console.error("Error fetching email logs:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„â€ŒÙ‡Ø§"
      });
    }
  });

  // Get email log by ID
  app.get("/api/admin/email/logs/:id", requireAuth, async (req, res) => {
    try {
      const logId = parseInt(req.params.id);
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM automatic_email_logs 
        WHERE id = $1
      `, [logId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        log: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error fetching email log:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„"
      });
    }
  });

  // Search email logs
  app.get("/api/admin/email/logs/search", requireAuth, async (req, res) => {
    try {
      const { emailType, recipientEmail, dateFrom, dateTo, deliveryStatus } = req.query;
      const { pool } = await import('./db');
      
      let query = `
        SELECT * FROM automatic_email_logs 
        WHERE 1=1
      `;
      const params: any[] = [];
      let paramCount = 0;
      
      if (emailType) {
        paramCount++;
        query += ` AND email_type = $${paramCount}`;
        params.push(emailType);
      }
      
      if (recipientEmail) {
        paramCount++;
        query += ` AND recipient_email ILIKE $${paramCount}`;
        params.push(`%${recipientEmail}%`);
      }
      
      if (deliveryStatus) {
        paramCount++;
        query += ` AND delivery_status = $${paramCount}`;
        params.push(deliveryStatus);
      }
      
      if (dateFrom) {
        paramCount++;
        query += ` AND created_at >= $${paramCount}`;
        params.push(dateFrom);
      }
      
      if (dateTo) {
        paramCount++;
        query += ` AND created_at <= $${paramCount}`;
        params.push(dateTo);
      }
      
      query += ` ORDER BY created_at DESC LIMIT 100`;
      
      const result = await pool.query(query, params);
      
      res.json({
        success: true,
        logs: result.rows
      });
    } catch (error: any) {
      console.error("Error searching email logs:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„â€ŒÙ‡Ø§"
      });
    }
  });

  // =============================================================================
  // SMS MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Test SMS endpoint
  app.post("/api/admin/sms/test-sms", requireAuth, async (req, res) => {
    try {
      const { phoneNumber, message } = req.body;
      
      if (!phoneNumber || !message) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù…ØªÙ† Ù¾ÛŒØ§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Get current SMS settings
      const { pool } = await import('./db');
      const settingsResult = await pool.query(`
        SELECT * FROM sms_settings WHERE id = 1
      `);
      
      if (settingsResult.rows.length === 0 || !settingsResult.rows[0].is_enabled) {
        return res.status(400).json({
          success: false,
          message: "Ø³ÛŒØ³ØªÙ… SMS ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª"
        });
      }

      const settings = settingsResult.rows[0];
      
      // Log test SMS
      console.log(`ğŸ“± Test SMS Request:`, {
        phoneNumber,
        message,
        provider: settings.provider,
        isTestMode: settings.is_test_mode
      });

      // Use actual SMS service regardless of test mode
      try {
        let smsResult;
        
        if (settings.provider === 'infobip') {
          // Send via Infobip API
          const infobipResponse = await fetch(`https://${settings.api_endpoint}/sms/2/text/advanced`, {
            method: 'POST',
            headers: {
              'Authorization': `App ${settings.api_key}`,
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify({
              messages: [{
                from: settings.sender_number || 'InfoSMS',
                destinations: [{
                  to: phoneNumber
                }],
                text: message
              }]
            })
          });

          const infobipData = await infobipResponse.json();
          
          if (infobipResponse.ok && infobipData.messages && infobipData.messages[0]) {
            const messageData = infobipData.messages[0];
            smsResult = {
              success: true,
              messageId: messageData.messageId,
              status: messageData.status?.name || 'PENDING'
            };
          } else {
            throw new Error(`Infobip API Error: ${infobipData.requestError?.serviceException?.text || 'Unknown error'}`);
          }
        } else if (settings.provider === 'kavenegar') {
          // Send via Kavenegar API
          const kavenegarUrl = `https://api.kavenegar.com/v1/${settings.api_key}/sms/send.json`;
          const kavenegarResponse = await fetch(kavenegarUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
              receptor: phoneNumber,
              message: message,
              sender: settings.sender_number || '1000596446'
            })
          });

          const kavenegarData = await kavenegarResponse.json();
          
          if (kavenegarResponse.ok && kavenegarData.return && kavenegarData.return.status === 200) {
            smsResult = {
              success: true,
              messageId: kavenegarData.entries[0].messageid.toString(),
              status: 'PENDING'
            };
          } else {
            throw new Error(`Kavenegar API Error: ${kavenegarData.return?.message || 'Unknown error'}`);
          }
        } else {
          // For other providers, simulate for now
          smsResult = {
            success: true,
            messageId: `PROVIDER_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            status: 'SIMULATED'
          };
        }

        res.json({
          success: true,
          message: settings.is_test_mode ? 
            `Ù¾ÛŒØ§Ù… ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (${settings.provider})` : 
            "Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
          messageId: smsResult.messageId,
          status: smsResult.status,
          provider: settings.provider,
          testMode: settings.is_test_mode
        });
        
        console.log(`âœ… Real SMS sent via ${settings.provider} - ID: ${smsResult.messageId}, Phone: ${phoneNumber}, Status: ${smsResult.status}`);
        
      } catch (smsError) {
        console.error('SMS sending error:', smsError);
        res.json({
          success: false,
          message: `Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ SMS: ${smsError.message}`,
          provider: settings.provider,
          testMode: settings.is_test_mode
        });
      }
      
    } catch (error) {
      console.error("Error sending test SMS:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… ØªØ³Øª"
      });
    }
  });

  // Get SMS settings
  app.get("/api/admin/sms/settings", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM sms_settings WHERE id = 1
      `);
      
      const settings = result.rows[0] || {
        isEnabled: false,
        provider: 'asiacell',
        customProviderName: '',
        apiKey: '',
        apiSecret: '',
        username: '',
        password: '',
        senderNumber: '',
        apiEndpoint: '',
        serviceType: 'pattern',
        patternId: '',
        serviceCode: '',
        codeLength: 6,
        codeExpiry: 300,
        maxAttempts: 3,
        rateLimitMinutes: 5
      };

      res.json({ success: true, settings });
    } catch (error) {
      console.error("Error fetching SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Update SMS settings - POST
  app.post("/api/admin/sms/settings", requireAuth, async (req, res) => {
    try {
      const settings = req.body;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        INSERT INTO sms_settings (id, is_enabled, provider, custom_provider_name, api_key, api_secret, username, password, sender_number, api_endpoint, service_type, pattern_id, service_code, code_length, code_expiry, max_attempts, rate_limit_minutes, updated_at)
        VALUES (1, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW())
        ON CONFLICT (id) DO UPDATE SET
          is_enabled = $1,
          provider = $2,
          custom_provider_name = $3,
          api_key = $4,
          api_secret = $5,
          username = $6,
          password = $7,
          sender_number = $8,
          api_endpoint = $9,
          service_type = $10,
          pattern_id = $11,
          service_code = $12,
          code_length = $13,
          code_expiry = $14,
          max_attempts = $15,
          rate_limit_minutes = $16,
          updated_at = NOW()
        RETURNING *
      `, [
        settings.isEnabled,
        settings.provider,
        settings.customProviderName,
        settings.apiKey,
        settings.apiSecret,
        settings.username,
        settings.password,
        settings.senderNumber,
        settings.apiEndpoint,
        settings.serviceType,
        settings.patternId,
        settings.serviceCode,
        settings.codeLength,
        settings.codeExpiry,
        settings.maxAttempts,
        settings.rateLimitMinutes
      ]);

      res.json({ success: true, settings: result.rows[0] });
    } catch (error) {
      console.error("Error updating SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Update SMS settings - PUT (for compatibility)
  app.put("/api/admin/sms/settings", requireAuth, async (req, res) => {
    try {
      const settings = req.body;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        INSERT INTO sms_settings (id, is_enabled, provider, custom_provider_name, api_key, api_secret, username, password, sender_number, api_endpoint, service_type, pattern_id, service_code, code_length, code_expiry, max_attempts, rate_limit_minutes, updated_at)
        VALUES (1, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW())
        ON CONFLICT (id) DO UPDATE SET
          is_enabled = $1,
          provider = $2,
          custom_provider_name = $3,
          api_key = $4,
          api_secret = $5,
          username = $6,
          password = $7,
          sender_number = $8,
          api_endpoint = $9,
          service_type = $10,
          pattern_id = $11,
          service_code = $12,
          code_length = $13,
          code_expiry = $14,
          max_attempts = $15,
          rate_limit_minutes = $16,
          updated_at = NOW()
        RETURNING *
      `, [
        settings.isEnabled,
        settings.provider,
        settings.customProviderName,
        settings.apiKey,
        settings.apiSecret,
        settings.username,
        settings.password,
        settings.senderNumber,
        settings.apiEndpoint,
        settings.serviceType,
        settings.patternId,
        settings.serviceCode,
        settings.codeLength,
        settings.codeExpiry,
        settings.maxAttempts,
        settings.rateLimitMinutes
      ]);

      res.json({ success: true, settings: result.rows[0] });
    } catch (error) {
      console.error("Error updating SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Test SMS sending
  app.post("/api/admin/sms/test", requireAuth, async (req, res) => {
    try {
      const { phoneNumber, message } = req.body;
      
      if (!phoneNumber || !message) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù¾ÛŒØ§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { createSmsService } = await import('./sms-service.js');
      const smsService = await createSmsService();
      
      const result = await smsService.sendSms({
        to: phoneNumber,
        message: message
      });

      if (result.success) {
        res.json({ 
          success: true, 
          message: "Ù¾ÛŒØ§Ù…Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
          messageId: result.messageId 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: `Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú©: ${result.error}` 
        });
      }
    } catch (error) {
      console.error("Error testing SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª SMS" });
    }
  });

  // Test SMS connection
  app.post("/api/admin/sms/test-connection", requireAuth, async (req, res) => {
    try {
      const { createSmsService } = await import('./sms-service.js');
      const smsService = await createSmsService();
      
      const result = await smsService.testConnection();

      if (result.success) {
        res.json({ 
          success: true, 
          message: "Ø§ØªØµØ§Ù„ SMS Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ³Øª Ø´Ø¯",
          messageId: result.messageId 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: `Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§ØªØµØ§Ù„: ${result.error}` 
        });
      }
    } catch (error) {
      console.error("Error testing SMS connection:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§ØªØµØ§Ù„ SMS" });
    }
  });

  // Get SMS logs (simplified statistics)
  app.get("/api/admin/sms/logs", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get SMS logs from customer verification codes
      const logsResult = await pool.query(`
        SELECT 
          cvc.id,
          CONCAT(c.first_name, ' ', c.last_name) as recipient_name,
          cvc.phone_number as recipient_phone,
          'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø´Ù…Ø§: ' || cvc.verification_code as message_text,
          cvc.created_at as sent_at,
          CASE 
            WHEN cvc.is_used = true THEN 'delivered'
            ELSE 'sent'
          END as status
        FROM customer_verification_codes cvc
        LEFT JOIN crm_customers c ON c.phone = cvc.phone_number
        ORDER BY cvc.created_at DESC
        LIMIT 100
      `);

      const logs = logsResult.rows.map((row: any) => ({
        id: row.id,
        recipientName: row.recipient_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        recipientPhone: row.recipient_phone,
        messageText: row.message_text,
        sentAt: row.sent_at,
        status: row.status
      }));

      res.json({ success: true, data: logs });
    } catch (error) {
      console.error("Error fetching SMS logs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ SMS" });
    }
  });

  // Get customer SMS settings
  app.get("/api/admin/sms/customers", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          c.id,
          c.first_name,
          c.last_name,
          c.email,
          c.phone,
          c.company,
          c.customer_status,
          COALESCE(c.sms_enabled, true) as sms_enabled,
          (SELECT COUNT(*) FROM customer_orders WHERE customer_id = c.id) as total_orders,
          (SELECT MAX(created_at) FROM customer_orders WHERE customer_id = c.id) as last_order_date
        FROM crm_customers c
        WHERE c.is_active = true
        ORDER BY c.first_name, c.last_name
      `);

      const customers = result.rows.map((row: any) => ({
        id: row.id,
        firstName: row.first_name,
        lastName: row.last_name,
        email: row.email,
        phone: row.phone,
        company: row.company,
        smsEnabled: row.sms_enabled,
        customerStatus: row.customer_status,
        totalOrders: parseInt(row.total_orders || 0),
        lastOrderDate: row.last_order_date
      }));

      res.json({ success: true, customers });
    } catch (error) {
      console.error("Error fetching customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø´ØªØ±ÛŒØ§Ù†" });
    }
  });

  // Update customer SMS settings
  app.put("/api/admin/sms/customers/:customerId", requireAuth, async (req, res) => {
    try {
      const { customerId } = req.params;
      const { smsEnabled } = req.body;
      const { pool } = await import('./db');

      await pool.query(`
        UPDATE crm_customers 
        SET sms_enabled = $2
        WHERE id = $1
      `, [customerId, smsEnabled]);

      res.json({ success: true, message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø´ØªØ±ÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Bulk toggle SMS for customers
  app.post("/api/admin/sms/bulk-toggle", requireAuth, async (req, res) => {
    try {
      const { customerIds, smsEnabled } = req.body;
      const { pool } = await import('./db');

      if (!customerIds || !Array.isArray(customerIds)) {
        return res.status(400).json({ success: false, message: "Ù„ÛŒØ³Øª Ù…Ø´ØªØ±ÛŒØ§Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }

      const placeholders = customerIds.map((_, index) => `$${index + 2}`).join(',');
      const query = `
        UPDATE crm_customers 
        SET sms_enabled = $1
        WHERE id IN (${placeholders})
      `;

      await pool.query(query, [smsEnabled, ...customerIds]);

      res.json({ 
        success: true, 
        message: `ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS Ø¨Ø±Ø§ÛŒ ${customerIds.length} Ù…Ø´ØªØ±ÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯` 
      });
    } catch (error) {
      console.error("Error bulk updating SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Get SMS categories
  app.get("/api/admin/sms/categories", requireAuth, async (req, res) => {
    try {
      const categories = [
        {
          id: 'authentication',
          name: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª',
          description: 'Ú©Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ Ùˆ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒØ§Ù†',
          icon: 'Shield',
          enabled: true,
          messageTemplate: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø´Ù…Ø§: {{code}}',
          triggerConditions: ['Ø«Ø¨Øª Ù†Ø§Ù…', 'ÙˆØ±ÙˆØ¯', 'ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 245,
            lastSent: '2025-07-17T10:30:00Z',
            successRate: 98.5
          }
        },
        {
          id: 'order-management',
          name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
          description: 'Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
          icon: 'ShoppingCart',
          enabled: true,
          messageTemplate: 'Ø³ÙØ§Ø±Ø´ {{orderNumber}} {{status}} Ø´Ø¯',
          triggerConditions: ['Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´', 'ØªØ§ÛŒÛŒØ¯ Ø³ÙØ§Ø±Ø´', 'Ø§Ø±Ø³Ø§Ù„ Ø³ÙØ§Ø±Ø´'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 156,
            lastSent: '2025-07-17T09:15:00Z',
            successRate: 97.2
          }
        },
        {
          id: 'delivery-verification',
          name: 'ØªØ§ÛŒÛŒØ¯ ØªØ­ÙˆÛŒÙ„',
          description: 'Ú©Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ù„Ø§',
          icon: 'Truck',
          enabled: true,
          messageTemplate: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„: {{deliveryCode}} - Ù¾ÛŒÚ©: {{courierName}} {{courierPhone}}',
          triggerConditions: ['Ø§Ø±Ø³Ø§Ù„ ØªÙˆØ³Ø· Ù„Ø¬Ø³ØªÛŒÚ©'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 89,
            lastSent: '2025-07-17T08:45:00Z',
            successRate: 99.1
          }
        },
        {
          id: 'logistics_delivery_codes',
          name: 'Ú©Ø¯Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ù„Ø¬Ø³ØªÛŒÚ©',
          description: 'Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯Ù‡Ø§ÛŒ Û´ Ø±Ù‚Ù…ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù„Ø¬Ø³ØªÛŒÚ© Ø¨Ø±Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ù…Ø­Ù…ÙˆÙ„Ù‡',
          icon: 'Shield',
          enabled: true,
          messageTemplate: 'Ù…Ø´ØªØ±ÛŒ Ù…Ø­ØªØ±Ù… {{customerName}}\nÚ©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø³ÙØ§Ø±Ø´ {{customerOrderId}}: {{verificationCode}}\nÙ‡Ù†Ú¯Ø§Ù… ØªØ­ÙˆÛŒÙ„ Ù…Ø­Ù…ÙˆÙ„Ù‡ Ø§ÛŒÙ† Ú©Ø¯ Ø±Ø§ Ø¨Ù‡ Ø­Ù…Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø§Ø¹Ù„Ø§Ù… Ù†Ù…Ø§ÛŒÛŒØ¯.\nØ´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ',
          triggerConditions: ['Logistics code generated', 'Delivery code resent'],
          recipients: ['Customers with pending deliveries'],
          frequency: 'On-demand by logistics department',
          priority: 'high' as const,
          statistics: {
            totalSent: 0,
            lastSent: undefined,
            successRate: 100
          }
        },
        {
          id: 'customer-communications',
          name: 'Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª Ù…Ø´ØªØ±ÛŒ',
          description: 'Ù¾ÛŒØ§Ù…Ú©â€ŒÙ‡Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ Ùˆ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ',
          icon: 'MessageSquare',
          enabled: true,
          messageTemplate: 'Ù¾ÛŒØ§Ù… Ø§Ø² {{company}}: {{message}}',
          triggerConditions: ['Ø¯Ø³ØªÛŒ', 'Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø´Ø¯Ù‡'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ', 'Ú¯Ø±ÙˆÙ‡ Ù…Ø´ØªØ±ÛŒØ§Ù†'],
          frequency: 'Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø´Ø¯Ù‡',
          priority: 'medium' as const,
          statistics: {
            totalSent: 67,
            lastSent: '2025-07-16T15:20:00Z',
            successRate: 96.8
          }
        },
        {
          id: 'inventory-alerts',
          name: 'Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø§Ù†Ø¨Ø§Ø±',
          description: 'Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ú©Ù…Ø¨ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ÛŒ',
          icon: 'Package',
          enabled: true,
          messageTemplate: 'Ù‡Ø´Ø¯Ø§Ø±: Ù…ÙˆØ¬ÙˆØ¯ÛŒ {{productName}} Ú©Ù…ØªØ± Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø²',
          triggerConditions: ['Ú©Ù…Ø¨ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ÛŒ', 'Ø§ØªÙ…Ø§Ù… Ù…ÙˆØ¬ÙˆØ¯ÛŒ'],
          recipients: ['Ù…Ø¯ÛŒØ± Ø§Ù†Ø¨Ø§Ø±', 'Ù…Ø¯ÛŒØ± ÙØ±ÙˆØ´'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 23,
            lastSent: '2025-07-15T11:30:00Z',
            successRate: 100
          }
        },
        {
          id: 'admin-notifications',
          name: 'Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª',
          description: 'Ù¾ÛŒØ§Ù…Ú©â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ',
          icon: 'Bell',
          enabled: true,
          messageTemplate: 'Ø§Ø·Ù„Ø§Ø¹ Ø³ÛŒØ³ØªÙ…: {{message}}',
          triggerConditions: ['Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…', 'Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ'],
          recipients: ['Ù…Ø¯ÛŒØ±Ø§Ù† Ø³ÛŒØ³ØªÙ…'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 12,
            lastSent: '2025-07-14T09:00:00Z',
            successRate: 100
          }
        }
      ];

      res.json({ success: true, categories });
    } catch (error) {
      console.error("Error fetching SMS categories:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§" });
    }
  });

  // Update SMS category
  app.put("/api/admin/sms/categories/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      const { enabled, messageTemplate, priority } = req.body;
      
      // In a real implementation, this would update database
      // For now, we'll just return success
      res.json({ 
        success: true, 
        message: `Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ${categoryId} Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯`,
        category: {
          id: categoryId,
          enabled,
          messageTemplate,
          priority
        }
      });
    } catch (error) {
      console.error("Error updating SMS category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ" });
    }
  });

  // Get delivery logs
  app.get("/api/admin/sms/delivery-logs", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          dvc.id,
          dvc.customer_order_id as order_id,
          dvc.customer_name,
          dvc.customer_phone as phone,
          dvc.verification_code,
          dvc.sms_status,
          dvc.created_at,
          dvc.sms_delivered_at as delivered_at,
          dvc.is_used as is_verified
        FROM delivery_verification_codes dvc
        WHERE dvc.sms_sent = true
        ORDER BY dvc.created_at DESC
        LIMIT 100
      `);

      const deliveryLogs = result.rows.map((row: any) => ({
        id: row.id,
        orderId: row.order_id,
        customerName: row.customer_name,
        phone: row.phone,
        verificationCode: row.verification_code,
        smsStatus: row.sms_status || 'sent',
        createdAt: row.created_at,
        deliveredAt: row.delivered_at,
        isVerified: row.is_verified
      }));

      res.json({ success: true, data: deliveryLogs });
    } catch (error) {
      console.error("Error fetching delivery logs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯â€ŒÙ‡Ø§" });
    }
  });

  // Get SMS template for logistics delivery codes
  app.get("/api/sms/template/logistics-delivery", async (req, res) => {
    try {
      const template = '{{customerName}} Ø¹Ø²ÛŒØ²ØŒ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø¯Ø± Ø±Ø§Ù‡ Ø§Ø³Øª.\nÚ©Ø¯ ØªØ­ÙˆÛŒÙ„: {{verificationCode}}\nØ§ÛŒÙ† Ú©Ø¯ Ø±Ø§ Ù‡Ù†Ú¯Ø§Ù… ØªØ­ÙˆÛŒÙ„ Ø¨Ù‡ Ù¾ÛŒÚ© Ø§Ø¹Ù„Ø§Ù… Ú©Ù†ÛŒØ¯.\nÙ…Ù…ØªØ§Ø²Ú©Ù…';
      
      res.json({
        success: true,
        template: template
      });
    } catch (error) {
      console.error("Error fetching SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…Ú©"
      });
    }
  });

  // SMS Template Categories Management
  app.get("/api/admin/sms/template-categories", requireAuth, async (req: Request, res: Response) => {
    try {
      const categories = await smsStorage.getAllTemplateCategories();
      res.json({ success: true, data: categories });
    } catch (error) {
      console.error("Error fetching template categories:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.post("/api/admin/sms/template-categories", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryName, categoryDescription, systemUsage, displayOrder } = req.body;
      
      if (!categoryName || !systemUsage) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const categoryNumber = await smsStorage.getNextCategoryNumber();
      
      const category = await smsStorage.createTemplateCategory({
        categoryNumber,
        categoryName,
        categoryDescription,
        systemUsage,
        displayOrder: displayOrder || 0
      });

      res.json({ success: true, data: category, message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error creating template category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.put("/api/admin/sms/template-categories/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const category = await smsStorage.updateTemplateCategory(parseInt(id), updates);
      res.json({ success: true, data: category, message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating template category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.delete("/api/admin/sms/template-categories/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await smsStorage.deleteTemplateCategory(parseInt(id));
      res.json({ success: true, message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting template category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  // SMS Templates Management
  app.get("/api/admin/sms/templates", requireAuth, async (req: Request, res: Response) => {
    try {
      const templates = await smsStorage.getAllTemplates();
      res.json({ success: true, data: templates });
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§" });
    }
  });

  app.get("/api/admin/sms/templates/category/:categoryId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryId } = req.params;
      const templates = await smsStorage.getTemplatesByCategory(parseInt(categoryId));
      res.json({ success: true, data: templates });
    } catch (error) {
      console.error("Error fetching templates by category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ" });
    }
  });

  app.post("/api/admin/sms/templates", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryId, templateName, templateContent, variables, isDefault, createdBy } = req.body;
      
      if (!categoryId || !templateName || !templateContent) {
        return res.status(400).json({
          success: false,
          message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒØŒ Ù†Ø§Ù… Ù‚Ø§Ù„Ø¨ Ùˆ Ù…Ø­ØªÙˆØ§ÛŒ Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const templateNumber = await smsStorage.getNextTemplateNumber(parseInt(categoryId));
      
      const template = await smsStorage.createTemplate({
        categoryId: parseInt(categoryId),
        templateNumber,
        templateName,
        templateContent,
        variables: variables || [],
        isDefault: isDefault || false,
        createdBy: createdBy || 'admin'
      });

      res.json({ success: true, data: template, message: "Ù‚Ø§Ù„Ø¨ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.put("/api/admin/sms/templates/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const template = await smsStorage.updateTemplate(parseInt(id), updates);
      res.json({ success: true, data: template, message: "Ù‚Ø§Ù„Ø¨ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.delete("/api/admin/sms/templates/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await smsStorage.deleteTemplate(parseInt(id));
      res.json({ success: true, message: "Ù‚Ø§Ù„Ø¨ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.get("/api/admin/sms/templates/usage/:systemUsage", requireAuth, async (req: Request, res: Response) => {
    try {
      const { systemUsage } = req.params;
      const { isDefault } = req.query;
      
      const template = await smsStorage.getTemplateBySystemUsage(
        systemUsage, 
        isDefault === 'true' ? true : undefined
      );
      
      if (!template) {
        return res.status(404).json({
          success: false,
          message: "Ù‚Ø§Ù„Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø³ÛŒØ³ØªÙ… ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      res.json({ success: true, data: template });
    } catch (error) {
      console.error("Error fetching template by system usage:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.post("/api/admin/sms/templates/:id/usage", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await smsStorage.incrementTemplateUsage(parseInt(id));
      res.json({ success: true, message: "Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚Ø§Ù„Ø¨ Ø«Ø¨Øª Ø´Ø¯" });
    } catch (error) {
      console.error("Error incrementing template usage:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚Ø§Ù„Ø¨" });
    }
  });

  // Test SMS configuration
  app.post("/api/admin/sms/test", requireAuth, async (req, res) => {
    try {
      const { phone, message } = req.body;
      
      if (!phone || !message) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù¾ÛŒØ§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // For demo purposes, we'll simulate a successful SMS send
      // In real implementation, this would use the SMS service
      res.json({
        success: true,
        message: "Ù¾ÛŒØ§Ù…Ú© ØªØ³Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        testResult: {
          phone,
          message,
          status: 'sent',
          provider: 'kavenegar',
          sentAt: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error("Error testing SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú© ØªØ³Øª" });
    }
  });

  // Get batch information for a specific order
  app.get("/api/orders/:orderId/batch-info", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (!orderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const { unifiedInventoryManager } = await import('./unified-inventory-manager');
      const batchInfo = await unifiedInventoryManager.getBatchInfoForOrder(orderId);
      
      res.json({
        success: true,
        data: batchInfo,
        message: `Ø§Ø·Ù„Ø§Ø¹Ø§Øª ${batchInfo.length} Ø¨Ú† Ø¨Ø±Ø§ÛŒ Ø³ÙØ§Ø±Ø´ ${orderId} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error fetching batch info for order:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†" });
    }
  });



  // Get batch details for a specific product by barcode
  app.get("/api/inventory/product-batch-details/:barcode", requireAuth, async (req, res) => {
    try {
      const barcode = req.params.barcode;
      
      if (!barcode) {
        return res.status(400).json({
          success: false,
          message: "Ø¨Ø§Ø±Ú©Ø¯ Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const batchDetails = await UnifiedInventoryManager.getProductBatchDetails(barcode);
      
      if (!batchDetails) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ø§ÛŒÙ† Ø¨Ø§Ø±Ú©Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        data: batchDetails,
        message: `Ø§Ø·Ù„Ø§Ø¹Ø§Øª ${batchDetails.batches.length} Ø¨Ú† Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„ ${batchDetails.productName} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error fetching product batch details:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú† Ù…Ø­ØµÙˆÙ„" });
    }
  });

  // Generate invoice PDF with batch information
  app.get("/api/orders/:orderId/invoice-with-batch", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (!orderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get order details
      const order = await orderManagementStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Get customer details
      const customer = await crmStorage.getCrmCustomerById(order.customerId);
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Get batch information
      const { unifiedInventoryManager } = await import('./unified-inventory-manager');
      const batchInfo = await unifiedInventoryManager.getBatchInfoForOrder(orderId);

      // Generate PDF with batch information using PDFMake
      const { generateInvoicePDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateInvoicePDFWithPDFMake(
        customer,
        order,
        batchInfo,
        `ÙØ§Ú©ØªÙˆØ± Ø³ÙØ§Ø±Ø´ ${orderId}`
      );

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${orderId}-with-batch.pdf"`);
      res.setHeader('Content-Length', pdfBuffer.length.toString());

      // Send PDF
      res.send(pdfBuffer);

    } catch (error) {
      console.error("Error generating invoice with batch info:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ± Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†" });
    }
  });

  // Customer registration endpoint - CRM-centric approach
  app.post("/api/customers/register", async (req, res) => {
    try {
      const { 
        firstName, 
        lastName, 
        email, 
        password, 
        passwordHash, // Support both password and passwordHash
        phone, 
        company, 
        country, 
        city, 
        address,
        secondaryAddress,
        postalCode,
        alternatePhone,
        province,
        state,
        industry,
        businessType,
        companySize,
        communicationPreference,
        preferredLanguage,
        marketingConsent,
        customerType,
        customerSource,
        productInterests,
        creditLimit,
        paymentTerms,
        preferredPaymentMethod,
        assignedSalesRep,
        tags,
        publicNotes
      } = req.body;
      
      // Check if customer already exists in CRM (primary check)
      const existingCrmCustomer = await crmStorage.getCrmCustomerByEmail(email);
      if (existingCrmCustomer) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª. Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª." 
        });
      }

      // Check if phone number already exists in CRM
      const existingCrmPhone = await crmStorage.getCrmCustomerByPhone(phone);
      if (existingCrmPhone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª. Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª." 
        });
      }

      // Validate mandatory fields
      if (!email || !phone || !country || !province || !city || !address) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ØŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†ØŒ Ú©Ø´ÙˆØ±ØŒ Ø§Ø³ØªØ§Ù†ØŒ Ø´Ù‡Ø± Ùˆ Ø¢Ø¯Ø±Ø³ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ù‡Ø³ØªÙ†Ø¯" 
        });
      }

      // Hash password
      const finalPassword = password || passwordHash;
      const hashedPassword = await bcrypt.hash(finalPassword, 10);

      // Create CRM customer first (central repository) with password for unified auth
      const crmCustomerData = {
        email,
        passwordHash: hashedPassword,
        firstName,
        lastName,
        company: company || null,
        phone,
        alternatePhone: alternatePhone || null,
        country,
        province: province || null,
        cityRegion: city, // Support both city and cityRegion for Excel format
        address,
        secondaryAddress: secondaryAddress || null,
        postalCode: postalCode || null,
        industry: industry || null,
        businessType: businessType || null,
        companySize: companySize || null,
        communicationPreference: communicationPreference || 'email',
        preferredLanguage: preferredLanguage || 'en',
        marketingConsent: marketingConsent || false,
        productInterests: productInterests || null,
        creditLimit: creditLimit || null,
        paymentTerms: paymentTerms || 'immediate',
        preferredPaymentMethod: preferredPaymentMethod || null,
        assignedSalesRep: assignedSalesRep || null,
        tags: tags || null,
        publicNotes: publicNotes || null,
        customerType: customerType || 'retail',
        customerSource: customerSource || 'website',
        customerStatus: 'active',
        createdBy: 'customer_registration',
        internalNotes: 'Customer registered through online shop',
        isActive: true,
      };

      const crmCustomer = await crmStorage.createCrmCustomer(crmCustomerData);

      // Create corresponding customer portal entry with password (for authentication)
      let portalCustomer = null;
      try {
        const portalData = {
          email: crmCustomerData.email,
          passwordHash: hashedPassword, // Password stored only in portal for authentication
          firstName: crmCustomerData.firstName,
          lastName: crmCustomerData.lastName,
          company: crmCustomerData.company,
          phone: crmCustomerData.phone,
          country: crmCustomerData.country,
          city: crmCustomerData.cityRegion, // Map cityRegion back to city for portal compatibility
          address: crmCustomerData.address,
          postalCode: crmCustomerData.postalCode,
          isActive: true,
        };
        portalCustomer = await customerStorage.createCustomer(portalData);
      } catch (portalError) {
        console.log('Portal customer creation failed, CRM customer created successfully');
      }

      // Log registration activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: crmCustomer.id,
        activityType: 'registration',
        description: 'Customer registered through online shop',
        performedBy: 'system',
        activityData: {
          source: 'website',
          registrationDate: new Date().toISOString(),
          hasPortalAccess: !!portalCustomer,
          portalCustomerId: portalCustomer?.id,
        }
      });

      // Update customer metrics immediately after registration
      await crmStorage.updateCustomerMetrics(crmCustomer.id);

      // Send SMS verification after successful registration using template 4
      try {
        const verificationCode = Math.floor(1000 + Math.random() * 9000).toString(); // 4-digit code
        
        // Store verification code in database
        await db.execute(sql`
          INSERT INTO customer_verification_codes (customer_id, verification_code, phone_number, expires_at)
          VALUES (${crmCustomer.id}, ${verificationCode}, ${phone}, ${new Date(Date.now() + 10 * 60 * 1000)})
        `);
        
        // Get SMS template 4 for registration verification
        const template = await simpleSmsStorage.getTemplateById(4);
        
        if (template && template.templateContent && phone) {
          // Replace variables in template
          let smsMessage = template.templateContent;
          smsMessage = smsMessage.replace(/\{\{customer_name\}\}/g, `${firstName} ${lastName}`);
          smsMessage = smsMessage.replace(/\{\{verification_code\}\}/g, verificationCode);
          
          // Here you would integrate with your SMS provider
          // For now, we'll log the message and mark it as sent
          console.log(`ğŸ“± [SMS VERIFICATION] Registration verification sent to ${phone} - Template: ${template.templateName}`);
          
          // Increment template usage using direct SQL
          await simpleSmsDb.execute(sql`
            UPDATE simple_sms_templates 
            SET usage_count = usage_count + 1, 
                last_used = NOW(), 
                updated_at = NOW() 
            WHERE id = ${4}
          `);
          
          // Log SMS activity in CRM
          await crmStorage.logCustomerActivity({
            customerId: crmCustomer.id,
            activityType: 'sms_sent',
            description: 'Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯',
            performedBy: 'system',
            activityData: {
              phone: phone,
              template_id: 8,
              verification_code: verificationCode,
              sent_at: new Date().toISOString()
            }
          });
        }
      } catch (smsError) {
        console.error('SMS verification error:', smsError);
        // Don't fail registration if SMS fails
      }
      
      res.json({
        success: true,
        message: "Registration successful",
        customer: {
          id: portalCustomer?.id || crmCustomer.id,
          firstName: crmCustomer.firstName,
          lastName: crmCustomer.lastName,
          email: crmCustomer.email,
          crmId: crmCustomer.id,
        }
      });
    } catch (error) {
      console.error("Error registering customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Registration failed" 
      });
    }
  });

  // SMS Verification Endpoint
  app.post('/api/customer/verify-sms', async (req, res) => {
    try {
      const { phone, verificationCode } = req.body;
      
      if (!phone || !verificationCode) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
        });
      }

      // Find valid verification code
      const result = await db.execute(sql`
        SELECT * FROM customer_verification_codes 
        WHERE phone_number = ${phone} 
        AND verification_code = ${verificationCode}
        AND is_used = false 
        AND expires_at > NOW()
        ORDER BY created_at DESC
        LIMIT 1
      `);

      if (result.rows.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      const verificationRecord = result.rows[0];
      
      // Mark verification code as used
      await db.execute(sql`
        UPDATE customer_verification_codes 
        SET is_used = true 
        WHERE id = ${verificationRecord.id}
      `);

      // Activate customer profile
      await db.execute(sql`
        UPDATE crm_customers 
        SET customer_status = 'active', 
            is_verified = true,
            verified_at = NOW()
        WHERE id = ${verificationRecord.customer_id}
      `);

      // Get customer data
      const customer = await crmStorage.getCrmCustomerById(verificationRecord.customer_id);
      
      if (customer) {
        // Log verification activity
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: 'sms_verification_completed',
          description: 'Customer verified phone number via SMS',
          performedBy: 'system',
          activityData: {
            phone: phone,
            verificationCode: verificationCode,
            verifiedAt: new Date().toISOString()
          }
        });

        // Set customer session
        req.session.isAuthenticated = true;
        req.session.customerId = customer.id;
        req.session.customerType = 'crm';
        
        res.json({
          success: true,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
          customer: {
            id: customer.id,
            firstName: customer.firstName,
            lastName: customer.lastName,
            email: customer.email,
            phone: customer.phone,
            isVerified: true
          }
        });
      } else {
        res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }
    } catch (error) {
      console.error("SMS verification error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª" 
      });
    }
  });

  // Resend SMS Verification Code
  app.post('/api/customer/resend-verification', async (req, res) => {
    try {
      const { phone } = req.body;
      
      if (!phone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
        });
      }

      // Find customer by phone
      const customer = await crmStorage.getCrmCustomerByPhone(phone);
      if (!customer) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Generate new verification code
      const verificationCode = Math.floor(1000 + Math.random() * 9000).toString();
      
      // Store new verification code
      await db.execute(sql`
        INSERT INTO customer_verification_codes (customer_id, verification_code, phone_number, expires_at)
        VALUES (${customer.id}, ${verificationCode}, ${phone}, ${new Date(Date.now() + 10 * 60 * 1000)})
      `);

      // Get SMS template 4 for resend
      const template = await simpleSmsStorage.getTemplateById(4);
      
      if (template && template.templateContent) {
        let smsMessage = template.templateContent;
        smsMessage = smsMessage.replace(/\{\{customer_name\}\}/g, `${customer.firstName} ${customer.lastName}`);
        smsMessage = smsMessage.replace(/\{\{verification_code\}\}/g, verificationCode);
        
        console.log(`ğŸ“± [SMS RESEND] Verification code resent to ${phone}: ${smsMessage}`);
        
        // Increment template usage
        await simpleSmsDb.execute(sql`
          UPDATE simple_sms_templates 
          SET usage_count = usage_count + 1, 
              last_used = NOW(), 
              updated_at = NOW() 
          WHERE id = ${4}
        `);
        
        // Log resend activity
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: 'sms_resend',
          description: 'Verification code resent to customer',
          performedBy: 'system',
          activityData: {
            phone: phone,
            templateUsed: template.templateName,
            verificationCode: verificationCode
          }
        });
      }

      res.json({
        success: true,
        message: "Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("SMS resend error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯" 
      });
    }
  });

  app.post("/api/customers/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      
      // ONLY authenticate via CRM (single source of truth)
      const crmCustomer = await crmStorage.getCrmCustomerByEmail(email);
      
      if (!crmCustomer || !crmCustomer.passwordHash) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }
      
      // Check password against CRM customer only
      const isValidPassword = await bcrypt.compare(password, crmCustomer.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Clear any existing admin session first (single session mode)
      req.session.adminId = undefined;
      req.session.customUserId = undefined;
      
      // Store customer session using CRM ID as primary
      (req.session as any).customerId = crmCustomer.id;
      (req.session as any).customerEmail = crmCustomer.email;
      (req.session as any).crmCustomerId = crmCustomer.id;
      (req.session as any).isAuthenticated = true;
      
      // Explicitly save session to ensure persistence
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) {
            console.error('Session save error:', err);
            reject(err);
          } else {
            resolve();
          }
        });
      });
      
      console.log(`âœ… [CUSTOMER LOGIN] Session saved for customer ${crmCustomer.id}:`, {
        customerId: crmCustomer.id,
        customerEmail: crmCustomer.email,
        sessionId: req.sessionID
      });

      // Log login activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: crmCustomer.id,
        customerName: `${crmCustomer.firstName || ''} ${crmCustomer.lastName || ''}`.trim(),
        activityType: 'login',
        description: 'Ù…Ø´ØªØ±ÛŒ ÙˆØ§Ø±Ø¯ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¢Ù†Ù„Ø§ÛŒÙ† Ø´Ø¯',
        performedBy: 'customer',
        activityData: {
          email: crmCustomer.email,
          phone: crmCustomer.phone || '',
          source: 'website',
          loginDate: new Date().toISOString(),
          userAgent: req.headers['user-agent'] || 'unknown',
          loginMethod: 'crm_direct'
        }
      });

      res.json({
        success: true,
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚",
        customer: {
          id: crmCustomer.id,
          firstName: crmCustomer.firstName,
          lastName: crmCustomer.lastName,
          email: crmCustomer.email,
          company: crmCustomer.company,
          phone: crmCustomer.phone,
          country: crmCustomer.country,
          city: crmCustomer.city,
          address: crmCustomer.address,
          crmId: crmCustomer.id,
        }
      });
    } catch (error) {
      console.error("Error logging in customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" 
      });
    }
  });

  // Change customer password endpoint
  app.post("/api/customers/change-password", async (req, res) => {
    try {
      const { oldPassword, newPassword } = req.body;
      
      // Check authentication
      const customerId = (req.session as any).customerId;
      if (!customerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù„Ø§Ø²Ù… Ø§Ø³Øª" 
        });
      }

      // Validate input
      if (!oldPassword || !newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù‚Ø¯ÛŒÙ…ÛŒ Ùˆ Ø¬Ø¯ÛŒØ¯ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
        });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 6 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯" 
        });
      }

      // Get current customer from CRM
      const crmCustomer = await crmStorage.getCrmCustomerById(customerId);
      if (!crmCustomer || !crmCustomer.passwordHash) {
        return res.status(404).json({ 
          success: false, 
          message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Verify old password
      const isOldPasswordValid = await bcrypt.compare(oldPassword, crmCustomer.passwordHash);
      if (!isOldPasswordValid) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù‚Ø¯ÛŒÙ…ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Generate new password hash
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password in CRM database
      await crmStorage.updateCrmCustomer(customerId, {
        passwordHash: newPasswordHash
      });

      console.log(`âœ… [PASSWORD CHANGE] Password updated for customer ${customerId} (${crmCustomer.email})`);

      // Log password change activity
      await crmStorage.logCustomerActivity({
        customerId: customerId,
        customerName: `${crmCustomer.firstName || ''} ${crmCustomer.lastName || ''}`.trim(),
        activityType: 'password_change',
        description: 'Ù…Ø´ØªØ±ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø®ÙˆØ¯ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯',
        performedBy: 'customer',
        activityData: {
          email: crmCustomer.email,
          changeDate: new Date().toISOString(),
          userAgent: req.headers['user-agent'] || 'unknown',
          source: 'website'
        }
      });

      res.json({
        success: true,
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª"
      });

    } catch (error) {
      console.error("Password change error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" 
      });
    }
  });

  // =============================================================================
  // DUAL VERIFICATION SYSTEM (SMS + EMAIL)
  // =============================================================================

  // Create dual verification codes (SMS + Email) during registration
  app.post("/api/customer/send-dual-verification", async (req, res) => {
    try {
      const { email, phone, firstName, lastName } = req.body;
      
      if (!email || !phone || !firstName || !lastName) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Get verification settings to check what's enabled
      const settings = await customerStorage.getVerificationSettings();
      
      if (!settings || (!settings.smsVerificationEnabled && !settings.emailVerificationEnabled)) {
        return res.status(400).json({
          success: false,
          message: "Ø³ÛŒØ³ØªÙ… Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª"
        });
      }

      let smsCodeSent = false;
      let emailCodeSent = false;

      // Generate and send SMS verification code if enabled
      if (settings.smsVerificationEnabled) {
        const smsCode = Math.floor(1000 + Math.random() * 9000).toString();
        await customerStorage.createSmsVerificationCode(null, phone, smsCode);
        
        // TODO: Integrate with SMS service to send actual SMS
        console.log(`ğŸ“± SMS verification code for ${phone}: ${smsCode}`);
        smsCodeSent = true;
      }

      // Generate and send email verification code if enabled
      if (settings.emailVerificationEnabled) {
        const emailCode = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit code
        await customerStorage.createEmailVerificationCode(null, email, emailCode);

        // Send email using universal email service
        try {
          const { UniversalEmailService } = await import('./universal-email-service');
          
          const emailSent = await UniversalEmailService.sendEmail({
            categoryKey: 'customer_support',
            to: [email],
            subject: 'Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø§ÛŒÙ…ÛŒÙ„ - Momtaz Chemical',
            html: `
              <div style="font-family: Arial, sans-serif; direction: rtl; text-align: right;">
                <h2>Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø§ÛŒÙ…ÛŒÙ„</h2>
                <p>Ø³Ù„Ø§Ù… ${firstName} ${lastName} Ø¹Ø²ÛŒØ²ØŒ</p>
                <p>Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§:</p>
                <div style="background: #f0f0f0; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; margin: 20px 0;">
                  ${emailCode}
                </div>
                <p>Ø§ÛŒÙ† Ú©Ø¯ ØªØ§ 30 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.</p>
                <p>Ø¨Ø§ ØªØ´Ú©Ø±ØŒ<br>ØªÛŒÙ… Momtaz Chemical</p>
              </div>
            `,
            variables: {
              firstName,
              lastName,
              verificationCode: emailCode
            }
          });
          
          emailCodeSent = emailSent;
          console.log(`ğŸ“§ Email verification code sent to ${email}: ${emailCode}`);
        } catch (emailError) {
          console.error("Error sending email verification:", emailError);
          emailCodeSent = false;
        }
      }

      const response: any = {
        success: true,
        message: "Ú©Ø¯Ù‡Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        verificationMethods: {
          sms: smsCodeSent,
          email: emailCodeSent
        }
      };

      if (settings.requireBothVerifications) {
        response.requiresBoth = true;
        response.message = "Ù„Ø·ÙØ§Ù‹ Ù‡Ø± Ø¯Ùˆ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ (SMS Ùˆ Ø§ÛŒÙ…ÛŒÙ„) Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯";
      }

      res.json(response);
    } catch (error) {
      console.error("Error sending dual verification:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯Ù‡Ø§ÛŒ ØªØ£ÛŒÛŒØ¯" 
      });
    }
  });

  // Verify dual codes (SMS + Email)
  app.post("/api/customer/verify-dual-codes", async (req, res) => {
    try {
      const { email, phone, smsCode, emailCode } = req.body;
      
      if (!email || !phone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ Ùˆ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Get verification settings
      const settings = await customerStorage.getVerificationSettings();
      
      if (!settings) {
        return res.status(400).json({
          success: false,
          message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      let smsVerified = false;
      let emailVerified = false;

      // Verify SMS code if enabled
      if (settings.smsVerificationEnabled && smsCode) {
        const smsResult = await customerStorage.verifySmsCode(phone, smsCode);
        smsVerified = !!smsResult;
      } else if (!settings.smsVerificationEnabled) {
        smsVerified = true; // Skip SMS if disabled
      }

      // Verify email code if enabled
      if (settings.emailVerificationEnabled && emailCode) {
        const emailResult = await customerStorage.verifyEmailCode(email, emailCode);
        emailVerified = !!emailResult;
      } else if (!settings.emailVerificationEnabled) {
        emailVerified = true; // Skip email if disabled
      }

      // Check if verification is complete based on settings
      const verificationComplete = settings.requireBothVerifications 
        ? (smsVerified && emailVerified)
        : (smsVerified || emailVerified);

      if (verificationComplete) {
        res.json({
          success: true,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
          verified: {
            sms: smsVerified,
            email: emailVerified,
            complete: true
          }
        });
      } else {
        res.status(400).json({
          success: false,
          message: "Ú©Ø¯Ù‡Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù†Ø§Ù‚Øµ Ø§Ø³Øª",
          verified: {
            sms: smsVerified,
            email: emailVerified,
            complete: false
          }
        });
      }
    } catch (error) {
      console.error("Error verifying dual codes:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø¯Ù‡Ø§" 
      });
    }
  });

  // Get verification settings (public endpoint)
  app.get("/api/customer/verification-settings", async (req, res) => {
    try {
      const settings = await customerStorage.getVerificationSettings();
      
      if (!settings) {
        // Return default settings if none exist
        res.json({
          success: true,
          settings: {
            smsVerificationEnabled: true,
            emailVerificationEnabled: true,
            requireBothVerifications: true,
            allowSkipVerification: false
          }
        });
      } else {
        res.json({
          success: true,
          settings: {
            smsVerificationEnabled: settings.smsVerificationEnabled,
            emailVerificationEnabled: settings.emailVerificationEnabled,
            requireBothVerifications: settings.requireBothVerifications,
            allowSkipVerification: settings.allowSkipVerification
          }
        });
      }
    } catch (error) {
      console.error("Error fetching verification settings:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª" 
      });
    }
  });

  app.post("/api/customers/logout", async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const customerEmail = (req.session as any).customerEmail;
      
      // Log logout activity before clearing session
      if (customerId) {
        try {
          // Get customer info for activity logging
          const crmCustomer = await crmStorage.getCrmCustomerById(customerId);
          
          await crmStorage.logCustomerActivity({
            customerId: customerId,
            customerName: crmCustomer ? `${crmCustomer.firstName || ''} ${crmCustomer.lastName || ''}`.trim() : 'Ù†Ø§Ù… Ù†Ø§Ù…Ø´Ø®Øµ',
            activityType: 'logout',
            description: 'Ù…Ø´ØªØ±ÛŒ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¢Ù†Ù„Ø§ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯',
            performedBy: 'customer',
            activityData: {
              email: customerEmail || crmCustomer?.email || '',
              phone: crmCustomer?.phone || '',
              source: 'website',
              logoutDate: new Date().toISOString(),
              userAgent: req.headers['user-agent'] || 'unknown',
              sessionId: req.sessionID
            }
          });
          
          console.log(`ğŸ“ [CUSTOMER LOGOUT] Activity logged for customer ${customerId}`);
        } catch (activityError) {
          console.error('Error logging logout activity:', activityError);
          // Continue with logout even if activity logging fails
        }
      }
      
      // Clear all session data (single session mode)
      req.session.customerId = undefined;
      req.session.customerEmail = undefined;
      req.session.crmCustomerId = undefined;
      req.session.adminId = undefined;
      req.session.customUserId = undefined;
      req.session.isAuthenticated = undefined;
      
      // Always destroy entire session for clean logout
      req.session.destroy((err) => {
        if (err) {
          console.error("Error destroying session:", err);
          return res.status(500).json({ 
            success: false, 
            message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬" 
          });
        }
        console.log('ğŸ”„ Complete customer logout - all sessions cleared');
        res.json({
          success: true,
          message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚"
        });
      });
    } catch (error) {
      console.error("Error logging out customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬" 
      });
    }
  });

  // =============================================================================
  // ABANDONED CART ENDPOINTS (CUSTOMER SECTION)
  // =============================================================================

  // Customer abandoned carts
  app.get("/api/customers/abandoned-carts", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      console.log(`ğŸ›’ [API DEBUG] Customer ${customerId} requesting abandoned carts`);
      const abandonedCarts = await cartStorage.getAbandonedCartsByCustomer(customerId);
      console.log(`ğŸ›’ [API DEBUG] Retrieved ${abandonedCarts.length} abandoned carts`);
      
      // Get cart details with items for each abandoned cart
      const cartsWithDetails = abandonedCarts.map((cart) => {
        let items = [];
        try {
          // Parse cart data JSON to get items
          items = typeof cart.cartData === 'string' ? JSON.parse(cart.cartData) : cart.cartData;
          if (!Array.isArray(items)) {
            items = [];
          }
        } catch (error) {
          console.error('Error parsing cart data:', error);
          items = [];
        }
        
        return {
          ...cart,
          items: items,
          hasItems: items.length > 0
        };
      });
      
      res.json({
        success: true,
        data: cartsWithDetails,
        count: cartsWithDetails.length
      });
    } catch (error) {
      console.error('Error getting abandoned carts:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³Ø¨Ø¯Ù‡Ø§ÛŒ Ø±Ù‡Ø§ Ø´Ø¯Ù‡'
      });
    }
  });

  // Complete abandoned cart (restore to active)
  app.post("/api/customers/abandoned-carts/:cartId/restore", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const cartId = parseInt(req.params.cartId);
      
      // Verify cart ownership
      const cart = await cartStorage.getCartSessionById(cartId);
      if (!cart || cart.customerId !== customerId) {
        return res.status(404).json({
          success: false,
          message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }
      
      // Restore cart to active state
      await cartStorage.updateCartSession(cartId, {
        isAbandoned: false,
        abandonedAt: null,
        lastActivity: new Date(),
        isActive: true
      });
      
      console.log(`ğŸ›’ [CART RESTORE] Customer ${customerId} restored cart ${cartId}`);
      
      res.json({
        success: true,
        message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error restoring abandoned cart:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯'
      });
    }
  });

  // Delete abandoned cart permanently
  app.delete("/api/customers/abandoned-carts/:cartId", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const cartId = parseInt(req.params.cartId);
      
      // Verify cart ownership
      const cart = await cartStorage.getCartSessionById(cartId);
      if (!cart || cart.customerId !== customerId) {
        return res.status(404).json({
          success: false,
          message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }
      
      // Delete cart permanently
      await cartStorage.deleteAbandonedCart(cartId);
      
      console.log(`ğŸ›’ [CART DELETE] Customer ${customerId} deleted abandoned cart ${cartId}`);
      
      res.json({
        success: true,
        message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error deleting abandoned cart:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯'
      });
    }
  });

  // =============================================================================
  // PERSISTENT CART ENDPOINTS (CUSTOMER SECTION)
  // =============================================================================

  // Get customer's persistent cart
  app.get("/api/customers/persistent-cart", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      console.log('ğŸ›’ [PERSISTENT CART] Getting cart for customer:', customerId);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM persistent_carts 
        WHERE customer_id = $1 
        ORDER BY updated_at DESC 
        LIMIT 1
      `, [customerId]);
      
      if (result.rows.length > 0) {
        const cart = result.rows[0];
        const cartData = typeof cart.cart_data === 'string' ? JSON.parse(cart.cart_data) : cart.cart_data;
        console.log('âœ… [PERSISTENT CART] Found cart:', cartData);
        
        res.json({
          success: true,
          data: {
            cartData,
            lastUpdated: cart.updated_at
          }
        });
      } else {
        console.log('âš ï¸ [PERSISTENT CART] No cart found for customer');
        res.json({
          success: true,
          data: {
            cartData: {},
            lastUpdated: null
          }
        });
      }
    } catch (error) {
      console.error('âŒ [PERSISTENT CART] Error getting cart:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯'
      });
    }
  });

  // Sync customer's persistent cart to database
  app.post("/api/customers/persistent-cart/sync", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const { cartData } = req.body;
      
      console.log('ğŸ›’ [PERSISTENT CART] Syncing cart for customer:', customerId);
      console.log('ğŸ›’ [PERSISTENT CART] Cart data:', cartData);
      
      const { pool } = await import('./db');
      
      // Upsert cart data (insert or update)
      await pool.query(`
        INSERT INTO persistent_carts (customer_id, cart_data, updated_at)
        VALUES ($1, $2, NOW())
        ON CONFLICT (customer_id)
        DO UPDATE SET 
          cart_data = $2,
          updated_at = NOW()
      `, [customerId, JSON.stringify(cartData)]);
      
      console.log('âœ… [PERSISTENT CART] Cart synced successfully');
      
      res.json({
        success: true,
        message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯'
      });
    } catch (error) {
      console.error('âŒ [PERSISTENT CART] Error syncing cart:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯'
      });
    }
  });

  // Save product to customer's persistent cart
  app.post("/api/customers/persistent-cart/save", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const { productId, quantity, unitPrice } = req.body;
      
      console.log('ğŸ›’ [PERSISTENT CART SAVE] Saving product for customer:', customerId, { productId, quantity });
      
      const { pool } = await import('./db');
      
      // Get current cart data
      const result = await pool.query(`
        SELECT cart_data FROM persistent_carts 
        WHERE customer_id = $1
      `, [customerId]);
      
      let cartData = {};
      if (result.rows.length > 0) {
        const existing = result.rows[0].cart_data;
        cartData = typeof existing === 'string' ? JSON.parse(existing) : existing;
      }
      
      // Update product quantity
      cartData[productId] = quantity;
      
      // Upsert cart data
      await pool.query(`
        INSERT INTO persistent_carts (customer_id, cart_data, updated_at)
        VALUES ($1, $2, NOW())
        ON CONFLICT (customer_id)
        DO UPDATE SET 
          cart_data = $2,
          updated_at = NOW()
      `, [customerId, JSON.stringify(cartData)]);
      
      console.log('âœ… [PERSISTENT CART SAVE] Product saved successfully');
      
      res.json({
        success: true,
        message: 'Ù…Ø­ØµÙˆÙ„ Ø¨Ù‡ Ø³Ø¨Ø¯ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯'
      });
    } catch (error) {
      console.error('âŒ [PERSISTENT CART SAVE] Error saving product:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø­ØµÙˆÙ„'
      });
    }
  });

  // Update product quantity in customer's persistent cart
  app.put("/api/customers/persistent-cart/update", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const { productId, quantity } = req.body;
      
      console.log('ğŸ›’ [PERSISTENT CART UPDATE] Updating product for customer:', customerId, { productId, quantity });
      
      const { pool } = await import('./db');
      
      // Get current cart data
      const result = await pool.query(`
        SELECT cart_data FROM persistent_carts 
        WHERE customer_id = $1
      `, [customerId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }
      
      const existing = result.rows[0].cart_data;
      const cartData = typeof existing === 'string' ? JSON.parse(existing) : existing;
      
      // Update product quantity
      cartData[productId] = quantity;
      
      // Update cart data
      await pool.query(`
        UPDATE persistent_carts 
        SET cart_data = $1, updated_at = NOW()
        WHERE customer_id = $2
      `, [JSON.stringify(cartData), customerId]);
      
      console.log('âœ… [PERSISTENT CART UPDATE] Product updated successfully');
      
      res.json({
        success: true,
        message: 'ØªØ¹Ø¯Ø§Ø¯ Ù…Ø­ØµÙˆÙ„ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });
    } catch (error) {
      console.error('âŒ [PERSISTENT CART UPDATE] Error updating product:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø­ØµÙˆÙ„'
      });
    }
  });

  // Remove product from customer's persistent cart
  app.delete("/api/customers/persistent-cart/remove", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      const { productId } = req.body;
      
      console.log('ğŸ›’ [PERSISTENT CART REMOVE] Removing product for customer:', customerId, { productId });
      
      const { pool } = await import('./db');
      
      // Get current cart data
      const result = await pool.query(`
        SELECT cart_data FROM persistent_carts 
        WHERE customer_id = $1
      `, [customerId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }
      
      const existing = result.rows[0].cart_data;
      const cartData = typeof existing === 'string' ? JSON.parse(existing) : existing;
      
      // Remove product
      delete cartData[productId];
      
      // Update cart data
      await pool.query(`
        UPDATE persistent_carts 
        SET cart_data = $1, updated_at = NOW()
        WHERE customer_id = $2
      `, [JSON.stringify(cartData), customerId]);
      
      console.log('âœ… [PERSISTENT CART REMOVE] Product removed successfully');
      
      res.json({
        success: true,
        message: 'Ù…Ø­ØµÙˆÙ„ Ø§Ø² Ø³Ø¨Ø¯ Ø­Ø°Ù Ø´Ø¯'
      });
    } catch (error) {
      console.error('âŒ [PERSISTENT CART REMOVE] Error removing product:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø­ØµÙˆÙ„'
      });
    }
  });

  // Clear customer's persistent cart
  app.delete("/api/customers/persistent-cart/clear", requireCustomerAuth, async (req, res) => {
    try {
      const customerId = (req.session as any).customerId;
      console.log('ğŸ›’ [PERSISTENT CART CLEAR] Clearing cart for customer:', customerId);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        DELETE FROM persistent_carts 
        WHERE customer_id = $1
      `, [customerId]);
      
      console.log(`âœ… [PERSISTENT CART CLEAR] Deleted ${result.rowCount} cart records for customer ${customerId}`);
      
      res.json({
        success: true,
        message: 'Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯ Ù¾Ø§Ú© Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error clearing persistent cart:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø³Ø¨Ø¯ Ø®Ø±ÛŒØ¯'
      });
    }
  });

  // Update customer profile
  app.patch("/api/customers/:id", async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const updateData = req.body;
      
      // Get session customer ID
      const sessionCustomerId = (req.session as any)?.customerId;
      const sessionCrmId = (req.session as any)?.crmCustomerId;
      
      // Ensure customer can only update their own profile
      if (customerId !== sessionCustomerId && customerId !== sessionCrmId) {
        return res.status(403).json({ 
          success: false, 
          message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª" 
        });
      }

      // Update customer in CRM (primary source)
      if (sessionCrmId) {
        const updatedCustomer = await crmStorage.updateCrmCustomer(sessionCrmId, updateData);
        res.json({
          success: true,
          message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
          customer: updatedCustomer
        });
      } else {
        // Fallback to portal customer update
        const updatedCustomer = await customerStorage.updateCustomer(customerId, updateData);
        res.json({
          success: true,
          message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
          customer: updatedCustomer
        });
      }
    } catch (error) {
      console.error("Error updating customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„" 
      });
    }
  });

  // Get complete CRM customer data for logged-in customer
  app.get("/api/customer/crm-profile", async (req, res) => {
    console.log('=== /api/customer/crm-profile endpoint called ===');
    try {
      const session = req.session as any;
      const crmCustomerId = session?.crmCustomerId;
      
      console.log('Session data:', {
        hasSession: !!session,
        customerId: session?.customerId,
        crmCustomerId: crmCustomerId,
        customerEmail: session?.customerEmail
      });
      
      if (!crmCustomerId) {
        console.log('No CRM customer ID found in session');
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡ ÛŒØ§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª CRM Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª" 
        });
      }

      console.log(`Fetching CRM customer with ID: ${crmCustomerId}`);
      const crmCustomer = await crmStorage.getCrmCustomerById(crmCustomerId);
      
      if (!crmCustomer) {
        console.log('CRM customer not found in database');
        return res.status(404).json({ 
          success: false, 
          message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ Ø¯Ø± CRM ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      console.log('CRM customer found:', {
        id: crmCustomer.id,
        email: crmCustomer.email,
        firstName: crmCustomer.firstName,
        lastName: crmCustomer.lastName,
        hasSecondaryAddress: !!crmCustomer.secondaryAddress,
        hasPostalCode: !!crmCustomer.postalCode
      });

      res.json({
        success: true,
        data: crmCustomer
      });
    } catch (error) {
      console.error("Error fetching CRM customer profile:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª CRM" 
      });
    }
  });

  app.get("/api/customers/me", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const adminId = (req.session as any)?.adminId;
      
      // If admin is logged in, don't allow customer data access
      if (adminId) {
        return res.status(401).json({ 
          success: false, 
          message: "Admin authenticated - not a customer" 
        });
      }
      
      if (!customerId && !crmCustomerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }

      // Prioritize CRM customer data
      let customer = null;
      let crmCustomer = null;

      if (crmCustomerId) {
        crmCustomer = await crmStorage.getCrmCustomerById(crmCustomerId);
        if (crmCustomer) {
          customer = crmCustomer; // Use CRM as primary source
          
          // Debug log for customer data
          console.log('ğŸ” [CRM GET] Customer data from DB:', {
            id: customer.id,
            website: customer.website,
            taxId: customer.taxId,
            registrationNumber: customer.registrationNumber,
            annualRevenue: customer.annualRevenue,
            priceRange: customer.priceRange,
            cityRegion: customer.cityRegion, // DEBUG: Check if cityRegion exists
            city: customer.city,
            province: customer.province
          });
        }
      }

      // Fallback to portal customer if CRM not available
      if (!customer && customerId) {
        const portalCustomer = await customerStorage.getCustomerById(customerId);
        if (portalCustomer) {
          customer = portalCustomer;
        }
      }

      if (!customer) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      res.json({
        success: true,
        customer: {
          id: customer.id,
          firstName: customer.firstName,
          lastName: customer.lastName,
          email: customer.email,
          company: customer.company || '',
          phone: customer.phone || '',
          country: customer.country || '',
          province: customer.province || '',
          city: customer.city || '',
          cityRegion: customer.cityRegion || customer.city_region || customer.city || '', // CRITICAL FIX: Check both cityRegion and city_region
          address: customer.address || '',
          postalCode: customer.postalCode,
          crmId: crmCustomer?.id || customer.id,
          totalOrders: crmCustomer?.totalOrdersCount || 0,
          totalOrderValue: crmCustomer?.totalSpent || "0",
          averageOrderValue: crmCustomer?.averageOrderValue || "0",
          lastOrderDate: crmCustomer?.lastOrderDate,
          customerStatus: crmCustomer?.customerStatus || 'active',
          customerType: crmCustomer?.customerType || 'retail',
          // Additional fields for profile editing
          secondaryAddress: customer.secondaryAddress,
          alternatePhone: customer.alternatePhone,
          industry: customer.industry,
          businessType: customer.businessType,
          companySize: customer.companySize,
          communicationPreference: customer.communicationPreference,
          preferredLanguage: customer.preferredLanguage,
          marketingConsent: customer.marketingConsent,
          notes: customer.publicNotes || customer.notes,
          preferredPaymentMethod: customer.preferredPaymentMethod,
          creditLimit: customer.creditLimit,
          website: customer.website,
          taxId: customer.taxId,
          registrationNumber: customer.registrationNumber,
          leadSource: customer.customerSource || customer.leadSource,
          assignedSalesRep: customer.assignedSalesRep,
          // Additional CRM fields that were missing
          annualRevenue: customer.annualRevenue,
          priceRange: customer.priceRange,
          orderFrequency: customer.orderFrequency,
          creditStatus: customer.creditStatus,
          smsEnabled: customer.smsEnabled,
          emailEnabled: customer.emailEnabled,
        }
      });
    } catch (error) {
      console.error("Error getting customer info:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª" 
      });
    }
  });

  // Update customer profile
  app.put("/api/customers/me", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const adminId = (req.session as any)?.adminId;
      
      // If admin is logged in, don't allow customer data access
      if (adminId) {
        return res.status(401).json({ 
          success: false, 
          message: "Admin authenticated - not a customer" 
        });
      }
      
      if (!customerId && !crmCustomerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }

      const {
        firstName,
        lastName,
        email,
        company,
        alternatePhone,
        country,
        province,
        city,
        address,
        secondaryAddress,
        postalCode,
        industry,
        businessType,
        companySize,
        communicationPreference,
        preferredLanguage,
        marketingConsent,
        // Additional fields
        taxId,
        registrationNumber,
        website,
        creditLimit,
        preferredPaymentMethod,
        customerType,
        leadSource,
        assignedSalesRep,
        notes,
        // CRM fields
        annualRevenue,
        priceRange,
        orderFrequency,
        creditStatus,
        smsEnabled,
        emailEnabled
      } = req.body;

      // Prioritize updating CRM customer data
      if (crmCustomerId) {
        const updateData = {
          firstName,
          lastName,
          email,
          company: company || null,
          alternatePhone: alternatePhone || null,
          country,
          province,
          city,
          address,
          secondaryAddress: secondaryAddress || null,
          postalCode: postalCode || null,
          industry: industry || null,
          businessType: businessType || null,
          companySize: companySize || null,
          communicationPreference: communicationPreference || 'email',
          preferredLanguage: preferredLanguage || 'en',
          marketingConsent: marketingConsent || false,
          // Additional fields
          taxId: taxId || null,
          registrationNumber: registrationNumber || null,
          website: website || null,
          creditLimit: creditLimit || null,
          preferredPaymentMethod: preferredPaymentMethod || null,
          customerType: customerType || null,
          leadSource: leadSource || null,
          assignedSalesRep: assignedSalesRep || null,
          notes: notes || null,
          // CRM fields
          annualRevenue: annualRevenue || null,
          priceRange: priceRange || null,
          orderFrequency: orderFrequency || null,
          creditStatus: creditStatus || null,
          smsEnabled: smsEnabled || false,
          emailEnabled: emailEnabled || false
        };

        await crmStorage.updateCrmCustomer(crmCustomerId, updateData);
        
        // Get updated customer data
        const updatedCustomer = await crmStorage.getCrmCustomerById(crmCustomerId);
        
        res.json({
          success: true,
          message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
          customer: updatedCustomer
        });
      } else if (customerId) {
        // Fallback to updating portal customer
        const updateData = {
          firstName,
          lastName,
          email,
          company: company || '',
          phone: req.body.phone, // Keep original phone
          country,
          city,
          address,
          postalCode: postalCode || ''
        };

        await customerStorage.updateCustomer(customerId, updateData);
        
        // Get updated customer data
        const updatedCustomer = await customerStorage.getCustomerById(customerId);
        
        res.json({
          success: true,
          message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
          customer: updatedCustomer
        });
      } else {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

    } catch (error) {
      console.error("Error updating customer profile:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„" 
      });
    }
  });

  // Create shop order and integrate with CRM
  app.post("/api/shop/orders", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const { items, customerInfo, recipientInfo, totalAmount, shippingCost, notes, shippingMethod, paymentMethod, walletAmountUsed, remainingAmount, vatAmount, dutiesAmount } = req.body;
      
      console.log('ğŸ›’ [ORDER DEBUG] Order data received:', {
        paymentMethod,
        walletAmountUsed,
        remainingAmount,
        totalAmount,
        vatAmount,
        dutiesAmount,
        customerId,
        crmCustomerId
      });

      let finalCustomerInfo = customerInfo;
      let finalCrmCustomerId = crmCustomerId;

      // If user is logged in, get customer info from CRM database
      if (customerId && !customerInfo) {
        console.log('Getting CRM customer info for customerId:', customerId);
        const customer = await crmStorage.getCrmCustomerById(customerId);
        console.log('Retrieved CRM customer:', customer);
        if (customer) {
          finalCustomerInfo = {
            email: customer.email,
            firstName: customer.firstName,
            lastName: customer.lastName,
            company: customer.company || '',
            phone: customer.phone || '',
            country: customer.country || 'Iraq',
            city: customer.cityRegion || customer.city || 'Baghdad',
            address: customer.address || 'Default Address',
          };
          console.log('finalCustomerInfo set to:', finalCustomerInfo);
        }
      }

      console.log('Final customer info before order creation:', finalCustomerInfo);

      // If user is not logged in, create or update CRM customer from order info
      if (!customerId && customerInfo) {
        const orderData = {
          email: customerInfo.email,
          firstName: customerInfo.firstName,
          lastName: customerInfo.lastName,
          company: customerInfo.company,
          phone: customerInfo.phone,
          country: customerInfo.country,
          city: customerInfo.city,
          address: customerInfo.address,
          orderValue: totalAmount,
        };

        const crmCustomer = await crmStorage.createOrUpdateCustomerFromOrder(orderData);
        finalCrmCustomerId = crmCustomer.id;
        finalCustomerInfo = crmCustomer;
      }

      // ğŸ”’ SEQUENTIAL: Generate order number using transaction-safe M[YY][NNNNN] system
      const { OrderManagementStorage } = await import('./order-management-storage');
      const orderManagementStorage = new OrderManagementStorage();
      
      console.log('ğŸ”’ [SEQUENTIAL] Starting transaction-safe order creation...');
      let orderNumber: string | null = null; // Will be null for bank payments initially

      // Handle wallet payments with smart conversion
      let finalPaymentStatus = "pending";
      let actualWalletUsed = 0;
      let finalPaymentMethod = paymentMethod || "bank_transfer";
      
      // Import currency utilities for IQD formatting
      const { formatIQDAmount, currencyAmountsEqual } = await import('./currency-utils');

      // Process wallet payment if walletAmountUsed is provided (for all payment methods including hybrid)
      // Convert all amounts to whole numbers for IQD
      const walletUsage = formatIQDAmount(walletAmountUsed || 0);
      const remaining = formatIQDAmount(remainingAmount || totalAmount);
      const formattedTotalAmount = formatIQDAmount(totalAmount);
      
      // Smart conversion for wallet_combined payment method
      if (paymentMethod === 'wallet_combined') {
        if (walletUsage >= formattedTotalAmount && remaining <= 1) {
          finalPaymentMethod = 'wallet_full';
          console.log('ğŸ”„ [BACKEND CONVERSION] wallet_combined â†’ wallet_full (sufficient balance)', {
            walletUsage, formattedTotalAmount, remaining
          });
        } else if (walletUsage > 0) {
          // Use the secondary payment method chosen by user for remaining amount
          const { secondaryPaymentMethod } = req.body;
          
          // Map frontend payment method to correct gateway type
          if (secondaryPaymentMethod === 'online_payment') {
            // Check active gateway type from database
            const db = await import('./db');
            const { eq } = await import('drizzle-orm');
            const { paymentGateways } = await import('../shared/schema');
            
            const activeGateway = await db.default.query.paymentGateways.findFirst({
              where: eq(paymentGateways.enabled, true)
            });
            
            finalPaymentMethod = activeGateway?.type || 'sep'; // Default to Shaparak if no active gateway found
            console.log('ğŸ”„ [GATEWAY MAPPING] Found active gateway:', { 
              gatewayName: activeGateway?.name, 
              gatewayType: activeGateway?.type,
              finalPaymentMethod 
            });
          } else {
            finalPaymentMethod = secondaryPaymentMethod || 'sep';
          }
          
          console.log('ğŸ”„ [BACKEND CONVERSION] wallet_combined â†’ user selected secondary method', {
            walletUsage, formattedTotalAmount, remaining, 
            secondaryPaymentMethod, finalPaymentMethod
          });
        } else {
          // Use the secondary payment method chosen by user (no wallet usage)
          const { secondaryPaymentMethod } = req.body;
          
          // Map frontend payment method to correct gateway type
          if (secondaryPaymentMethod === 'online_payment') {
            const db = await import('./db');
            const { eq } = await import('drizzle-orm');
            const { paymentGateways } = await import('../shared/schema');
            
            const activeGateway = await db.default.query.paymentGateways.findFirst({
              where: eq(paymentGateways.enabled, true)
            });
            
            finalPaymentMethod = activeGateway?.type || 'sep';
            console.log('ğŸ”„ [GATEWAY MAPPING] Found active gateway for no-wallet payment:', { 
              gatewayName: activeGateway?.name, 
              gatewayType: activeGateway?.type,
              finalPaymentMethod 
            });
          } else {
            finalPaymentMethod = secondaryPaymentMethod || 'sep';
          }
          
          console.log('ğŸ”„ [BACKEND CONVERSION] wallet_combined â†’ user selected method (no wallet usage)', {
            secondaryPaymentMethod, finalPaymentMethod
          });
        }
      }
      
      // ğŸ¦ BANK PAYMENT WORKFLOW: Only generate order numbers for non-bank payments
      // Bank payments will get order numbers after successful payment verification
      console.log(`ğŸ” [PAYMENT METHOD DEBUG] Original: ${paymentMethod}, Final: ${finalPaymentMethod}`);
      const bankPaymentMethods = ['bank_transfer', 'bank_gateway', 'bank', 'online_bank', 'gateway', 'online_payment', 'bank_receipt'];
      const isBankPayment = bankPaymentMethods.includes(finalPaymentMethod);
      console.log(`ğŸ” [BANK PAYMENT DEBUG] finalPaymentMethod: "${finalPaymentMethod}", bankMethods: [${bankPaymentMethods.join(', ')}], isBankPayment: ${isBankPayment}`);
      
      if (!isBankPayment) {
        // Generate order number for wallet payments and other non-bank methods
        orderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
        console.log(`âœ… [NON-BANK ORDER] Generated order number ${orderNumber} for ${finalPaymentMethod}`);
      } else {
        // Bank payments: no order number until payment verification
        console.log(`ğŸ¦ [BANK ORDER] No order number assigned - waiting for payment verification (${finalPaymentMethod})`);
      }
      
      console.log('ğŸ’° [WALLET DEBUG] Processing wallet payment:', {
        originalPaymentMethod: paymentMethod,
        finalPaymentMethod,
        walletUsage,
        remaining,
        totalAmount: formattedTotalAmount,
        finalCrmCustomerId,
        customerId,
        conversionApplied: paymentMethod === 'wallet_combined'
      });
      
      if (walletUsage > 0 && (finalCrmCustomerId || customerId)) {
          try {
            // Use the customer ID that exists (prioritize CRM customer)
            const customerIdToUse = finalCrmCustomerId || customerId;
            
            // Use walletStorage.debitWallet which handles all the logic
            const transaction = await walletStorage.debitWallet(
              customerIdToUse,
              walletUsage,
              `Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderNumber || 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ§ÛŒÛŒØ¯ Ø¨Ø§Ù†Ú©'}`,
              'order',
              undefined, // reference ID will be set after order creation
              undefined  // no admin processing this
            );
            
            console.log(`âœ… Wallet payment processed: ${walletUsage} IQD deducted, transaction ID: ${transaction.id}`);
            actualWalletUsed = walletUsage;
            
            // Enhanced payment status logic based on conversion (using whole numbers for IQD)
            if (finalPaymentMethod === 'wallet_full' || remaining <= 1) {
              finalPaymentStatus = "paid"; // Fully paid by wallet
              console.log('ğŸ’° [PAYMENT STATUS] Set to PAID - wallet_full conversion applied');
            } else {
              finalPaymentStatus = "partial"; // Partially paid by wallet
              console.log('ğŸ’° [PAYMENT STATUS] Set to PARTIAL - wallet_partial conversion applied');
            }

          } catch (error) {
            console.error('âŒ [WALLET ERROR] Failed to process wallet payment:', error);
            // Don't fail the order if wallet payment fails - set to pending
            finalPaymentStatus = "pending";
            finalPaymentMethod = "bank_transfer";
            actualWalletUsed = 0;
          }
      }
      
      console.log('ğŸ’° [WALLET DEBUG] Final wallet processing result:', {
        actualWalletUsed,
        finalPaymentStatus,
        finalPaymentMethod
      });

      // Create order in customer orders table - store VAT amounts as whole numbers for IQD
      const orderData = {
        orderNumber, // Will be null for bank payments initially
        customerId: customerId || null,
        totalAmount: Math.round(totalAmount).toString(),
        shippingCost: Math.round(shippingCost || 0).toString(),
        vatAmount: Math.round(vatAmount || 0).toString(), // Store frozen VAT amount from frontend calculation
        surchargeAmount: Math.round(dutiesAmount || 0).toString(), // Store frozen duties amount from frontend calculation
        status: 'pending' as const,
        paymentStatus: finalPaymentStatus,
        paymentMethod: finalPaymentMethod,
        walletAmountUsed: Math.round(actualWalletUsed).toString(),
        shippingAddress: {
          address: finalCustomerInfo.address,
          city: finalCustomerInfo.city,
          country: finalCustomerInfo.country,
        },
        notes: notes || '',
        ...(customerId ? {} : {
          guestEmail: finalCustomerInfo.email,
          guestName: `${finalCustomerInfo.firstName} ${finalCustomerInfo.lastName}`,
        }),
        // Store shipping method information
        carrier: shippingMethod === 'standard' ? 'Standard Shipping (5-7 days)' : 
                shippingMethod === 'express' ? 'Express Shipping (2-3 days)' : 
                shippingMethod === 'overnight' ? 'Overnight Shipping' : 
                'Standard Shipping',
        // Store recipient information (can be different from customer)
        recipientName: recipientInfo?.recipientName || '',
        recipientPhone: recipientInfo?.recipientPhone || '',
        recipientAddress: recipientInfo?.recipientAddress || '',
      };

      const order = await customerStorage.createOrder(orderData);

      // Create order items and update stock - IQD whole numbers only
      for (const item of items) {
        const unitPrice = Math.round(parseFloat(item.unitPrice || item.price || '0') || 0);
        const quantity = parseInt(item.quantity || '1') || 1;
        
        await customerStorage.createOrderItem({
          orderId: order.id,
          productId: item.productId,
          productName: item.productName || 'Unknown Product',
          quantity: String(quantity),
          unitPrice: String(unitPrice),
          totalPrice: String(Math.round(quantity * unitPrice)),
          productSku: item.productSku || '',
        });

        // Update product stock using unified inventory manager
        try {
          console.log(`ğŸ›’ UNIFIED STOCK UPDATE - Product ${item.productName} (ID: ${item.productId})`);
          
          // Use unified inventory manager for single source of truth
          const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
          const success = await UnifiedInventoryManager.reduceInventoryForOrder([{
            productName: item.productName,
            quantity: item.quantity
          }]);
          
          if (success) {
            console.log(`âœ… Stock updated successfully using unified system for product ${item.productId}`);
          } else {
            console.log(`âš ï¸ Failed to update stock for product ${item.productId}`);
          }
        } catch (stockError) {
          console.error(`Error updating stock for product ${item.productId}:`, stockError);
          // Continue with other products even if stock update fails
        }
      }

      // Log order activity in CRM
      if (finalCrmCustomerId) {
        await crmStorage.logCustomerActivity({
          customerId: finalCrmCustomerId,
          activityType: 'order_placed',
          description: `Ø³ÙØ§Ø±Ø´ Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ù…Ø¨Ù„Øº $${totalAmount} Ø«Ø¨Øª Ø´Ø¯`,
          activityData: {
            orderId: order.id,
            totalAmount,
            itemCount: items.length,
            source: 'website',
            orderDate: new Date().toISOString(),
          },
          relatedOrderId: order.id,
        });

        // Update customer metrics in CRM
        await crmStorage.updateCustomerMetrics(finalCrmCustomerId);
      }

      // Trigger automatic synchronization after shop order creation
      try {
        await globalSyncService.triggerOrderSync(order.id, 'shop_order_created');
        console.log(`ğŸ”„ [SYNC] Triggered automatic sync for shop order creation - order ${order.id}`);
      } catch (syncError) {
        console.error(`âŒ [SYNC] Auto-sync failed for shop order creation:`, syncError);
        // Don't fail order creation if sync fails
      }

      // Check if hybrid payment is required (wallet partially used + remaining amount)
      // CRITICAL FIX: Use the frontend's calculated remaining amount if provided, otherwise calculate
      let remainingAmountToPay;
      if (remainingAmount !== undefined && remainingAmount !== null) {
        // Frontend provided exact remaining amount - use it directly (format as whole number for IQD)
        remainingAmountToPay = formatIQDAmount(remainingAmount);
        console.log('ğŸ’¡ [REMAINING AMOUNT] Using frontend calculated value:', {
          frontendRemaining: remainingAmount,
          parsedValue: remainingAmountToPay
        });
      } else {
        // Fallback: calculate remaining amount (format as whole number for IQD)
        remainingAmountToPay = formatIQDAmount(Math.max(0, formattedTotalAmount - actualWalletUsed));
        console.log('ğŸ”¢ [REMAINING AMOUNT] Backend calculated value:', {
          totalAmount: formattedTotalAmount,
          actualWalletUsed,
          calculatedRemaining: remainingAmountToPay
        });
      }
      
      // Critical fix: For full wallet payments, completely bypass bank payment logic
      const isFullWalletPayment = finalPaymentMethod === 'wallet_full';
      const isPartialWalletPayment = finalPaymentMethod === 'wallet_partial';
      
      // Enhanced logic: For hybrid payments, check if wallet usage equals or exceeds total amount (using formatted amounts)
      const walletCoversFullAmount = actualWalletUsed >= formattedTotalAmount;
      // CRITICAL FIX: Check remaining amount is greater than 1 (whole number for IQD)
      const hasSignificantRemainingAmount = remainingAmountToPay > 1;
      
      // FIXED: If wallet covers full amount OR payment method is wallet_full, don't require bank payment
      const requiresBankPayment = !isFullWalletPayment && !walletCoversFullAmount && hasSignificantRemainingAmount && remainingAmountToPay > 0;
      
      console.log('ğŸ” [PAYMENT LOGIC DEBUG] Payment decision logic:', {
        actualWalletUsed,
        remainingAmountToPay,
        originalRemainingAmount: remainingAmount,
        totalAmount: formattedTotalAmount,
        requiresBankPayment,
        paymentMethod: finalPaymentMethod,
        walletUsedString: walletAmountUsed,
        remainingAmountString: remainingAmount,
        paymentMethodFromRequest: paymentMethod,
        isFullWalletPayment,
        isPartialWalletPayment,
        walletCoversFullAmount,
        hasSignificantRemainingAmount,
        walletPaymentComplete: isFullWalletPayment && actualWalletUsed > 0,
        shouldRedirectToBank: requiresBankPayment,
        isZeroRemaining: remainingAmountToPay <= 1,
        frontendSentZeroRemaining: remainingAmount === 0 || remainingAmount === '0'
      });
      
      // If wallet covers full amount, mark as paid and don't require bank payment
      if (isFullWalletPayment || walletCoversFullAmount || remainingAmountToPay <= 1) {
        console.log('âœ… [FULL WALLET] Payment covers full amount - order complete without bank gateway', {
          isFullWalletPayment,
          walletCoversFullAmount,
          actualWalletUsed,
          totalAmount: formattedTotalAmount,
          remainingAmountToPay
        });
        finalPaymentStatus = "paid";
        
        // Return success response immediately for full wallet payments
        return res.json({
          success: true,
          message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯",
          paymentMethod: 'wallet_full',
          order: {
            id: order.id,
            orderNumber: order.orderNumber,
            totalAmount: order.totalAmount,
            status: order.status,
            paymentStatus: "paid",
            paymentMethod: 'wallet_full',
            walletAmountUsed: actualWalletUsed,
            crmCustomerId: finalCrmCustomerId,
          }
        });
      }
      
      if (requiresBankPayment) {
        // Use the selected secondary payment method instead of generic finalPaymentMethod
        const { secondaryPaymentMethod } = req.body;
        let actualPaymentMethod = secondaryPaymentMethod || 'online_payment';
        
        // Map frontend payment method to correct gateway type for redirect URL
        if (actualPaymentMethod === 'online_payment') {
          const db = await import('./db');
          const { eq } = await import('drizzle-orm');
          const { paymentGateways } = await import('../shared/schema');
          
          const activeGateway = await db.default.query.paymentGateways.findFirst({
            where: eq(paymentGateways.enabled, true)
          });
          
          actualPaymentMethod = activeGateway?.type || 'sep'; // Use actual gateway type for redirect
          console.log('ğŸ”„ [REDIRECT MAPPING] Using active gateway type for URL:', { 
            gatewayName: activeGateway?.name, 
            gatewayType: activeGateway?.type,
            actualPaymentMethod 
          });
        }
        
        console.log('ğŸ’³ [PAYMENT REDIRECT] Using secondary payment method for remaining amount:', {
          secondaryPaymentMethod,
          actualPaymentMethod,
          remainingAmountToPay,
          orderId: order.id
        });
        
        // ğŸ¦ [WALLET_COMBINED] Route remaining amount to bank gateway (same as customers/orders)
        console.log(`ğŸ¦ [WALLET_COMBINED] Routing remaining ${remainingAmountToPay} IQD to bank gateway...`);
        
        const { BankGatewayRouter } = await import('./bank-gateway-router');
        const bankGatewayRouter = new BankGatewayRouter();
        
        const routingResult = await bankGatewayRouter.routePayment({
          orderId: order.id,
          customerId: finalCrmCustomerId || customerId,
          amount: remainingAmountToPay,
          currency: 'IQD',
          returnUrl: `${req.protocol}://${req.get('host')}/payment/success`,
          cancelUrl: `${req.protocol}://${req.get('host')}/payment/cancel`
        });

        if (routingResult.success) {
          console.log(`ğŸ¦ [PAYMENT ROUTING] Wallet combined payment routed to ${routingResult.gateway?.name}`);
          return res.json({
            success: true,
            message: "Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯ØŒ Ù„Ø·ÙØ§Ù‹ Ù…Ø§Ø¨Ù‚ÛŒ Ù…Ø¨Ù„Øº Ø±Ø§ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ù†ÛŒØ¯",
            requiresBankPayment: true,
            walletAmountDeducted: actualWalletUsed,
            remainingAmount: remainingAmountToPay,
            redirectUrl: routingResult.paymentUrl,
            paymentUrl: routingResult.paymentUrl,
            transactionId: routingResult.transactionId,
            order: {
              id: order.id,
              orderNumber: order.orderNumber,
              totalAmount: order.totalAmount,
              status: order.status,
              paymentStatus: finalPaymentStatus,
              paymentMethod: finalPaymentMethod,
              walletAmountUsed: actualWalletUsed,
              crmCustomerId: finalCrmCustomerId,
            }
          });
        } else {
          console.log(`âŒ [PAYMENT ROUTING] Failed to route wallet combined payment: ${routingResult.message}`);
          // Fallback to payment page redirect
          return res.json({
            success: true,
            message: "Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯ØŒ Ù„Ø·ÙØ§Ù‹ Ù…Ø§Ø¨Ù‚ÛŒ Ù…Ø¨Ù„Øº Ø±Ø§ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ù†ÛŒØ¯",
            requiresBankPayment: true,
            walletAmountDeducted: actualWalletUsed,
            remainingAmount: remainingAmountToPay,
            redirectUrl: `/payment?orderId=${order.id}&amount=${remainingAmountToPay}&method=${actualPaymentMethod}`,
            paymentError: routingResult.message,
            order: {
              id: order.id,
              orderNumber: order.orderNumber,
              totalAmount: order.totalAmount,
              status: order.status,
              paymentStatus: finalPaymentStatus,
              paymentMethod: finalPaymentMethod,
              walletAmountUsed: actualWalletUsed,
              crmCustomerId: finalCrmCustomerId,
            }
          });
        }
      } else {
        // Standard payment response
        res.json({
          success: true,
          message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯",
          order: {
            id: order.id,
            totalAmount: order.totalAmount,
            status: order.status,
            paymentStatus: finalPaymentStatus,
            paymentMethod: finalPaymentMethod,
            walletAmountUsed: actualWalletUsed,
            crmCustomerId: finalCrmCustomerId,
          }
        });
      }

    } catch (error) {
      console.error("Error creating shop order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´"
      });
    }
  });

  // Create customer order (from BilingualPurchaseForm)
  app.post("/api/customers/orders", async (req, res) => {
    console.log('ğŸš€ [ENDPOINT] /api/customers/orders called with timestamp:', req.query.t);
    console.log('ğŸš€ [ENDPOINT] Request method:', req.method);
    console.log('ğŸš€ [ENDPOINT] Request URL:', req.url);
    console.log('ğŸš€ [ENDPOINT] Request headers:', JSON.stringify(req.headers, null, 2));
    
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const orderData = req.body;
      
      console.log('ğŸš€ [ENDPOINT] Session data:', {
        customerId,
        crmCustomerId,
        hasSession: !!req.session,
        sessionId: req.sessionID
      });
      
      console.log('ğŸ›’ [BILINGUAL ORDER DEBUG] Order data received:', {
        paymentMethod: orderData.paymentMethod,
        walletAmountUsed: orderData.walletAmountUsed,
        remainingAmount: orderData.remainingAmount,
        totalAmount: orderData.totalAmount,
        customerId,
        crmCustomerId,
        'Will process wallet?': orderData.paymentMethod === 'wallet_full' || orderData.paymentMethod === 'wallet_partial',
        'Wallet amount to deduct': orderData.walletAmountUsed,
        'Entire order data': orderData
      });

      // Extract customer information from form data
      const customerInfo = {
        name: orderData.customerName,
        phone: orderData.phone,
        address: orderData.address,
        city: orderData.city,
        postalCode: orderData.postalCode || '',
        country: orderData.country || 'Iraq', // Add country from form
        notes: orderData.notes || '', // Add notes from form
      };

      // ğŸ”’ SEQUENTIAL: Generate M[YY][NNNNN] order number using transaction-safe system
      const { OrderManagementStorage } = await import('./order-management-storage');
      const orderManagementStorage = new OrderManagementStorage();
      
      console.log('ğŸ”’ [SEQUENTIAL] Starting transaction-safe order creation for wallet/payment...');
      let orderNumber: string | null = null;
      
      // Calculate order totals and taxes (using dynamic tax settings)
      // Note: orderData.totalAmount from frontend already includes all components
      // We need to extract the actual item subtotal for proper VAT calculation
      const itemsSubtotal = orderData.subtotalAmount || 0;
      const shippingAmount = orderData.shippingCost || 0;
      
      // Get current tax rates from tax_settings table and freeze them for this order
      const taxCalculation = await calculateOrderTaxes(itemsSubtotal);
      const totalAmount = itemsSubtotal + shippingAmount + taxCalculation.vatAmount + taxCalculation.dutiesAmount;
      
      console.log('ğŸ’° [ORDER TAX] Tax calculation for order:', {
        itemsSubtotal,
        shippingAmount,
        vatRate: taxCalculation.vatRate,
        vatAmount: taxCalculation.vatAmount,
        surchargeRate: taxCalculation.dutiesRate,
        surchargeAmount: taxCalculation.dutiesAmount,
        totalAmount
      });

      // Create order with proper customer linking
      let finalCustomerId = customerId;
      if (!customerId && crmCustomerId) {
        // Link to CRM customer if available
        finalCustomerId = crmCustomerId;
      }

      if (!finalCustomerId) {
        return res.status(401).json({
          success: false,
          message: "User must be logged in to place order"
        });
      }

      // Handle payment method processing
      let finalPaymentStatus = "pending";
      let walletAmountUsed = 0;
      let remainingAmount = totalAmount;
      let finalPaymentMethod = orderData.paymentMethod || "traditional";

      // BANK PAYMENT WORKFLOW: Create order first, then route to payment
      // Success callback will assign order number and send to warehouse
      // Failure callback will delete the orderless record
      
      // Set payment method and status based on customer choice
      if (orderData.paymentMethod === 'online_payment') {
        finalPaymentStatus = "pending";
        finalPaymentMethod = "online_payment";
        walletAmountUsed = 0;
        remainingAmount = totalAmount;
        console.log("âœ… [CUSTOMER CHOICE] Online payment validated and selected");
      }
      // If customer explicitly chose bank_transfer, NEVER use wallet instead
      else if (orderData.paymentMethod === 'bank_transfer') {
        finalPaymentStatus = "pending";
        finalPaymentMethod = "bank_transfer";
        walletAmountUsed = 0;
        remainingAmount = totalAmount;
        console.log("âœ… [CUSTOMER CHOICE] Bank transfer selected - NO wallet substitution allowed");
      }
      // Only process wallet payments when customer explicitly chose wallet options
      else if (orderData.paymentMethod === 'wallet_full' || orderData.paymentMethod === 'wallet_partial') {
        walletAmountUsed = Math.round(parseFloat(orderData.walletAmountUsed || 0));
        remainingAmount = Math.round(parseFloat(orderData.remainingAmount || totalAmount));
        
        console.log('ğŸ’° [BILINGUAL WALLET DEBUG] Processing wallet payment:', {
          walletAmountUsed,
          remainingAmount,
          finalCustomerId,
          paymentMethod: orderData.paymentMethod,
          'Bank payment required?': remainingAmount > 0
        });
        
        if (walletAmountUsed > 0) {
          try {
            // Use walletStorage.debitWallet which handles all the logic
            const transaction = await walletStorage.debitWallet(
              finalCustomerId,
              walletAmountUsed,
              `Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderNumber}`,
              'order',
              undefined, // reference ID will be set after order creation
              undefined  // no admin processing this
            );
            
            console.log(`âœ… Wallet payment processed: ${walletAmountUsed} IQD deducted, transaction ID: ${transaction.id}`);
            
            // CRITICAL FIX: Check if remainingAmount is 0 to send directly to warehouse
            if (Math.round(remainingAmount) <= 1) {
              finalPaymentStatus = "paid"; // Fully paid by wallet
              finalPaymentMethod = "wallet_full"; // Ensure correct method
              console.log('ğŸª [WAREHOUSE DIRECT] Bank payment = 0, sending order directly to warehouse');
            } else {
              finalPaymentStatus = "partial"; // Partially paid by wallet
              finalPaymentMethod = "wallet_partial"; // Requires bank payment
              console.log('ğŸ¦ [BANK REQUIRED] Bank payment > 0, will require bank gateway');
            }
          } catch (walletError) {
            console.log(`âŒ Wallet payment failed:`, walletError);
            return res.status(400).json({
              success: false,
              message: "Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª ÛŒØ§ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´"
            });
          }
        }
      }
      
      // Handle bank receipt method
      else if (orderData.paymentMethod === 'bank_receipt') {
        finalPaymentStatus = "pending";
        finalPaymentMethod = "bank_receipt";
        console.log("âœ… Bank receipt method selected - customer will upload receipt");
      }
      
      // Handle bank transfer with grace period method
      else if (orderData.paymentMethod === 'bank_transfer_grace') {
        finalPaymentStatus = "grace_period";
        finalPaymentMethod = "bank_transfer_grace";
        console.log("âœ… Bank transfer with grace period method selected - 3-day grace period activated");
      }

      // ğŸ” DETERMINE ORDER NUMBER ASSIGNMENT STRATEGY
      console.log(`ğŸ” [PAYMENT METHOD DEBUG] Original: ${orderData.paymentMethod}, Final: ${finalPaymentMethod}`);
      const isBankPayment = ['bank_transfer', 'bank_gateway', 'bank', 'online_bank', 'gateway'].includes(finalPaymentMethod);
      const isNonRoutedBankPayment = ['bank_receipt', 'bank_transfer_grace'].includes(finalPaymentMethod);
      
      // Generate order numbers based on payment type
      if (!isBankPayment && !isNonRoutedBankPayment && finalPaymentMethod !== 'online_payment') {
        // Generate order number for wallet payments and other non-bank methods
        orderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
        console.log(`âœ… [NON-BANK ORDER] Generated order number ${orderNumber} for ${finalPaymentMethod}`);
      } else {
        // Bank payments and online payments: no order number until payment verification
        console.log(`ğŸ¦ [BANK/ONLINE ORDER] No order number assigned - waiting for payment verification (${finalPaymentMethod})`);
      }

      const order = await customerStorage.createOrder({
        customerId: finalCustomerId,
        orderNumber,
        status: "pending",
        paymentStatus: finalPaymentStatus,
        paymentMethod: finalPaymentMethod,
        totalAmount: Math.round(totalAmount).toString(),
        shippingCost: Math.round(shippingAmount).toString(),
        currency: orderData.currency || "IQD",
        notes: orderData.notes || "",
        
        // Store frozen tax rates at order creation time
        vatRate: taxCalculation.vatRate.toString(),
        vatAmount: taxCalculation.vatAmount.toString(),
        surchargeRate: taxCalculation.dutiesRate.toString(),
        surchargeAmount: taxCalculation.dutiesAmount.toString(),
        
        billingAddress: JSON.stringify({
          name: customerInfo.name,
          phone: customerInfo.phone,
          address: customerInfo.address,
          city: customerInfo.city,
          postalCode: customerInfo.postalCode,
        }),
        shippingAddress: JSON.stringify({
          name: customerInfo.name,
          phone: customerInfo.phone,
          address: customerInfo.address,
          city: customerInfo.city,
          postalCode: customerInfo.postalCode,
          gpsLatitude: orderData.gpsLatitude,
          gpsLongitude: orderData.gpsLongitude,
        }),
        
        // Second delivery address fields from CRM conditional logic
        secondDeliveryAddress: orderData.secondDeliveryAddress || null,
        secondDeliveryCity: orderData.secondDeliveryCity || null,
        secondDeliveryProvince: orderData.secondDeliveryProvince || null,
        secondDeliveryPostalCode: orderData.secondDeliveryPostalCode || null,
        recipientMobile: orderData.recipientMobile || null,
        
        // Active delivery information tracking
        activeDeliveryInfo: orderData.activeDeliveryInfo ? JSON.stringify(orderData.activeDeliveryInfo) : null,
        
        // GPS location data for logistics coordination
        gpsLatitude: orderData.gpsLatitude || null,
        gpsLongitude: orderData.gpsLongitude || null,
        locationAccuracy: orderData.locationAccuracy || null,
        
        // Warehouse notes from frontend logic
        internalNotes: orderData.warehouseNotes || "",
        
        trackingNumber: null,
        carrier: null,

      });

      console.log('ğŸšš [ORDER CREATED] Enhanced order with delivery tracking:', {
        orderId: order.id,
        orderNumber: order.orderNumber,
        hasSecondAddress: !!orderData.secondDeliveryAddress,
        hasRecipientMobile: !!orderData.recipientMobile,
        activeDeliveryInfo: orderData.activeDeliveryInfo
      });

      // Create order items from cart
      if (orderData.cart) {
        for (const [productId, quantity] of Object.entries(orderData.cart)) {
          try {
            const product = await shopStorage.getShopProductById(parseInt(productId as string));
            if (product) {
              await customerStorage.createOrderItem({
                orderId: order.id,
                productId: parseInt(productId as string),
                productName: product.name,
                productSku: product.sku || `SKU-${productId}`,
                quantity: (quantity as number).toString(),
                unitPrice: product.price || "0",
                totalPrice: (parseFloat(product.price || "0") * (quantity as number)).toString(),
              });

              // Update product stock with batch tracking
              if (product.stockQuantity !== null && product.stockQuantity !== undefined) {
                const currentStock = product.stockQuantity;
                const quantityToSell = quantity as number;
                
                console.log(`ğŸ›’ STOCK UPDATE WITH BATCH TRACKING - Product ${product.name} (ID: ${productId})`);
                console.log(`   Current Stock: ${currentStock}`);
                console.log(`   Quantity Sold: ${quantityToSell}`);
                
                try {
                  // Use unified inventory manager for batch tracking
                  const { unifiedInventoryManager } = await import('./unified-inventory-manager');
                  
                  // Process inventory reduction with batch tracking
                  const result = await unifiedInventoryManager.processOrderWithBatchTracking(
                    parseInt(productId as string),
                    quantityToSell,
                    order.id,
                    `Order ${orderNumber} - Customer purchase`
                  );
                  
                  console.log(`âœ… Stock updated with batch tracking for product ${productId}:`, result);
                  
                  // Track batch usage for this sale
                  await unifiedInventoryManager.trackBatchUsageInSale(
                    order.id,
                    product.name,
                    result.batchesUsed
                  );
                  
                  console.log(`âœ… Batch usage tracked for order ${order.id}`);
                  
                } catch (batchError) {
                  console.error(`âŒ Batch tracking failed for product ${productId}:`, batchError);
                  
                  // Fallback to simple stock update if batch tracking fails
                  const newQuantity = Math.max(0, currentStock - quantityToSell);
                  await shopStorage.updateProductStock(
                    parseInt(productId as string),
                    newQuantity,
                    `Order ${orderNumber} - Sold ${quantityToSell} units (fallback)`
                  );
                  
                  console.log(`âš ï¸ Fallback stock update completed for product ${productId}`);
                }
              } else {
                console.log(`âš ï¸ No stock quantity available for product ${productId}`);
              }
            }
          } catch (productError) {
            console.error(`Error processing product ${productId}:`, productError);
            // Continue with other products even if one fails
          }
        }
      }

      // Auto-capture customer data in CRM system
      try {
        // Get customer details for CRM capture
        let customerForCrm = null;
        if (finalCustomerId) {
          try {
            customerForCrm = await customerStorage.getCustomerById(finalCustomerId);
          } catch (err) {
            console.log("Customer not found in customer storage, checking CRM...");
            try {
              customerForCrm = await crmStorage.getCrmCustomerById(finalCustomerId);
            } catch (crmErr) {
              console.log("Customer not found in CRM either, will create from order data");
            }
          }
        }

        // Extract customer information from order data - enhanced with all form fields
        const nameParts = customerInfo.name.split(' ');
        const firstName = nameParts[0] || 'Unknown';
        const lastName = nameParts.slice(1).join(' ') || 'Customer';
        
        const crmOrderData = {
          email: customerForCrm?.email || `customer${finalCustomerId}@temp.local`,
          firstName: firstName,
          lastName: lastName,
          company: customerForCrm?.company || null,
          phone: customerInfo.phone,
          country: customerInfo.country || 'Iraq', // Use form country or default
          city: customerInfo.city || 'Unknown',
          address: customerInfo.address,
          postalCode: customerInfo.postalCode || null,
          orderValue: totalAmount,
        };
        
        console.log('CRM Order Data being captured:', {
          firstName,
          lastName,
          phone: customerInfo.phone,
          country: customerInfo.country,
          city: customerInfo.city,
          address: customerInfo.address,
          postalCode: customerInfo.postalCode,
          orderValue: totalAmount
        });

        await crmStorage.createOrUpdateCustomerFromOrder(crmOrderData);
        console.log(`âœ… Customer auto-captured in CRM for order ${orderNumber}`);
      } catch (crmError) {
        console.error("âŒ Error auto-capturing customer in CRM:", crmError);
        // Don't fail the order if CRM capture fails
      }

      // Create order_management record for financial department workflow
      try {
        let orderMgmtData = {
          customerOrderId: order.id,
          customerId: finalCustomerId,
          currentStatus: finalPaymentStatus === 'grace_period' ? 'payment_grace_period' : 'pending',
          currentDepartment: 'customer',
          totalAmount: totalAmount.toString(),
          currency: orderData.currency || "IQD",
          notes: orderData.notes || "",
        };

        // Add grace period fields for bank_transfer_grace payment method
        if (orderData.paymentMethod === 'bank_transfer_grace') {
          const gracePeriodStart = new Date();
          const gracePeriodEnd = new Date();
          gracePeriodEnd.setDate(gracePeriodEnd.getDate() + 3); // 3 days grace period

          orderMgmtData = {
            ...orderMgmtData,
            paymentGracePeriodStart: gracePeriodStart,
            paymentGracePeriodEnd: gracePeriodEnd,
            isOrderLocked: true, // Lock order details during grace period
          };

          console.log(`ğŸ•’ Grace period activated for order ${orderNumber} - expires: ${gracePeriodEnd.toISOString()}`);
        }

        await orderManagementStorage.createOrderManagement(orderMgmtData);
        console.log(`âœ… Order management record created for order ${orderNumber}`);
        
        // Trigger automatic synchronization after order creation
        try {
          await globalSyncService.triggerOrderSync(order.id, 'order_created');
          console.log(`ğŸ”„ [SYNC] Triggered automatic sync for order ${orderNumber}`);
        } catch (syncError) {
          console.error(`âŒ [SYNC] Auto-sync failed for order ${orderNumber}:`, syncError);
          // Don't fail order creation if sync fails
        }
      } catch (orderMgmtError) {
        console.error("âŒ Error creating order management record:", orderMgmtError);
        // Don't fail the order if order management creation fails
      }

      // Prepare response based on payment method
      let responseData = {
        success: true,
        message: "Order created successfully",
        orderId: order.id,
        orderNumber: order.orderNumber,
        paymentMethod: finalPaymentMethod,
        totalAmount: Math.round(remainingAmount) > 0 ? Math.round(remainingAmount) : Math.round(totalAmount),
        walletAmountUsed: Math.round(walletAmountUsed),
      };

      // CRITICAL FIX: Check for full wallet payment first (remainingAmount = 0)
      if (finalPaymentStatus === "paid" && Math.round(remainingAmount) <= 1) {
        console.log(`ğŸª [WAREHOUSE DIRECT] Full wallet payment completed - sending order ${orderNumber} directly to warehouse`);
        console.log(`ğŸ’° [PAYMENT COMPLETE] Wallet: ${walletAmountUsed} IQD, Remaining: ${remainingAmount} IQD`);
        
        return res.json({
          success: true,
          message: 'Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯ - Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø±',
          orderId: order.id,
          orderNumber: orderNumber,
          totalAmount: Math.round(totalAmount),
          walletAmountUsed: Math.round(walletAmountUsed),
          remainingAmount: 0,
          paymentStatus: "paid",
          requiresBankPayment: false,
          directToWarehouse: true
        });
      }

      // Check for hybrid payment (wallet_partial with significant remaining amount > 1 IQD)
      // CRITICAL: Use the actual calculated remainingAmount from wallet processing, not from frontend
      const { formatIQDAmount } = await import('./currency-utils');
      
      // IMPORTANT: If wallet was successfully processed, recalculate the REAL remaining amount
      let actualRemainingAmount = Math.round(remainingAmount); // Default to original remaining amount (rounded)
      if (walletAmountUsed > 0) {
        // If wallet was used, the REAL remaining amount is total minus what was actually deducted
        actualRemainingAmount = Math.round(totalAmount) - Math.round(walletAmountUsed);
      }
      
      const formattedRemainingForBank = formatIQDAmount(actualRemainingAmount);
      
      console.log(`ğŸ” [PAYMENT DEBUG] Total: ${totalAmount}, Wallet Used: ${walletAmountUsed}, Original Remaining: ${remainingAmount}, Actual Remaining: ${actualRemainingAmount}, Formatted: ${formattedRemainingForBank}`);
      


      // Handle wallet_partial case where remaining amount rounds to 0 or 1 IQD (treated as complete)
      if (orderData.paymentMethod === 'wallet_partial' && formattedRemainingForBank <= 1) {
        console.log(`âœ… [WALLET COMPLETE] Wallet partial payment covers full amount - remaining ${actualRemainingAmount} rounds to ${formattedRemainingForBank} IQD`);
        
        return res.json({
          success: true,
          message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯",
          paymentMethod: 'wallet_full',
          order: {
            id: order.id,
            orderNumber: order.orderNumber,
            totalAmount: order.totalAmount,
            status: order.status,
            paymentStatus: "paid",
            paymentMethod: 'wallet_full',
            walletAmountUsed: Math.round(walletAmountUsed),
            crmCustomerId: finalCustomerId,
          }
        });
      }
      
      // ğŸ”„ [WALLET_PARTIAL] Route remaining amount to bank gateway after wallet deduction
      if (orderData.paymentMethod === 'wallet_partial' && formattedRemainingForBank > 1) {
        console.log(`ğŸ”„ [HYBRID PAYMENT] Routing remaining ${actualRemainingAmount} IQD to bank gateway...`);
        
        const { bankGatewayRouter } = await import('./bank-gateway-router');
        const formattedRemainingAmount = formatIQDAmount(actualRemainingAmount);
        
        const routingResult = await bankGatewayRouter.routePayment({
          orderId: order.id,
          customerId: finalCustomerId,
          amount: formattedRemainingAmount,
          currency: 'IQD',
          returnUrl: `${req.protocol}://${req.get('host')}/payment/success`,
          cancelUrl: `${req.protocol}://${req.get('host')}/payment/cancel`
        });

        if (routingResult.success) {
          console.log(`ğŸ¦ [PAYMENT ROUTING] Hybrid payment routed to ${routingResult.gateway?.name}`);
          return res.json({
            success: true,
            message: 'Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ø´Ø¯ - Ù‡Ø¯Ø§ÛŒØª Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª',
            orderId: order.id,
            orderNumber: null, // No order number until payment succeeds
            totalAmount: Math.round(totalAmount),
            walletAmountUsed: Math.round(walletAmountUsed),
            remainingAmount: formattedRemainingAmount,
            requiresBankPayment: true,
            paymentUrl: routingResult.paymentUrl
          });
        } else {
          // ğŸ—‘ï¸ DELETE ORDER: Bank routing failed
          console.log(`ğŸ—‘ï¸ [ORDER CLEANUP] Deleting order ${order.id} - bank routing failed`);
          await customerStorage.deleteTemporaryOrder(order.id);
          
          return res.status(400).json({
            success: false,
            message: `Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚ - Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ`,
            error: 'BANK_ROUTING_FAILED'
          });
        }
      }
      
      // ğŸ’° [PURE_WALLET] Handle pure wallet payment method FIRST (before bank routing)
      if (finalPaymentMethod === 'wallet' || finalPaymentMethod === 'wallet_full') {
        console.log(`ğŸ’° [PURE_WALLET] Processing pure wallet payment for ${totalAmount} IQD`);
        
        // ğŸ”¢ [AUTO ORDER NUMBER] Assign order number for confirmed wallet payment
        if (!order.orderNumber) {
          try {
            const newOrderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
            await customerStorage.updateOrderNumber(order.id, newOrderNumber);
            order.orderNumber = newOrderNumber;
            console.log(`ğŸ”¢ [WALLET PAYMENT] Auto-assigned order number: ${newOrderNumber}`);
          } catch (error) {
            console.error('âŒ Error auto-assigning order number for wallet payment:', error);
          }
        }
        
        // ğŸ­ [AUTO WAREHOUSE] Send confirmed wallet payment directly to warehouse
        try {
          await customerStorage.updateOrderStatus(order.id, 'warehouse_pending');
          
          // Update payment status and method directly in database
          await db
            .update(customerOrders)
            .set({
              paymentStatus: 'paid',
              paymentMethod: 'wallet_full',
              updatedAt: new Date()
            })
            .where(eq(customerOrders.id, order.id));
            
          console.log(`ğŸ­ [WALLET PAYMENT] Order ${order.orderNumber} sent directly to warehouse`);
        } catch (error) {
          console.error('âŒ Error sending wallet payment to warehouse:', error);
        }
        
        return res.json({
          success: true,
          message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯ Ùˆ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
          paymentMethod: 'wallet_full',
          order: {
            id: order.id,
            orderNumber: order.orderNumber,
            totalAmount: order.totalAmount,
            status: 'warehouse_pending',
            paymentStatus: "paid",
            paymentMethod: 'wallet_full',
            walletAmountUsed: Math.round(walletAmountUsed),
            crmCustomerId: finalCustomerId,
          }
        });
      }

      // ğŸ”„ [WALLET_PARTIAL] Handle wallet_partial payment method (hybrid wallet + bank)
      if (finalPaymentMethod === 'wallet_partial') {
        console.log(`ğŸ”„ [WALLET_PARTIAL] Processing hybrid wallet payment - Wallet: ${walletAmountUsed} IQD, Bank: ${remainingAmount} IQD`);
        
        // ğŸ’° [FULL WALLET COVERAGE] If remaining amount is 0, treat as pure wallet payment
        if (remainingAmount <= 0) {
          console.log(`ğŸ’° [WALLET_PARTIAL â†’ WALLET_FULL] Wallet covers full amount, no bank payment needed`);
          
          // ğŸ”¢ [AUTO ORDER NUMBER] Assign order number for confirmed full wallet payment
          if (!order.orderNumber) {
            try {
              const newOrderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
              await customerStorage.updateOrderNumber(order.id, newOrderNumber);
              order.orderNumber = newOrderNumber;
              console.log(`ğŸ”¢ [WALLET_FULL] Auto-assigned order number: ${newOrderNumber}`);
            } catch (error) {
              console.error('âŒ Error auto-assigning order number for full wallet payment:', error);
            }
          }
          
          // ğŸ­ [AUTO WAREHOUSE] Send confirmed full wallet payment directly to warehouse
          try {
            await customerStorage.updateOrderStatus(order.id, 'warehouse_pending');
            
            // Update payment status and method directly in database
            await db
              .update(customerOrders)
              .set({
                paymentStatus: 'paid',
                paymentMethod: 'wallet_full',
                updatedAt: new Date()
              })
              .where(eq(customerOrders.id, order.id));
              
            console.log(`ğŸ­ [WALLET_FULL] Order ${order.orderNumber} sent directly to warehouse`);
          } catch (error) {
            console.error('âŒ Error sending full wallet payment to warehouse:', error);
          }
          
          return res.json({
            success: true,
            message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯ Ùˆ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
            paymentMethod: 'wallet_full',
            order: {
              id: order.id,
              orderNumber: order.orderNumber,
              totalAmount: order.totalAmount,
              status: 'warehouse_pending',
              paymentStatus: "paid",
              paymentMethod: 'wallet_full',
              walletAmountUsed: Math.round(walletAmountUsed),
              crmCustomerId: finalCustomerId,
            }
          });
        }
        
        // ğŸ¦ [HYBRID PAYMENT] Route remaining amount to bank gateway
        const { BankGatewayRouter } = await import('./bank-gateway-router');
        const bankGatewayRouter = new BankGatewayRouter();
        
        const routingResult = await bankGatewayRouter.routePayment({
          orderId: order.id,
          customerId: finalCustomerId,
          amount: remainingAmount,
          currency: 'IQD',
          returnUrl: `${req.protocol}://${req.get('host')}/payment/success`,
          cancelUrl: `${req.protocol}://${req.get('host')}/payment/cancel`
        });

        if (routingResult.success) {
          console.log(`ğŸ¦ [PAYMENT ROUTING] Wallet partial payment routed to ${routingResult.gateway?.name}`);
          return res.json({
            success: true,
            message: "Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ø´Ø¯ - Ù‡Ø¯Ø§ÛŒØª Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª",
            orderId: order.id,
            orderNumber: order.orderNumber,
            totalAmount: Math.round(totalAmount),
            walletAmountUsed: Math.round(walletAmountUsed),
            remainingAmount: Math.round(remainingAmount),
            requiresBankPayment: true,
            paymentUrl: routingResult.paymentUrl,
            redirectUrl: routingResult.paymentUrl
          });
        } else {
          console.log(`âŒ [PAYMENT ROUTING] Failed to route wallet partial payment: ${routingResult.message}`);
          return res.status(400).json({
            success: false,
            message: `Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚ - Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ`,
            error: 'BANK_ROUTING_FAILED'
          });
        }
      }

      // ğŸ¦ [BANK_PAYMENTS] Route all bank-related payments to active gateway
      if (finalPaymentMethod === 'online_payment' || finalPaymentMethod === 'bank' || finalPaymentMethod === 'bank_transfer') {
        
        // For hybrid payment (wallet + bank gateway), return special response
        if (remainingAmount > 0 && walletAmountUsed > 0) {
          console.log(`ğŸ”„ [HYBRID PAYMENT] Routing remaining ${remainingAmount} IQD to bank gateway...`);
          // Ù‡Ø¯Ø§ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ ÙØ¹Ø§Ù„
          const { bankGatewayRouter } = await import('./bank-gateway-router');
          const routingResult = await bankGatewayRouter.routePayment({
            orderId: order.id,
            customerId: finalCustomerId,
            amount: remainingAmount,
            currency: 'IQD',
            returnUrl: `${req.protocol}://${req.get('host')}/payment/success`,
            cancelUrl: `${req.protocol}://${req.get('host')}/payment/cancel`
          });

          if (routingResult.success) {
            console.log(`ğŸ¦ [PAYMENT ROUTING] Successfully routed hybrid payment to ${routingResult.gateway?.name}`);
            return res.json({
              success: true,
              message: 'Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ø´Ø¯ - Ù‡Ø¯Ø§ÛŒØª Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª',
              orderId: orderNumber,
              orderNumber: orderNumber,
              totalAmount: totalAmount,
              walletAmountUsed: walletAmountUsed,
              remainingAmount: remainingAmount,
              requiresBankPayment: true,
              redirectToPayment: true,
              paymentGateway: routingResult.gateway,
              paymentUrl: routingResult.paymentUrl,
              transactionId: routingResult.transactionId,
              redirectUrl: routingResult.paymentUrl
            });
          } else {
            console.log(`âŒ [PAYMENT ROUTING] Failed to route hybrid payment: ${routingResult.message}`);
            return res.json({
              success: true,
              message: 'Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ø´Ø¯ - Ù‡Ø¯Ø§ÛŒØª Ø¨Ù‡ ØµÙØ­Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª',
              orderId: orderNumber,
              orderNumber: orderNumber,
              totalAmount: totalAmount,
              walletAmountUsed: walletAmountUsed,
              remainingAmount: remainingAmount,
              requiresBankPayment: true,
              redirectToPayment: true,
              paymentError: routingResult.message,
              redirectUrl: `/payment/${orderNumber}?amount=${remainingAmount}&wallet=${walletAmountUsed}&method=${finalPaymentMethod}`
            });
          }
        }
        
        // ğŸ¦ [FULL_BANK_PAYMENT] Route full amount to bank gateway for all bank payment types
        if (finalPaymentMethod === 'online_payment' || finalPaymentMethod === 'bank') {
          const fullAmount = Math.round(remainingAmount) > 0 ? Math.round(remainingAmount) : Math.round(totalAmount);
          console.log(`ğŸ¦ [BANK_PAYMENT] Routing ${fullAmount} IQD to bank gateway (method: ${finalPaymentMethod})...`);
          
          const { bankGatewayRouter } = await import('./bank-gateway-router');
          const routingResult = await bankGatewayRouter.routePayment({
            orderId: order.id,
            customerId: finalCustomerId,
            amount: fullAmount,
            currency: 'IQD',
            returnUrl: `${req.protocol}://${req.get('host')}/payment/success`,
            cancelUrl: `${req.protocol}://${req.get('host')}/payment/cancel`
          });

          if (routingResult.success) {
            console.log(`ğŸ¦ [PAYMENT ROUTING] Bank payment routed to ${routingResult.gateway?.name}`);
            return res.json({
              success: true,
              message: 'Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ø´Ø¯ - Ù‡Ø¯Ø§ÛŒØª Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª',
              orderId: order.id,
              orderNumber: null, // No order number until payment succeeds
              totalAmount: Math.round(totalAmount),
              walletAmountUsed: Math.round(walletAmountUsed),
              requiresBankPayment: true,
              paymentUrl: routingResult.paymentUrl
            });
          } else {
            // ğŸ—‘ï¸ DELETE ORDER: Bank routing failed
            console.log(`ğŸ—‘ï¸ [ORDER CLEANUP] Deleting order ${order.id} - bank routing failed`);
            await customerStorage.deleteTemporaryOrder(order.id);
            
            return res.status(400).json({
              success: false,
              message: `Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚ - Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ`,
              error: 'BANK_ROUTING_FAILED'
            });
          }
        }
        
        // ğŸ¦ [BANK_TRANSFER] Fallback for bank_transfer (only if no routing above)
        if (finalPaymentMethod === 'bank_transfer') {
          responseData.redirectToPayment = true;
          responseData.paymentGatewayUrl = `/payment?orderId=${order.id}&amount=${Math.round(remainingAmount) > 0 ? Math.round(remainingAmount) : Math.round(totalAmount)}&method=${finalPaymentMethod}`;
          console.log(`âœ… Order ${orderNumber} created - redirecting to payment gateway for ${Math.round(remainingAmount) > 0 ? Math.round(remainingAmount) : Math.round(totalAmount)} IQD (method: ${finalPaymentMethod})`);
          return res.json(responseData);
        }
      }

      // âŒ [FALLBACK ERROR] If we reach here, no payment method was handled properly
      console.error(`âŒ [PAYMENT ERROR] Unhandled payment method: ${finalPaymentMethod}, falling back to error response`);
      return res.status(400).json({
        success: false,
        message: `Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª ${finalPaymentMethod} Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯`,
        error: 'UNSUPPORTED_PAYMENT_METHOD'
      });
    } catch (error) {
      console.error("Error creating customer order:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create order"
      });
    }
  });

  // Get customer order history (including grace period orders)
  app.get("/api/customers/orders", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      
      console.log('ğŸ” [CUSTOMER ORDERS] Session check:', { customerId, crmCustomerId });
      
      if (!customerId && !crmCustomerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }
      
      // Use CRM customer ID if available, otherwise use legacy customer ID
      const finalCustomerId = crmCustomerId || customerId;
      console.log('ğŸ” [CUSTOMER ORDERS] Using customer ID:', finalCustomerId);

      // Get orders for profile display with priority for temporary orders
      const { displayOrders, totalOrders, hiddenOrders } = await customerStorage.getOrdersForProfile(finalCustomerId);
      
      // Get detailed order information with items for display orders only
      const detailedOrders = await Promise.all(
        displayOrders.map(async (order) => {
          const items = await customerStorage.getOrderItems(order.id);
          return {
            ...order,
            items,
            orderType: order.orderType === 'temporary' || 
                      order.orderCategory === 'temporary' || 
                      order.paymentMethod === 'bank_transfer_grace' ? 'temporary' : 'regular'
          };
        })
      );

      // Get grace period orders and all customer orders for this customer
      const { pool } = await import('./db');
      
      // Get all orders for this customer from customer_orders table
      // Include both temporary orders (before financial approval) and regular orders (after conversion)
      const allOrdersResult = await pool.query(`
        SELECT 
          co.id,
          co.order_number,
          co.customer_id,
          co.total_amount,
          co.shipping_cost,
          co.vat_amount,
          co.surcharge_amount,
          co.vat_rate,
          co.surcharge_rate,
          co.status,
          co.currency,
          co.payment_status,
          co.payment_method,
          co.guest_name,
          co.guest_email,
          co.recipient_phone,
          co.recipient_name,
          co.recipient_address,
          co.created_at,
          co.updated_at,
          om.payment_grace_period_start,
          om.payment_grace_period_end,
          om.is_order_locked,
          om.current_status,
          om.financial_reviewed_at,
          EXTRACT(EPOCH FROM (om.payment_grace_period_end - NOW()))/3600 as hours_remaining,
          CASE 
            WHEN om.payment_grace_period_end > NOW() THEN 'active'
            ELSE 'expired'
          END as grace_period_status,
          CASE 
            WHEN om.payment_grace_period_start IS NOT NULL AND om.financial_reviewed_at IS NULL THEN 'temporary'
            WHEN om.financial_reviewed_at IS NOT NULL THEN 'regular'
            ELSE 'regular'
          END as order_category
        FROM customer_orders co
        LEFT JOIN order_management om ON om.customer_order_id = co.id
        WHERE co.customer_id = $1
        ORDER BY co.created_at DESC
      `, [finalCustomerId]);
      
      // Get order items for each order
      const allOrdersWithItems = await Promise.all(
        allOrdersResult.rows.map(async (order: any) => {
          const itemsResult = await pool.query(`
            SELECT 
              oi.id,
              oi.product_id,
              oi.quantity,
              oi.unit_price,
              oi.total_price,
              p.name as product_name,
              p.sku,
              p.category
            FROM order_items oi
            LEFT JOIN shop_products p ON oi.product_id = p.id
            WHERE oi.order_id = $1
          `, [order.id]);
          
          return {
            ...order,
            items: itemsResult.rows
          };
        })
      );

      // Format customer orders to match regular order structure
      const customerOrders = allOrdersWithItems.map((row: any) => ({
        id: row.id,
        orderNumber: row.order_number,
        status: row.status,
        totalAmount: row.total_amount,
        shippingCost: row.shipping_cost,
        vatAmount: row.vat_amount,
        surchargeAmount: row.surcharge_amount,
        vatRate: row.vat_rate,
        surchargeRate: row.surcharge_rate,
        currency: row.currency,
        paymentStatus: row.payment_status,
        paymentMethod: row.payment_method,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        items: row.items || [],
        orderType: row.order_category, // 'temporary' or 'regular'
        orderCategory: row.order_category, // New field for order classification
        currentStatus: row.current_status, // Current order status in workflow
        financiallyApproved: row.financial_reviewed_at !== null,
        gracePeriodExpires: row.payment_grace_period_end,
        gracePeriodStatus: row.grace_period_status,
        hoursRemaining: Math.max(0, Math.floor(row.hours_remaining || 0)),
        isOrderLocked: row.is_order_locked,
        paymentGracePeriodStart: row.payment_grace_period_start,
        paymentGracePeriodEnd: row.payment_grace_period_end,
        customerName: row.guest_name,
        customerEmail: row.guest_email,
        customerPhone: row.recipient_phone,
        recipientName: row.recipient_name,
        recipientAddress: row.recipient_address
      }));

      // Get abandoned orders and carts information from enhanced profile data
      const profileData = await customerStorage.getOrdersForProfile(finalCustomerId);
      
      res.json({
        success: true,
        orders: detailedOrders,
        totalOrders: totalOrders, // Total number of orders from new method
        hiddenOrders: hiddenOrders, // Number of hidden orders as purchase history
        abandonedOrders: profileData.abandonedOrders,
        hasAbandonedOrders: profileData.hasAbandonedOrders,
        abandonedCount: profileData.abandonedOrders.length,
        abandonedCarts: profileData.abandonedCarts,
        hasAbandonedCarts: profileData.hasAbandonedCarts,
        abandonedCartsCount: profileData.abandonedCarts.length,
        displayInfo: {
          totalDisplayed: detailedOrders.length,
          hasTemporaryOrder: detailedOrders.some(order => order.orderType === 'temporary'),
          hasRegularOrder: detailedOrders.some(order => order.orderType === 'regular'),
          message: hiddenOrders > 0 ? `${hiddenOrders} Ø³ÙØ§Ø±Ø´ Ø¯ÛŒÚ¯Ø± Ø¯Ø± Ø³ÙˆØ§Ø¨Ù‚ Ø®Ø±ÛŒØ¯ Ù…Ø®ÙÛŒ Ø§Ø³Øª` : 'Ù‡Ù…Ù‡ Ø³ÙØ§Ø±Ø´Ø§Øª Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡'
        }
      });
    } catch (error) {
      console.error("Error getting customer orders:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª"
      });
    }
  });

  // Get detailed order information for financial review
  app.get("/api/customers/orders/:orderNumber/details", async (req, res) => {
    try {
      const orderNumber = req.params.orderNumber;
      
      console.log(`ğŸ” [ORDER DETAILS] Fetching details for order: ${orderNumber}`);
      
      // Use direct SQL query to avoid Drizzle ORM issues
      const orderQuery = await customerPool.query(
        'SELECT * FROM customer_orders WHERE order_number = $1 LIMIT 1',
        [orderNumber]
      );

      if (orderQuery.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const order = orderQuery.rows[0];

      // Get order items using direct SQL
      const itemsQuery = await customerPool.query(
        'SELECT * FROM order_items WHERE order_id = $1',
        [order.id]
      );
      const items = itemsQuery.rows;

      // Get customer info from CRM if available
      let customerDetails = {
        firstName: order.customer_name?.split(' ')[0] || '',
        lastName: order.customer_name?.split(' ').slice(1).join(' ') || '',
        email: order.guest_email,
        phone: order.guest_name,
        address: order.shipping_address?.address,
        city: order.shipping_address?.city,
        province: order.shipping_address?.province,
        country: order.shipping_address?.country,
        postalCode: order.shipping_address?.postalCode
      };

      if (order.customer_id) {
        try {
          const crmCustomer = await crmStorage.getCrmCustomerById(order.customer_id);
          if (crmCustomer) {
            customerDetails = {
              firstName: crmCustomer.firstName || customerDetails.firstName,
              lastName: crmCustomer.lastName || customerDetails.lastName,
              email: crmCustomer.email || customerDetails.email,
              phone: crmCustomer.phone || customerDetails.phone,
              address: crmCustomer.address || customerDetails.address,
              city: crmCustomer.city || customerDetails.city,
              province: crmCustomer.province || customerDetails.province,
              country: crmCustomer.country || customerDetails.country,
              postalCode: crmCustomer.postalCode || customerDetails.postalCode
            };
          }
        } catch (crmError) {
          console.warn('Could not fetch CRM customer data:', crmError);
        }
      }

      // Collect customer documents (payment receipts, etc.)
      const documents = [];
      
      // Add payment receipt if exists from order management
      try {
        const { OrderManagementStorage } = await import('./order-management-storage');
        const orderMgmtStorage = new OrderManagementStorage();
        const orderMgmt = await orderMgmtStorage.getOrderByOrderNumber(orderNumber);
        
        if (orderMgmt && orderMgmt.paymentReceiptUrl) {
          documents.push({
            name: 'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª',
            url: orderMgmt.paymentReceiptUrl,
            type: 'image',
            fileName: orderMgmt.receiptFileName || 'receipt.png'
          });
        }
      } catch (mgmtError) {
        console.warn('Could not fetch order management receipt:', mgmtError);
      }

      // Look for additional customer documents in uploads
      // (This would require implementing a document tracking system)

      // Fix column names to match database schema
      const orderDetails = {
        id: order.id,
        orderNumber: order.order_number,
        totalAmount: order.total_amount,
        currency: order.currency || 'IQD',
        paymentStatus: order.payment_status,
        paymentMethod: order.payment_method,
        status: order.status,
        createdAt: order.created_at,
        updatedAt: order.updated_at,
        notes: order.notes,
        shippingCost: order.shipping_cost,
        customerName: order.customer_name,
        guestName: order.guest_name,
        guestEmail: order.guest_email,
        shippingAddress: order.shipping_address,
        billingAddress: order.billing_address,
        walletAmountUsed: order.wallet_amount_used,
        remainingAmount: order.remaining_amount,
        customer: customerDetails,
        items: items.map(item => ({
          id: item.id,
          productId: item.product_id,
          productName: item.product_name,
          productSku: item.product_sku,
          quantity: item.quantity,
          unitPrice: item.unit_price,
          totalPrice: item.total_price,
          specifications: item.specifications
        })),
        currentStatus: order.status,
        orderType: (order.status === 'warehouse_ready' || order.status === 'shipped' || order.status === 'delivered') ? 'regular' : 'temporary'
      };

      console.log(`âœ… [ORDER DETAILS] Successfully fetched details for order ${orderNumber}`);

      res.json({
        success: true,
        order: orderDetails,
        documents: documents
      });

    } catch (error) {
      console.error('âŒ [ORDER DETAILS] Error fetching order details:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª Ø³ÙØ§Ø±Ø´"
      });
    }
  });

  // Get complete customer order history for purchase history modal
  app.get("/api/customers/orders/complete-history", async (req, res) => {
    try {
      console.log('ğŸ” [COMPLETE HISTORY API] Customer purchase history request received');
      
      // Get customer ID from session
      const customerId = req.session?.customerId || req.session?.crmCustomerId;
      
      if (!customerId) {
        console.log('âŒ [COMPLETE HISTORY API] No customer session found');
        return res.status(401).json({
          success: false,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡"
        });
      }

      console.log(`ğŸ” [COMPLETE HISTORY API] Loading complete order history for customer ${customerId}`);
      
      // Use customerStorage to get complete order history
      const orders = await customerStorage.getCompleteOrderHistory(customerId);
      
      console.log(`âœ… [COMPLETE HISTORY API] Successfully loaded ${orders.length} orders for customer ${customerId}`);
      
      res.json({
        success: true,
        orders: orders,
        totalCount: orders.length
      });

    } catch (error) {
      console.error('âŒ [COMPLETE HISTORY API] Error loading complete order history:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø³Ø§Ø¨Ù‚Ù‡ Ø®Ø±ÛŒØ¯"
      });
    }
  });

  // CSV Export for completed orders
  app.get("/api/customers/export-orders-csv", async (req, res) => {
    console.log('ğŸ“Š [CSV EXPORT] Called with query:', req.query);
    
    try {
      if (!req.session.isAuthenticated || !req.session.customerId) {
        console.log('âŒ [CSV EXPORT] Unauthorized access attempt');
        return res.status(401).json({
          success: false,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª"
        });
      }

      const customerId = req.session.customerId;
      const { startDate, endDate } = req.query;
      
      console.log(`ğŸ“Š [CSV EXPORT] Exporting CSV for customer ${customerId}, startDate: ${startDate}, endDate: ${endDate}`);
      
      // Get all orders for customer
      const allOrders = await customerStorage.getCompleteOrderHistory(customerId);
      console.log(`ğŸ“Š [CSV EXPORT] Found ${allOrders.length} total orders`);
      
      // Filter for completed orders only
      const completedOrders = allOrders.filter(order => {
        const isCompleted = order.status === 'confirmed' || 
                           order.status === 'delivered' || 
                           order.paymentStatus === 'paid';
        return isCompleted;
      });
      
      console.log(`ğŸ“Š [CSV EXPORT] Found ${completedOrders.length} completed orders`);
      
      // Apply date filtering if provided
      let filteredOrders = completedOrders;
      if (startDate || endDate) {
        filteredOrders = completedOrders.filter(order => {
          const orderDate = new Date(order.createdAt);
          
          if (startDate && endDate) {
            return orderDate >= new Date(startDate) && orderDate <= new Date(endDate + 'T23:59:59');
          } else if (startDate) {
            return orderDate >= new Date(startDate);
          } else if (endDate) {
            return orderDate <= new Date(endDate + 'T23:59:59');
          }
          
          return true;
        });
      }
      
      console.log(`ğŸ“Š [CSV EXPORT] After date filtering: ${filteredOrders.length} orders`);
      
      // Generate CSV headers in Persian
      const headers = [
        'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´',
        'ØªØ§Ø±ÛŒØ® Ø³ÙØ§Ø±Ø´', 
        'ÙˆØ¶Ø¹ÛŒØª',
        'ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª',
        'Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª',
        'Ù…Ø¨Ù„Øº Ú©Ù„ (Ø¯ÛŒÙ†Ø§Ø±)',
        'Ù…Ø­ØµÙˆÙ„Ø§Øª',
        'ØªØ¹Ø¯Ø§Ø¯ Ø§Ù‚Ù„Ø§Ù…',
        'Ø¢Ø¯Ø±Ø³ ØªØ­ÙˆÛŒÙ„'
      ];
      
      // Generate CSV rows
      const csvRows = [headers.join(',')];
      
      for (const order of filteredOrders) {
        const orderDate = new Date(order.createdAt).toLocaleDateString('fa-IR');
        const statusMap = {
          'pending': 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±',
          'confirmed': 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡',
          'processing': 'Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´',
          'shipped': 'Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡',
          'delivered': 'ØªØ­ÙˆÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡',
          'cancelled': 'Ù„ØºÙˆ Ø´Ø¯Ù‡'
        };
        
        const paymentStatusMap = {
          'pending': 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù¾Ø±Ø¯Ø§Ø®Øª',
          'paid': 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯Ù‡',
          'failed': 'Ù†Ø§Ù…ÙˆÙÙ‚',
          'refunded': 'Ø¨Ø±Ú¯Ø´Øª Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡'
        };
        
        const paymentMethodMap = {
          'online': 'Ø¢Ù†Ù„Ø§ÛŒÙ† Ù¾Ø±Ø¯Ø§Ø®Øª',
          'cash': 'Ù†Ù‚Ø¯ÛŒ',
          'bank_transfer': 'ÙˆØ§Ø±ÛŒØ² Ø¨Ø§Ù†Ú©ÛŒ',
          'wallet': 'ÙˆØ§Ù„Øª',
          'partial_wallet': 'Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ±Ú©ÛŒØ¨ÛŒ',
          'bank_transfer_grace': 'ÙˆØ§Ø±ÛŒØ² Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…Ù‡Ù„Øª 3 Ø±ÙˆØ²Ù‡'
        };
        
        const products = order.items ? order.items.map(item => `${item.productName} (${item.quantity})`).join('; ') : 'Ù†Ø§Ù…Ø´Ø®Øµ';
        const totalItems = order.items ? order.items.reduce((sum, item) => sum + item.quantity, 0) : 0;
        
        const row = [
          order.orderNumber || 'Ù†Ø§Ù…Ø´Ø®Øµ',
          orderDate,
          statusMap[order.status] || order.status,
          paymentStatusMap[order.paymentStatus] || order.paymentStatus,
          paymentMethodMap[order.paymentMethod] || order.paymentMethod,
          order.totalAmount ? order.totalAmount.toLocaleString('fa-IR') : '0',
          `"${products}"`, // Wrap in quotes to handle commas
          totalItems,
          `"${order.address || 'Ù†Ø§Ù…Ø´Ø®Øµ'}"` // Wrap in quotes to handle commas
        ];
        
        csvRows.push(row.join(','));
      }
      
      const csvContent = csvRows.join('\n');
      
      // Set CSV headers
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="completed-orders-${customerId}-${new Date().toISOString().split('T')[0]}.csv"`);
      
      // Add BOM for proper Persian character display
      res.write('\ufeff');
      res.end(csvContent);
      
      console.log(`âœ… [CSV EXPORT] CSV generated successfully with ${filteredOrders.length} orders`);

    } catch (error) {
      console.error('âŒ [CSV EXPORT] Error:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§ÛŒÙ„ CSV"
      });
    }
  });

  // Admin delete order (for test orders or administrative deletion)
  app.delete("/api/admin/orders/:orderId/delete", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId); 
      
      console.log(`ğŸ—‘ï¸ [ADMIN DELETE ORDER] Request to delete order ${orderId} by admin ${req.session.adminId}`);
      
      // Get order details first
      const order = await customerStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      // Delete order and release product reservations
      const result = await customerStorage.deleteTemporaryOrder(orderId);
      
      console.log(`âœ… [ADMIN DELETE ORDER] Order ${orderId} (${order.orderNumber}) successfully deleted by admin with ${result.releasedProducts.length} products released`);
      
      res.json({
        success: true,
        message: `Ø³ÙØ§Ø±Ø´ ${order.orderNumber} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯`,
        data: {
          deletedOrderId: orderId,
          deletedOrderNumber: order.orderNumber,
          releasedProducts: result.releasedProducts,
          message: `${result.releasedProducts.length} Ù…Ø­ØµÙˆÙ„ Ø±Ø²Ø±Ùˆ Ø´Ø¯Ù‡ Ø¢Ø²Ø§Ø¯ Ø´Ø¯`
        }
      });
      
    } catch (error: any) {
      console.error(`âŒ [ADMIN DELETE ORDER] Error deleting order:`, error);
      res.status(500).json({
        success: false,
        message: error.message || "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙØ§Ø±Ø´"
      });
    }
  });

  // Delete temporary order with product reservation release
  app.delete("/api/customers/orders/:orderId/delete-temporary", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      
      if (!customerId && !crmCustomerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }
      
      const orderId = parseInt(req.params.orderId);
      const finalCustomerId = crmCustomerId || customerId;
      
      console.log(`ğŸ—‘ï¸ [DELETE TEMP ORDER] Request to delete temporary order ${orderId} by customer ${finalCustomerId}`);
      
      // Verify order belongs to customer
      const order = await customerStorage.getOrderById(orderId);
      if (!order || order.customerId !== finalCustomerId) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ Ù…ØªØ¹Ù„Ù‚ Ø¨Ù‡ Ø´Ù…Ø§ Ù†ÛŒØ³Øª"
        });
      }
      
      // Delete temporary order and release product reservations
      const result = await customerStorage.deleteTemporaryOrder(orderId);
      
      console.log(`âœ… [DELETE TEMP ORDER] Order ${orderId} successfully deleted with ${result.releasedProducts.length} products released`);
      
      res.json({
        success: true,
        message: `Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª ${order.orderNumber} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯`,
        data: {
          deletedOrderId: orderId,
          deletedOrderNumber: order.orderNumber,
          releasedProducts: result.releasedProducts,
          message: `${result.releasedProducts.length} Ù…Ø­ØµÙˆÙ„ Ø±Ø²Ø±Ùˆ Ø´Ø¯Ù‡ Ø¢Ø²Ø§Ø¯ Ø´Ø¯`
        }
      });
      
    } catch (error: any) {
      console.error("âŒ [DELETE TEMP ORDER] Error deleting temporary order:", error);
      res.status(500).json({
        success: false,
        message: error.message || "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª"
      });
    }
  });

  // Activate grace period order (continue with order after uploading receipt)
  app.post("/api/customers/orders/:orderId/activate-grace-period", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }

      const { orderId } = req.params;
      const { pool } = await import('./db');

      // Check if this is a valid grace period order for this customer
      const checkResult = await pool.query(`
        SELECT om.*, co.guest_email, co.customer_id
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE om.customer_order_id = $1 
          AND om.current_status = 'payment_grace_period'
          AND om.payment_grace_period_end > NOW()
          AND (co.guest_email = (
            SELECT email FROM crm_customers WHERE id = $2
          ) OR co.customer_id = $2)
      `, [orderId, customerId]);

      if (checkResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª"
        });
      }

      // Update order status to continue processing
      const updateResult = await pool.query(`
        UPDATE order_management 
        SET 
          current_status = 'financial_pending',
          is_order_locked = false,
          updated_at = NOW()
        WHERE customer_order_id = $1
        RETURNING *
      `, [orderId]);

      if (updateResult.rows.length === 0) {
        return res.status(500).json({
          success: false,
          message: "Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÙØ§Ø±Ø´"
        });
      }

      res.json({
        success: true,
        message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙØ¹Ø§Ù„ Ø´Ø¯ Ùˆ ÙˆØ§Ø±Ø¯ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø§Ù„ÛŒ Ø´Ø¯",
        order: updateResult.rows[0]
      });

    } catch (error) {
      console.error("Error activating grace period order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª"
      });
    }
  });

  // Reset admin password (development only)
  app.post("/api/admin/reset-password-dev", async (req, res) => {
    try {
      const { username, newPassword } = req.body;
      
      if (!username || !newPassword) {
        return res.status(400).json({
          success: false,
          message: "Username and new password required"
        });
      }

      const hashedPassword = await bcrypt.hash(newPassword, 12);
      
      const { pool } = await import('./db');
      const result = await pool.query(
        'UPDATE users SET password_hash = $1 WHERE username = $2 RETURNING id, username',
        [hashedPassword, username]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }

      res.json({
        success: true,
        message: "Password updated successfully"
      });

    } catch (error) {
      console.error("Error resetting admin password:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // Customer password reset - Request reset (Alternative endpoint)
  app.post("/api/customers/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({
          success: false,
          message: "Email is required"
        });
      }

      console.log(`ğŸ“§ [Forgot Password] Email: ${email}`);
      
      // Use CRM storage instead of legacy customer storage to avoid schema issues
      const { CrmStorage } = await import('./crm-storage');
      const crmStorage = new CrmStorage();
      
      const customer = await crmStorage.getCrmCustomerByEmail(email);
      if (!customer) {
        // Don't reveal if email exists or not for security
        console.log(`âš ï¸ [Forgot Password] Customer not found for email: ${email}`);
        return res.json({
          success: true,
          message: "If the email is valid, password reset link has been sent"
        });
      }
      
      console.log(`âœ“ [Forgot Password] Customer found: ${customer.firstName} ${customer.lastName} (ID: ${customer.id})`);

      // Generate reset token
      const crypto = await import('crypto');
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 3600000); // 1 hour
      
      console.log(`ğŸ”‘ [Forgot Password] Generated token: ${resetToken.substring(0, 8)}... (expires in 1 hour)`);

      // Update customer with reset token
      await crmStorage.updateCrmCustomer(customer.id, {
        resetPasswordToken: resetToken,
        resetPasswordExpires: resetExpires
      });
      
      console.log(`ğŸ’¾ [Forgot Password] Token saved to database for customer ID: ${customer.id}`);

      // Send password reset email using Universal Email Service
      const { UniversalEmailService } = await import('./universal-email-service');
      const emailResult = await UniversalEmailService.sendPasswordResetEmail(
        customer.email,
        resetToken,
        `${customer.firstName} ${customer.lastName}`,
        req
      );
      
      console.log(`ğŸ“§ [Forgot Password] Email send result: ${emailResult ? 'Success' : 'Failed'}`);

      // Log activity in CRM
      await crmStorage.logActivity({
        customerId: customer.id,
        activityType: 'password_reset_requested',
        description: 'Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§ÛŒÙ…ÛŒÙ„ (endpoint Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†)',
        performedBy: 'customer'
      });

      res.json({
        success: true,
        message: "Password reset link sent to your email"
      });

    } catch (error) {
      console.error("âŒ [Forgot Password] Error:", error);
      res.status(500).json({
        success: false,
        message: "Error in password reset request"
      });
    }
  });

  // =============================================================================
  // IRAQI CITIES AND SHIPPING RATES MANAGEMENT
  // =============================================================================

  // Get all Iraqi provinces
  app.get("/api/logistics/provinces", async (req, res) => {
    try {
      const { iraqiProvinces } = await import('../shared/logistics-schema');
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const provinces = await db
        .select({
          id: iraqiProvinces.id,
          name: iraqiProvinces.name,
          nameArabic: iraqiProvinces.nameArabic,
          nameEnglish: iraqiProvinces.nameEnglish,
          capital: iraqiProvinces.capital,
          isActive: iraqiProvinces.isActive
        })
        .from(iraqiProvinces)
        .where(eq(iraqiProvinces.isActive, true))
        .orderBy(iraqiProvinces.nameArabic);
      
      res.json({
        success: true,
        data: provinces
      });
    } catch (error) {
      console.error("Error fetching Iraqi provinces:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch provinces" 
      });
    }
  });

  // Get all Iraqi cities with province information - supports filtering by provinceId
  app.get("/api/logistics/cities", async (req, res) => {
    try {
      const { iraqiCities, iraqiProvinces } = await import('../shared/logistics-schema');
      const { db } = await import('./db');
      const { eq, and } = await import('drizzle-orm');
      
      const provinceId = req.query.provinceId ? parseInt(req.query.provinceId as string) : null;
      
      let whereConditions = [eq(iraqiCities.isActive, true)];
      
      // Add province filter if provided
      if (provinceId && !isNaN(provinceId)) {
        whereConditions.push(eq(iraqiCities.provinceId, provinceId));
      }
      
      const cities = await db
        .select()
        .from(iraqiCities)
        .where(whereConditions.length > 1 ? and(...whereConditions) : whereConditions[0])
        .orderBy(iraqiCities.nameArabic);
      
      res.json({
        success: true,
        data: cities
      });
    } catch (error) {
      console.error("Error fetching Iraqi cities:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch cities" 
      });
    }
  });

  // Get cities by province
  app.get("/api/logistics/provinces/:provinceId/cities", async (req, res) => {
    try {
      const provinceId = parseInt(req.params.provinceId);
      if (isNaN(provinceId)) {
        return res.status(400).json({ success: false, message: "Invalid province ID" });
      }

      const { iraqiCities } = await import('../shared/logistics-schema');
      const { db } = await import('./db');
      const { eq, and } = await import('drizzle-orm');
      
      const cities = await db
        .select()
        .from(iraqiCities)
        .where(and(
          eq(iraqiCities.provinceId, provinceId),
          eq(iraqiCities.isActive, true)
        ))
        .orderBy(iraqiCities.nameArabic);
      
      res.json({
        success: true,
        data: cities
      });
    } catch (error) {
      console.error("Error fetching cities by province:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch cities" 
      });
    }
  });

  // Add new Iraqi city
  app.post("/api/logistics/cities", requireAuth, async (req, res) => {
    try {
      const { insertIraqiCitySchema, iraqiCities } = await import('../shared/logistics-schema');
      const { db } = await import('./db');
      
      const cityData = insertIraqiCitySchema.parse(req.body);
      const [city] = await db.insert(iraqiCities).values(cityData).returning();
      
      res.json({
        success: true,
        message: "City added successfully",
        data: city
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid city data", 
          errors: error.errors 
        });
      } else {
        console.error("Error adding Iraqi city:", error);
        res.status(500).json({ 
          success: false, 
          message: "Failed to add city" 
        });
      }
    }
  });

  // Update Iraqi city
  app.patch("/api/logistics/cities/:id", requireAuth, async (req, res) => {
    try {
      const cityId = parseInt(req.params.id);
      if (isNaN(cityId)) {
        return res.status(400).json({ success: false, message: "Invalid city ID" });
      }

      const { iraqiCities } = await import('../shared/logistics-schema');
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const updates = { ...req.body, updatedAt: new Date() };
      const [city] = await db
        .update(iraqiCities)
        .set(updates)
        .where(eq(iraqiCities.id, cityId))
        .returning();
      
      if (!city) {
        return res.status(404).json({ success: false, message: "City not found" });
      }
      
      res.json({
        success: true,
        message: "City updated successfully",
        data: city
      });
    } catch (error) {
      console.error("Error updating Iraqi city:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update city" 
      });
    }
  });

  // Get provinces with detailed information for geography management
  app.get("/api/logistics/provinces-detailed", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          id, 
          name, 
          name_arabic, 
          name_english, 
          name_kurdish,
          capital, 
          region, 
          area, 
          population, 
          is_active, 
          notes,
          created_at, 
          updated_at
        FROM iraqi_provinces 
        ORDER BY name_arabic ASC
      `);
      
      res.json({
        success: true,
        data: result.rows
      });
    } catch (error) {
      console.error("Error fetching detailed provinces:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch detailed provinces" 
      });
    }
  });

  // Get cities with detailed information including province names for geography management
  app.get("/api/logistics/cities-detailed", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          c.id, 
          c.name, 
          c.name_arabic, 
          c.name_english, 
          c.name_kurdish,
          c.province_id, 
          c.distance_from_erbil_km, 
          c.vehicle_id,
          c.is_active, 
          c.has_intercity_bus_line,
          c.notes,
          c.created_at, 
          c.updated_at,
          p.name_arabic as province_name
        FROM iraqi_cities c 
        LEFT JOIN iraqi_provinces p ON c.province_id = p.id
        ORDER BY c.name_arabic ASC
      `);
      
      res.json({
        success: true,
        data: result.rows
      });
    } catch (error) {
      console.error("Error fetching detailed cities:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch detailed cities" 
      });
    }
  });

  // Update province information
  app.put("/api/logistics/provinces/:id", requireAuth, async (req, res) => {
    try {
      const provinceId = parseInt(req.params.id);
      if (isNaN(provinceId)) {
        return res.status(400).json({ success: false, message: "Invalid province ID" });
      }

      const { name_arabic, name_english, capital, region, is_active } = req.body;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        UPDATE iraqi_provinces SET
          name_arabic = $1,
          name_english = $2,
          capital = $3,
          region = $4,
          is_active = $5,
          updated_at = NOW()
        WHERE id = $6
        RETURNING id, name_arabic, name_english, capital, region, is_active, updated_at
      `, [name_arabic, name_english, capital, region, is_active, provinceId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Province not found" });
      }
      
      res.json({
        success: true,
        message: "Province updated successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating province:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update province" 
      });
    }
  });

  // Update city information
  app.put("/api/logistics/cities/:id", requireAuth, async (req, res) => {
    try {
      const cityId = parseInt(req.params.id);
      if (isNaN(cityId)) {
        return res.status(400).json({ success: false, message: "Invalid city ID" });
      }

      const { name_arabic, name_english, distance_from_erbil_km, vehicle_id, is_active, has_intercity_bus_line } = req.body;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        UPDATE iraqi_cities SET
          name_arabic = $1,
          name_english = $2,
          distance_from_erbil_km = $3,
          vehicle_id = $4,
          is_active = $5,
          has_intercity_bus_line = $6,
          updated_at = NOW()
        WHERE id = $7
        RETURNING id, name_arabic, name_english, distance_from_erbil_km, vehicle_id, is_active, has_intercity_bus_line, updated_at
      `, [name_arabic, name_english, distance_from_erbil_km, vehicle_id, is_active, has_intercity_bus_line, cityId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "City not found" });
      }
      
      res.json({
        success: true,
        message: "City updated successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating city:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update city" 
      });
    }
  });

  // =============================================================================
  // SHIPPING RATES MANAGEMENT
  // =============================================================================

  // Get shipping rates for a specific city
  app.get("/api/logistics/shipping-rates/:cityName", async (req, res) => {
    try {
      const cityName = req.params.cityName;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT * FROM shipping_rates 
        WHERE city_name = $1 AND is_active = true
        ORDER BY delivery_method, base_price
      `, [cityName]);
      
      res.json({
        success: true,
        data: result.rows
      });
    } catch (error) {
      console.error("Error fetching shipping rates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch shipping rates" 
      });
    }
  });

  // Get all shipping rates with pagination
  app.get("/api/logistics/shipping-rates", async (req, res) => {
    try {
      const { page = 1, limit = 50, city, province, delivery_method } = req.query;
      const offset = (parseInt(page) - 1) * parseInt(limit);
      const { pool } = await import('./db');
      
      let whereClause = 'WHERE is_active = true';
      const params = [];
      let paramIndex = 1;
      
      if (city) {
        whereClause += ` AND city_name ILIKE $${paramIndex}`;
        params.push(`%${city}%`);
        paramIndex++;
      }
      
      if (province) {
        whereClause += ` AND province_name ILIKE $${paramIndex}`;
        params.push(`%${province}%`);
        paramIndex++;
      }
      
      if (delivery_method) {
        whereClause += ` AND delivery_method = $${paramIndex}`;
        params.push(delivery_method);
        paramIndex++;
      }
      
      const countQuery = `SELECT COUNT(*) FROM shipping_rates ${whereClause}`;
      const countResult = await pool.query(countQuery, params);
      const total = parseInt(countResult.rows[0].count);
      
      const dataQuery = `
        SELECT * FROM shipping_rates 
        ${whereClause}
        ORDER BY province_name, city_name, delivery_method
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      params.push(parseInt(limit), offset);
      
      const dataResult = await pool.query(dataQuery, params);
      
      res.json({
        success: true,
        data: dataResult.rows,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / parseInt(limit))
        }
      });
    } catch (error) {
      console.error("Error fetching shipping rates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch shipping rates" 
      });
    }
  });

  // Add new shipping rate
  app.post("/api/logistics/shipping-rates", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const {
        delivery_method,
        transportation_type,
        city_name,
        province_name,
        min_weight,
        max_weight,
        max_dimensions,
        base_price,
        price_per_kg,
        free_shipping_threshold,
        estimated_days,
        tracking_available,
        insurance_available,
        insurance_rate,
        description,
        internal_notes
      } = req.body;
      
      const result = await pool.query(`
        INSERT INTO shipping_rates (
          delivery_method, transportation_type, city_name, province_name,
          min_weight, max_weight, max_dimensions, base_price, price_per_kg,
          free_shipping_threshold, estimated_days, tracking_available,
          insurance_available, insurance_rate, description, internal_notes,
          is_active, created_at, updated_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,
          true, NOW(), NOW()
        ) RETURNING *
      `, [
        delivery_method, transportation_type, city_name, province_name,
        min_weight, max_weight, max_dimensions, base_price, price_per_kg,
        free_shipping_threshold, estimated_days, tracking_available,
        insurance_available, insurance_rate, description, internal_notes
      ]);
      
      res.json({
        success: true,
        message: "Shipping rate added successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error adding shipping rate:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to add shipping rate" 
      });
    }
  });

  // Update shipping rate
  app.patch("/api/logistics/shipping-rates/:id", requireAuth, async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      if (isNaN(rateId)) {
        return res.status(400).json({ success: false, message: "Invalid rate ID" });
      }

      const { pool } = await import('./db');
      const updates = { ...req.body, updated_at: new Date() };
      
      // Build dynamic update query
      const updateFields = Object.keys(updates)
        .filter(key => key !== 'id')
        .map((key, index) => `${key} = $${index + 2}`)
        .join(', ');
      
      const values = [rateId, ...Object.values(updates).filter((_, index) => Object.keys(updates)[index] !== 'id')];
      
      const result = await pool.query(`
        UPDATE shipping_rates 
        SET ${updateFields}
        WHERE id = $1
        RETURNING *
      `, values);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Shipping rate not found" });
      }
      
      res.json({
        success: true,
        message: "Shipping rate updated successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating shipping rate:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update shipping rate" 
      });
    }
  });

  // Delete shipping rate (soft delete)
  app.delete("/api/logistics/shipping-rates/:id", requireAuth, async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      if (isNaN(rateId)) {
        return res.status(400).json({ success: false, message: "Invalid rate ID" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE shipping_rates 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
        RETURNING *
      `, [rateId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Shipping rate not found" });
      }
      
      res.json({
        success: true,
        message: "Shipping rate deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting shipping rate:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to delete shipping rate" 
      });
    }
  });

  // Calculate shipping cost for a city and weight
  app.post("/api/logistics/calculate-shipping", async (req, res) => {
    try {
      const { cityName, provinceName, weight, deliveryMethod, orderValue } = req.body;
      
      if (!cityName || !weight) {
        return res.status(400).json({ 
          success: false, 
          message: "City name and weight are required" 
        });
      }

      const { pool } = await import('./db');
      
      let query = `
        SELECT * FROM shipping_rates 
        WHERE city_name = $1 AND is_active = true
      `;
      const params = [cityName];
      
      if (deliveryMethod) {
        query += ` AND delivery_method = $2`;
        params.push(deliveryMethod);
      }
      
      if (provinceName) {
        query += ` AND province_name = $${params.length + 1}`;
        params.push(provinceName);
      }
      
      query += ` ORDER BY base_price ASC`;
      
      const result = await pool.query(query, params);
      
      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No shipping rates found for this city"
        });
      }
      
      const calculations = result.rows.map(rate => {
        const basePrice = parseFloat(rate.base_price);
        const pricePerKg = parseFloat(rate.price_per_kg || 0);
        const weightCost = weight * pricePerKg;
        const totalCost = basePrice + weightCost;
        
        // Check for free shipping
        const freeShippingThreshold = parseFloat(rate.free_shipping_threshold || 0);
        const finalCost = (orderValue && orderValue >= freeShippingThreshold) ? 0 : totalCost;
        
        // Calculate insurance cost if applicable
        const insuranceCost = rate.insurance_available && rate.insurance_rate ? 
          (orderValue * parseFloat(rate.insurance_rate) / 100) : 0;
        
        return {
          ...rate,
          weight_cost: weightCost,
          total_shipping_cost: finalCost,
          insurance_cost: insuranceCost,
          final_total: finalCost + insuranceCost,
          is_free_shipping: finalCost === 0 && totalCost > 0
        };
      });
      
      res.json({
        success: true,
        city: cityName,
        province: provinceName,
        weight,
        calculations
      });
    } catch (error) {
      console.error("Error calculating shipping cost:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to calculate shipping cost" 
      });
    }
  });

  // =============================================================================
  // INTERNATIONAL GEOGRAPHY API ENDPOINTS
  // =============================================================================

  // Get all international countries
  app.get("/api/logistics/international-countries", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM international_countries 
        WHERE is_active = true
        ORDER BY name ASC
      `);
      
      res.json({
        success: true,
        data: result.rows
      });
    } catch (error) {
      console.error("Error fetching international countries:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch international countries" 
      });
    }
  });

  // Create new international country
  app.post("/api/logistics/international-countries", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const countryData = insertInternationalCountrySchema.parse(req.body);
      
      const result = await pool.query(`
        INSERT INTO international_countries (
          name, name_en, name_local, country_code, region, currency,
          is_active, has_customs_agreement, notes, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
        RETURNING *
      `, [
        countryData.name,
        countryData.nameEn,
        countryData.nameLocal,
        countryData.countryCode,
        countryData.region,
        countryData.currency,
        countryData.isActive,
        countryData.hasCustomsAgreement,
        countryData.notes
      ]);
      
      res.json({
        success: true,
        message: "Country created successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating international country:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to create international country" 
      });
    }
  });

  // Update international country
  app.put("/api/logistics/international-countries/:id", requireAuth, async (req, res) => {
    try {
      const countryId = parseInt(req.params.id);
      if (isNaN(countryId)) {
        return res.status(400).json({ success: false, message: "Invalid country ID" });
      }

      const { pool } = await import('./db');
      const countryData = req.body;
      
      const result = await pool.query(`
        UPDATE international_countries 
        SET name = $1, name_en = $2, name_local = $3, country_code = $4, 
            region = $5, currency = $6, is_active = $7, has_customs_agreement = $8, 
            notes = $9, updated_at = NOW()
        WHERE id = $10
        RETURNING *
      `, [
        countryData.name,
        countryData.nameEn,
        countryData.nameLocal,
        countryData.countryCode,
        countryData.region,
        countryData.currency,
        countryData.isActive,
        countryData.hasCustomsAgreement,
        countryData.notes,
        countryId
      ]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Country not found" });
      }
      
      res.json({
        success: true,
        message: "Country updated successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating international country:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update international country" 
      });
    }
  });

  // Delete international country (soft delete)
  app.delete("/api/logistics/international-countries/:id", requireAuth, async (req, res) => {
    try {
      const countryId = parseInt(req.params.id);
      if (isNaN(countryId)) {
        return res.status(400).json({ success: false, message: "Invalid country ID" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE international_countries 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
        RETURNING *
      `, [countryId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Country not found" });
      }
      
      res.json({
        success: true,
        message: "Country deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting international country:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to delete international country" 
      });
    }
  });

  // Get all international cities
  app.get("/api/logistics/international-cities", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT c.*, co.name as country_name, co.country_code
        FROM international_cities c
        LEFT JOIN international_countries co ON c.country_id = co.id
        WHERE c.is_active = true
        ORDER BY co.name, c.name ASC
      `);
      
      res.json({
        success: true,
        data: result.rows
      });
    } catch (error) {
      console.error("Error fetching international cities:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch international cities" 
      });
    }
  });

  // Create new international city
  app.post("/api/logistics/international-cities", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const cityData = insertInternationalCitySchema.parse(req.body);
      
      const result = await pool.query(`
        INSERT INTO international_cities (
          name, name_en, name_local, country_id, province_state, city_type,
          distance_from_erbil_km, is_active, has_shipping_routes, is_priority_destination,
          customs_information, notes, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), NOW())
        RETURNING *
      `, [
        cityData.name,
        cityData.nameEn,
        cityData.nameLocal,
        cityData.countryId,
        cityData.provinceState,
        cityData.cityType,
        cityData.distanceFromErbilKm,
        cityData.isActive,
        cityData.hasShippingRoutes,
        cityData.isPriorityDestination,
        cityData.customsInformation,
        cityData.notes
      ]);
      
      res.json({
        success: true,
        message: "City created successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating international city:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to create international city" 
      });
    }
  });

  // Update international city
  app.put("/api/logistics/international-cities/:id", requireAuth, async (req, res) => {
    try {
      const cityId = parseInt(req.params.id);
      if (isNaN(cityId)) {
        return res.status(400).json({ success: false, message: "Invalid city ID" });
      }

      const { pool } = await import('./db');
      const cityData = req.body;
      
      const result = await pool.query(`
        UPDATE international_cities 
        SET name = $1, name_en = $2, name_local = $3, country_id = $4, 
            province_state = $5, city_type = $6, distance_from_erbil_km = $7, 
            is_active = $8, has_shipping_routes = $9, is_priority_destination = $10,
            customs_information = $11, notes = $12, updated_at = NOW()
        WHERE id = $13
        RETURNING *
      `, [
        cityData.name,
        cityData.nameEn,
        cityData.nameLocal,
        cityData.countryId,
        cityData.provinceState,
        cityData.cityType,
        cityData.distanceFromErbilKm,
        cityData.isActive,
        cityData.hasShippingRoutes,
        cityData.isPriorityDestination,
        cityData.customsInformation,
        cityData.notes,
        cityId
      ]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "City not found" });
      }
      
      res.json({
        success: true,
        message: "City updated successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating international city:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update international city" 
      });
    }
  });

  // Delete international city (soft delete)
  app.delete("/api/logistics/international-cities/:id", requireAuth, async (req, res) => {
    try {
      const cityId = parseInt(req.params.id);
      if (isNaN(cityId)) {
        return res.status(400).json({ success: false, message: "Invalid city ID" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE international_cities 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
        RETURNING *
      `, [cityId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "City not found" });
      }
      
      res.json({
        success: true,
        message: "City deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting international city:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to delete international city" 
      });
    }
  });

  // Get all international shipping rates
  app.get("/api/logistics/international-shipping-rates", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT sr.*, co.name as country_name, ci.name as city_name
        FROM international_shipping_rates sr
        LEFT JOIN international_countries co ON sr.country_id = co.id
        LEFT JOIN international_cities ci ON sr.city_id = ci.id
        WHERE sr.is_active = true
        ORDER BY co.name, ci.name, sr.shipping_method ASC
      `);
      
      res.json({
        success: true,
        data: result.rows
      });
    } catch (error) {
      console.error("Error fetching international shipping rates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch international shipping rates" 
      });
    }
  });

  // Create new international shipping rate
  app.post("/api/logistics/international-shipping-rates", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const rateData = insertInternationalShippingRateSchema.parse(req.body);
      
      const result = await pool.query(`
        INSERT INTO international_shipping_rates (
          country_id, city_id, shipping_method, transport_provider, base_price,
          price_per_kg, price_per_km, minimum_charge, maximum_weight, estimated_days_min,
          estimated_days_max, currency, supports_hazardous, supports_flammable,
          supports_refrigerated, requires_customs_clearance, is_active, notes,
          created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, NOW(), NOW())
        RETURNING *
      `, [
        rateData.countryId,
        rateData.cityId,
        rateData.shippingMethod,
        rateData.transportProvider,
        rateData.basePrice,
        rateData.pricePerKg,
        rateData.pricePerKm,
        rateData.minimumCharge,
        rateData.maximumWeight,
        rateData.estimatedDaysMin,
        rateData.estimatedDaysMax,
        rateData.currency,
        rateData.supportsHazardous,
        rateData.supportsFlammable,
        rateData.supportsRefrigerated,
        rateData.requiresCustomsClearance,
        rateData.isActive,
        rateData.notes
      ]);
      
      res.json({
        success: true,
        message: "Shipping rate created successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating international shipping rate:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to create international shipping rate" 
      });
    }
  });

  // Update international shipping rate
  app.put("/api/logistics/international-shipping-rates/:id", requireAuth, async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      if (isNaN(rateId)) {
        return res.status(400).json({ success: false, message: "Invalid rate ID" });
      }

      const { pool } = await import('./db');
      const rateData = req.body;
      
      const result = await pool.query(`
        UPDATE international_shipping_rates 
        SET country_id = $1, city_id = $2, shipping_method = $3, transport_provider = $4,
            base_price = $5, price_per_kg = $6, price_per_km = $7, minimum_charge = $8,
            maximum_weight = $9, estimated_days_min = $10, estimated_days_max = $11,
            currency = $12, supports_hazardous = $13, supports_flammable = $14,
            supports_refrigerated = $15, requires_customs_clearance = $16, 
            is_active = $17, notes = $18, updated_at = NOW()
        WHERE id = $19
        RETURNING *
      `, [
        rateData.countryId,
        rateData.cityId,
        rateData.shippingMethod,
        rateData.transportProvider,
        rateData.basePrice,
        rateData.pricePerKg,
        rateData.pricePerKm,
        rateData.minimumCharge,
        rateData.maximumWeight,
        rateData.estimatedDaysMin,
        rateData.estimatedDaysMax,
        rateData.currency,
        rateData.supportsHazardous,
        rateData.supportsFlammable,
        rateData.supportsRefrigerated,
        rateData.requiresCustomsClearance,
        rateData.isActive,
        rateData.notes,
        rateId
      ]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Shipping rate not found" });
      }
      
      res.json({
        success: true,
        message: "Shipping rate updated successfully",
        data: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating international shipping rate:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update international shipping rate" 
      });
    }
  });

  // Delete international shipping rate (soft delete)
  app.delete("/api/logistics/international-shipping-rates/:id", requireAuth, async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      if (isNaN(rateId)) {
        return res.status(400).json({ success: false, message: "Invalid rate ID" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE international_shipping_rates 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
        RETURNING *
      `, [rateId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Shipping rate not found" });
      }
      
      res.json({
        success: true,
        message: "Shipping rate deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting international shipping rate:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to delete international shipping rate" 
      });
    }
  });

  // Customer password reset - Reset with token
  app.post("/api/customers/reset-password", async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      
      if (!token || !newPassword) {
        return res.status(400).json({
          success: false,
          message: "Token and new password are required"
        });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({
          success: false,
          message: "Password must be at least 6 characters"
        });
      }

      const { pool } = await import('./db');
      
      // Check if token is valid and not expired
      const tokenResult = await pool.query(
        'SELECT email FROM password_resets WHERE token = $1 AND expires_at > NOW() AND used = false',
        [token]
      );

      if (tokenResult.rows.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Invalid or expired token"
        });
      }

      const email = tokenResult.rows[0].email;
      
      // Get customer
      const customer = await customerStorage.getCustomerByEmail(email);
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Customer not found"
        });
      }

      // Update password
      await customerStorage.updateCustomerPassword(customer.id, newPassword);
      
      // Mark token as used AND delete all tokens for this email to prevent reuse
      await pool.query('DELETE FROM password_resets WHERE email = $1', [email]);
      
      console.log(`âœ… Password reset completed for customer: ${email}`);

      res.json({
        success: true,
        message: "Password successfully changed"
      });

    } catch (error) {
      console.error("Error in reset password:", error);
      res.status(500).json({
        success: false,
        message: "Error changing password"
      });
    }
  });

  // Get procedure documents
  app.get("/api/procedures/:procedureId/documents", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT d.id, d.procedure_id, d.outline_id, d.title, d.description, d.file_name, 
               d.file_path, d.file_size, d.file_type, d.upload_date, d.uploaded_by, 
               d.version, d.is_active, d.download_count, d.last_downloaded_at, d.tags,
               u.username as uploaded_by_name,
               o.title as outline_title
        FROM procedure_documents d
        LEFT JOIN users u ON d.uploaded_by = u.id
        LEFT JOIN procedure_outlines o ON d.outline_id = o.id
        WHERE d.procedure_id = $1 AND d.is_active = true
        ORDER BY d.upload_date DESC
      `, [procedureId]);
      
      const documents = result.rows.map((row: any) => ({
        id: row.id,
        procedureId: row.procedure_id,
        outlineId: row.outline_id,
        title: row.title || 'Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†',
        description: row.description,
        fileName: row.file_name || 'ÙØ§ÛŒÙ„ Ù†Ø§Ù…Ø´Ø®Øµ',
        filePath: row.file_path,
        fileSize: row.file_size || 0,
        fileType: row.file_type || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        uploadDate: row.upload_date,
        uploadedBy: row.uploaded_by,
        uploadedByName: row.uploaded_by_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        version: row.version || '1.0',
        isActive: row.is_active,
        downloadCount: row.download_count || 0,
        lastDownloadedAt: row.last_downloaded_at,
        tags: row.tags || [],
        outlineTitle: row.outline_title
      }));

      res.json(documents);
    } catch (error) {
      console.error("Error fetching procedure documents:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Upload procedure document
  app.post("/api/procedures/:procedureId/documents", requireAuth, (req, res, next) => {
    upload.single('document')(req, res, (err) => {
      if (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
      next();
    });
  }, async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, message: "No file uploaded" });
      }

      const { procedureId } = req.params;
      const { title, description, outlineId, version, tags } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process tags
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_documents (
          procedure_id, outline_id, title, description, file_name, 
          file_path, file_size, file_type, uploaded_by, version, tags,
          upload_date, is_active, download_count
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, COALESCE($10, '1.0'), $11, NOW(), true, 0)
        RETURNING id, title, file_name, upload_date, version
      `, [
        procedureId, 
        outlineId || null, 
        title || req.file.originalname, 
        description || null, 
        req.file.originalname, 
        req.file.path, 
        req.file.size, 
        req.file.mimetype, 
        userId, 
        version || '1.0', 
        tagsArray
      ]);

      res.json({
        success: true,
        document: result.rows[0],
        message: "Document uploaded successfully"
      });
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Download procedure document
  app.get("/api/procedures/documents/:documentId/download", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info
      const docResult = await pool.query(`
        SELECT file_path, file_name, file_type
        FROM procedure_documents
        WHERE id = $1 AND is_active = true
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Update download count
      await pool.query(`
        UPDATE procedure_documents 
        SET download_count = download_count + 1, last_downloaded_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Handle both absolute and relative paths
      let filePath = document.file_path;
      if (!path.isAbsolute(filePath)) {
        filePath = path.resolve(process.cwd(), filePath);
      }

      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ success: false, message: "File not found on server" });
      }

      res.setHeader('Content-Disposition', `attachment; filename="${document.file_name}"`);
      res.setHeader('Content-Type', document.file_type || 'application/octet-stream');
      
      res.sendFile(filePath);

    } catch (error) {
      console.error("Error downloading document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Upload procedure document
  app.post("/api/procedures/:procedureId/documents", requireAuth, upload.single('document'), async (req, res) => {
    try {
      const { procedureId } = req.params;
      const { title, description } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ success: false, message: "No file uploaded" });
      }

      const { pool } = await import('./db');
      
      const result = await pool.query(`
        INSERT INTO procedure_documents (
          procedure_id, title, description, file_name, file_path, 
          file_size, file_type, upload_date, uploaded_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), $8)
        RETURNING *
      `, [
        procedureId,
        title || file.originalname,
        description || null,
        file.originalname,
        file.path,
        file.size,
        file.mimetype,
        req.session.adminId
      ]);

      res.json({ 
        success: true, 
        message: "Document uploaded successfully",
        document: result.rows[0] 
      });

    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Delete procedure document
  app.delete("/api/procedures/documents/:documentId", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info before deletion
      const docResult = await pool.query(`
        SELECT file_path, file_name
        FROM procedure_documents
        WHERE id = $1 AND is_active = true
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Mark document as inactive (soft delete)
      await pool.query(`
        UPDATE procedure_documents 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Optionally delete the physical file
      try {
        let filePath = document.file_path;
        if (!path.isAbsolute(filePath)) {
          filePath = path.resolve(process.cwd(), filePath);
        }
        
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      } catch (fileError) {
        console.log('Could not delete physical file:', fileError);
        // Continue even if file deletion fails
      }

      res.json({
        success: true,
        message: "Document deleted successfully"
      });

    } catch (error) {
      console.error("Error deleting document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Generate procedure text document
  app.get("/api/procedures/:procedureId/export", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      const { pool } = await import('./db');
      
      // Get procedure details
      const procedureResult = await pool.query(`
        SELECT p.id, p.title, p.description, p.content, p.version, p.status, p.priority, 
               p.created_at, c.name as category_name
        FROM procedures p
        LEFT JOIN procedure_categories c ON p.category_id = c.id
        WHERE p.id = $1
      `, [procedureId]);

      if (procedureResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Procedure not found" });
      }

      const procedure = procedureResult.rows[0];

      // Generate simple text content
      const textContent = `Ø¯Ø³ØªÙˆØ±Ø§Ù„Ø¹Ù…Ù„: ${procedure.title}
Ù†Ø³Ø®Ù‡: ${procedure.version}
ÙˆØ¶Ø¹ÛŒØª: ${procedure.status}
Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: ${procedure.category_name || 'Ù†Ø§Ù…Ø´Ø®Øµ'}

ØªÙˆØ¶ÛŒØ­Ø§Øª:
${procedure.description || 'Ù†Ø¯Ø§Ø±Ø¯'}

Ù…Ø­ØªÙˆØ§:
${procedure.content}

ØªØ§Ø±ÛŒØ® ØªÙˆÙ„ÛŒØ¯: ${new Date().toLocaleDateString('en-US', {
  year: 'numeric',
  month: 'short',
  day: 'numeric'
})}
`;

      res.setHeader('Content-Type', 'text/plain; charset=utf-8');
      res.setHeader('Content-Disposition', 'attachment; filename=procedure-export.txt');
      res.send(textContent);

    } catch (error) {
      console.error("Error exporting procedure:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get database statistics
  app.get("/api/admin/database/stats", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get actual row counts for major tables
      const getTableCount = async (tableName: string) => {
        try {
          const result = await pool.query(`SELECT COUNT(*) FROM ${tableName}`);
          return parseInt(result.rows[0].count);
        } catch {
          return 0;
        }
      };

      // Get table sizes and statistics
      const tableStats = await pool.query(`
        SELECT 
          t.table_name as tablename,
          COALESCE(s.n_tup_ins, 0) as total_inserts,
          COALESCE(s.n_tup_upd, 0) as total_updates,
          COALESCE(s.n_tup_del, 0) as total_deletes,
          COALESCE(s.n_live_tup, 0) as live_rows,
          pg_size_pretty(pg_total_relation_size(c.oid)) as table_size,
          pg_total_relation_size(c.oid) as size_bytes
        FROM information_schema.tables t
        LEFT JOIN pg_stat_user_tables s ON s.relname = t.table_name
        LEFT JOIN pg_class c ON c.relname = t.table_name
        WHERE t.table_schema = 'public' 
          AND t.table_type = 'BASE TABLE'
        ORDER BY pg_total_relation_size(c.oid) DESC
        LIMIT 20;
      `);

      // Get actual counts for important tables
      const importantTables = ['users', 'products', 'showcase_products', 'shop_products', 'orders', 'crm_customers', 'customer_orders'];
      const tableStatsWithCounts = await Promise.all(
        tableStats.rows.map(async (table) => {
          let actualCount = table.live_rows;
          if (importantTables.includes(table.tablename)) {
            actualCount = await getTableCount(table.tablename);
          }
          return {
            ...table,
            live_rows: actualCount,
            actual_count: actualCount
          };
        })
      );
      
      const dbSize = await pool.query(`
        SELECT pg_size_pretty(pg_database_size(current_database())) as database_size;
      `);
      
      const tableCount = await pool.query(`
        SELECT COUNT(*) as table_count 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
      `);

      // Get total records across all main tables
      const totalRecords = await Promise.all([
        getTableCount('users'),
        getTableCount('products'),
        getTableCount('showcase_products'),
        getTableCount('shop_products'),
        getTableCount('orders'),
        getTableCount('customer_orders'),
        getTableCount('crm_customers'),
        getTableCount('leads'),
        getTableCount('customer_inquiries')
      ]);

      const sumRecords = totalRecords.reduce((sum, count) => sum + count, 0);
      
      res.json({
        database_size: dbSize.rows[0].database_size,
        table_count: parseInt(tableCount.rows[0].table_count),
        total_records: sumRecords,
        table_stats: tableStatsWithCounts.sort((a, b) => b.actual_count - a.actual_count)
      });
    } catch (error) {
      console.error("Error getting database stats:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get detailed inventory with batch information for all products
  app.get("/api/inventory/detailed-with-batches", requireAuth, async (req, res) => {
    try {
      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const detailedInventory = await UnifiedInventoryManager.getDetailedInventoryWithBatches();
      
      res.json({
        success: true,
        data: detailedInventory,
        message: `Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ${detailedInventory.length} Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨Ú† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error fetching detailed inventory with batches:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø§ Ø¨Ú†" });
    }
  });

  // Create inventory transaction and update stock
  app.post("/api/inventory/transaction", requireAuth, async (req, res) => {
    try {
      const { productId, transactionType, quantity, reason, reference, scannedBarcode } = req.body;
      
      // Get current product
      const product = await shopStorage.getShopProductById(productId);
      if (!product) {
        return res.status(404).json({ 
          success: false, 
          message: "Product not found" 
        });
      }
      
      const previousStock = product.stockQuantity || 0;
      let newStock;
      
      if (transactionType === 'in') {
        newStock = previousStock + Math.abs(quantity);
      } else if (transactionType === 'out') {
        newStock = Math.max(0, previousStock - Math.abs(quantity));
      } else if (transactionType === 'audit') {
        newStock = Math.abs(quantity);
      } else {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid transaction type" 
        });
      }
      
      // Update product stock
      await shopStorage.updateShopProduct(productId, { stockQuantity: newStock });
      
      // Log transaction
      console.log('Inventory transaction:', {
        productId,
        transactionType,
        quantity,
        previousStock,
        newStock,
        reason,
        reference,
        scannedBarcode,
        userId: req.session.adminId,
        timestamp: new Date().toISOString()
      });
      
      res.json({
        success: true,
        previousStock,
        newStock,
        quantity: transactionType === 'out' ? -Math.abs(quantity) : Math.abs(quantity)
      });
    } catch (error) {
      console.error("Error creating inventory transaction:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get mock inventory transactions for now
  app.get("/api/inventory/transactions", requireAuth, async (req, res) => {
    try {
      // Return empty array for now - can be extended with actual transaction storage
      res.json([]);
    } catch (error) {
      console.error("Error fetching inventory transactions:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Product inquiry routes
  app.post("/api/inquiries", async (req, res) => {
    try {
      const inquiryData = insertCustomerInquirySchema.parse(req.body);
      const inquiry = await simpleCustomerStorage.createInquiry(inquiryData);
      
      // Send email notification for the inquiry
      try {
        // Get product name for email
        let productName = 'Product';
        if (inquiryData.productIds && Array.isArray(inquiryData.productIds) && inquiryData.productIds.length > 0) {
          const product = await shopStorage.getShopProductById(inquiryData.productIds[0]);
          if (product) {
            productName = product.name;
          }
        }

        // Data for Universal Email Service
        const emailData = {
          contactEmail: inquiryData.contactEmail,
          contactPhone: inquiryData.contactPhone,
          company: inquiryData.company,
          subject: inquiryData.subject,
          message: inquiryData.message,
          type: inquiryData.type,
          priority: inquiryData.priority || 'normal',
          category: inquiryData.category || 'general',
          productName: productName,
          inquiryNumber: inquiry.inquiryNumber,
        };

        // Send inquiry email using Universal Email Service
        const { UniversalEmailService } = await import('./universal-email-service');
        
        // Map inquiry category to email category
        const categoryMap: { [key: string]: string } = {
          'fuel-additives': 'fuel-additives',
          'water-treatment': 'water-treatment', 
          'paint-solvents': 'paint-thinner',
          'agricultural-fertilizers': 'agricultural-fertilizers',
          'industrial-chemicals': 'admin',
          'paint-thinner': 'paint-thinner',
          'technical-equipment': 'admin',
          'commercial-goods': 'orders',
          'general': 'admin',
          'support': 'notifications'
        };
        
        const emailCategory = categoryMap[inquiryData.category] || 'admin';
        
        // Send admin notification email  
        await UniversalEmailService.sendEmail({
          categoryKey: emailCategory,
          to: [],
          cc: ['info@momtazchem.com'],
          subject: `New Product Inquiry: ${inquiryData.subject || 'General Inquiry'}`,
          html: `
            <h2>New Product Inquiry</h2>
            <p><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
            <p><strong>Product:</strong> ${productName || 'General'}</p>
            <p><strong>Contact Email:</strong> ${inquiryData.contactEmail}</p>
            <p><strong>Contact Phone:</strong> ${inquiryData.contactPhone || 'Not provided'}</p>
            <p><strong>Company:</strong> ${inquiryData.company || 'Not provided'}</p>
            <p><strong>Category:</strong> ${inquiryData.category}</p>
            <p><strong>Type:</strong> ${inquiryData.type}</p>
            <p><strong>Priority:</strong> ${inquiryData.priority}</p>
            <p><strong>Message:</strong></p>
            <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px;">
              ${(inquiryData.message || '').replace(/\n/g, '<br>')}
            </div>
            <hr>
            <p style="color: #d32f2f; font-weight: bold;">â° Response Required: Within 24 hours</p>
          `,
          variables: {
            inquiryNumber: inquiry.inquiryNumber,
            productName: productName || 'General',
            contactEmail: inquiryData.contactEmail,
            contactPhone: inquiryData.contactPhone || 'Not provided',
            company: inquiryData.company || 'Not provided',
            category: inquiryData.category,
            type: inquiryData.type,
            priority: inquiryData.priority,
            message: inquiryData.message || ''
          }
        });
        
        console.log(`Admin inquiry notification sent via Universal Email Service for category: ${inquiryData.category} â†’ ${emailCategory}`);

        // Send confirmation email to customer using Template #05 - Follow-up Response
        try {
          const { emailStorage } = await import('./email-storage');
          const followUpTemplate = await emailStorage.getTemplateByNumber('#05');
          
          if (followUpTemplate) {
            console.log(`ğŸ“§ Using Template #05 - ${followUpTemplate.templateName}`);
            console.log(`ğŸ“§ Template #05 debug:`, {
              hasHtmlContent: !!followUpTemplate.htmlContent,
              hasSubject: !!followUpTemplate.subject,
              htmlLength: followUpTemplate.htmlContent?.length || 0,
              subjectText: followUpTemplate.subject
            });
            
            const templateVariables = {
              customer_name: inquiryData.contactEmail.split('@')[0] || 'Valued Customer',
              inquiry_number: inquiry.inquiryNumber,
              inquiry_subject: inquiryData.subject || 'General Inquiry',
              inquiry_category: inquiryData.category || 'general',
              customer_message: inquiryData.message || 'No specific message provided',
              response_text: `Dear ${inquiryData.contactEmail.split('@')[0] || 'Customer'},

Thank you for your inquiry about our ${inquiryData.category || 'chemical products'}. We are pleased to provide you with detailed information about this product. 

Our technical team has reviewed your requirements and will send you a comprehensive quote including pricing, specifications, and availability within 24 hours. 

If you need immediate assistance or have specific technical questions, please feel free to contact us directly.

Best regards,
Momtaz Chemical Technical Team`,
              contact_phone: '+964 770 999 6771',
              contact_email: 'info@momtazchem.com'
            };

            // Process template content with variables - with null safety
            let processedHtml = followUpTemplate.htmlContent || '';
            let processedSubject = followUpTemplate.subject || `Inquiry Confirmation - ${inquiry.inquiryNumber}`;
            
            // Only process variables if we have content
            if (processedHtml && processedSubject) {
              for (const [key, value] of Object.entries(templateVariables)) {
                const placeholder = `{{${key}}}`;
                processedHtml = processedHtml.replace(new RegExp(placeholder, 'g'), String(value || ''));
                processedSubject = processedSubject.replace(new RegExp(placeholder, 'g'), String(value || ''));
              }
            } else {
              console.warn(`âš ï¸ Template #05 missing content, using fallback`);
              // Use fallback template
              processedSubject = `Inquiry Confirmation - ${inquiry.inquiryNumber}`;
              processedHtml = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                  <h2>Thank you for your inquiry!</h2>
                  <p>Dear ${templateVariables.customer_name},</p>
                  <p>We have received your inquiry about <strong>${inquiryData.category}</strong> and will respond within 24 hours.</p>
                  <p><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
                  <p><strong>Your Message:</strong><br>${inquiryData.message}</p>
                  <hr>
                  <p>Best regards,<br>Momtaz Chemical Team</p>
                  <p>Email: info@momtazchem.com<br>Phone: +964 770 999 6771</p>
                </div>
              `;
            }

            await UniversalEmailService.sendEmail({
              categoryKey: 'notifications',
              to: [inquiryData.contactEmail],
              subject: processedSubject,
              html: processedHtml,
              templateNumber: '#05',
              variables: templateVariables
            });
            
            console.log(`âœ… Follow-up email sent using Template #05 to: ${inquiryData.contactEmail}`);
          } else {
            console.warn(`âš ï¸ Template #05 not found, using fallback template`);
            // Fallback to hardcoded template
            await UniversalEmailService.sendEmail({
              categoryKey: 'notifications',
              to: [inquiryData.contactEmail],
              cc: [],
              subject: `Inquiry Confirmation - ${inquiry.inquiryNumber}`,
              html: `
              <div style="font-family: 'Arial', 'Helvetica', sans-serif; max-width: 600px; margin: 0 auto; background: #ffffff; padding: 30px; border: 1px solid #e0e0e0; border-radius: 8px;">
                
                <div style="text-align: center; margin-bottom: 30px;">
                  <h1 style="color: #2c3e50; font-size: 24px; font-weight: bold; margin: 0;">Momtaz Chemical Solutions</h1>
                  <p style="color: #7f8c8d; font-size: 14px; margin: 5px 0 0 0;">Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ</p>
                </div>
                
                <p style="color: #2c3e50; font-size: 16px; line-height: 1.6; margin: 0 0 20px 0;">
                  Dear Valued Customer,
                </p>
                
                <p style="color: #2c3e50; font-size: 16px; line-height: 1.6; margin: 0 0 25px 0;">
                  Thank you for your inquiry. We have prepared a follow-up response regarding your request:
                </p>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 6px; margin: 25px 0; border-left: 4px solid #3498db;">
                  <h3 style="color: #2c3e50; font-size: 16px; font-weight: bold; margin: 0 0 15px 0;">Your Original Inquiry:</h3>
                  <p style="margin: 8px 0; color: #34495e; font-size: 14px;"><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
                  <p style="margin: 8px 0; color: #34495e; font-size: 14px;"><strong>Subject:</strong> ${inquiryData.subject || 'General Inquiry'}</p>
                  <p style="margin: 8px 0; color: #34495e; font-size: 14px;"><strong>Category:</strong> ${inquiryData.category || 'General'}</p>
                  
                  <hr style="border: none; height: 1px; background: linear-gradient(to right, #3498db, #e74c3c, #3498db); margin: 15px 0;">
                  
                  <div style="background: #ffffff; padding: 15px; border-radius: 4px; border: 1px solid #ddd;">
                    <h4 style="color: #2c3e50; font-size: 14px; font-weight: bold; margin: 0 0 10px 0;">Your Message:</h4>
                    <p style="color: #555; font-size: 14px; line-height: 1.6; margin: 0; font-style: italic;">
                      "${inquiryData.message || 'No specific message provided'}"
                    </p>
                  </div>
                </div>
                
                <div style="background: #e8f4fd; padding: 20px; border-radius: 6px; margin: 25px 0; border-left: 4px solid #27ae60;">
                  <h3 style="color: #2c3e50; font-size: 16px; font-weight: bold; margin: 0 0 15px 0;">Our Response:</h3>
                  
                  <hr style="border: none; height: 2px; background: linear-gradient(to right, #27ae60, #3498db, #27ae60); margin: 15px 0;">
                  
                  <div style="background: #ffffff; padding: 18px; border-radius: 4px; border: 1px solid #27ae60; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; font-size: 15px; line-height: 1.6; margin: 0;">
                      Thank you for your inquiry about our <strong>${productName || 'chemical products'}</strong>. We are pleased to provide you with detailed information about this product. Our technical team has reviewed your requirements and will send you a comprehensive quote including pricing, specifications, and availability within <strong>24 hours</strong>. Please feel free to contact us if you have any additional questions.
                    </p>
                  </div>
                </div>
                
                <div style="background: #fff3cd; padding: 20px; border-radius: 6px; margin: 25px 0; border-left: 4px solid #f39c12;">
                  <h3 style="color: #2c3e50; font-size: 16px; font-weight: bold; margin: 0 0 15px 0;">Need Further Assistance?</h3>
                  <p style="color: #2c3e50; font-size: 14px; line-height: 1.6; margin: 0 0 15px 0;">
                    If you have any additional questions or need clarification, please don't hesitate to contact us:
                  </p>
                  <p style="margin: 5px 0; color: #2c3e50; font-size: 14px;"><strong>Email:</strong> info@momtazchem.com</p>
                  <p style="margin: 5px 0; color: #2c3e50; font-size: 14px;"><strong>Phone:</strong> +964 770 999 6771</p>
                  <p style="margin: 5px 0; color: #2c3e50; font-size: 14px;"><strong>Website:</strong> www.momtazchem.com</p>
                </div>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ecf0f1;">
                  <p style="color: #2c3e50; font-size: 16px; line-height: 1.6; margin: 0 0 10px 0;">
                    Best regards,
                  </p>
                  <p style="color: #3498db; font-size: 16px; font-weight: bold; margin: 0 0 5px 0;">
                    Momtaz Chemical Team
                  </p>
                  <p style="color: #7f8c8d; font-size: 14px; margin: 0;">
                    Leading Chemical Solutions Provider
                  </p>
                </div>
                
                <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ecf0f1;">
                  <p style="color: #95a5a6; font-size: 12px; margin: 0;">
                    Â© 2025 Momtaz Chemical Solutions. All rights reserved.
                  </p>
                </div>
              </div>
            `
            });
            
            console.log(`âœ… Customer confirmation email sent to: ${inquiryData.contactEmail} (using fallback)`);
          }
        } catch (customerEmailError) {
          console.error("âŒ Failed to send customer confirmation email:", customerEmailError);
        }
      } catch (emailError) {
        console.error("Failed to send inquiry email:", emailError);
        // Don't fail the inquiry creation if email fails
      }

      // Auto-capture customer data in CRM system
      try {
        // Check if customer exists in CRM
        let existingCustomer = null;
        if (inquiryData.contactEmail) {
          existingCustomer = await crmStorage.getCrmCustomerByEmail(inquiryData.contactEmail);
        }

        if (existingCustomer) {
          // Log inquiry activity for existing customer
          await crmStorage.logCustomerActivity({
            customerId: existingCustomer.id,
            activityType: 'product_inquiry',
            description: `Product inquiry: ${inquiryData.subject || 'General inquiry'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_product_inquiry',
              inquiryType: inquiryData.type,
              category: inquiryData.category,
              priority: inquiryData.priority,
              productName: 'General',
              inquiryNumber: inquiry.inquiryNumber,
              message: inquiryData.message
            }
          });
          console.log(`âœ… Product inquiry logged to existing CRM customer: ${inquiryData.contactEmail}`);
        } else {
          // Create new CRM customer from inquiry
          const newCrmCustomer = await crmStorage.createCrmCustomer({
            email: inquiryData.contactEmail,
            firstName: (inquiryData.contactEmail.split('@')[0] || 'Customer').split('.')[0],
            lastName: '',
            company: inquiryData.company || null,
            phone: inquiryData.contactPhone || null,
            customerType: 'prospect',
            customerSource: 'website_inquiry',
            isActive: true,
            passwordHash: '', // Will be set when customer creates account
          });

          // Log initial inquiry activity
          await crmStorage.logCustomerActivity({
            customerId: newCrmCustomer.id,
            activityType: 'first_contact',
            description: `First contact via product inquiry: ${inquiryData.subject || 'General inquiry'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_product_inquiry',
              inquiryType: inquiryData.type,
              category: inquiryData.category,
              priority: inquiryData.priority,
              productName: 'General',
              inquiryNumber: inquiry.inquiryNumber,
              message: inquiryData.message
            }
          });
          console.log(`âœ… New CRM customer created from product inquiry: ${inquiryData.contactEmail}`);
        }
      } catch (crmError) {
        console.error("âŒ Error auto-capturing customer in CRM from product inquiry:", crmError);
        // Don't fail the inquiry if CRM capture fails
      }
      
      res.status(201).json({ 
        success: true, 
        message: "Inquiry submitted successfully",
        inquiry 
      });
    } catch (error) {
      console.error("Error creating inquiry:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid inquiry data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });



  app.patch("/api/inquiries/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid inquiry ID" 
        });
      }

      const updates = req.body;
      const inquiry = await simpleCustomerStorage.updateInquiry(id, updates);
      res.json({ 
        success: true, 
        message: "Inquiry updated successfully",
        inquiry 
      });
    } catch (error) {
      console.error("Error updating inquiry:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // CRM Lead management routes
  app.post("/api/leads", requireAuth, async (req, res) => {
    try {
      console.log('Creating lead with data:', req.body);
      const leadData = insertLeadSchema.parse(req.body);
      console.log('Parsed lead data:', leadData);
      const lead = await storage.createLead(leadData);
      res.status(201).json(lead);
    } catch (error) {
      console.error('Lead creation error:', error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid lead data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  });

  app.get("/api/leads", requireAuth, async (req, res) => {
    try {
      const { status, priority, assignedTo, search } = req.query;
      const filters = {
        status: status as string,
        priority: priority as string,
        assignedTo: assignedTo ? parseInt(assignedTo as string) : undefined,
        search: search as string,
      };
      
      const leads = await storage.getLeads(filters);
      res.json(leads);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/leads/statistics", requireAuth, async (req, res) => {
    try {
      const stats = await storage.getLeadStatistics();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/leads/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const lead = await storage.getLeadById(id);
      if (!lead) {
        return res.status(404).json({ 
          success: false, 
          message: "Lead not found" 
        });
      }

      res.json(lead);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.patch("/api/leads/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const leadData = insertLeadSchema.partial().parse(req.body);
      const lead = await storage.updateLead(id, leadData);
      res.json(lead);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid lead data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  app.delete("/api/leads/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      await storage.deleteLead(id);
      res.json({ success: true, message: "Lead deleted successfully" });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Convert contact to lead
  app.post("/api/contacts/:id/convert-to-lead", requireAuth, async (req, res) => {
    try {
      const contactId = parseInt(req.params.id);
      if (isNaN(contactId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid contact ID" 
        });
      }

      const additionalData = req.body || {};
      const lead = await storage.convertContactToLead(contactId, additionalData);
      res.status(201).json(lead);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : "Internal server error" 
      });
    }
  });

  // Lead activities routes
  app.post("/api/leads/:leadId/activities", requireAuth, async (req, res) => {
    try {
      const leadId = parseInt(req.params.leadId);
      if (isNaN(leadId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const activityData = insertLeadActivitySchema.parse({
        ...req.body,
        leadId,
        createdBy: req.session.adminId
      });
      
      const activity = await storage.createLeadActivity(activityData);
      res.status(201).json(activity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid activity data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  app.get("/api/leads/:leadId/activities", requireAuth, async (req, res) => {
    try {
      const leadId = parseInt(req.params.leadId);
      if (isNaN(leadId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const activities = await storage.getLeadActivities(leadId);
      res.json(activities);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Shop/E-commerce API endpoints - Inventory-based product management
  app.get("/api/shop/products", async (req, res) => {
    try {
      const products = await shopStorage.getShopProducts();
      
      // Map database fields to frontend expected format
      const mappedProducts = products.map(product => ({
        ...product,
        imageUrl: product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls[0] : null,
        imageUrls: product.imageUrls || [], // Include the full array of images
        unitPrice: product.price,
        currency: (product.priceUnit === 'IQD' || !product.priceUnit || product.priceUnit === 'unit') ? 'IQD' : product.priceUnit,
        weight: product.weight,
        weightUnit: product.weightUnit
      }));
      
      res.json(mappedProducts);
    } catch (error) {
      console.error("Error fetching shop products:", error);
      res.status(500).json({ success: false, message: "Failed to fetch products" });
    }
  });

  app.get("/api/shop/categories", async (req, res) => {
    try {
      const categories = await shopStorage.getShopCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching shop categories:", error);
      res.status(500).json({ success: false, message: "Failed to fetch categories" });
    }
  });

  app.get("/api/shop/products/:id", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      const product = await shopStorage.getShopProductById(productId);
      if (!product) {
        return res.status(404).json({ success: false, message: "Product not found" });
      }
      
      // Map database fields to frontend expected format
      const mappedProduct = {
        ...product,
        imageUrl: product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls[0] : null,
        imageUrls: product.imageUrls || [], // Include the full array of images
        unitPrice: product.price,
        currency: (product.priceUnit === 'IQD' || !product.priceUnit || product.priceUnit === 'unit') ? 'IQD' : product.priceUnit,
        weight: product.weight,
        weightUnit: product.weightUnit
      };
      
      res.json(mappedProduct);
    } catch (error) {
      console.error("Error fetching shop product:", error);
      res.status(500).json({ success: false, message: "Failed to fetch product" });
    }
  });

  app.post("/api/shop/products", requireAuth, async (req, res) => {
    try {
      const productData = insertShopProductSchema.parse(req.body);
      const product = await shopStorage.createShopProduct(productData);
      res.json({ success: true, product });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid product data", 
          errors: error.errors 
        });
      } else {
        console.error("Error creating shop product:", error);
        res.status(500).json({ success: false, message: "Failed to create product" });
      }
    }
  });

  app.patch("/api/shop/products/:id", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      const updates = req.body;
      const product = await shopStorage.updateShopProduct(productId, updates);
      res.json(product);
    } catch (error) {
      console.error("Error updating shop product:", error);
      res.status(500).json({ success: false, message: "Failed to update product" });
    }
  });

  app.delete("/api/shop/products/:id", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      await shopStorage.deleteShopProduct(productId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting shop product:", error);
      res.status(500).json({ success: false, message: "Failed to delete product" });
    }
  });

  // Advanced shop product search
  app.get("/api/shop/search", async (req, res) => {
    try {
      const {
        q: query = '',
        category,
        priceMin,
        priceMax,
        inStock,
        tags,
        sortBy = 'relevance',
        sortOrder = 'desc',
        limit = 50,
        offset = 0
      } = req.query;

      const filters = {
        category: category as string,
        priceMin: priceMin ? parseFloat(priceMin as string) : undefined,
        priceMax: priceMax ? parseFloat(priceMax as string) : undefined,
        inStock: inStock ? inStock === 'true' : undefined,
        tags: tags ? (Array.isArray(tags) ? tags as string[] : [tags as string]) : undefined,
        sortBy: sortBy as 'name' | 'price' | 'created' | 'relevance',
        sortOrder: sortOrder as 'asc' | 'desc',
        limit: parseInt(limit as string) || 50,
        offset: parseInt(offset as string) || 0
      };

      const searchResults = await shopStorage.searchShopProducts(query as string, filters);
      
      // Map database fields to frontend expected format
      const mappedProducts = searchResults.products.map(product => ({
        ...product,
        imageUrl: product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls[0] : null,
        imageUrls: product.imageUrls || [], // Include the full array of images
        unitPrice: product.price,
        currency: (product.priceUnit === 'IQD' || !product.priceUnit || product.priceUnit === 'unit') ? 'IQD' : product.priceUnit,
        weight: product.weight,
        weightUnit: product.weightUnit
      }));
      
      res.json({
        success: true,
        data: {
          ...searchResults,
          products: mappedProducts
        },
        query: {
          searchTerm: query,
          filters: filters,
          pagination: {
            limit: filters.limit,
            offset: filters.offset,
            total: searchResults.total,
            pages: Math.ceil(searchResults.total / filters.limit)
          }
        }
      });
    } catch (error) {
      console.error("Error searching shop products:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to search products",
        error: error.message 
      });
    }
  });

  // Get product stats for all products (for star ratings display in shop)
  app.get("/api/shop/product-stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get all product stats
      const statsResult = await pool.query(`
        SELECT 
          product_id,
          total_reviews,
          average_rating,
          rating_distribution,
          last_review_date
        FROM product_stats 
        WHERE total_reviews > 0
        ORDER BY product_id
      `);

      // Convert to object with product_id as key
      const statsData = {};
      statsResult.rows.forEach(row => {
        statsData[row.product_id] = {
          totalReviews: parseInt(row.total_reviews) || 0,
          averageRating: parseFloat(row.average_rating) || 0,
          ratingDistribution: row.rating_distribution || {},
          lastReviewDate: row.last_review_date
        };
      });

      res.json({
        success: true,
        data: statsData
      });
    } catch (error) {
      console.error("Error fetching product stats:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ù…Ø­ØµÙˆÙ„Ø§Øª" });
    }
  });

  // Shop categories management
  app.post("/api/shop/categories", requireAuth, async (req, res) => {
    try {
      const categoryData = insertShopCategorySchema.parse(req.body);
      const category = await shopStorage.createShopCategory(categoryData);
      res.json({ success: true, category });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid category data", 
          errors: error.errors 
        });
      } else {
        console.error("Error creating shop category:", error);
        res.status(500).json({ success: false, message: "Failed to create category" });
      }
    }
  });

  app.patch("/api/shop/categories/:id", requireAuth, async (req, res) => {
    try {
      const categoryId = parseInt(req.params.id);
      if (isNaN(categoryId)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const updates = req.body;
      const category = await shopStorage.updateShopCategory(categoryId, updates);
      res.json(category);
    } catch (error) {
      console.error("Error updating shop category:", error);
      res.status(500).json({ success: false, message: "Failed to update category" });
    }
  });

  // Goods in Transit management endpoints
  app.get("/api/shop/goods-in-transit", async (req, res) => {
    try {
      const { status } = req.query;
      const goodsInTransit = await shopStorage.getGoodsInTransit(status as string);
      res.json(goodsInTransit);
    } catch (error) {
      console.error("Error fetching goods in transit:", error);
      res.status(500).json({ success: false, message: "Failed to fetch goods in transit" });
    }
  });

  app.get("/api/shop/inventory-movements", async (req, res) => {
    try {
      const { productId } = req.query;
      const movements = await shopStorage.getShopInventoryMovements(productId ? parseInt(productId as string) : undefined);
      res.json(movements);
    } catch (error) {
      console.error("Error fetching inventory movements:", error);
      res.status(500).json({ success: false, message: "Failed to fetch inventory movements" });
    }
  });

  app.post("/api/shop/goods-in-transit", requireAuth, async (req, res) => {
    try {
      const transitData = req.body;
      const newTransit = await shopStorage.createGoodsInTransit(transitData);
      res.json({ success: true, data: newTransit });
    } catch (error) {
      console.error("Error creating goods in transit:", error);
      res.status(500).json({ success: false, message: "Failed to create goods in transit" });
    }
  });

  app.patch("/api/shop/goods-in-transit/:id", requireAuth, async (req, res) => {
    try {
      const transitId = parseInt(req.params.id);
      if (isNaN(transitId)) {
        return res.status(400).json({ success: false, message: "Invalid transit ID" });
      }
      
      const updates = req.body;
      const updatedTransit = await shopStorage.updateGoodsInTransit(transitId, updates);
      res.json({ success: true, data: updatedTransit });
    } catch (error) {
      console.error("Error updating goods in transit:", error);
      res.status(500).json({ success: false, message: "Failed to update goods in transit" });
    }
  });

  // Inventory synchronization endpoints  
  app.post("/api/inventory/sync/force", async (req, res) => {
    try {
      const { InventorySyncManager } = await import("./inventory-sync-manager");
      await InventorySyncManager.forceBidirectionalSync();
      res.json({ success: true, message: "Bidirectional sync completed successfully" });
    } catch (error) {
      console.error("Error in force sync:", error);
      res.status(500).json({ success: false, message: "Failed to sync inventories" });
    }
  });

  // Unified inventory endpoint - single source of truth
  app.get("/api/inventory/unified/products", async (req, res) => {
    try {
      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const products = await UnifiedInventoryManager.getAllProductsWithInventory();
      res.json(products);
    } catch (error) {
      console.error("Error getting unified products:", error);
      res.status(500).json({ success: false, message: "Failed to get unified products" });
    }
  });

  // Get specific product inventory
  app.get("/api/products/:name/inventory", async (req, res) => {
    try {
      const productName = decodeURIComponent(req.params.name);
      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const inventory = await UnifiedInventoryManager.getProductInventory(productName);
      
      if (!inventory) {
        return res.status(404).json({ success: false, message: "Product not found" });
      }
      
      res.json({ success: true, inventory });
    } catch (error) {
      console.error("Error getting product inventory:", error);
      res.status(500).json({ success: false, message: "Failed to get product inventory" });
    }
  });

  app.post("/api/inventory/sync/product/:name", async (req, res) => {
    try {
      const productName = decodeURIComponent(req.params.name);
      const { InventorySyncManager } = await import("./inventory-sync-manager");
      await InventorySyncManager.syncProductByName(productName);
      res.json({ success: true, message: `Product ${productName} synchronized successfully` });
    } catch (error) {
      console.error("Error syncing product:", error);
      res.status(500).json({ success: false, message: "Failed to sync product" });
    }
  });

  // Inventory management endpoints
  app.get("/api/shop/inventory/:productId", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.productId);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      const transactions = await shopStorage.getShopInventoryMovements(productId);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching inventory transactions:", error);
      res.status(500).json({ success: false, message: "Failed to fetch inventory data" });
    }
  });

  app.post("/api/shop/inventory/update", requireAuth, async (req, res) => {
    try {
      const { productId, newQuantity, reason } = req.body;
      
      if (!productId || newQuantity === undefined || !reason) {
        return res.status(400).json({ 
          success: false, 
          message: "Missing required fields: productId, newQuantity, reason" 
        });
      }
      
      await shopStorage.updateProductStock(productId, newQuantity, reason);
      res.json({ success: true, message: "Inventory updated successfully" });
    } catch (error) {
      console.error("Error updating inventory:", error);
      res.status(500).json({ success: false, message: "Failed to update inventory" });
    }
  });

  // Order management endpoints - REMOVED DUPLICATE ENDPOINT TO PREVENT WALLET PAYMENT OVERRIDE

  app.get("/api/shop/orders", requireAuth, async (req, res) => {
    try {
      // Get customer orders from the customer_orders table
      const orders = await customerStorage.getAllOrders();
      
      // Get detailed order information with items and customer details
      const detailedOrders = await Promise.all(
        orders.map(async (order) => {
          const items = await customerStorage.getOrderItems(order.id);
          let customer = null;
          if (order.customerId) {
            customer = await customerStorage.getCustomerById(order.customerId);
          }

          // Calculate wallet amount used for payment source display
          let walletAmountUsed = 0;
          if (order.paymentMethod === 'wallet_full') {
            walletAmountUsed = parseFloat(order.totalAmount || 0);
          } else if (order.paymentMethod === 'wallet_partial') {
            // Get wallet transaction for this order to find actual amount used
            try {
              const { pool } = await import('./db');
              const walletResult = await pool.query(`
                SELECT amount FROM wallet_transactions 
                WHERE reference_type = 'order' AND reference_id = $1 AND transaction_type = 'debit'
                ORDER BY created_at DESC LIMIT 1
              `, [order.id]);
              
              if (walletResult.rows.length > 0) {
                walletAmountUsed = parseFloat(walletResult.rows[0].amount || 0);
              }
            } catch (error) {
              console.error(`Error fetching wallet transaction for order ${order.id}:`, error);
            }
          }

          return {
            ...order,
            items,
            customer,
            orderDate: order.createdAt, // Map for compatibility
            orderNumber: order.orderNumber,
            // Include shipping method information
            carrier: order.carrier,
            paymentMethod: order.paymentMethod,
            // Add wallet amount used for payment source display
            walletAmountUsed: walletAmountUsed,
          };
        })
      );

      res.json(detailedOrders);
    } catch (error) {
      console.error("Error fetching customer orders:", error);
      res.status(500).json({ success: false, message: "Failed to fetch customer orders" });
    }
  });

  app.get("/api/shop/orders/:id", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }
      
      const order = await shopStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Order not found" });
      }

      const orderItems = await shopStorage.getOrderItems(orderId);
      res.json({ ...order, items: orderItems });
    } catch (error) {
      console.error("Error fetching order:", error);
      res.status(500).json({ success: false, message: "Failed to fetch order" });
    }
  });

  app.patch("/api/shop/orders/:id", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }
      
      const updates = req.body;
      const currentOrder = await customerStorage.getOrderById(orderId);
      
      if (!currentOrder) {
        return res.status(404).json({ success: false, message: "Order not found" });
      }
      
      // Update the customer order status
      const updatedOrder = await customerStorage.updateOrder(orderId, updates);
      
      // Trigger automatic synchronization after order update
      try {
        await globalSyncService.triggerOrderSync(orderId, 'order_updated');
        console.log(`ğŸ”„ [SYNC] Triggered automatic sync for order update ${orderId}`);
      } catch (syncError) {
        console.error(`âŒ [SYNC] Auto-sync failed for order ${orderId}:`, syncError);
        // Don't fail order update if sync fails
      }
      
      res.json({
        success: true,
        message: "Order status updated successfully",
        order: updatedOrder
      });
    } catch (error) {
      console.error("Error updating customer order:", error);
      res.status(500).json({ success: false, message: "Failed to update customer order" });
    }
  });

  // Product Returns endpoints
  app.get("/api/shop/returns", requireAuth, async (req, res) => {
    try {
      const returns = await shopStorage.getProductReturns();
      res.json({ success: true, data: returns });
    } catch (error) {
      console.error("Error fetching product returns:", error);
      res.status(500).json({ success: false, message: "Failed to fetch product returns" });
    }
  });

  app.post("/api/shop/returns", requireAuth, async (req, res) => {
    try {
      const returnData = req.body;
      
      // Find customer by phone number
      const customer = await shopStorage.findCustomerByPhone(returnData.customerPhone);
      if (customer) {
        returnData.customerName = `${customer.firstName} ${customer.lastName}`;
      }
      
      // Get product information
      const product = await shopStorage.getShopProductById(returnData.productId);
      if (!product) {
        return res.status(404).json({ success: false, message: "Product not found" });
      }
      
      returnData.productName = product.name;
      returnData.productSku = product.sku;
      returnData.unitPrice = product.price;
      
      // Ensure returnDate is a proper Date object
      if (returnData.returnDate && typeof returnData.returnDate === 'string') {
        returnData.returnDate = new Date(returnData.returnDate);
      } else if (!returnData.returnDate) {
        returnData.returnDate = new Date();
      }
      
      const newReturn = await shopStorage.createProductReturn(returnData);
      res.json({ success: true, data: newReturn });
    } catch (error) {
      console.error("Error creating product return:", error);
      res.status(500).json({ success: false, message: "Failed to create product return" });
    }
  });

  app.get("/api/shop/returns/:id", requireAuth, async (req, res) => {
    try {
      const returnId = parseInt(req.params.id);
      if (isNaN(returnId)) {
        return res.status(400).json({ success: false, message: "Invalid return ID" });
      }
      
      const returnRecord = await shopStorage.getProductReturnById(returnId);
      if (!returnRecord) {
        return res.status(404).json({ success: false, message: "Return not found" });
      }
      
      res.json({ success: true, data: returnRecord });
    } catch (error) {
      console.error("Error fetching product return:", error);
      res.status(500).json({ success: false, message: "Failed to fetch product return" });
    }
  });

  app.patch("/api/shop/returns/:id", requireAuth, async (req, res) => {
    try {
      const returnId = parseInt(req.params.id);
      if (isNaN(returnId)) {
        return res.status(400).json({ success: false, message: "Invalid return ID" });
      }
      
      const updateData = req.body;
      const updatedReturn = await shopStorage.updateProductReturn(returnId, updateData);
      res.json({ success: true, data: updatedReturn });
    } catch (error) {
      console.error("Error updating product return:", error);
      res.status(500).json({ success: false, message: "Failed to update product return" });
    }
  });

  app.delete("/api/shop/returns/:id", requireAuth, async (req, res) => {
    try {
      const returnId = parseInt(req.params.id);
      if (isNaN(returnId)) {
        return res.status(400).json({ success: false, message: "Invalid return ID" });
      }
      
      await shopStorage.deleteProductReturn(returnId);
      res.json({ success: true, message: "Product return deleted successfully" });
    } catch (error) {
      console.error("Error deleting product return:", error);
      res.status(500).json({ success: false, message: "Failed to delete product return" });
    }
  });

  app.get("/api/shop/returns/stats", requireAuth, async (req, res) => {
    try {
      console.log("ğŸ”„ Attempting to fetch return statistics...");
      const stats = await shopStorage.getReturnStatistics();
      console.log("âœ… Return statistics fetched successfully:", stats);
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("âŒ Error fetching return statistics:", error);
      res.status(400).json({ success: false, message: "Invalid request for return statistics" });
    }
  });

  // Find customer by phone for returns
  app.get("/api/shop/customers/phone/:phone", requireAuth, async (req, res) => {
    try {
      const phone = req.params.phone;
      const customer = await shopStorage.findCustomerByPhone(phone);
      if (customer) {
        res.json({ success: true, data: customer });
      } else {
        res.json({ success: false, message: "Customer not found" });
      }
    } catch (error) {
      console.error("Error finding customer by phone:", error);
      res.status(500).json({ success: false, message: "Failed to find customer" });
    }
  });

  // Order statistics for dashboard
  app.get("/api/shop/statistics", requireAuth, async (req, res) => {
    try {
      // Get customer order statistics from the correct table
      const customerStats = await customerStorage.getCustomerStats();
      
      // Get all customer orders for additional calculations
      const allOrders = await customerStorage.getAllOrders();
      
      // Calculate statistics based on customer orders
      const totalOrders = allOrders.length;
      const pendingOrders = allOrders.filter(order => order.status === 'pending').length;
      const shippedOrders = allOrders.filter(order => order.status === 'shipped').length;
      const deliveredOrders = allOrders.filter(order => order.status === 'delivered').length;
      
      // Calculate total revenue from customer orders
      const totalRevenue = allOrders.reduce((sum, order) => {
        return sum + parseFloat(order.totalAmount || '0');
      }, 0);

      const stats = {
        totalOrders,
        pendingOrders,
        shippedOrders,
        deliveredOrders,
        totalRevenue: totalRevenue.toFixed(2),
        totalCustomers: customerStats.totalCustomers,
        openInquiries: customerStats.openInquiries
      };
      
      res.json(stats);
    } catch (error) {
      console.error("Error fetching customer order statistics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch customer order statistics" });
    }
  });

  // Get paid orders only for invoice management
  app.get("/api/shop/orders/paid", requireAuth, async (req, res) => {
    try {
      // Get all customer orders that are paid/settled
      const allOrders = await customerStorage.getAllOrders();
      
      // Filter for orders with completed payments (settled orders)
      const paidOrders = allOrders.filter(order => 
        order.status === 'completed' || 
        order.status === 'delivered' ||
        (order.paymentMethod && ['wallet_full', 'wallet_partial', 'bank_transfer'].includes(order.paymentMethod))
      );
      
      // Get detailed information for each paid order including items
      const detailedPaidOrders = await Promise.all(
        paidOrders.map(async (order) => {
          const items = await customerStorage.getOrderItems(order.id);
          let customer = null;
          if (order.customerId) {
            customer = await customerStorage.getCustomerById(order.customerId);
          }

          return {
            id: order.id,
            orderNumber: order.orderNumber,
            customerFirstName: customer?.firstName || 'Ù†Ø§Ù…Ø´Ø®Øµ',
            customerLastName: customer?.lastName || '',
            customerEmail: customer?.email || '',
            customerPhone: customer?.phone || '',
            totalAmount: order.totalAmount,
            currency: order.currency || 'IQD',
            paymentMethod: order.paymentMethod || 'Ù†Ø§Ù…Ø´Ø®Øµ',
            paymentDate: order.paymentConfirmedAt || order.updatedAt,
            createdAt: order.createdAt,
            status: order.status,
            items: items.map(item => ({
              productName: item.productName,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              totalPrice: item.totalPrice
            }))
          };
        })
      );

      res.json({ success: true, data: detailedPaidOrders });
    } catch (error) {
      console.error("Error fetching paid orders:", error);
      res.status(500).json({ success: false, message: "Failed to fetch paid orders" });
    }
  });

  // Get invoice statistics for shop admin
  app.get("/api/shop/invoices/stats", requireAuth, async (req, res) => {
    try {
      // Get all customer orders
      const allOrders = await customerStorage.getAllOrders();
      
      // Filter for paid/settled orders
      const paidOrders = allOrders.filter(order => 
        order.status === 'completed' || 
        order.status === 'delivered' ||
        (order.paymentMethod && ['wallet_full', 'wallet_partial', 'bank_transfer'].includes(order.paymentMethod))
      );

      // Calculate statistics
      const totalPaidOrders = paidOrders.length;
      const totalInvoiceAmount = paidOrders.reduce((sum, order) => {
        return sum + parseFloat(order.totalAmount || '0');
      }, 0);
      const averageOrderValue = totalPaidOrders > 0 ? totalInvoiceAmount / totalPaidOrders : 0;

      // Calculate this month's invoices
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      const thisMonthInvoices = paidOrders.filter(order => {
        const orderDate = new Date(order.createdAt);
        return orderDate.getMonth() === currentMonth && orderDate.getFullYear() === currentYear;
      }).length;

      const stats = {
        totalPaidOrders,
        totalInvoiceAmount: Math.round(totalInvoiceAmount),
        averageOrderValue: Math.round(averageOrderValue),
        thisMonthInvoices
      };

      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching invoice statistics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch invoice statistics" });
    }
  });

  // Payment processing endpoints
  app.post("/api/shop/orders/:id/payment", async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }

      const { paymentStatus, paymentMethod, transactionId, paymentData } = req.body;
      
      // Get the order from customer_orders table
      const order = await customerStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Order not found" });
      }

      // Update order with payment information
      const updatedOrder = await customerStorage.updateOrder(orderId, {
        status: paymentStatus === 'paid' ? 'payment_confirmed' : order.status,
        notes: order.notes ? `${order.notes}\n\nPayment processed: ${paymentMethod}${transactionId ? ` (ID: ${transactionId})` : ''}` 
               : `Payment processed: ${paymentMethod}${transactionId ? ` (ID: ${transactionId})` : ''}`
      });

      // Trigger automatic synchronization after payment update
      try {
        await globalSyncService.triggerOrderSync(orderId, 'payment_processed');
        console.log(`ğŸ”„ [SYNC] Triggered automatic sync for payment update - order ${orderId}`);
      } catch (syncError) {
        console.error(`âŒ [SYNC] Auto-sync failed for payment update:`, syncError);
        // Don't fail payment update if sync fails
      }

      // Log the payment activity in CRM if customer exists
      if (order.customerId) {
        try {
          await crmStorage.logCustomerActivity({
            customerId: order.customerId,
            activityType: 'payment_processed',
            description: `Payment of ${order.totalAmount} processed via ${paymentMethod}${transactionId ? ` (Transaction: ${transactionId})` : ''}`,
            performedBy: 'System',
            relatedOrderId: orderId
          });
        } catch (crmError) {
          console.warn("Failed to log payment activity to CRM:", crmError);
        }
      }

      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error("Error updating payment status:", error);
      res.status(500).json({ success: false, message: "Failed to update payment status" });
    }
  });

  // Sales Reports API
  app.get("/api/reports/sales", requireAuth, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      
      if (!startDate || !endDate) {
        return res.status(400).json({ 
          success: false, 
          message: "Start date and end date are required" 
        });
      }

      // Get all orders within date range
      const orders = await customerStorage.getAllOrders();
      const filteredOrders = orders.filter(order => {
        const orderDate = new Date(order.createdAt);
        const start = new Date(startDate as string);
        const end = new Date(endDate as string);
        end.setHours(23, 59, 59, 999); // Include full end date
        
        return orderDate >= start && orderDate <= end;
      });

      // Calculate total sales metrics
      const totalSales = filteredOrders.reduce((sum, order) => 
        sum + parseFloat(order.totalAmount), 0
      );
      const totalOrders = filteredOrders.length;

      // Get detailed order items for product analysis
      const productSalesMap = new Map<string, { productName: string; quantity: number; totalAmount: number; orders: Set<number> }>();
      let totalQuantity: number = 0;

      for (const order of filteredOrders) {
        const items = await customerStorage.getOrderItems(order.id);
        
        for (const item of items) {
          const key = item.productName;
          const existing = productSalesMap.get(key) || {
            productName: item.productName,
            quantity: 0,
            totalAmount: 0,
            orders: new Set()
          };
          
          existing.quantity += Number(item.quantity);
          existing.totalAmount += parseFloat(String(item.unitPrice)) * Number(item.quantity);
          existing.orders.add(order.id);
          totalQuantity += Number(item.quantity);
          
          productSalesMap.set(key, existing);
        }
      }

      // Convert to array and add order count
      const productSales = Array.from(productSalesMap.values()).map(product => ({
        ...product,
        orders: product.orders.size
      })).sort((a, b) => b.totalAmount - a.totalAmount);

      // Create top products for pie chart (top 8 products)
      const topProducts = productSales.slice(0, 8).map(product => {
        const percentage = totalSales > 0 ? ((product.totalAmount / totalSales) * 100) : 0;
        return {
          name: product.productName,
          value: product.totalAmount,
          percentage: Math.round(percentage * 10) / 10
        };
      });

      // Create daily breakdown
      const dailyMap = new Map();
      filteredOrders.forEach(order => {
        const date = new Date(order.createdAt).toISOString().split('T')[0];
        const existing = dailyMap.get(date) || { date, sales: 0, orders: 0 };
        existing.sales += parseFloat(order.totalAmount);
        existing.orders += 1;
        dailyMap.set(date, existing);
      });

      const dailyBreakdown = Array.from(dailyMap.values()).sort((a, b) => 
        new Date(a.date).getTime() - new Date(b.date).getTime()
      );

      const reportData = {
        totalSales,
        totalOrders,
        totalQuantity,
        productSales,
        dailyBreakdown,
        topProducts
      };

      res.json(reportData);
    } catch (error) {
      console.error("Error generating sales report:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate sales report" 
      });
    }
  });

  // Discount settings management
  app.get("/api/shop/discounts", async (req, res) => {
    try {
      const discounts = await shopStorage.getDiscountSettings();
      res.json({ success: true, data: discounts });
    } catch (error) {
      console.error("Error fetching discounts:", error);
      res.status(500).json({ success: false, message: "Failed to fetch discounts" });
    }
  });

  app.get("/api/shop/discounts/active", async (req, res) => {
    try {
      const discounts = await shopStorage.getActiveDiscountSettings();
      res.json({ success: true, data: discounts });
    } catch (error) {
      console.error("Error fetching active discounts:", error);
      res.status(500).json({ success: false, message: "Failed to fetch active discounts" });
    }
  });

  // Get specific discount by ID
  app.get("/api/shop/discounts/:id", async (req, res) => {
    try {
      const discountId = parseInt(req.params.id);
      if (!discountId || isNaN(discountId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Valid discount ID is required" 
        });
      }

      const discount = await shopStorage.getDiscountSettingById(discountId);
      if (!discount) {
        return res.status(404).json({ 
          success: false, 
          message: "Discount not found" 
        });
      }

      res.json({ success: true, data: discount });
    } catch (error) {
      console.error('Error fetching discount:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch discount" 
      });
    }
  });

  app.post("/api/shop/discounts", requireAuth, async (req, res) => {
    try {
      const discountData = req.body;
      console.log("ğŸ¯ [DISCOUNT API] Creating new discount with data:", discountData);
      
      const discount = await shopStorage.createDiscountSetting(discountData);
      console.log("ğŸ¯ [DISCOUNT API] Discount created successfully:", discount);
      
      res.json({ success: true, data: discount });
    } catch (error) {
      console.error("ğŸ¯ [DISCOUNT API] Error creating discount:", error);
      console.error("ğŸ¯ [DISCOUNT API] Error details:", error instanceof Error ? error.message : error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to create discount",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.patch("/api/shop/discounts/:id", requireAuth, async (req, res) => {
    try {
      const discountId = parseInt(req.params.id);
      if (isNaN(discountId)) {
        return res.status(400).json({ success: false, message: "Invalid discount ID" });
      }
      
      const updates = req.body;
      console.log("ğŸ¯ [DISCOUNT API] Updating discount", discountId, "with updates:", updates);
      
      const discount = await shopStorage.updateDiscountSetting(discountId, updates);
      console.log("ğŸ¯ [DISCOUNT API] Discount updated successfully:", discount);
      
      // Fetch the updated discount to ensure we return the latest data
      const updatedDiscount = await shopStorage.getDiscountSettingById(discountId);
      console.log("ğŸ¯ [DISCOUNT API] Fresh discount data:", updatedDiscount);
      
      res.json({ success: true, data: updatedDiscount });
    } catch (error) {
      console.error("ğŸ¯ [DISCOUNT API] Error updating discount:", error);
      console.error("ğŸ¯ [DISCOUNT API] Error details:", error instanceof Error ? error.message : error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update discount",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.delete("/api/shop/discounts/:id", requireAuth, async (req, res) => {
    try {
      const discountId = parseInt(req.params.id);
      if (isNaN(discountId)) {
        return res.status(400).json({ success: false, message: "Invalid discount ID" });
      }
      
      await shopStorage.deleteDiscountSetting(discountId);
      res.json({ success: true, message: "Discount deleted successfully" });
    } catch (error) {
      console.error("Error deleting discount:", error);
      res.status(500).json({ success: false, message: "Failed to delete discount" });
    }
  });

  // Sync centralized discount settings to all products
  app.post("/api/shop/discounts/sync-to-products", requireAuth, async (req, res) => {
    try {
      // Get active discount settings
      const activeDiscounts = await shopStorage.getActiveDiscountSettings();
      
      // Convert to product quantityDiscounts format
      const quantityDiscounts = activeDiscounts.map((discount: any) => ({
        minQty: discount.minQuantity,
        discount: parseFloat(discount.discountPercentage) / 100
      })).sort((a: any, b: any) => a.minQty - b.minQty);

      // Get all products without quantity discounts
      const products = await shopStorage.getShopProducts();
      const productsToUpdate = products.filter((product: any) => 
        !product.quantityDiscounts || product.quantityDiscounts === null
      );

      // Update each product with the centralized discounts
      let updatedCount = 0;
      for (const product of productsToUpdate) {
        await shopStorage.updateShopProduct(product.id, {
          quantityDiscounts: JSON.stringify(quantityDiscounts)
        });
        updatedCount++;
      }

      res.json({
        success: true,
        message: `Applied centralized discounts to ${updatedCount} products`,
        discountsApplied: quantityDiscounts,
        productsUpdated: updatedCount,
        totalProducts: products.length
      });
    } catch (error) {
      console.error("Error syncing discounts to products:", error);
      res.status(500).json({ success: false, message: "Failed to sync discounts to products" });
    }
  });

  // Financial transactions endpoints for accounting
  app.get("/api/shop/financial-transactions", async (req, res) => {
    try {
      const { type, startDate, endDate, orderId } = req.query;
      const filters: any = {};
      
      if (type) filters.type = type as string;
      if (orderId) filters.orderId = parseInt(orderId as string);
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);

      const transactions = await shopStorage.getFinancialTransactions(filters);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching financial transactions:", error);
      res.status(500).json({ success: false, message: "Failed to fetch financial transactions" });
    }
  });

  app.post("/api/shop/financial-transactions", async (req, res) => {
    try {
      const transaction = await shopStorage.createFinancialTransaction(req.body);
      res.json(transaction);
    } catch (error) {
      console.error("Error creating financial transaction:", error);
      res.status(500).json({ success: false, message: "Failed to create financial transaction" });
    }
  });

  // Sales reports endpoints
  app.get("/api/shop/sales-reports", async (req, res) => {
    try {
      const { reportType, startDate, endDate } = req.query;
      const filters: any = {};
      
      if (reportType) filters.reportType = reportType as string;
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);

      const reports = await shopStorage.getSalesReports(filters);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching sales reports:", error);
      res.status(500).json({ success: false, message: "Failed to fetch sales reports" });
    }
  });

  app.post("/api/shop/sales-reports", async (req, res) => {
    try {
      const report = await shopStorage.createSalesReport(req.body);
      res.json(report);
    } catch (error) {
      console.error("Error creating sales report:", error);
      res.status(500).json({ success: false, message: "Failed to create sales report" });
    }
  });

  // Real-time accounting statistics
  app.get("/api/shop/accounting-stats", async (req, res) => {
    try {
      const stats = await shopStorage.getAccountingStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching accounting stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch accounting stats" });
    }
  });

  // Process refund/return
  app.post("/api/shop/orders/:id/refund", async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { amount, reason, type } = req.body;
      
      await shopStorage.processOrderRefund(orderId, amount, reason, type);
      res.json({ success: true, message: `${type === 'refund' ? 'Refund' : 'Return'} processed successfully` });
    } catch (error) {
      console.error("Error processing refund/return:", error);
      res.status(500).json({ success: false, message: "Failed to process refund/return" });
    }
  });

  // Product synchronization endpoint - sync showcase products to shop
  app.post("/api/sync-products", async (req, res) => {
    try {
      console.log("ğŸ”„ Starting complete product synchronization from showcase to shop...");
      
      // Get all showcase products
      const showcaseProducts = await storage.getProducts();
      
      // Get existing shop products for comparison
      const existingShopProducts = await shopStorage.getShopProducts();
      
      let syncedCount = 0;
      let skippedCount = 0;
      
      for (const showcaseProduct of showcaseProducts) {
        // Check if product already exists in shop
        const existingShopProduct = existingShopProducts.find(sp => sp.name === showcaseProduct.name);
        
        if (existingShopProduct) {
          console.log(`âš ï¸  Product already exists in shop: ${showcaseProduct.name}`);
          skippedCount++;
          continue;
        }
        
        // Create new shop product from showcase product
        const shopProductData = {
          name: showcaseProduct.name,
          category: showcaseProduct.category,
          description: showcaseProduct.description,
          shortDescription: showcaseProduct.shortDescription || showcaseProduct.description,
          price: showcaseProduct.unitPrice || showcaseProduct.price || 0,
          priceUnit: showcaseProduct.currency || showcaseProduct.priceUnit || 'IQD',
          inStock: (showcaseProduct.stockQuantity || 0) > 0 || (showcaseProduct.showWhenOutOfStock || false),
          stockQuantity: showcaseProduct.stockQuantity || 0,
          lowStockThreshold: 10,
          minStockLevel: showcaseProduct.minStockLevel || 5,
          maxStockLevel: showcaseProduct.maxStockLevel || 100,
          showWhenOutOfStock: showcaseProduct.showWhenOutOfStock || false,
          sku: showcaseProduct.sku || `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
          barcode: showcaseProduct.barcode,
          imageUrls: showcaseProduct.imageUrl ? [showcaseProduct.imageUrl] : [],
          specifications: showcaseProduct.specifications || {},
          features: showcaseProduct.features || [],
          applications: showcaseProduct.applications || [],
          isActive: true,
          isFeatured: false,
          metaTitle: showcaseProduct.name,
          metaDescription: showcaseProduct.description
        };
        
        await shopStorage.createShopProduct(shopProductData);
        console.log(`âœ… Synced to shop: ${showcaseProduct.name}`);
        syncedCount++;
      }
      
      console.log(`ğŸ”„ Sync completed: ${syncedCount} products added, ${skippedCount} already existed`);
      
      res.json({ 
        success: true, 
        message: `Successfully synchronized ${syncedCount} products to shop. ${skippedCount} products already existed.`,
        syncedCount,
        skippedCount,
        totalShowcaseProducts: showcaseProducts.length
      });
    } catch (error) {
      console.error("Error syncing products:", error);
      res.status(500).json({ success: false, message: "Failed to sync products" });
    }
  });

  // Reverse sync: Update showcase inventory from shop sales
  app.post("/api/sync-products-reverse", async (req, res) => {
    try {
      // No sync needed - unified table approach
      res.json({ success: true, message: "All products synchronized from shop to showcase successfully" });
    } catch (error) {
      console.error("Error syncing products from shop:", error);
      res.status(500).json({ success: false, message: "Failed to sync products from shop" });
    }
  });

  // Sales analytics endpoint
  app.get("/api/analytics/sales", requireAuth, async (req, res) => {
    try {
      // Get all orders with order items
      const orders = await shopStorage.getOrders();
      
      // Build comprehensive order data with items
      const ordersWithItems = [];
      for (const order of orders) {
        const orderItems = await shopStorage.getOrderItems(order.id);
        for (const item of orderItems) {
          ordersWithItems.push({
            ...order,
            product_name: item.productName,
            quantity: item.quantity,
            unit_price: item.unitPrice,
            item_total: parseFloat(item.unitPrice) * item.quantity
          });
        }
      }

      // Calculate key metrics
      const totalRevenue = orders.reduce((sum, order) => sum + parseFloat(order.totalAmount || '0'), 0);
      const totalOrders = orders.length;
      const averageOrderValue = totalRevenue / totalOrders || 0;
      
      // Get unique customers from shop_customers
      const customers = await shopStorage.getCustomers();
      const uniqueCustomers = customers.length;
      
      // Calculate growth rate (comparing last 15 days vs previous 15 days)
      const now = new Date();
      const fifteenDaysAgo = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      
      const recentOrders = orders.filter(o => new Date(o.createdAt) >= fifteenDaysAgo);
      const previousOrders = orders.filter(o => 
        new Date(o.createdAt) >= thirtyDaysAgo && new Date(o.createdAt) < fifteenDaysAgo
      );
      
      const recentRevenue = recentOrders.reduce((sum, o) => sum + parseFloat(o.totalAmount || '0'), 0);
      const previousRevenue = previousOrders.reduce((sum, o) => sum + parseFloat(o.totalAmount || '0'), 0);
      const growthRate = previousRevenue > 0 ? ((recentRevenue - previousRevenue) / previousRevenue) * 100 : 0;

      // Generate daily sales data for last 30 days
      const dailySales = [];
      const ordersByDate = new Map();
      
      orders.forEach(order => {
        const date = order.createdAt.toISOString().split('T')[0];
        if (!ordersByDate.has(date)) {
          ordersByDate.set(date, { revenue: 0, orderIds: new Set() });
        }
        ordersByDate.get(date).revenue += parseFloat(order.totalAmount || '0');
        ordersByDate.get(date).orderIds.add(order.id);
      });

      for (let i = 29; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        
        const dayData = ordersByDate.get(dateStr);
        dailySales.push({
          date: dateStr,
          revenue: dayData?.revenue || 0,
          orders: dayData?.orderIds.size || 0
        });
      }

      // Top products by revenue
      const productSales = new Map();
      ordersWithItems.forEach(orderItem => {
        if (orderItem.product_name) {
          const key = orderItem.product_name;
          if (!productSales.has(key)) {
            productSales.set(key, { 
              name: key, 
              revenue: 0, 
              quantity: 0, 
              orderIds: new Set() 
            });
          }
          const product = productSales.get(key);
          product.revenue += orderItem.item_total;
          product.quantity += orderItem.quantity;
          product.orderIds.add(orderItem.id);
        }
      });

      const topProducts = Array.from(productSales.values())
        .map(p => ({ ...p, orders: p.orderIds.size }))
        .sort((a, b) => b.revenue - a.revenue)
        .slice(0, 10);

      // Orders by status
      const statusCounts = new Map();
      orders.forEach(order => {
        const status = order.status;
        statusCounts.set(status, (statusCounts.get(status) || 0) + 1);
      });

      const ordersByStatus = Array.from(statusCounts.entries()).map(([status, count]) => ({
        status: status || 'unknown',
        count,
        percentage: (count / totalOrders) * 100
      }));

      // Revenue by category - analyze product names
      const categoryMapping = {
        'Chemicals': ['chemical', 'thinner', 'clarifier', 'stabilizer'],
        'Fertilizers': ['fertilizer', 'npk'],
        'Additives': ['additive', 'anti-gel'],
        'Cleaners': ['cleaner', 'system']
      };

      const revenueByCategory = Object.entries(categoryMapping).map(([category, keywords]) => {
        const categoryRevenue = topProducts
          .filter(p => keywords.some(keyword => 
            p.name.toLowerCase().includes(keyword.toLowerCase())
          ))
          .reduce((sum, p) => sum + p.revenue, 0);
        
        return {
          category,
          revenue: categoryRevenue,
          percentage: totalRevenue > 0 ? (categoryRevenue / totalRevenue) * 100 : 0
        };
      }).filter(c => c.revenue > 0);

      const analyticsData = {
        totalRevenue,
        totalOrders,
        averageOrderValue,
        totalCustomers: uniqueCustomers,
        conversionRate: totalOrders > 0 ? (totalOrders / (totalOrders + 5)) * 100 : 0, // Simple conversion estimate
        growthRate,
        dailySales,
        topProducts,
        ordersByStatus,
        revenueByCategory
      };

      res.json(analyticsData);
    } catch (error) {
      console.error("Error fetching sales analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch analytics" });
    }
  });

  // Export sales report endpoint
  app.get("/api/analytics/sales/export", requireAuth, async (req, res) => {
    try {
      const format = req.query.format as string || 'csv';
      
      // Get all orders with items
      const orders = await shopStorage.getOrders();
      
      // Build detailed report data
      const reportData = [];
      for (const order of orders) {
        const orderItems = await shopStorage.getOrderItems(order.id);
        const customer = await shopStorage.getCustomerById(order.customerId);
        
        for (const item of orderItems) {
          reportData.push({
            orderNumber: order.orderNumber,
            orderDate: order.createdAt.toISOString().split('T')[0],
            customerName: customer ? `${customer.firstName} ${customer.lastName}` : 'N/A',
            customerEmail: customer?.email || 'N/A',
            productName: item.productName,
            quantity: item.quantity,
            unitPrice: parseFloat(item.unitPrice),
            itemTotal: parseFloat(item.unitPrice) * item.quantity,
            orderStatus: order.status,
            paymentStatus: order.paymentStatus,
            subtotal: parseFloat(order.subtotal || '0'),
            taxAmount: parseFloat(order.taxAmount || '0'),
            shippingAmount: parseFloat(order.shippingAmount || '0'),
            totalAmount: parseFloat(order.totalAmount || '0'),
            currency: order.currency || 'USD'
          });
        }
      }

      if (format === 'csv') {
        // Generate CSV with proper UTF-8 encoding for Arabic/Persian text
        const csvHeaders = [
          'Order Number', 'Order Date', 'Customer Name', 'Customer Email',
          'Product Name', 'Quantity', 'Unit Price', 'Item Total',
          'Order Status', 'Payment Status', 'Subtotal', 'Tax Amount',
          'Shipping Amount', 'Total Amount', 'Currency'
        ].join(',');
        
        const csvRows = reportData.map(row => {
          // Ensure all text fields are properly escaped and encoded
          const escapeForCsv = (str) => {
            if (str == null) return '';
            return `"${String(str).replace(/"/g, '""')}"`;
          };
          
          return [
            escapeForCsv(row.orderNumber),
            escapeForCsv(row.orderDate),
            escapeForCsv(row.customerName),
            escapeForCsv(row.customerEmail),
            escapeForCsv(row.productName),
            row.quantity,
            row.unitPrice.toFixed(2),
            row.itemTotal.toFixed(2),
            escapeForCsv(row.orderStatus),
            escapeForCsv(row.paymentStatus),
            row.subtotal.toFixed(2),
            row.taxAmount.toFixed(2),
            row.shippingAmount.toFixed(2),
            row.totalAmount.toFixed(2),
            escapeForCsv(row.currency)
          ].join(',');
        });
        
        const csvContent = [csvHeaders, ...csvRows].join('\r\n');
        
        // Add UTF-8 BOM for Excel compatibility with Arabic/Persian text
        const bom = Buffer.from([0xEF, 0xBB, 0xBF]);
        const csvBuffer = Buffer.from(csvContent, 'utf8');
        const finalBuffer = Buffer.concat([bom, csvBuffer]);
        
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''sales-report-${new Date().toISOString().split('T')[0]}.csv`);
        res.send(finalBuffer);
      } else {
        // Return JSON for other formats or direct download
        res.json({
          success: true,
          data: reportData,
          summary: {
            totalOrders: orders.length,
            totalRevenue: reportData.reduce((sum, item) => sum + item.itemTotal, 0),
            reportDate: new Date().toISOString().split('T')[0]
          }
        });
      }
    } catch (error) {
      console.error("Error generating sales report:", error);
      res.status(500).json({ success: false, message: "Failed to generate sales report" });
    }
  });

  // Email template management routes - remove auth requirement temporarily
  app.get("/api/email-templates", async (req, res) => {
    try {
      console.log("ğŸ“§ GET /api/email-templates - Fetching templates...");
      const templates = await customerStorage.getEmailTemplates();
      console.log("ğŸ“§ Found templates:", templates?.length || 0);
      res.json(templates);
    } catch (error) {
      console.error("âŒ Error fetching email templates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/email-templates/category/:category", async (req, res) => {
    try {
      const { category } = req.params;
      const templates = await customerStorage.getEmailTemplatesByCategory(category);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates by category:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/email-templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      const template = await customerStorage.getEmailTemplateById(id);
      if (!template) {
        return res.status(404).json({ 
          success: false, 
          message: "Template not found" 
        });
      }

      res.json(template);
    } catch (error) {
      console.error("Error fetching email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/email-templates", requireAuth, async (req, res) => {
    try {
      const sessionData = req.session;
      const templateData = insertEmailTemplateSchema.parse({
        ...req.body,
        createdBy: sessionData.adminId
      });
      
      const template = await customerStorage.createEmailTemplate(templateData);
      res.status(201).json({ 
        success: true, 
        message: "Email template created successfully",
        template 
      });
    } catch (error) {
      console.error("Error creating email template:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid template data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  app.patch("/api/email-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      const updates = req.body;
      const template = await customerStorage.updateEmailTemplate(id, updates);
      res.json({ 
        success: true, 
        message: "Email template updated successfully",
        template 
      });
    } catch (error) {
      console.error("Error updating email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.delete("/api/email-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      await customerStorage.deleteEmailTemplate(id);
      res.json({ 
        success: true, 
        message: "Email template deleted successfully" 
      });
    } catch (error) {
      console.error("Error deleting email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/email-templates/:id/set-default", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      const { category } = req.body;
      if (!category) {
        return res.status(400).json({ 
          success: false, 
          message: "Category is required" 
        });
      }

      await customerStorage.setDefaultTemplate(id, category);
      res.json({ 
        success: true, 
        message: "Default template set successfully" 
      });
    } catch (error) {
      console.error("Error setting default template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Admin Email Templates Management - New endpoints for the admin interface
  app.get("/api/admin/email/templates", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const templates = await emailStorage.getAllTemplates();
      
      // Convert database fields to frontend expected fields
      const formattedTemplates = templates.map(template => ({
        id: template.id,
        name: template.templateName || template.name,
        templateName: template.templateName || template.name,
        subject: template.subject,
        html_content: template.htmlContent || template.html_content,
        htmlContent: template.htmlContent || template.html_content,
        text_content: template.textContent || template.text_content,
        textContent: template.textContent || template.text_content,
        category: template.categoryName || template.category,
        categoryName: template.categoryName || template.category,
        variables: template.variables || [],
        is_active: template.isActive !== false,
        isActive: template.isActive !== false,
        is_default: template.isDefault || false,
        isDefault: template.isDefault || false,
        language: template.language || 'fa',
        created_by: template.createdBy || template.created_by,
        createdBy: template.createdBy || template.created_by,
        usage_count: template.usageCount || template.usage_count || 0,
        usageCount: template.usageCount || template.usage_count || 0,
        last_used: template.lastUsed || template.last_used,
        lastUsed: template.lastUsed || template.last_used,
        created_at: template.createdAt || template.created_at,
        createdAt: template.createdAt || template.created_at,
        updated_at: template.updatedAt || template.updated_at,
        updatedAt: template.updatedAt || template.updated_at
      }));
      
      console.log(`ğŸ“§ Formatted ${formattedTemplates.length} templates for frontend`);
      res.json(formattedTemplates);
    } catch (error) {
      console.error("Error fetching admin email templates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ…ÛŒÙ„",
        error: error.message
      });
    }
  });

  app.post("/api/admin/email/templates", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const { insertEmailTemplateSchema } = await import("../shared/email-schema");
      
      const templateData = {
        ...req.body,
        createdBy: req.session.adminId
      };
      
      const template = await emailStorage.createTemplate(templateData);
      res.status(201).json({ 
        success: true, 
        message: "Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯",
        template 
      });
    } catch (error) {
      console.error("Error creating admin email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  // Simple endpoint to update phone number in template
  app.put("/api/admin/email/templates/:id/phone", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { phoneNumber } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      console.log('ğŸ“§ Updating phone number for template ID:', id);
      console.log('ğŸ“§ New phone number:', phoneNumber);
      
      // Update phone number in HTML content using direct SQL
      const result = await sql`
        UPDATE email_templates 
        SET html_content = replace(html_content, '+964 771 234 5678', ${phoneNumber}),
            text_content = replace(text_content, '+964 770 999 6771', ${phoneNumber})
        WHERE id = ${id}
      `;
      
      console.log('ğŸ“§ Phone number updated successfully');
      
      res.json({ 
        success: true, 
        message: "Phone number updated successfully" 
      });
    } catch (error) {
      console.error("Error updating phone number:", error);
      res.status(500).json({ 
        success: false, 
        message: "Error updating phone number: " + error.message 
      });
    }
  });

  // Simple endpoint to update subject
  app.put("/api/admin/email/templates/:id/subject", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { subject } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      console.log('ğŸ“§ Updating subject for template ID:', id);
      console.log('ğŸ“§ New subject:', subject);
      
      // Update subject using direct SQL
      const result = await sql`
        UPDATE email_templates 
        SET subject = ${subject}
        WHERE id = ${id}
      `;
      
      console.log('ğŸ“§ Subject updated successfully');
      
      res.json({ 
        success: true, 
        message: "Subject updated successfully" 
      });
    } catch (error) {
      console.error("Error updating subject:", error);
      res.status(500).json({ 
        success: false, 
        message: "Error updating subject: " + error.message 
      });
    }
  });

  app.put("/api/admin/email/templates/:id", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      console.log('ğŸ“§ Updating template ID:', id);
      console.log('ğŸ“§ Request body keys:', Object.keys(req.body));
      
      // Simple approach - just use req.body directly
      const requestData = req.body;
      
      // Clean and prepare update data
      const updates: any = {};
      
      if (requestData.templateName !== undefined) {
        updates.templateName = String(requestData.templateName).trim();
      }
      if (requestData.name !== undefined) {
        updates.templateName = String(requestData.name).trim();
      }
      if (requestData.categoryName !== undefined) {
        updates.categoryName = String(requestData.categoryName).trim();
      }
      if (requestData.category !== undefined) {
        updates.categoryName = String(requestData.category).trim();
      }
      if (requestData.subject !== undefined) {
        updates.subject = String(requestData.subject).trim();
      }
      if (requestData.htmlContent !== undefined) {
        updates.htmlContent = String(requestData.htmlContent);
      }
      if (requestData.textContent !== undefined) {
        updates.textContent = String(requestData.textContent);
      }
      if (requestData.variables !== undefined) {
        if (Array.isArray(requestData.variables)) {
          updates.variables = requestData.variables;
        } else if (typeof requestData.variables === 'string') {
          // Parse comma-separated string into array
          updates.variables = requestData.variables.split(',').map((v: string) => v.trim()).filter((v: string) => v.length > 0);
        }
      }
      if (requestData.isActive !== undefined) {
        updates.isActive = Boolean(requestData.isActive);
      }
      if (requestData.isDefault !== undefined) {
        updates.isDefault = Boolean(requestData.isDefault);
      }
      if (requestData.language !== undefined) {
        updates.language = String(requestData.language).trim();
      }

      console.log('ğŸ“§ Cleaned update data fields:', Object.keys(updates));

      const template = await emailStorage.updateTemplate(id, updates);
      
      console.log('ğŸ“§ Template updated successfully:', template.templateName);
      
      res.json({ 
        success: true, 
        message: "Email template updated successfully",
        template 
      });
    } catch (error) {
      console.error("Error updating admin email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Error updating email template: " + error.message 
      });
    }
  });

  // Toggle template status (active/inactive)
  app.patch("/api/admin/email/templates/:id/toggle", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }
      
      const template = await emailStorage.toggleTemplateStatus(id);
      
      console.log(`ğŸ“§ Template ${template.templateName} status toggled to: ${template.isActive ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'}`);
      
      res.json({ 
        success: true, 
        message: `ÙˆØ¶Ø¹ÛŒØª Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø­Ø§Ù„Øª ${template.isActive ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`,
        template
      });
    } catch (error) {
      console.error("Error toggling template status:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù‚Ø§Ù„Ø¨: " + error.message 
      });
    }
  });

  app.delete("/api/admin/email/templates/:id", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      await emailStorage.deleteTemplate(id);
      res.json({ 
        success: true, 
        message: "Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" 
      });
    } catch (error) {
      console.error("Error deleting admin email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  app.put("/api/admin/email/templates/:id/toggle", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      const { isActive } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      const template = await emailStorage.updateTemplate(id, { isActive });
      res.json({ 
        success: true, 
        message: isActive ? "Ù‚Ø§Ù„Ø¨ ÙØ¹Ø§Ù„ Ø´Ø¯" : "Ù‚Ø§Ù„Ø¨ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯",
        template 
      });
    } catch (error) {
      console.error("Error toggling email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù‚Ø§Ù„Ø¨" 
      });
    }
  });

  app.put("/api/admin/email/templates/:id/set-default", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      // Get the template to find its category
      const template = await emailStorage.getTemplateById(id);
      if (!template) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      await emailStorage.setDefaultTemplate(id, template.category);
      res.json({ 
        success: true, 
        message: "Ù‚Ø§Ù„Ø¨ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯" 
      });
    } catch (error) {
      console.error("Error setting default template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ´â€ŒÙØ±Ø¶" 
      });
    }
  });

  app.get("/api/admin/email/categories", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const categories = await emailStorage.getCategories();
      
      // Enhanced categories with SMTP settings and recipients
      const enhancedCategories = await Promise.all(
        categories.map(async (category) => {
          const smtp = await emailStorage.getSmtpSettingByCategory(category.id);
          const recipients = await emailStorage.getRecipientsByCategory(category.id);
          
          console.log(`[EMAIL API] Category ${category.categoryName}:`, {
            hasSmtp: !!smtp,
            smtpData: smtp ? {
              id: smtp.id,
              host: smtp.host,
              port: smtp.port,
              username: smtp.username,
              fromName: smtp.fromName,
              fromEmail: smtp.fromEmail,
              testStatus: smtp.testStatus
            } : null
          });
          
          return {
            ...category,
            smtp,
            recipients
          };
        })
      );
      
      res.json({ 
        success: true, 
        categories: enhancedCategories 
      });
    } catch (error) {
      console.error("Error fetching email categories:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  // Create new email category
  app.post("/api/admin/email/categories", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const { categoryKey, categoryName, description } = req.body;

      if (!categoryKey || !categoryName) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ø§Ù… Ùˆ Ú©Ù„ÛŒØ¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Check if category key already exists
      const existing = await emailStorage.getCategoryByKey(categoryKey);
      if (existing) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ† Ú©Ù„ÛŒØ¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"
        });
      }

      const newCategory = await emailStorage.createCategory({
        categoryKey,
        categoryName,
        description: description || ""
      });

      res.json({
        success: true,
        message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯",
        category: newCategory
      });
    } catch (error) {
      console.error("Error creating email category:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÛŒÙ…ÛŒÙ„"
      });
    }
  });

  // Delete email category
  app.delete("/api/admin/email/categories/:id", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const categoryId = parseInt(req.params.id);

      if (isNaN(categoryId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Check if category exists
      const category = await emailStorage.getCategoryById(categoryId);
      if (!category) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Delete related SMTP settings first
      const smtp = await emailStorage.getSmtpSettingByCategory(categoryId);
      if (smtp) {
        await emailStorage.deleteSmtpSetting(smtp.id);
      }

      // Delete related recipients
      const recipients = await emailStorage.getRecipientsByCategory(categoryId);
      for (const recipient of recipients) {
        await emailStorage.deleteRecipient(recipient.id);
      }

      // Delete the category
      await emailStorage.deleteCategory(categoryId);

      res.json({
        success: true,
        message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting email category:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÛŒÙ…ÛŒÙ„"
      });
    }
  });

  // Template processing routes
  app.post("/api/templates/send-response", requireAuth, async (req, res) => {
    try {
      const { inquiryId, templateId, customVariables, customContent } = req.body;
      
      if (!inquiryId || !templateId) {
        return res.status(400).json({
          success: false,
          message: "Inquiry ID and Template ID are required"
        });
      }

      await TemplateProcessor.sendTemplatedResponse(
        inquiryId,
        templateId,
        customVariables,
        customContent
      );

      res.json({
        success: true,
        message: "Email response sent successfully"
      });
    } catch (error) {
      console.error("Error sending templated response:", error);
      res.status(500).json({
        success: false,
        message: "Failed to send email response"
      });
    }
  });

  app.post("/api/templates/preview", requireAuth, async (req, res) => {
    try {
      const { templateId, variables } = req.body;
      
      const template = await customerStorage.getEmailTemplateById(templateId);
      if (!template) {
        return res.status(404).json({
          success: false,
          message: "Template not found"
        });
      }

      const preview = TemplateProcessor.previewTemplate(template, variables || {});
      
      res.json({
        success: true,
        preview
      });
    } catch (error) {
      console.error("Error previewing template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to preview template"
      });
    }
  });

  app.get("/api/templates/suggestions/:category", requireAuth, async (req, res) => {
    try {
      const { category } = req.params;
      const { language = 'en' } = req.query;
      
      const suggestions = await TemplateProcessor.getTemplateSuggestions(
        category, 
        language as string
      );
      
      res.json(suggestions);
    } catch (error) {
      console.error("Error getting template suggestions:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get template suggestions"
      });
    }
  });

  // Dashboard and inquiry tracking routes (public)
  app.get("/api/inquiries", async (req, res) => {
    try {
      const inquiries = await simpleCustomerStorage.getAllInquiries();
      res.json(inquiries);
    } catch (error) {
      console.error("Error fetching inquiries:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiries"
      });
    }
  });

  app.get("/api/inquiries/stats", async (req, res) => {
    try {
      const stats = await simpleCustomerStorage.getCustomerStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching inquiry stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiry statistics"
      });
    }
  });

  app.get("/api/inquiries/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const inquiry = await simpleCustomerStorage.getInquiryById(id);
      if (!inquiry) {
        return res.status(404).json({
          success: false,
          message: "Inquiry not found"
        });
      }

      res.json(inquiry);
    } catch (error) {
      console.error("Error fetching inquiry:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiry"
      });
    }
  });

  app.get("/api/inquiries/:id/responses", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const responses = await simpleCustomerStorage.getInquiryResponses(id);
      res.json(responses);
    } catch (error) {
      console.error("Error fetching inquiry responses:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiry responses"
      });
    }
  });

  // Create inquiry response (admin only)
  app.post("/api/inquiries/:id/response", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const { responseText, responseType = 'follow_up' } = req.body;
      
      if (!responseText?.trim()) {
        return res.status(400).json({
          success: false,
          message: "Response text is required"
        });
      }

      // Get the inquiry first to verify it exists
      const inquiry = await simpleCustomerStorage.getInquiryById(id);
      if (!inquiry) {
        return res.status(404).json({
          success: false,
          message: "Inquiry not found"
        });
      }

      // Try to get customer language preference from CRM
      let customerLanguage = 'en'; // Default to English
      try {
        const { pool } = await import('./db');
        const customerResult = await pool.query(`
          SELECT preferred_language 
          FROM crm_customers 
          WHERE email = $1 AND is_active = true
        `, [inquiry.contactEmail]);
        
        if (customerResult.rows.length > 0 && customerResult.rows[0].preferred_language) {
          customerLanguage = customerResult.rows[0].preferred_language;
          console.log(`ğŸ“ Customer language preference found: ${customerLanguage} for ${inquiry.contactEmail}`);
        } else {
          console.log(`ğŸ“ No language preference found for ${inquiry.contactEmail}, using default: ${customerLanguage}`);
        }
      } catch (langError) {
        console.log(`âŒ Error fetching customer language preference: ${langError.message}, using default: ${customerLanguage}`);
      }

      // Create the response
      const response = await simpleCustomerStorage.createInquiryResponse({
        inquiryId: id,
        senderId: req.session.adminId,
        senderType: 'admin',
        message: responseText,
        isInternal: false,
      });

      // Send follow-up email to customer
      try {
        // Create transporter using existing email system
        const createTransporter = async (categoryKey: string) => {
          const categorySettings = await emailStorage.getCategoryWithSettings(categoryKey);
          
          if (!categorySettings?.smtp) {
            throw new Error(`No SMTP configuration found for category: ${categoryKey}`);
          }

          const smtp = categorySettings.smtp;
          
          return nodemailer.createTransport({
            host: smtp.host,
            port: smtp.port,
            secure: smtp.port === 465,
            auth: {
              user: smtp.username,
              pass: smtp.password,
            },
          });
        };

        // Determine the correct category for email routing based on inquiry category
        let emailCategory = 'admin'; // Default fallback
        
        if (inquiry.category) {
          // Map inquiry category to email category key
          const categoryMap: { [key: string]: string } = {
            'fuel-additives': 'fuel-additives',
            'water-treatment': 'water-treatment', 
            'paint-solvents': 'paint-solvents',
            'agricultural-fertilizers': 'agricultural-fertilizers',
            'industrial-chemicals': 'industrial-chemicals',
            'paint-thinner': 'paint-thinner',
            'technical-equipment': 'technical-equipment',
            'commercial-goods': 'commercial-goods',
            'general': 'admin',
            'support': 'support'
          };
          
          emailCategory = categoryMap[inquiry.category] || 'admin';
          console.log(`ğŸ“§ Inquiry response routing: inquiry category '${inquiry.category}' â†’ email category '${emailCategory}'`);
        }

        // Try to get category-specific settings, fallback to admin if not found
        let categorySettings, smtp, transporter;
        
        try {
          categorySettings = await emailStorage.getCategoryWithSettings(emailCategory);
          if (!categorySettings?.smtp) {
            throw new Error(`No SMTP configuration found for category: ${emailCategory}`);
          }
          transporter = await createTransporter(emailCategory);
          smtp = categorySettings.smtp;
          console.log(`âœ… Using SMTP settings for category '${emailCategory}': ${smtp.fromEmail}`);
        } catch (categoryError) {
          console.log(`âŒ Category '${emailCategory}' not configured, falling back to admin: ${categoryError.message}`);
          // Fallback to admin category
          categorySettings = await emailStorage.getCategoryWithSettings('admin');
          if (!categorySettings?.smtp) {
            throw new Error('No SMTP configuration found for admin fallback category');
          }
          transporter = await createTransporter('admin');
          smtp = categorySettings.smtp;
          console.log(`âœ… Using fallback admin SMTP settings: ${smtp.fromEmail}`);
        }

        if (smtp) {
          // Get the "#05 - Momtaz Chemical Follow-up Response" template from database
          let emailTemplate;
          try {
            const templates = await emailStorage.getAllTemplates();
            emailTemplate = templates.find(t => t.templateName === '#05 - Momtaz Chemical Follow-up Response');
            console.log(`ğŸ“§ Using template: ${emailTemplate ? emailTemplate.templateName : 'Default hardcoded template'}`);
          } catch (templateError) {
            console.log(`âŒ Error loading template: ${templateError.message}, using default`);
          }

          let htmlContent, textContent;
          
          if (emailTemplate) {
            // Use template from database with variable substitution
            htmlContent = emailTemplate.htmlContent
              .replace(/\{\{customer_name\}\}/g, inquiry.contactName || 'Valued Customer')
              .replace(/\{\{inquiry_number\}\}/g, inquiry.inquiryNumber)
              .replace(/\{\{inquiry_subject\}\}/g, inquiry.subject || 'Product Inquiry')
              .replace(/\{\{inquiry_category\}\}/g, inquiry.category || 'General')
              .replace(/\{\{response_text\}\}/g, responseText);
              
            textContent = emailTemplate.textContent || `
Follow-up Response - Momtaz Chemical

Dear ${inquiry.contactName || 'Valued Customer'},

Thank you for your inquiry. We have prepared a follow-up response regarding your request.

Your Original Inquiry:
Inquiry Number: ${inquiry.inquiryNumber}
Subject: ${inquiry.subject || 'Product Inquiry'}
Category: ${inquiry.category || 'General'}

Our Response:
${responseText}

Need Further Assistance?
If you have any additional questions or need clarification, please don't hesitate to contact us:
- Email: info@momtazchem.com
- Phone: +964 771 234 5678
- Website: www.momtazchem.com

Best regards,
Momtaz Chemical Team
Leading Chemical Solutions Provider
            `;
          } else {
            // Fallback to hardcoded template with updated phone number
            htmlContent = `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; text-align: center;">
                  <h1 style="margin: 0; font-size: 24px;">Momtaz Chemical</h1>
                  <p style="margin: 5px 0 0 0; opacity: 0.9;">Follow-up Response</p>
                </div>
                
                <div style="padding: 30px; background-color: #f9f9f9;">
                  <p style="font-size: 16px; color: #333; margin-bottom: 20px;">
                    Dear ${inquiry.contactName || 'Valued Customer'},
                  </p>
                  
                  <p style="color: #666; margin-bottom: 15px;">
                    Thank you for your inquiry. We have prepared a follow-up response regarding your request:
                  </p>
                  
                  <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #667eea;">
                    <h3 style="color: #333; margin-top: 0;">Your Original Inquiry:</h3>
                    <p style="color: #666; margin-bottom: 15px;"><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
                    <p style="color: #666; margin-bottom: 15px;"><strong>Subject:</strong> ${inquiry.subject || 'Product Inquiry'}</p>
                    <p style="color: #666;"><strong>Category:</strong> ${inquiry.category || 'General'}</p>
                  </div>
                  
                  <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #28a745;">
                    <h3 style="color: #333; margin-top: 0;">Our Response:</h3>
                    <p style="color: #444; line-height: 1.6; white-space: pre-wrap;">${responseText}</p>
                  </div>
                  
                  <div style="margin-top: 30px; padding: 20px; background: #e8f4f8; border-radius: 8px;">
                    <h4 style="color: #333; margin-top: 0;">Need Further Assistance?</h4>
                    <p style="color: #666; margin-bottom: 15px;">
                      If you have any additional questions or need clarification, please don't hesitate to contact us:
                    </p>
                    <ul style="color: #666; margin: 0;">
                      <li>Email: info@momtazchem.com</li>
                      <li>Phone: +964 771 234 5678</li>
                      <li>Website: www.momtazchem.com</li>
                    </ul>
                  </div>
                  
                  <p style="color: #888; font-size: 14px; margin-top: 30px; text-align: center;">
                    Best regards,<br>
                    <strong>Momtaz Chemical Team</strong><br>
                    Leading Chemical Solutions Provider
                  </p>
                </div>
              </div>
            `;
            
            textContent = `
Follow-up Response - Momtaz Chemical

Dear ${inquiry.contactName || 'Valued Customer'},

Thank you for your inquiry. We have prepared a follow-up response regarding your request.

Your Original Inquiry:
Inquiry Number: ${inquiry.inquiryNumber}
Subject: ${inquiry.subject || 'Product Inquiry'}
Category: ${inquiry.category || 'General'}

Our Response:
${responseText}

Need Further Assistance?
If you have any additional questions or need clarification, please don't hesitate to contact us:
- Email: info@momtazchem.com
- Phone: +964 771 234 5678
- Website: www.momtazchem.com

Best regards,
Momtaz Chemical Team
Leading Chemical Solutions Provider
            `;
          }

          // Use multilingual email service if language preference is available
          if (customerLanguage && customerLanguage !== 'en') {
            try {
              const { emailService } = await import('./email-service');
              const { getLocalizedEmailSubject } = await import('./multilingual-messages');
              
              // Get localized subject line for inquiry response
              const localizedSubject = getLocalizedEmailSubject('inquiryResponse', customerLanguage);
              
              const emailSent = await emailService.sendLocalizedEmail(
                inquiry.contactEmail,
                'inquiryResponse',
                customerLanguage,
                {
                  customerName: inquiry.contactName || 'Valued Customer',
                  inquiryNumber: inquiry.inquiryNumber,
                  inquirySubject: inquiry.subject || 'Product Inquiry',
                  inquiryCategory: inquiry.category || 'General',
                  responseText
                },
                emailCategory,
                localizedSubject + ` - ${inquiry.inquiryNumber}`
              );
              
              if (emailSent) {
                console.log(`ğŸ“§ Multilingual follow-up email sent successfully to: ${inquiry.contactEmail} in ${customerLanguage}`);
              } else {
                throw new Error('Multilingual email sending failed');
              }
            } catch (multilingualError) {
              console.log(`âŒ Multilingual email failed, using standard template: ${multilingualError.message}`);
              // Fallback to standard email
              await transporter.sendMail({
                from: `${smtp.fromName} <${smtp.fromEmail}>`,
                to: inquiry.contactEmail,
                subject: `Follow-up: ${inquiry.subject || 'Your Inquiry'} - ${inquiry.inquiryNumber}`,
                html: htmlContent,
                text: textContent
              });
            }
          } else {
            // Send standard email
            await transporter.sendMail({
              from: `${smtp.fromName} <${smtp.fromEmail}>`,
              to: inquiry.contactEmail,
              subject: `Follow-up: ${inquiry.subject || 'Your Inquiry'} - ${inquiry.inquiryNumber}`,
              html: htmlContent,
              text: textContent
            });
          }

          console.log(`Follow-up email sent successfully to: ${inquiry.contactEmail}`);
        }
      } catch (emailError) {
        console.error('Error sending follow-up email:', emailError);
        // Don't fail the response creation if email fails
      }

      // Update inquiry status to 'in_progress' if it was 'open'
      if (inquiry.status === 'open') {
        await simpleCustomerStorage.updateInquiry(id, { status: 'in_progress' });
      }

      res.json({
        success: true,
        message: "Follow-up response sent successfully to customer's email",
        response
      });
    } catch (error) {
      console.error("Error creating inquiry response:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create response"
      });
    }
  });

  // Update inquiry status (admin only)
  app.patch("/api/inquiries/:id/status", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const { status } = req.body;
      if (!status) {
        return res.status(400).json({
          success: false,
          message: "Status is required"
        });
      }

      // Validate status values
      const validStatuses = ['open', 'in_progress', 'resolved', 'closed'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({
          success: false,
          message: "Invalid status value"
        });
      }

      const updatedInquiry = await simpleCustomerStorage.updateInquiryStatus(id, status);
      
      res.json({
        success: true,
        message: "Inquiry status updated successfully",
        inquiry: updatedInquiry
      });
    } catch (error) {
      console.error("Error updating inquiry status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update inquiry status"
      });
    }
  });

  // Quote request routes (public)
  app.post("/api/quote-requests", async (req, res) => {
    try {
      const { firstName, lastName, email, phone, company, productName, category, quantity, urgency, message } = req.body;
      
      if (!firstName || !lastName || !email || !productName || !company) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields"
        });
      }

      // Generate quote number
      const quoteNumber = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      const quoteRequest = await customerStorage.createQuoteRequest({
        quoteNumber,
        contactEmail: email,
        contactPhone: phone,
        company,
        deliveryLocation: "To be determined",
        requestedProducts: [{
          name: productName,
          category: category || "general",
          quantity: quantity || "To be discussed",
          urgency: urgency || "normal"
        }],
        specialRequirements: message || "",
        priority: urgency || "normal",
        notes: `Contact: ${firstName} ${lastName}`,
      });

      // Auto-capture customer data in CRM system
      try {
        // Check if customer exists in CRM
        let existingCustomer = await crmStorage.getCrmCustomerByEmail(email);

        if (existingCustomer) {
          // Log quote request activity for existing customer
          await crmStorage.logCustomerActivity({
            customerId: existingCustomer.id,
            activityType: 'quote_request',
            description: `Quote requested for ${productName} - Category: ${category || 'general'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_quote_form',
              productName: productName,
              category: category,
              quantity: quantity,
              urgency: urgency,
              quoteNumber: quoteRequest.quoteNumber,
              message: message
            }
          });
          console.log(`âœ… Quote request logged to existing CRM customer: ${email}`);
        } else {
          // Create new CRM customer from quote request
          const newCrmCustomer = await crmStorage.createCrmCustomer({
            email: email,
            firstName: firstName,
            lastName: lastName,
            company: company,
            phone: phone || null,
            customerType: 'prospect',
            customerSource: 'website_quote',
            isActive: true,
            passwordHash: '', // Will be set when customer creates account
          });

          // Log initial quote request activity
          await crmStorage.logCustomerActivity({
            customerId: newCrmCustomer.id,
            activityType: 'first_contact',
            description: `First contact via quote request: ${productName} - Category: ${category || 'general'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_quote_form',
              productName: productName,
              category: category,
              quantity: quantity,
              urgency: urgency,
              quoteNumber: quoteRequest.quoteNumber,
              message: message
            }
          });
          console.log(`âœ… New CRM customer created from quote request: ${email}`);
        }
      } catch (crmError) {
        console.error("âŒ Error auto-capturing customer in CRM from quote request:", crmError);
        // Don't fail the quote request if CRM capture fails
      }

      res.json({
        success: true,
        message: "Quote request submitted successfully",
        quoteNumber: quoteRequest.quoteNumber
      });
    } catch (error) {
      console.error("Error creating quote request:", error);
      res.status(500).json({
        success: false,
        message: "Failed to submit quote request"
      });
    }
  });

  // Inventory monitoring routes
  app.post("/api/inventory/check-all", requireAuth, async (req, res) => {
    try {
      await InventoryAlertService.checkInventoryLevels();
      res.json({
        success: true,
        message: "Inventory check completed and alerts sent if needed"
      });
    } catch (error) {
      console.error("Error checking inventory:", error);
      res.status(500).json({
        success: false,
        message: "Failed to check inventory levels"
      });
    }
  });

  app.post("/api/inventory/check-product/:id", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      const alertSent = await InventoryAlertService.checkProductInventory(productId);
      
      res.json({
        success: true,
        alertSent,
        message: alertSent ? "Alert sent for low stock" : "Stock levels are adequate"
      });
    } catch (error) {
      console.error("Error checking product inventory:", error);
      res.status(500).json({
        success: false,
        message: "Failed to check product inventory"
      });
    }
  });





  // SMTP Configuration Validator
  app.post("/api/admin/validate-smtp", requireAuth, async (req, res) => {
    try {
      const { email, password, customHost, customPort, categoryId } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: "Email and password are required"
        });
      }

      const { SMTPValidator } = await import('./smtp-validator');
      const result = await SMTPValidator.validateConfiguration(
        email, 
        password, 
        customHost, 
        customPort
      );
      
      // Update database with test result if categoryId is provided
      if (categoryId) {
        console.log(`ğŸ”„ Attempting to update SMTP test status for category ${categoryId}`);
        const { emailStorage } = await import("./email-storage");
        try {
          const smtp = await emailStorage.getSmtpSettingByCategory(categoryId);
          console.log(`ğŸ“§ Found SMTP setting:`, smtp);
          if (smtp) {
            const updateResult = await emailStorage.updateSmtpSetting(smtp.id, {
              testStatus: result.isValid ? "success" : "failed",
              lastTested: new Date()
            });
            console.log(`âœ… Updated SMTP test status for category ${categoryId}: ${result.isValid ? "success" : "failed"}`, updateResult);
          } else {
            console.log(`âŒ No SMTP setting found for category ${categoryId}`);
          }
        } catch (dbError) {
          console.error("âŒ Error updating SMTP test status:", dbError);
        }
      } else {
        console.log("âš ï¸ No categoryId provided for SMTP test update");
      }
      
      res.json({
        success: result.isValid,
        ...result
      });
    } catch (error) {
      console.error("Error validating SMTP:", error);
      res.status(500).json({
        success: false,
        message: "Failed to validate SMTP configuration"
      });
    }
  });

  // Initialize default email categories if they don't exist
  app.post("/api/admin/email/init-categories", requireAuth, async (req, res) => {
    try {
      const defaultCategories = [
        {
          categoryKey: "admin",
          categoryName: "Admin & General Contact",
          description: "Main administrative and general contact email",
        },
        {
          categoryKey: "fuel-additives",
          categoryName: "Fuel Additives Department",
          description: "Dedicated email for fuel additives inquiries and orders",
        },
        {
          categoryKey: "water-treatment",
          categoryName: "Water Treatment Department",
          description: "Dedicated email for water treatment solutions",
        },
        {
          categoryKey: "agricultural-fertilizers",
          categoryName: "Agricultural Fertilizers Department",
          description: "Dedicated email for fertilizer products and agricultural solutions",
        },
        {
          categoryKey: "paint-thinner",
          categoryName: "Paint & Thinner Department",
          description: "Dedicated email for paint and thinner products",
        },
        {
          categoryKey: "orders",
          categoryName: "Order Processing",
          description: "Handles order confirmations and processing",
        },
        {
          categoryKey: "notifications",
          categoryName: "System Notifications",
          description: "Receives system alerts and notifications",
        }
      ];

      const createdCategories = [];
      
      for (const categoryData of defaultCategories) {
        const existing = await emailStorage.getCategoryByKey(categoryData.categoryKey);
        if (!existing) {
          const category = await emailStorage.createCategory(categoryData);
          createdCategories.push(category);
        }
      }

      res.json({
        success: true,
        message: `Initialized ${createdCategories.length} categories`,
        categories: createdCategories
      });
    } catch (error) {
      console.error("Error initializing categories:", error);
      res.status(500).json({
        success: false,
        message: "Failed to initialize categories"
      });
    }
  });

  // Get all email categories with their settings
  app.get("/api/admin/email/categories", requireAuth, async (req, res) => {
    try {
      const categories = await emailStorage.getCategories();
      const categoriesWithSettings = [];

      for (const category of categories) {
        const smtp = await emailStorage.getSmtpSettingByCategory(category.id);
        const recipients = await emailStorage.getRecipientsByCategory(category.id);
        
        categoriesWithSettings.push({
          ...category,
          smtp: smtp || null,
          recipients
        });
      }

      res.json({
        success: true,
        categories: categoriesWithSettings
      });
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch categories"
      });
    }
  });

  // Create/Update SMTP settings for a category
  app.post("/api/admin/email/smtp/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      console.log("Received SMTP data:", req.body);
      
      // Manual validation instead of strict schema
      const {
        host,
        port,
        secure,
        username,
        password,
        fromName,
        fromEmail
      } = req.body;

      if (!host || !username || !password || !fromName || !fromEmail) {
        return res.status(400).json({
          success: false,
          message: "All SMTP fields are required"
        });
      }

      const smtpData = {
        host: host.toString(),
        port: parseInt(port) || 587,
        secure: Boolean(secure),
        username: username.toString(),
        password: password.toString(),
        fromName: fromName.toString(),
        fromEmail: fromEmail.toString(),
        categoryId: parseInt(categoryId)
      };

      console.log("Processed SMTP data:", smtpData);
      
      // Check if SMTP settings already exist for this category
      const existing = await emailStorage.getSmtpSettingByCategory(parseInt(categoryId));
      
      let smtp;
      if (existing) {
        console.log("Updating existing SMTP settings");
        smtp = await emailStorage.updateSmtpSetting(existing.id, smtpData);
      } else {
        console.log("Creating new SMTP settings");
        smtp = await emailStorage.createSmtpSetting(smtpData);
      }

      res.json({
        success: true,
        message: "SMTP settings saved successfully",
        smtp
      });
    } catch (error) {
      console.error("Error saving SMTP settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save SMTP settings",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Test SMTP connection for a category
  app.post("/api/admin/email/test-smtp/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      const smtp = await emailStorage.getSmtpSettingByCategory(parseInt(categoryId));
      
      if (!smtp) {
        return res.status(404).json({
          success: false,
          message: "SMTP settings not found for this category"
        });
      }

      const success = await emailStorage.testSmtpConnection(smtp.id);
      
      res.json({
        success,
        message: success ? "SMTP connection test successful" : "SMTP connection test failed"
      });
    } catch (error) {
      console.error("SMTP test failed:", error);
      res.status(500).json({
        success: false,
        message: `SMTP test failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  });

  // Add/Update email recipients for a category
  app.post("/api/admin/email/recipients/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      const { recipients } = req.body;
      
      // Validate categoryId
      const categoryIdNum = parseInt(categoryId);
      if (isNaN(categoryIdNum)) {
        return res.status(400).json({
          success: false,
          message: "Invalid category ID"
        });
      }
      
      // Delete existing recipients for this category
      const existingRecipients = await emailStorage.getRecipientsByCategory(categoryIdNum);
      for (const recipient of existingRecipients) {
        await emailStorage.deleteRecipient(recipient.id);
      }
      
      // Add new recipients
      const createdRecipients = [];
      for (const recipientData of recipients) {
        // Clean the recipient data to remove any invalid fields
        const cleanedData = {
          email: recipientData.email,
          name: recipientData.name || null,
          isPrimary: Boolean(recipientData.isPrimary),
          isActive: Boolean(recipientData.isActive !== false), // default to true
          receiveTypes: Array.isArray(recipientData.receiveTypes) ? recipientData.receiveTypes : [],
          recipientType: recipientData.recipientType || 'to', // 'to', 'cc', 'bcc'
          categoryId: categoryIdNum
        };
        
        const recipient = await emailStorage.createRecipient(cleanedData);
        createdRecipients.push(recipient);
      }

      res.json({
        success: true,
        message: "Recipients updated successfully",
        recipients: createdRecipients
      });
    } catch (error) {
      console.error("Error updating recipients:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update recipients",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Legacy endpoint for compatibility
  app.get("/api/admin/email-settings", requireAuth, async (req, res) => {
    try {
      const categories = await emailStorage.getCategories();
      const emailSettings = [];

      for (const category of categories) {
        const recipients = await emailStorage.getRecipientsByCategory(category.id);
        const primaryRecipient = recipients.find(r => r.isPrimary);
        
        emailSettings.push({
          id: category.id,
          category: category.categoryKey,
          name: category.categoryName,
          description: category.description,
          emailAddress: primaryRecipient?.email || "info@momtazchem.com",
          isActive: category.isActive,
          isPrimary: category.categoryKey === "admin",
          usage: recipients.flatMap(r => r.receiveTypes || [])
        });
      }

      // Get SMTP settings from database only
      const smtpSettings = null; // No fallback - only use database settings

      res.json({
        success: true,
        emailSettings,
        smtpSettings
      });
    } catch (error) {
      console.error("Error fetching email settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch email settings"
      });
    }
  });

  app.post("/api/admin/email-settings", requireAuth, async (req, res) => {
    try {
      const { emailSettings } = req.body;
      
      // In a real implementation, you would save these to database
      // For now, we'll just return success
      console.log("Email settings updated:", emailSettings);
      
      res.json({
        success: true,
        message: "Email settings saved successfully"
      });
    } catch (error) {
      console.error("Error saving email settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save email settings"
      });
    }
  });

  app.post("/api/admin/smtp-settings", requireAuth, async (req, res) => {
    try {
      const { host, port, secure, user, pass, fromName, fromEmail } = req.body;
      
      // In a real implementation, you would save these to environment or database
      console.log("SMTP settings updated:", { host, port, secure, user, fromName, fromEmail });
      
      res.json({
        success: true,
        message: "SMTP settings saved successfully"
      });
    } catch (error) {
      console.error("Error saving SMTP settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save SMTP settings"
      });
    }
  });

  app.post("/api/admin/test-smtp", requireAuth, async (req, res) => {
    try {
      const { host, port, secure, user, pass } = req.body;
      
      if (!host || !port || !user || !pass) {
        return res.status(400).json({
          success: false,
          message: "All SMTP fields are required for testing"
        });
      }

      // Nodemailer is already imported at the top
      
      const transporter = nodemailer.createTransport({
        host,
        port: parseInt(port),
        secure: secure || port == 465,
        auth: {
          user,
          pass,
        },
        connectionTimeout: 10000,
        greetingTimeout: 5000,
      });

      await transporter.verify();
      
      res.json({
        success: true,
        message: "SMTP connection test successful"
      });
    } catch (error) {
      console.error("SMTP test failed:", error);
      res.status(500).json({
        success: false,
        message: `SMTP test failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  });

  // Detect email provider
  app.post("/api/admin/detect-provider", requireAuth, async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({
          success: false,
          message: "Email is required"
        });
      }

      const { SMTPValidator } = await import('./smtp-validator');
      const provider = SMTPValidator.detectProvider(email);
      const config = SMTPValidator.generateOptimalConfig(email);
      
      res.json({
        success: true,
        provider,
        recommendedConfig: config
      });
    } catch (error) {
      console.error("Error detecting provider:", error);
      res.status(500).json({
        success: false,
        message: "Failed to detect email provider"
      });
    }
  });

  // =============================================================================
  // CRM ROUTES - Professional Customer Relationship Management
  // =============================================================================

  // Get CRM dashboard statistics
  app.get("/api/crm/dashboard", requireAuth, async (req, res) => {
    try {
      const stats = await crmStorage.getCrmDashboardStats();
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching CRM dashboard stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch dashboard statistics"
      });
    }
  });

  // Get all CRM customers with pagination
  app.get("/api/crm/customers", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      
      const customers = await crmStorage.getCrmCustomers(limit, offset);
      res.json({
        success: true,
        data: customers,
        pagination: {
          limit,
          offset,
          count: customers.length
        }
      });
    } catch (error) {
      console.error("Error fetching CRM customers:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch customers"
      });
    }
  });

  // Search CRM customers
  app.get("/api/crm/customers/search", requireAuth, async (req, res) => {
    try {
      const query = req.query.q as string;
      if (!query || query.length < 2) {
        return res.status(400).json({
          success: false,
          message: "Search query must be at least 2 characters"
        });
      }

      const customers = await crmStorage.searchCrmCustomers(query);
      res.json({
        success: true,
        data: customers
      });
    } catch (error) {
      console.error("Error searching CRM customers:", error);
      res.status(500).json({
        success: false,
        message: "Failed to search customers"
      });
    }
  });

  // Search CRM customers by phone for dropdown suggestions
  app.get("/api/crm/customers/search-phone/:phone", requireAuth, async (req, res) => {
    try {
      const phone = decodeURIComponent(req.params.phone);
      
      if (!phone || phone.length < 3) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const customers = await crmStorage.searchCrmCustomersByPhone(phone);
      
      // Format customers for dropdown
      const formattedCustomers = customers.map(customer => ({
        id: customer.id,
        phone: customer.phone,
        firstName: customer.firstName || customer.first_name,
        lastName: customer.lastName || customer.last_name,
        email: customer.email,
        displayName: `${customer.firstName || customer.first_name} ${customer.lastName || customer.last_name}`,
        displayText: `${customer.phone} - ${customer.firstName || customer.first_name} ${customer.lastName || customer.last_name}`
      }));

      res.json({
        success: true,
        customers: formattedCustomers,
        count: formattedCustomers.length,
        message: `${formattedCustomers.length} Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error searching customers by phone:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†"
      });
    }
  });

  // Get CRM customer by phone number
  app.get("/api/crm/customers/by-phone/:phone", requireAuth, async (req, res) => {
    try {
      const phone = decodeURIComponent(req.params.phone);
      
      if (!phone || phone.length < 3) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const customer = await crmStorage.getCrmCustomerByPhone(phone);
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø´ØªØ±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Map database fields to frontend expected format - ensure proper field mapping
      const formattedCustomer = {
        ...customer,
        firstName: customer.firstName || customer.first_name,
        lastName: customer.lastName || customer.last_name,
        // Keep original fields for debugging
        first_name: customer.first_name,
        last_name: customer.last_name
      };
      
      console.log('[CUSTOMER LOOKUP] Original customer:', customer);
      console.log('[CUSTOMER LOOKUP] Formatted customer:', formattedCustomer);

      res.json({
        success: true,
        customer: formattedCustomer,
        message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error fetching customer by phone:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ"
      });
    }
  });

  // Get specific CRM customer by ID
  app.get("/api/crm/customers/:id", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Customer not found"
        });
      }

      // Get customer analytics
      const analytics = await crmStorage.getCustomerAnalytics(customerId);
      
      // Get customer activities
      const activities = await crmStorage.getCustomerActivities(customerId, 20);

      res.json({
        success: true,
        data: {
          customer,
          analytics,
          activities
        }
      });
    } catch (error) {
      console.error("Error fetching CRM customer:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch customer"
      });
    }
  });

  // Create new CRM customer (enhanced with password handling)
  app.post("/api/crm/customers", requireAuth, async (req, res) => {
    try {
      const { password, ...customerData } = req.body;
      
      // Hash password if provided
      let passwordHash = '';
      if (password && password.trim()) {
        passwordHash = await bcrypt.hash(password.trim(), 10);
      }
      
      // Validate mandatory fields
      if (!customerData.email || !customerData.phone || !customerData.country || !customerData.city || !customerData.address) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ØŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†ØŒ Ú©Ø´ÙˆØ±ØŒ Ø´Ù‡Ø± Ùˆ Ø¢Ø¯Ø±Ø³ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ù‡Ø³ØªÙ†Ø¯"
        });
      }

      const validatedData = {
        ...customerData,
        passwordHash,
        createdBy: "admin",
        isActive: true,
        customerStatus: customerData.customerStatus || "active",
        emailVerified: false,
      };
      
      // Create CRM customer
      const crmCustomer = await crmStorage.createCrmCustomer(validatedData);
      
      // Also create in customer portal system if password provided
      if (passwordHash) {
        try {
          const portalCustomer = await customerStorage.createCustomer({
            ...validatedData,
            crmCustomerId: crmCustomer.id,
          });
          
          // Log activity
          await crmStorage.logCustomerActivity({
            customerId: crmCustomer.id,
            activityType: 'created',
            description: 'Customer created with portal access from CRM',
            performedBy: 'admin',
            activityData: { hasPortalAccess: true, portalCustomerId: portalCustomer.id }
          });
        } catch (portalError) {
          console.log('Portal customer creation failed, continuing with CRM-only customer');
        }
      }
      
      res.status(201).json({
        success: true,
        data: crmCustomer
      });
    } catch (error: any) {
      console.error("Error creating CRM customer:", error);
      // Check if it's a duplicate error message
      if (error.message && (error.message.includes("Ø§ÛŒÙ…ÛŒÙ„ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª") || error.message.includes("Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª"))) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      res.status(500).json({
        success: false,
        message: "Failed to create customer"
      });
    }
  });

  // Update CRM customer
  app.put("/api/crm/customers/:id", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const updateData = req.body;
      
      console.log("ğŸ”§ [CRM UPDATE] Customer ID:", customerId);
      console.log("ğŸ”§ [CRM UPDATE] Update data received:", JSON.stringify(updateData, null, 2));
      console.log("ğŸ”§ [CRM UPDATE] cityRegion field:", updateData.cityRegion);
      console.log("ğŸ”§ [CRM UPDATE] province field:", updateData.province);
      
      const customer = await crmStorage.updateCrmCustomer(customerId, updateData);
      
      console.log("ğŸ”§ [CRM UPDATE] Updated customer:", JSON.stringify(customer, null, 2));
      console.log("ğŸ”§ [CRM UPDATE] Updated cityRegion:", customer.cityRegion);
      
      res.json({
        success: true,
        data: customer
      });
    } catch (error: any) {
      console.error("Error updating CRM customer:", error);
      // Check if it's a duplicate error message
      if (error.message && (error.message.includes("Ø§ÛŒÙ…ÛŒÙ„ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª") || error.message.includes("Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª"))) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      res.status(500).json({
        success: false,
        message: "Failed to update customer"
      });
    }
  });

  // Delete CRM customer
  app.delete("/api/crm/customers/:id", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      
      await crmStorage.deleteCrmCustomer(customerId);
      res.json({
        success: true,
        message: "Customer deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting CRM customer:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete customer"
      });
    }
  });

  // Customer Authentication endpoint - Send SMS or Email verification
  app.post("/api/crm/customer-authentication", requireAuth, async (req, res) => {
    try {
      const { customerId, method, customerEmail, customerPhone, customerName } = req.body;
      
      if (!customerId || !method || !customerName) {
        return res.status(400).json({
          success: false,
          message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¶Ø±ÙˆØ±ÛŒ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª"
        });
      }

      if (method !== 'sms' && method !== 'email') {
        return res.status(400).json({
          success: false,
          message: "Ø±ÙˆØ´ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¨Ø§ÛŒØ¯ 'sms' ÛŒØ§ 'email' Ø¨Ø§Ø´Ø¯"
        });
      }

      // Validate email/phone based on method
      if (method === 'email' && !customerEmail) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ Ù…Ø´ØªØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      if (method === 'sms' && !customerPhone) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù…Ø´ØªØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Generate verification code (6 digits)
      const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();
      
      let successMessage = "";
      let authData = {};

      if (method === 'sms') {
        // Send SMS verification code
        try {
          const { smsStorage } = await import("./sms-storage");
          const smsResult = await smsStorage.sendSMS({
            to: customerPhone,
            message: `Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø´Ù…Ø§: ${verificationCode}\nØ´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ\nØ§ÛŒÙ† Ú©Ø¯ ØªØ§ 10 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.`,
            templateId: 2, // Authentication template
            customerId: customerId
          });

          if (smsResult.success) {
            successMessage = `Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS Ø¨Ø±Ø§ÛŒ ${customerName} Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ ${customerPhone} Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`;
            authData = {
              method: 'sms',
              phone: customerPhone,
              verificationCode,
              sentAt: new Date().toISOString(),
              smsId: smsResult.smsId
            };
          } else {
            throw new Error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ SMS');
          }
        } catch (smsError) {
          console.error('SMS sending failed:', smsError);
          return res.status(500).json({
            success: false,
            message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ SMS Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª"
          });
        }
      } else if (method === 'email') {
        // Send Email verification code
        try {
          const { UniversalEmailService } = await import("./universal-email-service");
          const emailResult = await UniversalEmailService.sendTemplateEmail({
            to: customerEmail,
            templateType: 'customer-authentication',
            variables: {
              customerName: customerName,
              verificationCode: verificationCode,
              validFor: '10 Ø¯Ù‚ÛŒÙ‚Ù‡',
              companyName: 'Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ'
            },
            category: 'authentication'
          });

          if (emailResult.success) {
            successMessage = `Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø±Ø§ÛŒ ${customerName} Ø¨Ù‡ Ø¢Ø¯Ø±Ø³ ${customerEmail} Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`;
            authData = {
              method: 'email',
              email: customerEmail,
              verificationCode,
              sentAt: new Date().toISOString(),
              emailId: emailResult.emailId
            };
          } else {
            throw new Error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…ÛŒÙ„');
          }
        } catch (emailError) {
          console.error('Email sending failed:', emailError);
          return res.status(500).json({
            success: false,
            message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª"
          });
        }
      }

      // Log the authentication activity in CRM
      try {
        await crmStorage.logCustomerActivity({
          customerId: customerId,
          activityType: 'authentication_request',
          description: `Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª ${method === 'sms' ? 'SMS' : 'Ø§ÛŒÙ…ÛŒÙ„'} ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`,
          performedBy: 'admin',
          activityData: authData
        });
      } catch (logError) {
        console.error('Failed to log authentication activity:', logError);
        // Don't fail the request if logging fails
      }

      console.log(`ğŸ” [CUSTOMER AUTH] ${method.toUpperCase()} verification code sent to customer ${customerId} (${customerName})`);

      res.json({
        success: true,
        message: successMessage,
        data: {
          method,
          sentAt: new Date().toISOString(),
          customerId,
          customerName
        }
      });
    } catch (error) {
      console.error("Error sending customer authentication:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª"
      });
    }
  });

  // Bulk toggle verification settings for all customers
  app.post("/api/crm/customers/bulk-toggle-verification", requireAuth, async (req, res) => {
    try {
      const { type, enabled } = req.body;
      
      if (!type || (type !== 'sms' && type !== 'email')) {
        return res.status(400).json({
          success: false,
          message: "Ù†ÙˆØ¹ Ø¨Ø§ÛŒØ¯ 'sms' ÛŒØ§ 'email' Ø¨Ø§Ø´Ø¯"
        });
      }

      if (typeof enabled !== 'boolean') {
        return res.status(400).json({
          success: false,
          message: "ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ø§Ù„/ØºÛŒØ±ÙØ¹Ø§Ù„ Ø¨Ø§ÛŒØ¯ boolean Ø¨Ø§Ø´Ø¯"
        });
      }

      const { pool } = await import('./db');
      
      // Determine which field to update
      const fieldToUpdate = type === 'sms' ? 'sms_enabled' : 'email_enabled';
      
      // Update all customers
      const result = await pool.query(`
        UPDATE crm_customers 
        SET ${fieldToUpdate} = $1,
            updated_at = CURRENT_TIMESTAMP
        WHERE is_active = true
      `, [enabled]);

      const updatedCount = result.rowCount || 0;
      
      console.log(`ğŸ“¢ Bulk ${type} verification ${enabled ? 'enabled' : 'disabled'} for ${updatedCount} customers`);

      res.json({
        success: true,
        message: `ØªÙ†Ø¸ÛŒÙ…Ø§Øª ${type === 'sms' ? 'SMS' : 'Ø§ÛŒÙ…ÛŒÙ„'} Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù…Ø´ØªØ±ÛŒØ§Ù† ${enabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯`,
        updatedCount
      });
    } catch (error) {
      console.error("Error bulk toggling verification:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÛŒÚ©Ø¬Ø§"
      });
    }
  });

  // Log customer activity
  app.post("/api/crm/customers/:id/activities", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { activityType, description, activityData } = req.body;
      
      const activity = await crmStorage.logCustomerActivity({
        customerId,
        activityType,
        description,
        activityData,
        performedBy: "admin"
      });

      res.status(201).json({
        success: true,
        data: activity
      });
    } catch (error) {
      console.error("Error logging customer activity:", error);
      res.status(500).json({
        success: false,
        message: "Failed to log activity"
      });
    }
  });

  // Get customer activities
  app.get("/api/crm/customers/:id/activities", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const limit = parseInt(req.query.limit as string) || 20;
      
      const activities = await crmStorage.getCustomerActivities(customerId, limit);
      res.json({
        success: true,
        data: activities
      });
    } catch (error) {
      console.error("Error fetching customer activities:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch activities"
      });
    }
  });

  // Duplicate route removed - using main route at line 2959

  // Customer profile update endpoint
  app.put("/api/customers/profile", async (req: Request, res: Response) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({
          success: false,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡"
        });
      }

      const {
        firstName,
        lastName,
        phone,
        email,
        company,
        country,
        province,
        city,
        cityRegion,
        address,
        secondaryAddress,
        postalCode,
        alternatePhone,
        industry,
        businessType,
        companySize,
        communicationPreference,
        preferredLanguage,
        marketingConsent,
        notes,
        customerType,
        customerStatus,
        preferredPaymentMethod,
        creditLimit,
        website,
        taxId,
        registrationNumber,
        leadSource,
        assignedSalesRep,
        // Additional CRM fields
        annualRevenue,
        priceRange,
        orderFrequency,
        creditStatus,
        smsEnabled,
        emailEnabled
      } = req.body;

      // Validate required fields
      if (!firstName || !lastName || !phone || !country || !city || !address) {
        return res.status(400).json({
          success: false,
          message: "ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯"
        });
      }

      console.log('ğŸ”„ [CRM INTEGRATION] Updating customer profile with data preservation');
      console.log('ğŸ“¥ [CRM INTEGRATION] Received data:', {
        firstName, lastName, phone, email, company, country, province, city, address,
        secondaryAddress, postalCode, alternatePhone, industry, businessType, companySize,
        communicationPreference, preferredLanguage, marketingConsent, notes,
        customerType, customerStatus, preferredPaymentMethod, creditLimit,
        website, taxId, registrationNumber, leadSource, assignedSalesRep,
        annualRevenue, priceRange, orderFrequency, creditStatus, smsEnabled, emailEnabled
      });
      console.log('ğŸ”§ [CRITICAL FIX] Mapping city field to cityRegion for database storage:', city);
      console.log('ğŸ”§ [CRITICAL FIX] cityRegion field from request:', cityRegion);
      
      // Get current customer data first to preserve existing information
      const currentCustomer = await crmStorage.getCrmCustomerById(customerId);
      if (!currentCustomer) {
        return res.status(404).json({
          success: false,
          message: "Customer not found"
        });
      }

      // Merge new data with existing data to prevent data loss
      const updateData = {
        // Core fields
        firstName: firstName || currentCustomer.firstName,
        lastName: lastName || currentCustomer.lastName,
        phone: phone || currentCustomer.phone,
        email: email || currentCustomer.email,
        company: company || currentCustomer.company,
        country: country || currentCustomer.country,
        province: province || currentCustomer.province,
        cityRegion: (cityRegion || city) ? (cityRegion || city) : currentCustomer.cityRegion, // FIX: Update city when provided
        address: address || currentCustomer.address,
        
        // Additional contact info
        secondaryAddress: secondaryAddress || currentCustomer.secondaryAddress,
        postalCode: postalCode || currentCustomer.postalCode,
        alternatePhone: alternatePhone || currentCustomer.alternatePhone,
        
        // Business information
        industry: industry || currentCustomer.industry,
        businessType: businessType || currentCustomer.businessType,
        companySize: companySize || currentCustomer.companySize,
        website: website || currentCustomer.website,
        taxId: taxId || currentCustomer.taxId,
        registrationNumber: registrationNumber || currentCustomer.registrationNumber,
        
        // Customer management
        customerType: customerType || currentCustomer.customerType,
        customerStatus: customerStatus || currentCustomer.customerStatus,
        preferredPaymentMethod: preferredPaymentMethod || currentCustomer.preferredPaymentMethod,
        creditLimit: creditLimit ? parseFloat(creditLimit) : currentCustomer.creditLimit,
        customerSource: leadSource || currentCustomer.customerSource,
        assignedSalesRep: assignedSalesRep || currentCustomer.assignedSalesRep,
        
        // Preferences
        communicationPreference: communicationPreference || currentCustomer.communicationPreference,
        preferredLanguage: preferredLanguage || currentCustomer.preferredLanguage,
        marketingConsent: marketingConsent !== undefined ? marketingConsent : currentCustomer.marketingConsent,
        
        // Additional CRM fields with data preservation
        annualRevenue: annualRevenue || currentCustomer.annualRevenue,
        priceRange: priceRange || currentCustomer.priceRange,
        orderFrequency: orderFrequency || currentCustomer.orderFrequency,
        creditStatus: creditStatus || currentCustomer.creditStatus,
        smsEnabled: smsEnabled !== undefined ? smsEnabled : currentCustomer.smsEnabled,
        emailEnabled: emailEnabled !== undefined ? emailEnabled : currentCustomer.emailEnabled,
        
        // Notes
        publicNotes: notes || currentCustomer.publicNotes,
        
        // System fields
        updatedAt: new Date()
      };

      console.log('ğŸ”„ [CRM INTEGRATION] Update data prepared with preservation:', Object.keys(updateData));
      console.log('ğŸ”§ [DEBUG] Final updateData.cityRegion value:', updateData.cityRegion);

      // Update customer profile in CRM with data preservation
      const updatedCustomer = await crmStorage.updateCrmCustomer(customerId, updateData);

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId,
        activityType: 'profile_updated',
        description: `Customer updated their profile information`,
        performedBy: 'Customer'
      });

      res.json({
        success: true,
        message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        customer: updatedCustomer
      });

    } catch (error) {
      console.error("Error updating customer profile:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„"
      });
    }
  });

  // Create customer segment
  app.post("/api/crm/segments", requireAuth, async (req, res) => {
    try {
      const { name, description, criteria } = req.body;
      
      const segment = await crmStorage.createCustomerSegment({
        name,
        description,
        criteria
      });

      res.status(201).json({
        success: true,
        data: segment
      });
    } catch (error) {
      console.error("Error creating customer segment:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create segment"
      });
    }
  });

  // Get all customer segments
  app.get("/api/crm/segments", requireAuth, async (req, res) => {
    try {
      const segments = await crmStorage.getCustomerSegments();
      res.json({
        success: true,
        data: segments
      });
    } catch (error) {
      console.error("Error fetching customer segments:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch segments"
      });
    }
  });

  // =============================================================================
  // CONTACT SALES AND QUOTE REQUEST ENDPOINTS
  // =============================================================================

  // Contact sales team
  app.post("/api/contact/sales", async (req, res) => {
    try {
      const { name, email, company, phone, message, type } = req.body;

      if (!name || !email || !message) {
        return res.status(400).json({
          success: false,
          message: "Name, email, and message are required"
        });
      }

      // Send email to sales team using direct nodemailer approach
      try {
        const nodemailer = await import('nodemailer');
        const { emailStorage } = await import('./email-storage');
        
        // Get admin SMTP settings
        const categorySettings = await emailStorage.getCategoryWithSettings('admin');
        
        if (!categorySettings?.smtp) {
          throw new Error('No SMTP configuration found');
        }

        const smtp = categorySettings.smtp;
        
        // Create transporter
        const transporter = nodemailer.createTransport({
          host: smtp.host,
          port: smtp.port,
          secure: smtp.port === 465,
          auth: {
            user: smtp.username,
            pass: smtp.password,
          },
        });

        // Send email directly to sales team
        await transporter.sendMail({
          from: `${smtp.fromName} <${smtp.fromEmail}>`,
          to: "sales@momtazchem.com",
          replyTo: email,
          subject: "New Sales Inquiry from Website",
          html: `
            <h2>New Sales Inquiry</h2>
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Company:</strong> ${company || 'Not specified'}</p>
            <p><strong>Phone:</strong> ${phone || 'Not provided'}</p>
            <p><strong>Message:</strong></p>
            <p>${message}</p>
          `,
          text: `
New Sales Inquiry

Name: ${name}
Email: ${email}
Company: ${company || 'Not specified'}
Phone: ${phone || 'Not provided'}

Message:
${message}
          `
        });

        // Also log this as a CRM activity if we can match to existing customer
        try {
          const existingCustomer = await crmStorage.getCrmCustomerByEmail(email);
          if (existingCustomer) {
            await crmStorage.logCustomerActivity({
              customerId: existingCustomer.id,
              activityType: 'contact_form',
              description: `Sales inquiry submitted via website: ${message.substring(0, 100)}...`,
              activityData: {
                source: 'website_contact_form',
                contactType: 'sales_inquiry',
                company: company,
                phone: phone,
                fullMessage: message
              }
            });
          } else {
            // Create new CRM customer for this inquiry
            const newCrmCustomer = await crmStorage.createCrmCustomer({
              firstName: name.split(' ')[0] || name,
              lastName: name.split(' ').slice(1).join(' ') || '',
              email: email,
              company: company || null,
              phone: phone || null,
              customerType: 'prospect'
            });

            await crmStorage.logCustomerActivity({
              customerId: newCrmCustomer.id,
              activityType: 'contact_form',
              description: `First contact via sales inquiry form: ${message.substring(0, 100)}...`,
              activityData: {
                source: 'website_contact_form',
                contactType: 'sales_inquiry',
                company: company,
                phone: phone,
                fullMessage: message
              }
            });
          }
        } catch (crmError) {
          console.error("Error logging to CRM:", crmError);
          // Don't fail the request if CRM logging fails
        }

        res.json({
          success: true,
          message: "Your message has been sent to our sales team. We'll contact you within 24 hours."
        });
      } catch (emailError) {
        console.error("Error sending sales contact email:", emailError);
        res.status(500).json({
          success: false,
          message: "Failed to send message. Please try again or contact us directly."
        });
      }
    } catch (error) {
      console.error("Error in sales contact endpoint:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // Quote request
  app.post("/api/contact/quote", async (req, res) => {
    try {
      const { 
        name, 
        email, 
        company, 
        phone, 
        productCategory, 
        quantity, 
        specifications, 
        timeline, 
        message 
      } = req.body;

      if (!name || !email || !company || !productCategory || !quantity || !specifications) {
        return res.status(400).json({
          success: false,
          message: "Name, email, company, product category, quantity, and specifications are required"
        });
      }

      // Send detailed quote request email to sales team using direct approach
      try {
        const nodemailer = await import('nodemailer');
        const { emailStorage } = await import('./email-storage');
        
        // Get admin SMTP settings
        const categorySettings = await emailStorage.getCategoryWithSettings('admin');
        
        if (!categorySettings?.smtp) {
          throw new Error('No SMTP configuration found');
        }

        const smtp = categorySettings.smtp;
        
        // Create transporter
        const transporter = nodemailer.createTransport({
          host: smtp.host,
          port: smtp.port,
          secure: smtp.port === 465,
          auth: {
            user: smtp.username,
            pass: smtp.password,
          },
        });

        // Send quote request email
        await transporter.sendMail({
          from: `${smtp.fromName} <${smtp.fromEmail}>`,
          to: "sales@momtazchem.com",
          replyTo: email,
          subject: `New Quote Request - ${productCategory}`,
          html: `
            <h2>New Quote Request</h2>
            <h3>Customer Information</h3>
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Company:</strong> ${company}</p>
            <p><strong>Phone:</strong> ${phone || 'Not provided'}</p>
            
            <h3>Product Requirements</h3>
            <p><strong>Product Category:</strong> ${productCategory}</p>
            <p><strong>Quantity:</strong> ${quantity}</p>
            <p><strong>Timeline:</strong> ${timeline || 'Not specified'}</p>
            
            <h3>Specifications</h3>
            <p>${specifications}</p>
            
            ${message ? `<h3>Additional Requirements</h3><p>${message}</p>` : ''}
          `,
          text: `
New Quote Request

Customer Information:
Name: ${name}
Email: ${email}
Company: ${company}
Phone: ${phone || 'Not provided'}

Product Requirements:
Product Category: ${productCategory}
Quantity: ${quantity}
Timeline: ${timeline || 'Not specified'}

Specifications:
${specifications}

${message ? `Additional Requirements:\n${message}` : ''}
          `
        });

        // Log this in CRM system
        try {
          let crmCustomer = await crmStorage.getCrmCustomerByEmail(email);
          
          if (!crmCustomer) {
            // Create new CRM customer for this quote request
            crmCustomer = await crmStorage.createCrmCustomer({
              firstName: name.split(' ')[0] || name,
              lastName: name.split(' ').slice(1).join(' ') || '',
              email: email,
              company: company,
              phone: phone || null,
              customerType: 'prospect'
            });
          }

          await crmStorage.logCustomerActivity({
            customerId: crmCustomer.id,
            activityType: 'quote_request',
            description: `Quote requested for ${productCategory} - Qty: ${quantity}`,
            activityData: {
              source: 'website_quote_form',
              productCategory: productCategory,
              quantity: quantity,
              specifications: specifications,
              timeline: timeline,
              additionalMessage: message,
              estimatedValue: 0 // Could be calculated based on product category
            }
          });

          // Update customer metrics
          await crmStorage.updateCustomerMetrics(crmCustomer.id);
        } catch (crmError) {
          console.error("Error logging quote request to CRM:", crmError);
          // Don't fail the request if CRM logging fails
        }

        res.json({
          success: true,
          message: "Your quote request has been submitted. Our team will prepare a detailed quote and respond within 24 hours."
        });
      } catch (emailError) {
        console.error("Error sending quote request email:", emailError);
        res.status(500).json({
          success: false,
          message: "Failed to submit quote request. Please try again or contact us directly."
        });
      }
    } catch (error) {
      console.error("Error in quote request endpoint:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // =============================================================================
  // CATEGORY MANAGEMENT API ROUTES
  // =============================================================================

  // Get all categories
  app.get("/api/admin/categories", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const categories = await shopStorage.getCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ success: false, message: "Failed to fetch categories" });
    }
  });

  // Get category by ID
  app.get("/api/admin/categories/:id", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const category = await shopStorage.getCategoryById(id);
      if (!category) {
        return res.status(404).json({ success: false, message: "Category not found" });
      }
      
      res.json(category);
    } catch (error) {
      console.error("Error fetching category:", error);
      res.status(500).json({ success: false, message: "Failed to fetch category" });
    }
  });

  // Create new category
  app.post("/api/admin/categories", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const { insertShopCategorySchema } = await import('../shared/shop-schema');
      
      const categoryData = insertShopCategorySchema.parse(req.body);
      const category = await shopStorage.createCategory(categoryData);
      
      res.json({
        success: true,
        message: "Category created successfully",
        category
      });
    } catch (error) {
      console.error("Error creating category:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          message: "Invalid category data",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create category" });
    }
  });

  // Update category
  app.put("/api/admin/categories/:id", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const { insertShopCategorySchema } = await import('../shared/shop-schema');
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const categoryData = insertShopCategorySchema.partial().parse(req.body);
      const category = await shopStorage.updateCategory(id, categoryData);
      
      res.json({
        success: true,
        message: "Category updated successfully",
        category
      });
    } catch (error) {
      console.error("Error updating category:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          message: "Invalid category data",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to update category" });
    }
  });

  // Delete category
  app.delete("/api/admin/categories/:id", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      // Check if category has products
      const products = await shopStorage.getProductsByCategory(id);
      if (products.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Cannot delete category with existing products"
        });
      }
      
      // Check if category has subcategories
      const subcategories = await shopStorage.getSubcategories(id);
      if (subcategories.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Cannot delete category with existing subcategories"
        });
      }
      
      await shopStorage.deleteCategory(id);
      
      res.json({
        success: true,
        message: "Category deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting category:", error);
      res.status(500).json({ success: false, message: "Failed to delete category" });
    }
  });

  // Get products by category
  app.get("/api/admin/categories/:id/products", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const products = await shopStorage.getProductsByCategory(id);
      res.json(products);
    } catch (error) {
      console.error("Error fetching products by category:", error);
      res.status(500).json({ success: false, message: "Failed to fetch products" });
    }
  });

  // =============================================================================
  // AI SEO ASSISTANT ROUTES
  // =============================================================================

  // AI Content Generation
  app.post('/api/ai/seo/generate', requireAuth, async (req, res) => {
    try {
      const { generateAISeoContent } = await import('./ai-seo-generator');
      const result = await generateAISeoContent(req.body);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error generating AI SEO content:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to generate AI content'
      });
    }
  });

  // AI Keyword Research
  app.post('/api/ai/seo/keywords', requireAuth, async (req, res) => {
    try {
      const { generateKeywordSuggestions } = await import('./ai-seo-generator');
      const { seedKeywords, language, industry, targetMarket } = req.body;
      
      const result = await generateKeywordSuggestions(seedKeywords, language, industry);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error researching keywords:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to research keywords'
      });
    }
  });

  // Business-specific keyword research
  app.post('/api/ai/seo/keyword-research', requireAuth, async (req, res) => {
    try {
      const { generateKeywordsForBusiness } = await import('./ai-seo-generator');
      const result = await generateKeywordsForBusiness(req.body);
      
      res.json({
        success: true,
        type: 'keywords',
        data: result
      });
    } catch (error) {
      console.error('Error generating keyword research:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to generate keyword research'
      });
    }
  });

  // AI Content Optimization
  app.post('/api/ai/seo/optimize', requireAuth, async (req, res) => {
    try {
      const { optimizeContentForSeo } = await import('./ai-seo-generator');
      const { content, targetKeywords, language } = req.body;
      
      const result = await optimizeContentForSeo(content, targetKeywords, language);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error optimizing content:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to optimize content'
      });
    }
  });

  // AI SEO Performance Analysis
  app.post('/api/ai/seo/analyze', requireAuth, async (req, res) => {
    try {
      const { analyzeSeoPerformance } = await import('./ai-seo-generator');
      const { url, targetKeywords } = req.body;
      
      const result = await analyzeSeoPerformance(url, targetKeywords);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error analyzing SEO performance:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to analyze SEO performance'
      });
    }
  });

  // =============================================================================
  // SEO MANAGEMENT ROUTES
  // =============================================================================

  // Get all SEO settings
  app.get("/api/admin/seo/settings", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const language = req.query.language as string;
      const settings = await seoStorage.getSeoSettings(language);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching SEO settings:", error);
      res.status(500).json({ success: false, message: "Failed to fetch SEO settings" });
    }
  });

  // Get supported languages
  app.get("/api/admin/seo/languages", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const languages = await seoStorage.getSupportedLanguages();
      res.json(languages);
    } catch (error) {
      console.error("Error fetching supported languages:", error);
      res.status(500).json({ success: false, message: "Failed to fetch supported languages" });
    }
  });

  // Create supported language
  app.post("/api/admin/seo/languages", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertSupportedLanguageSchema } = await import('../shared/schema');
      
      const validatedData = insertSupportedLanguageSchema.parse(req.body);
      const language = await seoStorage.createSupportedLanguage(validatedData);
      
      res.status(201).json({
        success: true,
        message: "Language created successfully",
        data: language
      });
    } catch (error) {
      console.error("Error creating language:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create language" });
    }
  });

  // Get multilingual analytics
  app.get("/api/admin/seo/multilingual-analytics", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const analytics = await seoStorage.getMultilingualAnalytics();
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching multilingual analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch multilingual analytics" });
    }
  });

  // Get keywords performance
  app.get("/api/admin/seo/keywords/performance", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const language = req.query.language as string;
      const performance = await seoStorage.getKeywordPerformance(language);
      res.json(performance);
    } catch (error) {
      console.error("Error fetching keyword performance:", error);
      res.status(500).json({ success: false, message: "Failed to fetch keyword performance" });
    }
  });

  // Create multilingual keyword
  app.post("/api/admin/seo/keywords", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertMultilingualKeywordSchema } = await import('../shared/schema');
      
      const validatedData = insertMultilingualKeywordSchema.parse(req.body);
      const keyword = await seoStorage.createMultilingualKeyword(validatedData);
      
      res.status(201).json({
        success: true,
        message: "Keyword created successfully",
        data: keyword
      });
    } catch (error) {
      console.error("Error creating keyword:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create keyword" });
    }
  });

  // Generate hreflang tags
  app.get("/api/admin/seo/hreflang/:pageType", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { pageType } = req.params;
      const pageIdentifier = req.query.pageIdentifier as string;
      
      const hreflangTags = await seoStorage.generateHreflangTags(pageType, pageIdentifier);
      res.json({ tags: hreflangTags });
    } catch (error) {
      console.error("Error generating hreflang tags:", error);
      res.status(500).json({ success: false, message: "Failed to generate hreflang tags" });
    }
  });

  // Generate multilingual sitemap
  app.get("/api/admin/seo/sitemap/multilingual", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const sitemapXml = await seoStorage.generateMultilingualSitemap();
      res.set('Content-Type', 'application/xml');
      res.send(sitemapXml);
    } catch (error) {
      console.error("Error generating multilingual sitemap:", error);
      res.status(500).send("Error generating multilingual sitemap");
    }
  });

  // Generate language-specific sitemap
  app.get("/sitemap-:language.xml", async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { language } = req.params;
      const sitemapXml = await seoStorage.generateSitemap(language);
      res.set('Content-Type', 'application/xml');
      res.send(sitemapXml);
    } catch (error) {
      console.error("Error generating language-specific sitemap:", error);
      res.status(500).send("Error generating sitemap");
    }
  });

  // Create SEO setting
  app.post("/api/admin/seo/settings", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertSeoSettingSchema } = await import('../shared/schema');
      
      const validatedData = insertSeoSettingSchema.parse(req.body);
      
      // Validate SEO settings
      const validationErrors = await seoStorage.validateSeoSettings(validatedData);
      if (validationErrors.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: validationErrors
        });
      }
      
      const setting = await seoStorage.createSeoSetting(validatedData);
      res.status(201).json({
        success: true,
        message: "SEO setting created successfully",
        data: setting
      });
    } catch (error) {
      console.error("Error creating SEO setting:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create SEO setting" });
    }
  });

  // Update SEO setting
  app.put("/api/admin/seo/settings/:id", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertSeoSettingSchema } = await import('../shared/schema');
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid SEO setting ID" });
      }
      
      const validatedData = insertSeoSettingSchema.partial().parse(req.body);
      const setting = await seoStorage.updateSeoSetting(id, validatedData);
      
      res.json({
        success: true,
        message: "SEO setting updated successfully",
        data: setting
      });
    } catch (error) {
      console.error("Error updating SEO setting:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to update SEO setting" });
    }
  });

  // Delete SEO setting
  app.delete("/api/admin/seo/settings/:id", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid SEO setting ID" });
      }
      
      await seoStorage.deleteSeoSetting(id);
      res.json({
        success: true,
        message: "SEO setting deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting SEO setting:", error);
      res.status(500).json({ success: false, message: "Failed to delete SEO setting" });
    }
  });

  // Get SEO analytics summary
  app.get("/api/admin/seo/analytics", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const summary = await seoStorage.getSeoAnalyticsSummary();
      res.json(summary);
    } catch (error) {
      console.error("Error fetching SEO analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch SEO analytics" });
    }
  });

  // Get sitemap entries
  app.get("/api/admin/seo/sitemap", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const entries = await seoStorage.getSitemapEntries();
      res.json(entries);
    } catch (error) {
      console.error("Error fetching sitemap entries:", error);
      res.status(500).json({ success: false, message: "Failed to fetch sitemap entries" });
    }
  });

  // Generate and serve XML sitemap
  app.get("/sitemap.xml", async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const sitemapXml = await seoStorage.generateSitemap();
      res.set('Content-Type', 'application/xml');
      res.send(sitemapXml);
    } catch (error) {
      console.error("Error generating sitemap:", error);
      res.status(500).send("Error generating sitemap");
    }
  });

  // Generate and serve robots.txt
  app.get("/robots.txt", async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const robotsTxt = await seoStorage.generateRobotsTxt();
      res.set('Content-Type', 'text/plain');
      res.send(robotsTxt);
    } catch (error) {
      console.error("Error generating robots.txt:", error);
      res.status(500).send("Error generating robots.txt");
    }
  });

  // Get redirects
  app.get("/api/admin/seo/redirects", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const redirectsList = await seoStorage.getRedirects();
      res.json(redirectsList);
    } catch (error) {
      console.error("Error fetching redirects:", error);
      res.status(500).json({ success: false, message: "Failed to fetch redirects" });
    }
  });

  // Create redirect
  app.post("/api/admin/seo/redirects", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertRedirectSchema } = await import('../shared/schema');
      
      const validatedData = insertRedirectSchema.parse(req.body);
      const redirect = await seoStorage.createRedirect(validatedData);
      
      res.status(201).json({
        success: true,
        message: "Redirect created successfully",
        data: redirect
      });
    } catch (error) {
      console.error("Error creating redirect:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create redirect" });
    }
  });

  // Customer PDF export routes
  app.get("/api/crm/customers/:id/export-pdf", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      if (isNaN(customerId)) {
        return res.status(400).json({ success: false, message: "Invalid customer ID" });
      }

      // Get customer data
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Customer not found" });
      }

      // Get customer analytics
      const analytics = await crmStorage.getCustomerAnalytics(customerId);
      
      // Get customer activities
      const activities = await crmStorage.getCustomerActivities(customerId, 20);

      // Generate PDF using PDFKit with proper customer profile format
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF(customer);

      // Validate PDF buffer before sending
      if (!pdfBuffer || pdfBuffer.length === 0) {
        throw new Error('Generated PDF is empty');
      }
      
      console.log('Customer report PDF generated successfully, size:', pdfBuffer.length, 'bytes');
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="customer-report-${customerId}-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Send PDF buffer
      res.end(pdfBuffer);
      
    } catch (error) {
      console.error("Error generating customer PDF:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate customer PDF report" 
      });
    }
  });

  // CRM Analytics PDF export
  app.get("/api/crm/analytics/export-pdf", requireAuth, async (req, res) => {
    try {
      // Get dashboard statistics
      const dashboardStats = await crmStorage.getCrmDashboardStats();
      
      // Generate PDF using PDFKit for better reliability
      const { generateAnalyticsPDF } = await import('./pdfkit-generator.js');
      const pdfBuffer = await generateAnalyticsPDF(dashboardStats, 'Ú¯Ø²Ø§Ø±Ø´ Ø¢Ù…Ø§Ø±Ù‡Ø§');

      // Validate PDF buffer before sending
      if (!pdfBuffer || pdfBuffer.length === 0) {
        throw new Error('Generated PDF is empty');
      }
      
      console.log('Analytics report PDF generated successfully, size:', pdfBuffer.length, 'bytes');
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="customer-analytics-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Send PDF buffer
      res.end(pdfBuffer);
      
    } catch (error) {
      console.error("Error generating analytics PDF:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate analytics PDF report" 
      });
    }
  });

  // CRM Customer Profile PDF export
  app.get("/api/crm/customers/:id/export-pdf", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      if (isNaN(customerId)) {
        return res.status(400).json({ success: false, message: "Invalid customer ID" });
      }

      // Get customer data
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Customer not found" });
      }

      // Generate PDF using PDFKit
      const { generateCustomerProfilePDF } = await import('./pdfkit-generator');
      const pdfBuffer = await generateCustomerProfilePDF(customer);

      // Validate PDF buffer before sending
      if (!pdfBuffer || pdfBuffer.length === 0) {
        throw new Error('Generated PDF is empty');
      }
      
      console.log('Customer profile PDF generated successfully, size:', pdfBuffer.length, 'bytes');
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="customer-profile-${customerId}-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Send PDF buffer
      res.end(pdfBuffer);
      
    } catch (error) {
      console.error("Error generating customer profile PDF:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate customer profile PDF" 
      });
    }
  });



  // Toggle SMS system (admin only)
  app.post("/api/admin/sms/toggle", requireAuth, async (req: Request, res: Response) => {
    try {
      const { enabled } = req.body;
      const adminId = req.session.adminId;
      const adminUsername = 'Admin';
      
      const settings = await smsStorage.toggleSmsSystem(enabled, adminUsername);
      
      res.json({ 
        success: true, 
        data: settings, 
        message: enabled ? "Ø³ÛŒØ³ØªÙ… SMS ÙØ¹Ø§Ù„ Ø´Ø¯" : "Ø³ÛŒØ³ØªÙ… SMS ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error toggling SMS system:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ… SMS" });
    }
  });

  // Get customer SMS settings (admin only)
  app.get("/api/admin/customers/:customerId/sms", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerId } = req.params;
      const settings = await smsStorage.getCustomerSmsSettings(parseInt(customerId));
      
      res.json({ 
        success: true, 
        data: settings || { 
          customerId: parseInt(customerId),
          smsAuthEnabled: false
        }
      });
    } catch (error) {
      console.error("Error fetching customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS Ù…Ø´ØªØ±ÛŒ" });
    }
  });

  // Enable SMS for customer (admin only)
  app.post("/api/admin/customers/:customerId/sms/enable", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerId } = req.params;
      const adminId = req.session.adminId;
      
      // Get admin username for logging
      const adminUsername = 'Admin';
      
      const settings = await smsStorage.enableCustomerSms(parseInt(customerId), adminUsername);
      
      // Log activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: parseInt(customerId),
        activityType: 'sms_enabled',
        description: `SMS authentication enabled by admin: ${adminUsername}`,
        performedBy: adminUsername
      });
      
      res.json({ 
        success: true, 
        data: settings, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error enabling customer SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ SMS Ù…Ø´ØªØ±ÛŒ" });
    }
  });

  // Disable SMS for customer (admin only)
  app.post("/api/admin/customers/:customerId/sms/disable", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerId } = req.params;
      const adminId = req.session.adminId;
      
      // Get admin username for logging
      const adminUsername = 'Admin';
      
      const settings = await smsStorage.disableCustomerSms(parseInt(customerId), adminUsername);
      
      // Log activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: parseInt(customerId),
        activityType: 'sms_disabled',
        description: `SMS authentication disabled by admin: ${adminUsername}`,
        performedBy: adminUsername
      });
      
      res.json({ 
        success: true, 
        data: settings, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error disabling customer SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØºÛŒØ±ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ SMS Ù…Ø´ØªØ±ÛŒ" });
    }
  });

  // Get all customers with SMS settings (admin only)
  app.get("/api/admin/sms/customers", requireAuth, async (req: Request, res: Response) => {
    try {
      const customers = await crmStorage.getCrmCustomers(100, 0);
      
      const customerSmsData = customers.map(customer => ({
        id: customer.id,
        firstName: customer.firstName,
        lastName: customer.lastName,
        email: customer.email,
        phone: customer.phone || '',
        company: customer.company,
        smsEnabled: customer.smsEnabled === true, // Explicit boolean check
        customerStatus: customer.customerStatus,
        totalOrders: customer.totalOrdersCount || 0,
        lastOrderDate: customer.lastOrderDate ? new Date(customer.lastOrderDate).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        }) : null
      }));
      
      res.json({ success: true, data: customerSmsData });
    } catch (error) {
      console.error("Error fetching customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS Ù…Ø´ØªØ±ÛŒØ§Ù†" });
    }
  });

  // Update individual customer SMS setting (admin only)
  app.put("/api/admin/sms/customers/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const customerId = parseInt(req.params.id);
      const { smsEnabled } = req.body;
      
      if (typeof smsEnabled !== 'boolean') {
        return res.status(400).json({ success: false, message: "Ù…Ù‚Ø¯Ø§Ø± SMS Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }
      
      // First check if customer exists
      const existingCustomer = await crmStorage.getCrmCustomerById(customerId);
      if (!existingCustomer) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }
      
      // Update customer SMS setting
      await crmStorage.updateCrmCustomer(customerId, { smsEnabled });
      
      // Log activity
      await crmStorage.logCustomerActivity({
        customerId,
        activityType: "sms_setting_changed",
        description: `SMS ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†`,
        performedBy: req.session?.adminId?.toString() || 'admin',
        activityData: { smsEnabled, changedBy: 'admin' }
      });
      
      res.json({ 
        success: true, 
        message: `SMS Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒ ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error updating customer SMS setting:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS" });
    }
  });

  // Bulk enable/disable SMS for all customers (admin only)
  app.post("/api/admin/sms/customers/bulk", requireAuth, async (req: Request, res: Response) => {
    try {
      const { action } = req.body; // 'enable' or 'disable'
      
      if (!['enable', 'disable'].includes(action)) {
        return res.status(400).json({ success: false, message: "Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }
      
      const smsEnabled = action === 'enable';
      
      // Get all customers
      const customers = await crmStorage.getCrmCustomers(1000, 0);
      
      // Update all customers
      for (const customer of customers) {
        await crmStorage.updateCrmCustomer(customer.id, { smsEnabled });
        
        // Log activity for each customer
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: "sms_bulk_setting_changed",
          description: `SMS ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù…Ø´ØªØ±ÛŒØ§Ù† ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†`,
          performedBy: req.session?.adminId?.toString() || 'admin',
          activityData: { smsEnabled, action: 'bulk', changedBy: 'admin' }
        });
      }
      
      res.json({ 
        success: true, 
        message: `SMS Ø¨Ø±Ø§ÛŒ ${customers.length} Ù…Ø´ØªØ±ÛŒ ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error bulk updating customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù†Ø¨ÙˆÙ‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS" });
    }
  });

  // Get SMS statistics (admin only)
  app.get("/api/admin/sms/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const stats = await smsStorage.getSmsStats();
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching SMS stats:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± SMS" });
    }
  });

  // Get delivery SMS logs (admin only)
  app.get("/api/admin/sms/delivery-logs", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { smsLogs } = await import("../shared/schema");
      const { eq, desc } = await import("drizzle-orm");
      
      const deliveryLogs = await db
        .select()
        .from(smsLogs)
        .where(eq(smsLogs.purpose, 'delivery_notification'))
        .orderBy(desc(smsLogs.createdAt))
        .limit(50);
      
      res.json({ success: true, data: deliveryLogs });
    } catch (error) {
      console.error("Error fetching delivery SMS logs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ SMS ØªØ­ÙˆÛŒÙ„" });
    }
  });

  // Send SMS verification code (public endpoint for customer login)
  app.post("/api/sms/send-verification", async (req: Request, res: Response) => {
    try {
      const { phone, purpose } = req.body;
      
      if (!phone || !purpose) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù‡Ø¯Ù Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }
      
      // Check if SMS system is enabled
      const settings = await smsStorage.getSmsSettings();
      if (!settings?.isEnabled) {
        return res.status(503).json({ success: false, message: "Ø³ÛŒØ³ØªÙ… Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª" });
      }
      
      // Generate verification code
      const code = Math.random().toString().slice(2, 2 + (settings.codeLength || 6));
      const expiresAt = new Date(Date.now() + (settings.codeExpiry || 300) * 1000);
      
      // Save verification code
      await smsStorage.createVerification({
        phone,
        code,
        purpose,
        expiresAt
      });
      
      // Here you would integrate with SMS provider (Kavenegar, etc.)
      // For now, we'll just log the code for development
      console.log(`SMS Verification Code for ${phone}: ${code}`);
      
      res.json({ 
        success: true, 
        message: "Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        // In production, don't send the code in response
        ...(process.env.NODE_ENV === 'development' && { code })
      });
    } catch (error) {
      console.error("Error sending SMS verification:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯" });
    }
  });

  // Verify SMS code (public endpoint for customer login)
  app.post("/api/sms/verify-code", async (req: Request, res: Response) => {
    try {
      const { phone, code, purpose } = req.body;
      
      if (!phone || !code || !purpose) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†ØŒ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ùˆ Ù‡Ø¯Ù Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }
      
      // Find verification
      const verification = await smsStorage.getVerification(phone, code, purpose);
      
      if (!verification) {
        return res.status(400).json({ success: false, message: "Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }
      
      // Mark as used
      await smsStorage.markVerificationUsed(verification.id);
      
      res.json({ 
        success: true, 
        message: "Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ£ÛŒÛŒØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error verifying SMS code:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø¯" });
    }
  });

  // ============================================================================
  // CUSTOMER ADDRESS MANAGEMENT ROUTES
  // ============================================================================

  // Get customer addresses
  app.get("/api/customers/addresses", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addresses = await customerAddressStorage.getCustomerAddresses(req.session.customerId);
      res.json({ success: true, addresses });
    } catch (error) {
      console.error("Error fetching customer addresses:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§" });
    }
  });

  // Create new address
  app.post("/api/customers/addresses", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      // Get customer info to auto-fill firstName and lastName
      const customer = await crmStorage.getCrmCustomerById(req.session.customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const addressData = insertCustomerAddressSchema.parse({
        ...req.body,
        customerId: req.session.customerId,
        firstName: customer.firstName,
        lastName: customer.lastName
      });

      const newAddress = await customerAddressStorage.createAddress(addressData);
      res.json({ success: true, address: newAddress, message: "Ø¢Ø¯Ø±Ø³ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error creating address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¢Ø¯Ø±Ø³ Ø¬Ø¯ÛŒØ¯" });
    }
  });

  // Update address
  app.put("/api/customers/addresses/:id", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addressId = parseInt(req.params.id);
      const existingAddress = await customerAddressStorage.getAddressById(addressId);
      
      if (!existingAddress || existingAddress.customerId !== req.session.customerId) {
        return res.status(404).json({ success: false, message: "Ø¢Ø¯Ø±Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const updatedAddress = await customerAddressStorage.updateAddress(addressId, req.body);
      res.json({ success: true, address: updatedAddress, message: "Ø¢Ø¯Ø±Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ø¯Ø±Ø³" });
    }
  });

  // Delete address
  app.delete("/api/customers/addresses/:id", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addressId = parseInt(req.params.id);
      const existingAddress = await customerAddressStorage.getAddressById(addressId);
      
      if (!existingAddress || existingAddress.customerId !== req.session.customerId) {
        return res.status(404).json({ success: false, message: "Ø¢Ø¯Ø±Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      await customerAddressStorage.deleteAddress(addressId);
      res.json({ success: true, message: "Ø¢Ø¯Ø±Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¢Ø¯Ø±Ø³" });
    }
  });

  // Set default address
  app.post("/api/customers/addresses/:id/set-default", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addressId = parseInt(req.params.id);
      const existingAddress = await customerAddressStorage.getAddressById(addressId);
      
      if (!existingAddress || existingAddress.customerId !== req.session.customerId) {
        return res.status(404).json({ success: false, message: "Ø¢Ø¯Ø±Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      await customerAddressStorage.setDefaultAddress(req.session.customerId, addressId);
      res.json({ success: true, message: "Ø¢Ø¯Ø±Ø³ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯" });
    } catch (error) {
      console.error("Error setting default address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ø¢Ø¯Ø±Ø³ Ù¾ÛŒØ´â€ŒÙØ±Ø¶" });
    }
  });

  // =============================================================================
  // WIDGET RECOMMENDATION API ROUTES
  // =============================================================================

  // Get available dashboard widgets
  app.get("/api/admin/widgets", requireAuth, async (req: Request, res: Response) => {
    try {
      const { category, userLevel } = req.query;
      const widgets = await widgetRecommendationStorage.getWidgets(
        category as string, 
        userLevel as string || 'admin'
      );
      res.json({ success: true, data: widgets });
    } catch (error) {
      console.error("Error fetching widgets:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§" });
    }
  });

  // Get user's widget preferences
  app.get("/api/admin/widgets/preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const preferences = await widgetRecommendationStorage.getUserPreferences(userId);
      res.json({ success: true, data: preferences });
    } catch (error) {
      console.error("Error fetching widget preferences:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§" });
    }
  });

  // Toggle widget visibility
  app.post("/api/admin/widgets/:widgetId/toggle", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const widgetId = parseInt(req.params.widgetId);
      const preference = await widgetRecommendationStorage.toggleWidgetVisibility(userId, widgetId);
      
      res.json({ 
        success: true, 
        data: preference,
        message: `ÙˆÛŒØ¬Øª ${preference.isVisible ? 'Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯' : 'Ù…Ø®ÙÛŒ Ø´Ø¯'}` 
      });
    } catch (error) {
      console.error("Error toggling widget visibility:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ù†Ù…Ø§ÛŒØ´ ÙˆÛŒØ¬Øª" });
    }
  });

  // Track widget usage
  app.post("/api/admin/widgets/:widgetId/track", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const widgetId = parseInt(req.params.widgetId);
      const { action, duration, sessionId } = req.body;

      await widgetRecommendationStorage.trackWidgetUsage({
        userId,
        widgetId,
        action,
        duration,
        sessionId,
        userAgent: req.headers['user-agent'],
        ipAddress: req.ip
      });

      res.json({ success: true, message: "Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆÛŒØ¬Øª Ø«Ø¨Øª Ø´Ø¯" });
    } catch (error) {
      console.error("Error tracking widget usage:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆÛŒØ¬Øª" });
    }
  });

  // Get widget recommendations for user
  app.get("/api/admin/widgets/recommendations", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendations = await widgetRecommendationStorage.getRecommendationsForUser(userId);
      res.json({ success: true, data: recommendations });
    } catch (error) {
      console.error("Error fetching recommendations:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª" });
    }
  });

  // Generate new recommendations
  app.post("/api/admin/widgets/recommendations/generate", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendations = await widgetRecommendationStorage.generateRecommendations(userId);
      res.json({ 
        success: true, 
        data: recommendations,
        message: `${recommendations.length} Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯` 
      });
    } catch (error) {
      console.error("Error generating recommendations:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª" });
    }
  });

  // Delete corrupted orders (Admin only)
  app.delete("/api/admin/orders/corrupted/:orderNumber", requireAuth, async (req: Request, res: Response) => {
    try {
      const orderNumber = req.params.orderNumber;
      
      // Security check - only allow deletion of M25T003 and M25T004
      if (orderNumber !== 'M25T003' && orderNumber !== 'M25T004') {
        return res.status(403).json({ 
          success: false, 
          message: "ÙÙ‚Ø· Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø¹ÛŒÙˆØ¨ M25T003 Ùˆ M25T004 Ù‚Ø§Ø¨Ù„ Ø­Ø°Ù Ù‡Ø³ØªÙ†Ø¯" 
        });
      }

      console.log(`ğŸ—‘ï¸ [ADMIN DELETE] Starting deletion of corrupted order: ${orderNumber}`);
      
      // Get order details first
      const order = await customerDb
        .select()
        .from(customerOrders)
        .where(eq(customerOrders.orderNumber, orderNumber))
        .limit(1);

      if (!order.length) {
        return res.status(404).json({ success: false, message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const orderId = order[0].id;
      const orderAmount = order[0].totalAmount;

      // Delete from order_management table
      await orderManagementDb
        .delete(orderManagement)
        .where(eq(orderManagement.customerOrderId, orderId));

      // Mark as deleted in customer_orders table
      await customerDb
        .update(customerOrders)
        .set({ 
          status: 'deleted',
          notes: `Ø­Ø°Ù Ø³ÙØ§Ø±Ø´ Ù…Ø¹ÛŒÙˆØ¨ - ${new Date().toLocaleDateString('fa-IR')} - Ø¨Ø¯ÙˆÙ† Ø¢ÛŒØªÙ… Ø§Ù…Ø§ Ø¯Ø§Ø±Ø§ÛŒ Ù…Ø¨Ù„Øº ${orderAmount} Ø¯ÛŒÙ†Ø§Ø±`
        })
        .where(eq(customerOrders.id, orderId));

      console.log(`âœ… [ADMIN DELETE] Successfully deleted corrupted order ${orderNumber} (ID: ${orderId}, Amount: ${orderAmount} IQD)`);

      res.json({ 
        success: true, 
        message: `Ø³ÙØ§Ø±Ø´ Ù…Ø¹ÛŒÙˆØ¨ ${orderNumber} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯`,
        deletedOrder: {
          orderNumber,
          orderId,
          amount: orderAmount
        }
      });

    } catch (error) {
      console.error("Error deleting corrupted order:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙØ§Ø±Ø´ Ù…Ø¹ÛŒÙˆØ¨" });
    }
  });

  // Accept recommendation
  app.post("/api/admin/widgets/recommendations/:recommendationId/accept", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendationId = parseInt(req.params.recommendationId);
      await widgetRecommendationStorage.acceptRecommendation(userId, recommendationId);
      
      res.json({ success: true, message: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù¾Ø°ÛŒØ±ÙØªÙ‡ Ø´Ø¯ Ùˆ ÙˆÛŒØ¬Øª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯" });
    } catch (error) {
      console.error("Error accepting recommendation:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø°ÛŒØ±Ø´ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯" });
    }
  });

  // Dismiss recommendation
  app.post("/api/admin/widgets/recommendations/:recommendationId/dismiss", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendationId = parseInt(req.params.recommendationId);
      await widgetRecommendationStorage.dismissRecommendation(userId, recommendationId);
      
      res.json({ success: true, message: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø±Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error dismissing recommendation:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯" });
    }
  });

  // Get popular widgets
  app.get("/api/admin/widgets/popular", requireAuth, async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 10;
      const popularWidgets = await widgetRecommendationStorage.getPopularWidgets(limit);
      res.json({ success: true, data: popularWidgets });
    } catch (error) {
      console.error("Error fetching popular widgets:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø­Ø¨ÙˆØ¨" });
    }
  });

  // Get user activity summary
  app.get("/api/admin/widgets/activity", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const days = parseInt(req.query.days as string) || 30;
      const activity = await widgetRecommendationStorage.getUserActivitySummary(userId, days);
      res.json({ success: true, data: activity });
    } catch (error) {
      console.error("Error fetching user activity:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ¹Ø§Ù„ÛŒØª Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // =============================================================================
  // FINANCIAL DEPARTMENT SPECIFIC API ROUTES
  // =============================================================================

  // Financial department authentication check
  app.get('/api/financial/auth/me', async (req: Request, res: Response) => {
    try {
      // Check if user has admin session first
      if (req.session?.isAuthenticated && req.session?.adminId) {
        // Return admin user as financial user
        const adminUser = {
          id: req.session.adminId,
          username: 'admin_financial',
          email: 'admin@momtazchem.com',
          department: 'financial',
          isAdmin: true
        };
        return res.json({ success: true, user: adminUser });
      }

      // For now, return a default financial user for testing
      // In production, this would check actual financial department authentication
      const defaultFinancialUser = {
        id: 1,
        username: 'financial_admin',
        email: 'financial@momtazchem.com',
        department: 'financial'
      };
      
      res.json({ success: true, user: defaultFinancialUser });
    } catch (error) {
      console.error('Error in financial auth check:', error);
      res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø§Ù„ÛŒ Ù†Ø´Ø¯Ù‡' });
    }
  });

  // Financial department logout
  app.post('/api/financial/logout', async (req: Request, res: Response) => {
    try {
      // Clear session if needed
      res.json({ success: true, message: 'Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚ÛŒØªâ€ŒØ¢Ù…ÛŒØ²' });
    } catch (error) {
      console.error('Error in financial logout:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬' });
    }
  });



  // Approve financial order with smart wallet management (public access for financial department)
  app.post('/api/finance/orders/:id/approve', async (req: Request, res: Response) => {
    try {
      const orderId = parseInt(req.params.id);
      const { notes, receiptAmount } = req.body; // receiptAmount: Ù…Ø¨Ù„Øº ÙˆØ§Ø±ÛŒØ²ÛŒ Ø¯Ø± ÙÛŒØ´
      const adminId = 1; // Default financial admin ID

      console.log(`âœ… [FINANCE] Processing payment approval for order ${orderId} with smart wallet management`);

      const { pool } = await import('./db');
      
      // First try to find by order management ID
      let orderManagementResult = await pool.query(`
        SELECT om.*, co.payment_method, co.status, co.total_amount, co.currency, co.customer_id
        FROM order_management om
        JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE om.id = $1
      `, [orderId]);

      // If not found, try to find by customer_order_id (for frontend compatibility)
      if (orderManagementResult.rows.length === 0) {
        console.log(`ğŸ” [FINANCE] Order management ID ${orderId} not found, searching by customer_order_id`);
        orderManagementResult = await pool.query(`
          SELECT om.*, co.payment_method, co.status, co.total_amount, co.currency, co.customer_id
          FROM order_management om
          JOIN customer_orders co ON om.customer_order_id = co.id
          WHERE om.customer_order_id = $1
        `, [orderId]);
      }

      if (orderManagementResult.rows.length === 0) {
        console.log(`âŒ [FINANCE] Order ${orderId} not found in either order_management.id or customer_order_id`);
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const orderData = orderManagementResult.rows[0];
      const isTemporaryOrder = orderData.payment_grace_period_start !== null;
      const orderManagementId = orderData.id; // Use correct order management ID
      const customerId = orderData.customer_id;
      const orderTotalAmount = parseFloat(orderData.total_amount);
      const paidAmount = receiptAmount ? parseFloat(receiptAmount) : orderTotalAmount;

      console.log(`ğŸ“Š [FINANCE] Order details - Management ID: ${orderManagementId}, Customer: ${customerId}, Total: ${orderTotalAmount}, Paid: ${paidAmount}`);

      // Smart wallet management logic
      let walletTransactionMessage = '';
      if (receiptAmount && paidAmount !== orderTotalAmount) {
        const difference = paidAmount - orderTotalAmount;
        
        if (difference > 0) {
          // Customer paid more than required - credit excess to wallet
          console.log(`ğŸ’° [WALLET] Customer overpaid by ${difference} IQD, crediting to wallet`);
          await walletStorage.creditWallet(
            customerId,
            difference,
            `Ø§Ø¶Ø§ÙÙ‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderData.order_number || orderData.customer_order_id} - Ø§Ø¹ØªØ¨Ø§Ø± Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„`,
            'overpayment',
            orderData.customer_order_id,
            adminId
          );
          walletTransactionMessage = ` - Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ${difference.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯`;
        } else {
          // Customer paid less - check wallet for deficit
          const deficit = Math.abs(difference);
          console.log(`ğŸ’¸ [WALLET] Customer underpaid by ${deficit} IQD, checking wallet balance`);
          
          const walletBalance = await walletStorage.getWalletBalance(customerId);
          console.log(`ğŸ¦ [WALLET] Customer wallet balance: ${walletBalance} IQD`);
          
          if (walletBalance >= deficit) {
            // Sufficient wallet balance - debit the deficit
            console.log(`âœ… [WALLET] Deducting ${deficit} IQD from wallet to complete payment`);
            await walletStorage.debitWallet(
              customerId,
              deficit,
              `ØªÚ©Ù…ÛŒÙ„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderData.order_number || orderData.customer_order_id} - Ú©Ø³Ø± Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„`,
              'payment_completion',
              orderData.customer_order_id,
              adminId
            );
            walletTransactionMessage = ` - Ù…Ø¨Ù„Øº ${deficit.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ Ú©Ø³Ø± Ø´Ø¯`;
          } else {
            // Insufficient wallet balance
            console.log(`âŒ [WALLET] Insufficient wallet balance. Required: ${deficit}, Available: ${walletBalance}`);
            return res.status(400).json({ 
              success: false, 
              message: `Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ø±Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„ Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª. Ù…Ø·Ù„ÙˆØ¨: ${deficit.toLocaleString()} - Ù…ÙˆØ¬ÙˆØ¯: ${walletBalance.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±` 
            });
          }
        }
      }

      // ğŸš¨ CRITICAL: Grace period orders need manual approval to go to warehouse
      const { orderStatuses } = await import('../shared/order-management-schema');
      
      // Check if this is a grace period order
      const isGracePeriodOrder = orderData.payment_method === 'bank_transfer_grace' || isTemporaryOrder;
      
      let targetStatus, statusMessage;
      if (isGracePeriodOrder) {
        // Grace period orders stay in financial_approved - require manual warehouse transfer
        targetStatus = 'financial_approved';
        statusMessage = (notes || 'Grace period payment approved by financial department - awaiting manual warehouse transfer') + walletTransactionMessage;
        console.log(`ğŸ¦ [GRACE PERIOD] Order ${orderData.customer_order_id} approved but staying in financial_approved - requires manual warehouse transfer`);
      } else {
        // Regular orders can go directly to warehouse
        targetStatus = orderStatuses.WAREHOUSE_PENDING;
        statusMessage = (notes || 'Payment approved by financial department - moving to warehouse') + walletTransactionMessage;
      }
      
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderManagementId, // Use correct order management ID
        targetStatus,
        adminId, 
        'financial', 
        statusMessage
      );
      
      // Trigger automatic synchronization after financial approval
      try {
        await globalSyncService.triggerOrderSync(orderData.customer_order_id, 'financial_approved');
        console.log(`ğŸ”„ [SYNC] Triggered automatic sync for financial approval - order ${orderData.customer_order_id}`);
      } catch (syncError) {
        console.error(`âŒ [SYNC] Auto-sync failed for financial approval:`, syncError);
        // Don't fail order update if sync fails
      }

      // If this was a temporary order (grace period), convert it to regular order
      if (isTemporaryOrder) {
        console.log(`ğŸ”„ [FINANCE] Converting temporary order ${orderId} to regular order`);
        
        // ğŸ†• Generate order number for the approved grace period order
        const { OrderManagementStorage } = await import('./order-management-storage');
        const orderManagementStorage = new OrderManagementStorage();
        const newOrderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
        console.log(`ğŸ”¢ [FINANCE] Generated order number ${newOrderNumber} for approved grace period order`);
        
        // Clear grace period fields and unlock the order
        await pool.query(`
          UPDATE order_management 
          SET payment_grace_period_start = NULL,
              payment_grace_period_end = NULL,
              is_order_locked = false
          WHERE id = $1
        `, [orderManagementId]);

        // Update customer order status to 'confirmed' and assign order number
        await pool.query(`
          UPDATE customer_orders 
          SET status = 'confirmed',
              payment_status = 'paid',
              order_number = $2
          WHERE id = $1
        `, [orderData.customer_order_id, newOrderNumber]);

        console.log(`âœ… [FINANCE] Order ${orderManagementId} (Customer Order ${orderData.customer_order_id}) converted from temporary to regular order with number ${newOrderNumber} and moved to warehouse`);
        res.json({ 
          success: true, 
          order: updatedOrder, 
          orderNumber: newOrderNumber,
          message: `Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø´Ù…Ø§Ø±Ù‡ ${newOrderNumber} Ø¯Ø±ÛŒØ§ÙØª Ú©Ø±Ø¯. Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ø¨Ø§Ø± Ø§Ø³Øª` + walletTransactionMessage,
          walletTransaction: walletTransactionMessage.length > 0
        });
      } else {
        // ğŸ†• Regular orders also need order numbers after financial approval
        let orderNumber = orderData.order_number; // Use existing order number if available
        
        if (!orderNumber) {
          console.log(`ğŸ”¢ [FINANCE] Assigning order number to regular order ${orderData.customer_order_id}`);
          const { OrderManagementStorage } = await import('./order-management-storage');
          const orderManagementStorage = new OrderManagementStorage();
          orderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
          
          // Update customer order with new order number
          await pool.query(`
            UPDATE customer_orders 
            SET order_number = $2
            WHERE id = $1
          `, [orderData.customer_order_id, orderNumber]);
          
          console.log(`âœ… [FINANCE] Regular order ${orderManagementId} assigned order number ${orderNumber}`);
        }
        
        console.log(`âœ… [FINANCE] Regular order ${orderManagementId} (Customer Order ${orderData.customer_order_id}) approved and moved to warehouse department`);
        res.json({ 
          success: true, 
          order: updatedOrder, 
          orderNumber: orderNumber,
          message: 'Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ø¨Ø§Ø± Ø§Ø³Øª' + walletTransactionMessage,
          walletTransaction: walletTransactionMessage.length > 0
        });
      }
    } catch (error) {
      console.error('Error approving financial order:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª: ' + error.message });
    }
  });

  // Reject financial order (public access for financial department)
  app.post('/api/finance/orders/:id/reject', async (req: Request, res: Response) => {
    try {
      const orderId = parseInt(req.params.id);
      const { notes } = req.body;
      const adminId = 1; // Default financial admin ID

      console.log(`âŒ [FINANCE] Rejecting order ${orderId}`);

      // When financial rejects, set to financial_rejected (stays in financial for rejected list)
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderId, 
        'financial_rejected', 
        adminId, 
        'financial', 
        notes || 'Payment rejected by financial department'
      );

      console.log(`âŒ [FINANCE] Order ${orderId} rejected by financial department`);
      res.json({ success: true, order: updatedOrder, message: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø¯ Ø´Ø¯' });
    } catch (error) {
      console.error('Error rejecting financial order:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª' });
    }
  });



  // =============================================================================
  // ORDER MANAGEMENT API ROUTES (3-Department System)
  // =============================================================================

  // UNIFIED ORDER STATISTICS - Same source as tracking API for consistency (MOVED BEFORE DEPARTMENT ROUTE)
  app.get('/api/order-management/statistics', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ“Š [UNIFIED STATS] Fetching statistics using same query as tracking API...');
      
      // Use SAME query as tracking API to ensure consistency
      const statsResult = await customerPool.query(`
        SELECT 
          COUNT(*) as total_orders,
          COUNT(CASE WHEN (om.current_status IS NULL OR om.current_status IN ('pending', 'payment_uploaded', 'financial_reviewing')) THEN 1 END) as pending_orders,
          COUNT(CASE WHEN om.current_status IN ('delivered', 'completed') THEN 1 END) as completed_orders,
          COUNT(CASE WHEN co.created_at >= CURRENT_DATE THEN 1 END) as todays_orders,
          SUM(CASE WHEN om.current_status IN ('delivered', 'completed') THEN co.total_amount ELSE 0 END) as total_revenue,
          AVG(co.total_amount) as average_order_value
        FROM customer_orders co
        LEFT JOIN crm_customers cc ON co.customer_id = cc.id
        LEFT JOIN order_management om ON co.id = om.customer_order_id
        -- SHOW ALL ORDERS: No filtering by status for complete management statistics
      `);

      const stats = statsResult.rows[0];
      
      console.log('ğŸ“Š [UNIFIED STATS] Raw statistics:', stats);

      const result = {
        totalOrders: parseInt(stats.total_orders) || 0,
        pendingOrders: parseInt(stats.pending_orders) || 0,
        completedOrders: parseInt(stats.completed_orders) || 0,
        todaysOrders: parseInt(stats.todays_orders) || 0,
        totalRevenue: parseFloat(stats.total_revenue) || 0,
        averageOrderValue: parseFloat(stats.average_order_value) || 0
      };
      
      console.log('âœ… [UNIFIED STATS] Final statistics result:', result);
      
      res.json(result);
    } catch (error) {
      console.error('âŒ [UNIFIED STATS] Error fetching order statistics:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  });

  // Get orders for specific department (respects workflow sequence)
  app.get('/api/order-management/:department', async (req, res) => {
    try {
      const department = req.params.department as 'financial' | 'warehouse' | 'logistics';
      
      if (!['financial', 'warehouse', 'logistics'].includes(department)) {
        return res.status(400).json({ success: false, message: 'Ø¨Ø®Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' });
      }

      // For financial department, allow access without admin auth
      if (department === 'financial') {
        const orders = await orderManagementStorage.getOrdersByDepartment(department);
        return res.json({ success: true, orders });
      }

      // For other departments, require admin auth
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const orders = await orderManagementStorage.getOrdersByDepartment(department);
      res.json({ success: true, orders });
    } catch (error) {
      console.error(`Error fetching ${req.params.department} orders:`, error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // =============================================================================  
  // ORDER TRACKING MANAGEMENT API ROUTES - REMOVED DUPLICATE
  // =============================================================================
  
  // REMOVED: Second duplicate endpoint that used wrong data structure

  // Get order statistics for dashboard
  app.get('/api/orders/statistics', async (req, res) => {
    try {
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const { pool } = await import('./db');
      
      // Get comprehensive order statistics
      const statsQuery = `
        SELECT
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status IN ('pending_payment', 'payment_uploaded', 'financial_reviewing', 'warehouse_processing', 'logistics_processing') THEN 1 END) as pending_orders,
          COUNT(CASE WHEN status IN ('delivered', 'completed') THEN 1 END) as completed_orders,
          COALESCE(SUM(CASE WHEN status IN ('delivered', 'completed') THEN total_amount ELSE 0 END), 0) as total_revenue,
          COALESCE(AVG(CASE WHEN status IN ('delivered', 'completed') THEN total_amount ELSE NULL END), 0) as average_order_value,
          COUNT(CASE WHEN DATE(created_at) = CURRENT_DATE THEN 1 END) as todays_orders
        FROM customer_orders
        WHERE created_at >= CURRENT_DATE - INTERVAL '1 year'
      `;
      
      const result = await pool.query(statsQuery);
      const stats = result.rows[0];
      
      console.log('ğŸ“Š [ORDER STATS] Retrieved order statistics:', stats);
      
      res.json({ 
        success: true, 
        stats: {
          totalOrders: parseInt(stats.total_orders) || 0,
          pendingOrders: parseInt(stats.pending_orders) || 0,
          completedOrders: parseInt(stats.completed_orders) || 0,
          totalRevenue: parseFloat(stats.total_revenue) || 0,
          averageOrderValue: parseFloat(stats.average_order_value) || 0,
          todaysOrders: parseInt(stats.todays_orders) || 0
        }
      });
    } catch (error) {
      console.error('âŒ [ORDER STATS] Error fetching order statistics:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¢Ù…Ø§Ø± Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // Get order history for specific order
  app.get('/api/orders/:id/history', async (req, res) => {
    try {
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const orderId = parseInt(req.params.id);
      const { pool } = await import('./db');
      
      // Get order status history
      const historyQuery = `
        SELECT 
          osh.id,
          osh.from_status as fromStatus,
          osh.to_status as toStatus,
          osh.changed_by as changedBy,
          osh.changed_by_department as changedByDepartment,
          osh.notes,
          osh.created_at as createdAt
        FROM order_status_history osh
        WHERE osh.order_management_id = (
          SELECT id FROM order_management WHERE customer_order_id = $1
        )
        ORDER BY osh.created_at DESC
      `;
      
      const result = await pool.query(historyQuery, [orderId]);
      console.log('ğŸ“œ [ORDER HISTORY] Retrieved', result.rows.length, 'history items for order', orderId);
      
      res.json({ success: true, history: result.rows });
    } catch (error) {
      console.error('âŒ [ORDER HISTORY] Error fetching order history:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø³ÙØ§Ø±Ø´' });
    }
  });



  // Update order status (department-specific)
  app.put('/api/order-management/:id/status', async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { newStatus, department, notes } = req.body;
      
      // For financial department, use default admin ID (financial department operations)
      let adminId = req.session.adminId;
      if (department === 'financial' && !adminId) {
        adminId = 1; // Default financial admin ID for financial operations
      }

      if (!adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      // Validate that admin can perform this action
      const canView = await orderManagementStorage.canDepartmentViewOrder(orderId, department);
      if (!canView) {
        return res.status(403).json({ success: false, message: 'Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª' });
      }

      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderId, 
        newStatus, 
        adminId, 
        department, 
        notes
      );

      // Trigger automatic synchronization after status update
      try {
        await globalSyncService.triggerOrderSync(updatedOrder.customerOrderId, 'status_updated');
        console.log(`ğŸ”„ [SYNC] Triggered automatic sync for status update - order ${updatedOrder.customerOrderId}`);
      } catch (syncError) {
        console.error(`âŒ [SYNC] Auto-sync failed for status update:`, syncError);
        // Don't fail order update if sync fails
      }

      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error updating order status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Get order status history
  app.get('/api/order-management/:id/history', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const history = await orderManagementStorage.getOrderStatusHistory(orderId);
      res.json({ success: true, history });
    } catch (error) {
      console.error('Error fetching order history:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Send or resend delivery code SMS using template #3
  app.post('/api/order-management/send-delivery-code', requireAuth, async (req, res) => {
    try {
      const { orderManagementId, action } = req.body;
      
      console.log('ğŸ“± [DELIVERY CODE] Manual request:', { orderManagementId, action });
      
      if (!orderManagementId) {
        return res.status(400).json({ success: false, message: 'Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' });
      }

      // Send delivery code using template #3
      const result = await orderManagementStorage.sendManualDeliveryCode(orderManagementId);
      
      if (result.success) {
        console.log('âœ… [DELIVERY CODE] Manual SMS sent successfully');
        res.json({ 
          success: true, 
          deliveryCode: result.deliveryCode,
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯'
        });
      } else {
        console.error('âŒ [DELIVERY CODE] Manual SMS failed:', result.error);
        res.status(500).json({ 
          success: false, 
          message: result.error || 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú© Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' 
        });
      }
    } catch (error) {
      console.error('âŒ [DELIVERY CODE] Manual endpoint error:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø³Ø±ÙˆØ± Ù‡Ù†Ú¯Ø§Ù… Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // =============================================================================
  // WAREHOUSE DEPARTMENT API ROUTES
  // =============================================================================

  // Warehouse orders - Get orders approved by financial department
  app.get('/api/order-management/warehouse', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ“¦ [WAREHOUSE] Fetching warehouse orders...');
      
      // Get orders that are approved by financial department and ready for warehouse processing
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          o.id,
          o.customer_name as "customerName",
          o.customer_email as "customerEmail", 
          o.total_amount as "totalAmount",
          o.status,
          o.created_at as "createdAt",
          o.shipping_address as "shippingAddress",
          o.payment_method as "paymentMethod",
          o.notes,
          o.warehouse_notes as "warehouseNotes",
          o.financial_approved_at as "financialApprovedAt",
          o.fulfilled_at as "fulfilledAt",
          o.fulfilled_by as "fulfilledBy",
          COALESCE(
            json_agg(
              json_build_object(
                'id', oi.id,
                'name', oi.name,
                'quantity', oi.quantity,
                'price', oi.price,
                'sku', oi.sku,
                'barcode', oi.barcode
              )
            ) FILTER (WHERE oi.id IS NOT NULL),
            '[]'::json
          ) as items
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE o.status = 'financial_approved'
        GROUP BY o.id, o.customer_name, o.customer_email, o.total_amount, o.status, 
                 o.created_at, o.shipping_address, o.payment_method, o.notes, 
                 o.warehouse_notes, o.financial_approved_at, o.fulfilled_at, o.fulfilled_by
        ORDER BY o.financial_approved_at DESC
      `);
      
      const orders = result.rows;
      console.log('ğŸ“¦ [WAREHOUSE] Found financial approved orders:', orders.length);
      console.log('ğŸ“¦ [WAREHOUSE] Orders ready for warehouse processing:', JSON.stringify(orders, null, 2));
      res.json({ success: true, orders });
    } catch (error) {
      console.error('âŒ [WAREHOUSE] Error fetching warehouse orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ù†Ø¨Ø§Ø±' });
    }
  });

  // Process warehouse order - support both admin and custom users
  app.patch('/api/order-management/warehouse/:id/process', async (req, res) => {
    
    console.log('âœ… [DEBUG] Authentication successful');
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      // Support both admin and custom users - convert UUID to numeric for database compatibility
      const userId = req.session?.adminId || (req.session?.customUserId ? 2 : 1); // Use 2 for custom users, 1 for fallback
      
      console.log('ğŸ“¦ [WAREHOUSE] Processing order:', { 
        id, 
        status, 
        notes, 
        userId,
        originalCustomUserId: req.session?.customUserId,
        sessionType: req.session?.adminId ? 'admin' : 'custom' 
      });
      
      // Use order management storage to update order status
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        parseInt(id),
        status,
        userId,
        'warehouse',
        notes
      );
      
      if (!updatedOrder) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      console.log('ğŸ“¦ [WAREHOUSE] Order updated successfully:', updatedOrder);
      
      // Auto-generate and send delivery code when order is approved to logistics
      if (status === 'warehouse_approved') {
        try {
          console.log('ğŸšš [AUTO-CODE] Order approved to logistics, auto-generating delivery code...');
          
          // Get order details for customer info
          const orderDetails = await orderManagementStorage.getOrderById(parseInt(id));
          if (orderDetails && orderDetails.customerPhone && orderDetails.customerFirstName) {
            const customerName = `${orderDetails.customerFirstName} ${orderDetails.customerLastName || ''}`.trim();
            
            console.log('ğŸšš [AUTO-CODE] Customer info:', {
              orderId: orderDetails.customerOrderId,
              phone: orderDetails.customerPhone,
              name: customerName
            });
            
            // Generate delivery code using logistics storage
            const { logisticsStorage } = await import('./logistics-storage');
            const codeResult = await logisticsStorage.generateDeliveryCode(
              orderDetails.customerOrderId,
              orderDetails.customerPhone,
              customerName
            );
            
            if (codeResult.success) {
              console.log('âœ… [AUTO-CODE] Delivery code generated and sent automatically:', codeResult.deliveryCode);
            } else {
              console.log('âŒ [AUTO-CODE] Failed to generate delivery code:', codeResult.message);
            }
          } else {
            console.log('âŒ [AUTO-CODE] Missing customer information for auto-code generation');
          }
        } catch (autoCodeError) {
          console.error('âŒ [AUTO-CODE] Error in auto-code generation:', autoCodeError);
          // Don't fail the warehouse approval if code generation fails
        }
      }
      
      res.json({ success: true, data: updatedOrder });
    } catch (error) {
      console.error('âŒ [WAREHOUSE] Error processing warehouse order:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Get order items for warehouse processing - shows what products are in each order
  app.get('/api/order-management/warehouse/:customerOrderId/items', async (req, res) => {
    
    try {
      const { customerOrderId } = req.params;
      
      console.log('ğŸ“¦ [WAREHOUSE-ITEMS] Getting order items for customer order:', customerOrderId);
      
      // Get order items using direct pool query to avoid Drizzle issues
      const result = await customerPool.query(
        `SELECT 
          id, 
          product_id, 
          product_name, 
          product_sku, 
          quantity, 
          unit, 
          unit_price, 
          total_price, 
          specifications, 
          notes,
          created_at
        FROM order_items 
        WHERE order_id = $1 
        ORDER BY id`,
        [parseInt(customerOrderId)]
      );
      
      const orderItemsData = result.rows;
      
      console.log(`ğŸ“¦ [WAREHOUSE-ITEMS] Found ${orderItemsData.length} items for order ${customerOrderId}`);
      
      if (orderItemsData.length > 0) {
        console.log('ğŸ“¦ [WAREHOUSE-ITEMS] First item sample:', JSON.stringify(orderItemsData[0], null, 2));
      }
      
      res.json({ 
        success: true, 
        orderItems: orderItemsData,
        totalItems: orderItemsData.length 
      });
    } catch (error) {
      console.error('âŒ [WAREHOUSE-ITEMS] Error fetching order items:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø§Ù‚Ù„Ø§Ù… Ø³ÙØ§Ø±Ø´' 
      });
    }
  });

  // Get complete order details with customer info and items
  app.get('/api/order-management/warehouse/:customerOrderId/details', async (req, res) => {
    
    try {
      const { customerOrderId } = req.params;
      
      console.log('ğŸ“¦ [ORDER-DETAILS] Getting complete order details for customer order:', customerOrderId);
      
      // Get order details using order management storage
      const orderDetails = await orderManagementStorage.getOrderWithItems(parseInt(customerOrderId));
      
      console.log('âœ… [ORDER-DETAILS] Successfully retrieved order details');
      
      res.json({ 
        success: true, 
        order: orderDetails 
      });
    } catch (error) {
      console.error('âŒ [ORDER-DETAILS] Error fetching order details:', error);
      res.status(500).json({ 
        success: false, 
        message: error.message || 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ø³ÙØ§Ø±Ø´' 
      });
    }
  });

  // =============================================================================
  // LOGISTICS DEPARTMENT API ROUTES
  // =============================================================================

  // Logistics authentication check
  app.get('/api/logistics/auth/me', async (req, res) => {
    try {
      // Check if user is authenticated as admin (temporary solution)
      if (req.session?.adminId || req.session?.isAuthenticated) {
        res.json({ success: true, authenticated: true });
      } else {
        res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù…ÙˆÙÙ‚' });
      }
    } catch (error) {
      res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù…ÙˆÙÙ‚' });
    }
  });



  // Shipping rates management endpoints (removed duplicates)

  // Shipping cost calculation endpoint
  app.post('/api/logistics/calculate-shipping', async (req, res) => {
    try {
      const { deliveryMethod, city, province, orderTotal, weight } = req.body;
      const shippingCost = await orderManagementStorage.calculateShippingCost({
        deliveryMethod,
        city,
        province,
        orderTotal: parseFloat(orderTotal) || 0,
        weight: parseFloat(weight) || 0,
      });
      res.json({ success: true, data: { shippingCost } });
    } catch (error) {
      console.error('Error calculating shipping cost:', error);
      res.status(500).json({ 
        success: false, 
        message: error.message || 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„' 
      });
    }
  });

  // Get available shipping methods for location/order
  app.post('/api/logistics/available-methods', async (req, res) => {
    try {
      const { city, province, orderTotal } = req.body;
      const availableMethods = await orderManagementStorage.getAvailableShippingMethods({
        city,
        province,
        orderTotal: parseFloat(orderTotal) || 0,
      });
      res.json({ success: true, data: availableMethods });
    } catch (error) {
      console.error('Error fetching available shipping methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ù…ÙˆØ¬ÙˆØ¯' });
    }
  });

  // Update order delivery information (enhanced logistics details)
  app.post('/api/logistics/orders/:orderId/delivery-info', async (req, res) => {
    try {
      const { orderId } = req.params;
      const updatedOrder = await orderManagementStorage.updateDeliveryInfo(
        parseInt(orderId),
        req.body
      );
      res.json({ success: true, data: updatedOrder });
    } catch (error) {
      console.error('Error updating delivery info:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Update delivery information for an order
  app.put('/api/logistics/orders/:id/delivery-info', async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const deliveryInfo = req.body;
      
      const updatedOrder = await orderManagementStorage.updateDeliveryInfo(orderId, deliveryInfo);
      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error updating delivery info:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Complete delivery for an order
  app.post('/api/logistics/orders/:id/complete', async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const adminId = req.session?.adminId || 1; // Default for logistics operations
      
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderId,
        'logistics_delivered',
        adminId,
        'logistics',
        'Order delivered successfully'
      );
      
      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error completing delivery:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÚ©Ù…ÛŒÙ„ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // =============================================================================
  // DELIVERY METHODS MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all delivery methods for logistics department
  app.get('/api/logistics/delivery-methods', requireAuth, async (req, res) => {
    try {
      const { db } = await import('./db');
      const result = await db.select().from(deliveryMethods).orderBy(deliveryMethods.sortOrder);
      res.json(result);
    } catch (error) {
      console.error('Error fetching delivery methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Create new delivery method (logistics)
  app.post('/api/logistics/delivery-methods', requireAuth, async (req, res) => {
    try {
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const result = await db.insert(deliveryMethods).values({
        value,
        label,
        icon: icon || 'package',
        color: color || 'blue',
        baseCost: baseCost ? parseFloat(baseCost) : 0,
        costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
        minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
        freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
        estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
        maxDistance: maxDistance ? parseInt(maxDistance) : null,
        availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
        description: description || null,
        isActive: isActive !== undefined ? isActive : true,
        sortOrder: sortOrder || 0
      }).returning();

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error creating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Update delivery method (logistics)
  app.put('/api/logistics/delivery-methods/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.update(deliveryMethods)
        .set({
          value,
          label,
          icon: icon || 'package',
          color: color || 'blue',
          baseCost: baseCost ? parseFloat(baseCost) : 0,
          costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
          minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
          freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
          estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
          maxDistance: maxDistance ? parseInt(maxDistance) : null,
          availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
          description: description || null,
          isActive: isActive !== undefined ? isActive : true,
          sortOrder: sortOrder || 0,
          updatedAt: new Date()
        })
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error updating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Delete delivery method (logistics)
  app.delete('/api/logistics/delivery-methods/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.delete(deliveryMethods)
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting delivery method:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Get all delivery methods (public endpoint)
  app.get('/api/delivery-methods', async (req, res) => {
    try {
      const { db } = await import('./db');
      const result = await db.select().from(deliveryMethods).orderBy(deliveryMethods.sortOrder);
      res.json(result);
    } catch (error) {
      console.error('Error fetching delivery methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Get active delivery methods for customer checkout
  app.get('/api/checkout/delivery-methods', async (req, res) => {
    try {
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.select().from(deliveryMethods)
        .where(eq(deliveryMethods.isActive, true))
        .orderBy(deliveryMethods.sortOrder);
      
      res.json(result);
    } catch (error) {
      console.error('Error fetching active delivery methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Create new delivery method
  app.post('/api/delivery-methods', async (req, res) => {
    try {
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const result = await db.insert(deliveryMethods).values({
        value,
        label,
        icon: icon || 'package',
        color: color || 'blue',
        baseCost: baseCost ? parseFloat(baseCost) : 0,
        costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
        minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
        freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
        estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
        maxDistance: maxDistance ? parseInt(maxDistance) : null,
        availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
        description: description || null,
        isActive: isActive !== undefined ? isActive : true,
        sortOrder: sortOrder || 0
      }).returning();

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error creating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Update delivery method
  app.put('/api/delivery-methods/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.update(deliveryMethods)
        .set({
          value,
          label,
          icon: icon || 'package',
          color: color || 'blue',
          baseCost: baseCost ? parseFloat(baseCost) : 0,
          costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
          minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
          freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
          estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
          maxDistance: maxDistance ? parseInt(maxDistance) : null,
          availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
          description: description || null,
          isActive: isActive !== undefined ? isActive : true,
          sortOrder: sortOrder || 0,
          updatedAt: new Date()
        })
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error updating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Delete delivery method
  app.delete('/api/delivery-methods/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.delete(deliveryMethods)
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting delivery method:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // =============================================================================
  // SHIPPING RATES MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all shipping rates
  app.get('/api/logistics/shipping-rates', async (req, res) => {
    try {
      const { db } = await import('./db');
      const result = await db.select().from(shippingRates).orderBy(shippingRates.deliveryMethod);
      res.json(result);
    } catch (error) {
      console.error('Error fetching shipping rates:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Create new shipping rate
  app.post('/api/logistics/shipping-rates', async (req, res) => {
    try {
      const {
        deliveryMethod, cityName, provinceName, minWeight, maxWeight, maxDimensions,
        basePrice, pricePerKg, freeShippingThreshold, estimatedDays, 
        trackingAvailable, insuranceAvailable, insuranceRate, isActive,
        smsVerificationEnabled, description, internalNotes
      } = req.body;
      
      if (!deliveryMethod || !basePrice || !minWeight) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ØŒ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÙ‡ Ùˆ Ø­Ø¯Ø§Ù‚Ù„ ÙˆØ²Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const result = await db.insert(shippingRates).values({
        deliveryMethod,
        cityName: cityName || null,
        provinceName: provinceName || null,
        minWeight,
        maxWeight: maxWeight || null,
        maxDimensions: maxDimensions || null,
        basePrice,
        pricePerKg: pricePerKg || '0',
        freeShippingThreshold: freeShippingThreshold || null,
        estimatedDays: estimatedDays || null,
        trackingAvailable: trackingAvailable || false,
        insuranceAvailable: insuranceAvailable || false,
        insuranceRate: insuranceRate || '0',
        isActive: isActive !== undefined ? isActive : true,
        smsVerificationEnabled: smsVerificationEnabled || false,
        description: description || null,
        internalNotes: internalNotes || null
      }).returning();

      res.json({ success: true, data: result[0] });
    } catch (error) {
      console.error('Error creating shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Update shipping rate
  app.put('/api/logistics/shipping-rates/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const {
        deliveryMethod, cityName, provinceName, minWeight, maxWeight, maxDimensions,
        basePrice, pricePerKg, freeShippingThreshold, estimatedDays, 
        trackingAvailable, insuranceAvailable, insuranceRate, isActive,
        smsVerificationEnabled, description, internalNotes
      } = req.body;
      
      if (!deliveryMethod || !basePrice || !minWeight) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ØŒ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÙ‡ Ùˆ Ø­Ø¯Ø§Ù‚Ù„ ÙˆØ²Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.update(shippingRates)
        .set({
          deliveryMethod,
          cityName: cityName || null,
          provinceName: provinceName || null,
          minWeight,
          maxWeight: maxWeight || null,
          maxDimensions: maxDimensions || null,
          basePrice,
          pricePerKg: pricePerKg || '0',
          freeShippingThreshold: freeShippingThreshold || null,
          estimatedDays: estimatedDays || null,
          trackingAvailable: trackingAvailable || false,
          insuranceAvailable: insuranceAvailable || false,
          insuranceRate: insuranceRate || '0',
          isActive: isActive !== undefined ? isActive : true,
          smsVerificationEnabled: smsVerificationEnabled || false,
          description: description || null,
          internalNotes: internalNotes || null,
          updatedAt: new Date()
        })
        .where(eq(shippingRates.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: result[0] });
    } catch (error) {
      console.error('Error updating shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Delete shipping rate
  app.delete('/api/logistics/shipping-rates/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.delete(shippingRates)
        .where(eq(shippingRates.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Second set of duplicate shipping rate endpoints removed

  // Get available shipping methods for checkout
  app.get('/api/shipping/methods', async (req, res) => {
    try {
      const { city, province, orderTotal } = req.query;
      const methods = await orderManagementStorage.getAvailableShippingMethods({
        city: city as string,
        province: province as string,
        orderTotal: orderTotal ? parseFloat(orderTotal as string) : 0
      });
      res.json({ success: true, methods });
    } catch (error) {
      console.error('Error fetching shipping methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Calculate shipping cost
  app.post('/api/shipping/calculate', async (req, res) => {
    try {
      const { deliveryMethod, city, province, orderTotal, weight } = req.body;
      const cost = await orderManagementStorage.calculateShippingCost({
        deliveryMethod,
        city,
        province,
        orderTotal: parseFloat(orderTotal),
        weight: weight ? parseFloat(weight) : 1
      });
      res.json({ success: true, cost });
    } catch (error) {
      console.error('Error calculating shipping cost:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Upload payment receipt (customer action)
  app.post('/api/order-management/:customerOrderId/payment-receipt', upload.single('receipt'), async (req, res) => {
    try {
      const customerOrderId = parseInt(req.params.customerOrderId);
      const customerId = req.session.customerId;

      if (!customerId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡' });
      }

      if (!req.file) {
        return res.status(400).json({ success: false, message: 'ÙØ§ÛŒÙ„ Ø±Ø³ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' });
      }

      // Save payment receipt
      const receipt = await orderManagementStorage.uploadPaymentReceipt({
        customerOrderId,
        customerId,
        receiptUrl: `/uploads/documents/${req.file.filename}`,
        originalFileName: req.file.originalname,
        fileSize: req.file.size,
        mimeType: req.file.mimetype,
        notes: req.body.notes || ''
      });

      // Update order status to PAYMENT_UPLOADED
      const orderMgmt = await orderManagementStorage.getOrderManagementByCustomerOrderId(customerOrderId);
      if (orderMgmt) {
        await orderManagementStorage.updateOrderStatus(
          orderMgmt.id,
          'payment_uploaded' as any,
          customerId,
          'financial' as any,
          'Ø±Ø³ÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª ØªÙˆØ³Ø· Ù…Ø´ØªØ±ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯'
        );
      }

      res.json({ success: true, receipt });
    } catch (error) {
      console.error('Error uploading payment receipt:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ Ø±Ø³ÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª' });
    }
  });

  // Verify delivery code (logistics department)
  app.post('/api/order-management/verify-delivery', requireAuth, async (req, res) => {
    try {
      const { code, verifiedBy } = req.body;
      const verified = await orderManagementStorage.verifyDeliveryCode(code, verifiedBy);
      
      if (verified) {
        res.json({ success: true, message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯' });
      } else {
        res.status(400).json({ success: false, message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡' });
      }
    } catch (error) {
      console.error('Error verifying delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // =============================================
  // SMART DELIVERY COST CALCULATION API
  // =============================================

  // Helper function to standardize city/province names to Arabic format
  const standardizeCityName = (cityName: string): string => {
    const cityMappings: { [key: string]: string } = {
      'Erbil': 'Ø§Ø±Ø¨ÛŒÙ„',
      'Baghdad': 'Ø¨ØºØ¯Ø§Ø¯',
      'Karbala': 'Ú©Ø±Ø¨Ù„Ø§',
      'Basra': 'Ø¨ØµØ±Ù‡',
      'Mosul': 'Ù…ÙˆØµÙ„',
      'Najaf': 'Ù†Ø¬Ù',
      'Sulaymaniyah': 'Ø³Ù„ÛŒÙ…Ø§Ù†ÛŒÙ‡',
      'Dohuk': 'Ø¯Ù‡ÙˆÚ©',
      'Kirkuk': 'Ú©Ø±Ú©ÙˆÚ©',
      'Hillah': 'Ø­Ù„Ù‡',
      'Nasiriyah': 'Ù†Ø§ØµØ±ÛŒÙ‡',
      'Amarah': 'Ø¹Ù…Ø§Ø±Ù‡',
      'Ramadi': 'Ø±Ù…Ø§Ø¯ÛŒ',
      'Fallujah': 'ÙÙ„ÙˆØ¬Ù‡',
      'Tikrit': 'ØªÚ©Ø±ÛŒØª',
      'Baqubah': 'Ø¨Ø¹Ù‚ÙˆØ¨Ù‡',
      'Samarra': 'Ø³Ø§Ù…Ø±Ø§Ø¡'
    };
    
    return cityMappings[cityName] || cityName;
  };

  const standardizeProvinceName = (provinceName: string): string => {
    const provinceMappings: { [key: string]: string } = {
      'Erbil': 'Ø§Ø±Ø¨ÛŒÙ„',
      'Baghdad': 'Ø¨ØºØ¯Ø§Ø¯',
      'Karbala': 'Ú©Ø±Ø¨Ù„Ø§',
      'Basra': 'Ø¨ØµØ±Ù‡',
      'Ninawa': 'Ù†ÛŒÙ†ÙˆØ§',
      'Najaf': 'Ù†Ø¬Ù',
      'Sulaymaniyah': 'Ø³Ù„ÛŒÙ…Ø§Ù†ÛŒÙ‡',
      'Dohuk': 'Ø¯Ù‡ÙˆÚ©',
      'Kirkuk': 'Ú©Ø±Ú©ÙˆÚ©',
      'Babylon': 'Ø¨Ø§Ø¨Ù„',
      'Dhi Qar': 'Ø°ÛŒÙ‚Ø§Ø±',
      'Maysan': 'Ù…ÛŒØ³Ø§Ù†',
      'Anbar': 'Ø§Ù†Ø¨Ø§Ø±',
      'Diyala': 'Ø¯ÛŒØ§Ù„ÛŒ',
      'Salah ad-Din': 'ØµÙ„Ø§Ø­â€ŒØ§Ù„Ø¯ÛŒÙ†',
      'Al-Qadisiyyah': 'Ù‚Ø§Ø¯Ø³ÛŒÙ‡',
      'Al-Muthanna': 'Ù…Ø«Ù†ÛŒ',
      'Wasit': 'ÙˆØ§Ø³Ø·'
    };
    
    return provinceMappings[provinceName] || provinceName;
  };

  // Calculate optimal delivery cost based on weight and destination
  app.post("/api/calculate-delivery-cost", async (req, res) => {
    try {
      console.log('ğŸšš [DELIVERY COST] Request received:', req.body);
      
      const { 
        weight, 
        destinationCity: rawDestinationCity, 
        destinationProvince: rawDestinationProvince, 
        cart, 
        useSecondaryAddress, 
        secondaryAddress, 
        originCity: rawOriginCity = 'Ø§Ø±Ø¨ÛŒÙ„' 
      } = req.body;

      // Standardize city and province names to Arabic format
      const destinationCity = standardizeCityName(rawDestinationCity);
      const destinationProvince = standardizeProvinceName(rawDestinationProvince);
      const originCity = standardizeCityName(rawOriginCity);

      console.log('ğŸ”¤ [STANDARDIZATION] Name standardization:', {
        raw: { originCity: rawOriginCity, destinationCity: rawDestinationCity, destinationProvince: rawDestinationProvince },
        standardized: { originCity, destinationCity, destinationProvince }
      });
      
      if (!weight || !destinationCity) {
        return res.status(400).json({
          success: false,
          message: "ÙˆØ²Ù† Ù…Ø­Ù…ÙˆÙ„Ù‡ Ùˆ Ø´Ù‡Ø± Ù…Ù‚ØµØ¯ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª"
        });
      }

      // Get vehicle templates  
      const { vehicleTemplates: vehicleTemplatesTable, iraqiCities } = await import('@shared/logistics-schema');
      
      const vehicleTemplates = await db.select().from(vehicleTemplatesTable).where(eq(vehicleTemplatesTable.isActive, true));
      
      if (!vehicleTemplates.length) {
        return res.status(500).json({
          success: false,
          message: "Ù‡ÛŒÚ† Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª"
        });
      }

      // Get origin and destination city data for distance calculation and bus line check
      console.log('ğŸ” [DEBUG] Starting city queries for:', { originCity, destinationCity });
      
      let originCityData, destinationCityData;
      try {
        console.log('ğŸ” [DEBUG] Schema available:', { hasIraqiCities: !!iraqiCities, hasDb: !!db, hasEq: !!eq });
        
        originCityData = await db.select().from(iraqiCities).where(eq(iraqiCities.nameArabic, originCity)).limit(1);
        destinationCityData = await db.select().from(iraqiCities).where(eq(iraqiCities.nameArabic, destinationCity)).limit(1);
        
        console.log('ğŸ” [QUERY DEBUG]', {
          originQuery: originCity,
          destinationQuery: destinationCity,
          originResult: originCityData.length,
          destinationResult: destinationCityData.length
        });
      } catch (error) {
        console.error('âŒ [CITY QUERY ERROR]', error);
        return res.status(500).json({
          success: false,
          message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ù‡Ø±Ù‡Ø§"
        });
      }

      if (!destinationCityData || destinationCityData.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù‡Ø± Ù…Ù‚ØµØ¯ Ø¯Ø± Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      if (!originCityData || originCityData.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù‡Ø± Ù…Ø¨Ø¯Ø§ Ø¯Ø± Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const originCity_data = originCityData[0];
      const destinationCity_data = destinationCityData[0];
      
      const distance = parseFloat(destinationCity_data.distanceFromErbilKm || '0');
      const weightKg = parseFloat(weight);

      // Check if cart contains flammable products FIRST (before checking bus lines)
      let containsFlammableProducts = false;
      if (cart && typeof cart === 'object') {
        // Get product IDs from cart (cart is in format { productId: quantity })
        const productIds = Object.keys(cart).map(id => parseInt(id));
        
        if (productIds.length > 0) {
          console.log('ğŸ” [FLAMMABLE] Checking products:', productIds);
          
          // Query BOTH product tables to check if any products are flammable
          const { showcaseProducts } = await import('@shared/showcase-schema');
          const { shopProducts } = await import('@shared/shop-schema');
          
          // Check showcase_products first
          const showcaseOrConditions = productIds.map(id => eq(showcaseProducts.id, id));
          const showcaseProductsFound = await db.select().from(showcaseProducts).where(
            showcaseOrConditions.length === 1 ? showcaseOrConditions[0] : or(...showcaseOrConditions)
          );
          
          // Check shop_products as well
          const shopOrConditions = productIds.map(id => eq(shopProducts.id, id));
          const shopProductsFound = await db.select().from(shopProducts).where(
            shopOrConditions.length === 1 ? shopOrConditions[0] : or(...shopOrConditions)
          );
          
          // Combine results from both tables
          const allProducts = [
            ...showcaseProductsFound.map(p => ({ id: p.id, name: p.name, isFlammable: p.isFlammable, source: 'showcase' })),
            ...shopProductsFound.map(p => ({ id: p.id, name: p.name, isFlammable: p.isFlammable, source: 'shop' }))
          ];
          
          console.log('ğŸ” [FLAMMABLE] Products found in both tables:', allProducts);
          
          // Check if any product is flammable
          for (const product of allProducts) {
            if (product.isFlammable === true) {
              containsFlammableProducts = true;
              console.log(`ğŸ”¥ [FLAMMABLE] Found flammable product: ${product.name} (ID: ${product.id}) from ${product.source}_products table`);
              break;
            }
          }
        }
      }

      console.log('ğŸ”¥ [FLAMMABLE CHECK]', {
        containsFlammableProducts: containsFlammableProducts,
        cartItems: Object.keys(cart || {}).length
      });

      console.log('ğŸš› [VEHICLE SELECTION] Using vehicle templates from database exclusively - including bus templates from admin panel');

      // === ENHANCED VEHICLE SELECTION USING VEHICLE TEMPLATES TABLE ===
      console.log('ğŸš› [VEHICLE TEMPLATES] Starting enhanced vehicle selection from database');
      console.log('ğŸ” [TEMPLATES] Available templates:', vehicleTemplates.map(vt => ({ 
        id: vt.id, 
        name: vt.name, 
        type: vt.vehicleType, 
        maxWeight: vt.maxWeightKg,
        supportsFlammable: vt.supportsFlammable 
      })));

      // SAFETY CHECK: Filter vehicles based on flammable materials
      console.log('ğŸ”¥ [SAFETY FILTER] Applying flammable materials filtering');
      const safeVehicles = vehicleTemplates.filter(template => {
        if (containsFlammableProducts) {
          // Only vehicles that support flammable materials
          const isAuthorized = template.supportsFlammable === true;
          console.log(`ğŸš› [VEHICLE] ${template.name}: ${isAuthorized ? 'âœ… AUTHORIZED' : 'âŒ EXCLUDED'} for flammable transport`);
          return isAuthorized;
        }
        // All vehicles allowed for non-flammable products
        console.log(`ğŸš› [VEHICLE] ${template.name}: âœ… AUTHORIZED for non-flammable transport`);
        return true;
      });

      console.log('ğŸ¯ [SAFETY RESULT] Authorized vehicles count:', safeVehicles.length);

      if (safeVehicles.length === 0) {
        console.log('âŒ [NO VEHICLES] No authorized vehicles found for this transport request');
        return res.status(400).json({
          success: false,
          message: containsFlammableProducts 
            ? "Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø­Ù…Ù„ Ù…ÙˆØ§Ø¯ Ø¢ØªØ´â€ŒØ²Ø§ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª" 
            : "Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª"
        });
      }

      // Calculate route type based on distance
      let routeType = 'urban';
      if (distance > 100) routeType = 'highway';
      else if (distance > 30) routeType = 'interurban';

      // Function to calculate single vehicle option
      const calculateVehicleOption = (template: any, weight: number) => {
        const maxWeight = parseFloat(template.maxWeightKg);
        const basePrice = parseFloat(template.basePrice);
        const pricePerKm = parseFloat(template.pricePerKm);
        const pricePerKg = parseFloat(template.pricePerKg || '0');

        // Check if vehicle supports this route type
        if (!template.allowedRoutes.includes(routeType)) {
          return null; // Vehicle doesn't support this route type
        }

        // Check flammable products compatibility
        if (containsFlammableProducts && !template.supportsFlammable) {
          console.log(`ğŸ”¥ [FLAMMABLE CHECK] Vehicle ${template.name} cannot transport flammable materials`);
          return null; // Vehicle cannot transport flammable materials
        }

        // Calculate total cost
        const distanceCost = distance * pricePerKm;
        const weightCost = weight * pricePerKg;
        const totalCost = basePrice + distanceCost + weightCost;

        return {
          vehicleId: template.id,
          vehicleName: template.name,
          vehicleNameEn: template.nameEn,
          vehicleType: template.vehicleType,
          maxWeight: maxWeight,
          routeType: routeType,
          basePrice: basePrice,
          distanceCost: distanceCost,
          weightCost: weightCost,
          totalCost: totalCost,
          estimatedTime: Math.round(distance / parseFloat(template.averageSpeedKmh || '50') * 60), // minutes
          fuelConsumption: parseFloat(template.fuelConsumptionL100km || '0'),
          priority: template.priority || 0,
          weight: weight
        };
      };

      // Multi-vehicle algorithm: Calculate best combination for heavy loads
      const calculateMultiVehicleSolution = () => {
        console.log('ğŸš› [MULTI-VEHICLE] Starting calculation for weight:', weightKg, 'kg');
        const solutions = [];

        // Try single vehicle solutions first - Use ONLY safe vehicles
        for (const template of safeVehicles) {
          const maxWeight = parseFloat(template.maxWeightKg);
          
          // If single vehicle can handle the weight
          if (weightKg <= maxWeight) {
            const option = calculateVehicleOption(template, weightKg);
            if (option) {
              solutions.push({
                vehicles: [option],
                totalCost: option.totalCost,
                totalVehicles: 1,
                description: `${option.vehicleName} - ÛŒÚ© Ø®ÙˆØ¯Ø±Ùˆ`
              });
            }
          }
        }

        // If no single vehicle can handle the weight, try multiple vehicles
        if (solutions.length === 0 || weightKg > Math.max(...safeVehicles.map(t => parseFloat(t.maxWeightKg)))) {
          console.log('ğŸš› [MULTI-VEHICLE] Heavy load detected, calculating multi-vehicle solutions');

          // Sort templates by efficiency (cost per kg capacity) - Use ONLY safe vehicles
          const sortedTemplates = [...safeVehicles]
            .filter(t => t.allowedRoutes.includes(routeType))
            .sort((a, b) => {
              const efficiencyA = parseFloat(a.basePrice) / parseFloat(a.maxWeightKg);
              const efficiencyB = parseFloat(b.basePrice) / parseFloat(b.maxWeightKg);
              return efficiencyA - efficiencyB;
            });

          // Try combinations of vehicles
          for (let i = 0; i < sortedTemplates.length; i++) {
            const template = sortedTemplates[i];
            const maxWeight = parseFloat(template.maxWeightKg);
            
            // Calculate how many vehicles needed
            const vehiclesNeeded = Math.ceil(weightKg / maxWeight);
            if (vehiclesNeeded > 5) continue; // Limit to 5 vehicles max

            const vehicles = [];
            let remainingWeight = weightKg;
            let totalCost = 0;

            for (let j = 0; j < vehiclesNeeded; j++) {
              const vehicleWeight = Math.min(remainingWeight, maxWeight);
              const vehicleOption = calculateVehicleOption(template, vehicleWeight);
              
              if (vehicleOption) {
                vehicles.push({
                  ...vehicleOption,
                  vehicleNumber: j + 1,
                  weight: vehicleWeight
                });
                totalCost += vehicleOption.totalCost;
                remainingWeight -= vehicleWeight;
              }
            }

            if (remainingWeight <= 0) {
              solutions.push({
                vehicles: vehicles,
                totalCost: totalCost,
                totalVehicles: vehiclesNeeded,
                description: `${vehiclesNeeded} Ã— ${template.name} - Ú†Ù†Ø¯ÛŒÙ† Ø®ÙˆØ¯Ø±Ùˆ`
              });
            }
          }

          // Try mixed vehicle combinations (largest + smaller vehicles)
          const largestTemplate = sortedTemplates[sortedTemplates.length - 1];
          if (largestTemplate) {
            const largestMaxWeight = parseFloat(largestTemplate.maxWeightKg);
            let remainingWeight = weightKg;
            const mixedVehicles = [];
            let mixedTotalCost = 0;

            // Use largest vehicle(s) first
            while (remainingWeight > largestMaxWeight) {
              const vehicleOption = calculateVehicleOption(largestTemplate, largestMaxWeight);
              if (vehicleOption) {
                mixedVehicles.push({
                  ...vehicleOption,
                  vehicleNumber: mixedVehicles.length + 1,
                  weight: largestMaxWeight
                });
                mixedTotalCost += vehicleOption.totalCost;
                remainingWeight -= largestMaxWeight;
              } else {
                break;
              }
            }

            // Find best vehicle for remaining weight
            if (remainingWeight > 0) {
              for (const template of sortedTemplates) {
                const maxWeight = parseFloat(template.maxWeightKg);
                if (remainingWeight <= maxWeight) {
                  const vehicleOption = calculateVehicleOption(template, remainingWeight);
                  if (vehicleOption) {
                    mixedVehicles.push({
                      ...vehicleOption,
                      vehicleNumber: mixedVehicles.length + 1,
                      weight: remainingWeight
                    });
                    mixedTotalCost += vehicleOption.totalCost;
                    remainingWeight = 0;
                    break;
                  }
                }
              }
            }

            if (remainingWeight <= 0 && mixedVehicles.length > 0) {
              solutions.push({
                vehicles: mixedVehicles,
                totalCost: mixedTotalCost,
                totalVehicles: mixedVehicles.length,
                description: `Ø±Ø§Ù‡â€ŒØ­Ù„ ØªØ±Ú©ÛŒØ¨ÛŒ - ${mixedVehicles.length} Ø®ÙˆØ¯Ø±Ùˆ`
              });
            }
          }
        }

        return solutions;
      };

      const allSolutions = calculateMultiVehicleSolution();

      if (!allSolutions.length) {
        let errorMessage = "Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† ÙˆØ²Ù† Ùˆ Ù…Ù‚ØµØ¯ Ù…Ù†Ø§Ø³Ø¨ Ù†ÛŒØ³Øª";
        
        if (containsFlammableProducts) {
          errorMessage = "âš ï¸ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø´Ø§Ù…Ù„ Ù…ÙˆØ§Ø¯ Ø¢ØªØ´â€ŒØ²Ø§ Ø§Ø³Øª. Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒÛŒ Ø¨Ø§ Ù…Ø¬ÙˆØ² Ø­Ù…Ù„ Ù…ÙˆØ§Ø¯ Ø¢ØªØ´â€ŒØ²Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ© ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯.";
        }
        
        return res.status(400).json({
          success: false,
          message: errorMessage,
          containsFlammableProducts: containsFlammableProducts
        });
      }

      // Sort solutions by cost efficiency
      allSolutions.sort((a, b) => {
        // Prefer single vehicle solutions when possible
        if (a.totalVehicles === 1 && b.totalVehicles > 1) return -1;
        if (b.totalVehicles === 1 && a.totalVehicles > 1) return 1;
        
        // Then by total cost
        return a.totalCost - b.totalCost;
      });

      const optimalSolution = allSolutions[0];
      
      // Format response for single or multiple vehicles
      let optimalVehicle;
      if (optimalSolution.totalVehicles === 1) {
        optimalVehicle = optimalSolution.vehicles[0];
      } else {
        // For multiple vehicles, create a summary
        optimalVehicle = {
          vehicleId: 'multi',
          vehicleName: optimalSolution.description,
          vehicleNameEn: `Multi-vehicle solution (${optimalSolution.totalVehicles} vehicles)`,
          vehicleType: 'multiple',
          totalCost: optimalSolution.totalCost,
          totalVehicles: optimalSolution.totalVehicles,
          vehicles: optimalSolution.vehicles,
          routeType: routeType,
          estimatedTime: Math.max(...optimalSolution.vehicles.map(v => v.estimatedTime)),
          weightUtilization: (weightKg / optimalSolution.vehicles.reduce((sum, v) => sum + v.maxWeight, 0)) * 100,
          score: optimalSolution.totalCost / weightKg // Cost per kg
        };
      }

      const alternatives = allSolutions.slice(1, 4).map(solution => {
        if (solution.totalVehicles === 1) {
          return {
            ...solution.vehicles[0],
            weightUtilization: (weightKg / solution.vehicles[0].maxWeight) * 100,
            score: solution.totalCost / weightKg
          };
        } else {
          return {
            vehicleId: 'multi',
            vehicleName: solution.description,
            vehicleNameEn: `Multi-vehicle solution (${solution.totalVehicles} vehicles)`,
            vehicleType: 'multiple',
            totalCost: solution.totalCost,
            totalVehicles: solution.totalVehicles,
            vehicles: solution.vehicles,
            routeType: routeType,
            estimatedTime: Math.max(...solution.vehicles.map(v => v.estimatedTime)),
            weightUtilization: (weightKg / solution.vehicles.reduce((sum, v) => sum + v.maxWeight, 0)) * 100,
            score: solution.totalCost / weightKg
          };
        }
      });

      console.log('âœ… [DELIVERY COST] Calculation completed:', {
        optimal: optimalVehicle.vehicleName,
        cost: optimalVehicle.totalCost,
        alternativeCount: alternatives.length
      });

      // Track abandoned cart if customer information is available
      if (req.isAuthenticated && req.isAuthenticated()) {
        try {
          const customerInfo = req.user || req.customer;
          if (customerInfo && cart && Object.keys(cart).length > 0) {
            await db.insert(abandonedOrders).values({
              customerId: customerInfo.id,
              customerEmail: customerInfo.email,
              customerName: `${customerInfo.firstName || ''} ${customerInfo.lastName || ''}`.trim(),
              customerPhone: customerInfo.phone,
              cartData: cart,
              shippingData: { 
                destinationCity, 
                destinationProvince, 
                weight: weightKg,
                useSecondaryAddress,
                secondaryAddress 
              },
              totalAmount: optimalVehicle.totalCost.toString(),
              currency: 'IQD',
              checkoutStep: 'shipping',
              sessionId: req.sessionID,
              ipAddress: req.ip,
              userAgent: req.get('User-Agent')
            }).onConflictDoNothing();
            
            console.log('ğŸ“‹ [ABANDONED] Tracked potential abandoned order for customer:', customerInfo.id);
          }
        } catch (error) {
          console.error('âŒ [ABANDONED] Error tracking abandoned order:', error);
        }
      }

      res.json({
        success: true,
        data: {
          optimalVehicle,
          alternatives,
          calculationDetails: {
            weight: weightKg,
            destination: destinationCity,
            distance: distance,
            routeType: optimalVehicle.routeType
          }
        }
      });

    } catch (error) {
      console.error('âŒ [DELIVERY COST] Calculation error:', error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø§Ø±Ø³Ø§Ù„"
      });
    }
  });

  // =============================================================================
  // ABANDONED ORDERS TRACKING SYSTEM
  // =============================================================================

  // Track hybrid payment abandonment
  app.post('/api/abandoned-orders/hybrid-payment', async (req, res) => {
    try {
      const { orderNumber, walletAmount, bankAmount, customerInfo, cartData } = req.body;

      await db.insert(abandonedOrders).values({
        customerId: customerInfo.id,
        customerEmail: customerInfo.email,
        customerName: `${customerInfo.firstName || ''} ${customerInfo.lastName || ''}`.trim(),
        customerPhone: customerInfo.phone,
        cartData: cartData,
        totalAmount: (parseFloat(walletAmount) + parseFloat(bankAmount)).toString(),
        currency: 'IQD',
        checkoutStep: 'hybrid_payment_pending',
        walletAmountUsed: walletAmount.toString(),
        bankAmountPending: bankAmount.toString(),
        hybridOrderNumber: orderNumber,
        sessionId: req.sessionID,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent')
      });

      console.log('ğŸ“‹ [HYBRID ABANDONED] Tracked hybrid payment abandonment:', orderNumber);
      
      res.json({ success: true, message: 'Hybrid payment abandonment tracked' });
    } catch (error) {
      console.error('âŒ [HYBRID ABANDONED] Error tracking hybrid abandonment:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ Ø±Ù‡Ø§ Ø´Ø¯Ù‡' });
    }
  });

  // Get abandoned orders for admin panel
  app.get('/api/abandoned-orders', requireAuth, async (req, res) => {
    try {
      const abandonedOrdersList = await db
        .select()
        .from(abandonedOrders)
        .orderBy(desc(abandonedOrders.createdAt))
        .limit(100);

      res.json({ 
        success: true, 
        data: abandonedOrdersList.map(order => ({
          ...order,
          isHybridPayment: order.checkoutStep === 'hybrid_payment_pending',
          totalValue: parseFloat(order.totalAmount || '0'),
          walletUsed: parseFloat(order.walletAmountUsed || '0'),
          bankPending: parseFloat(order.bankAmountPending || '0')
        }))
      });
    } catch (error) {
      console.error('âŒ [ABANDONED] Error fetching abandoned orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø±Ù‡Ø§ Ø´Ø¯Ù‡' });
    }
  });

  // Mark abandoned order as recovered
  app.post('/api/abandoned-orders/:id/recover', requireAuth, async (req, res) => {
    try {
      const { orderId } = req.body;
      const abandonedId = parseInt(req.params.id);

      await db
        .update(abandonedOrders)
        .set({ 
          isRecovered: true, 
          recoveredOrderId: orderId,
          lastUpdated: new Date()
        })
        .where(eq(abandonedOrders.id, abandonedId));

      console.log('âœ… [RECOVERED] Marked abandoned order as recovered:', abandonedId);
      
      res.json({ success: true, message: 'Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø¨Ø§Ø²ÛŒØ§ÙØª Ø´Ø¯Ù‡ Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ø¯' });
    } catch (error) {
      console.error('âŒ [RECOVERED] Error marking as recovered:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø³ÙØ§Ø±Ø´' });
    }
  });

  // =============================================================================
  // ABANDONED ORDERS AUTOMATED REMINDER SYSTEM
  // =============================================================================

  // Send automated reminders for abandoned orders
  const sendAbandonedOrderReminders = async () => {
    try {
      console.log('ğŸ“§ [ABANDONED REMINDERS] Starting automated reminder process...');
      
      const now = new Date();
      const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000); // 1 hour ago
      const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000); // 24 hours ago
      const threeDaysAgo = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago

      // First reminder: 1 hour after abandonment
      const firstReminderOrders = await db
        .select()
        .from(abandonedOrders)
        .where(
          and(
            gte(abandonedOrders.createdAt, oneHourAgo),
            eq(abandonedOrders.remindersSent, 0),
            eq(abandonedOrders.isRecovered, false)
          )
        );

      // Second reminder: 24 hours after abandonment
      const secondReminderOrders = await db
        .select()
        .from(abandonedOrders)
        .where(
          and(
            gte(abandonedOrders.createdAt, oneDayAgo),
            eq(abandonedOrders.remindersSent, 1),
            eq(abandonedOrders.isRecovered, false)
          )
        );

      // Final reminder: 3 days after abandonment
      const finalReminderOrders = await db
        .select()
        .from(abandonedOrders)
        .where(
          and(
            gte(abandonedOrders.createdAt, threeDaysAgo),
            eq(abandonedOrders.remindersSent, 2),
            eq(abandonedOrders.isRecovered, false)
          )
        );

      // Process first reminders
      for (const order of firstReminderOrders) {
        try {
          await sendAbandonedOrderReminder(order, 'first');
          await db
            .update(abandonedOrders)
            .set({ 
              remindersSent: 1, 
              lastReminderAt: now,
              lastUpdated: now
            })
            .where(eq(abandonedOrders.id, order.id));
          
          console.log(`âœ… [FIRST REMINDER] Sent to customer ${order.customerEmail} for order ${order.hybridOrderNumber || order.id}`);
        } catch (error) {
          console.error(`âŒ [FIRST REMINDER] Failed for order ${order.id}:`, error);
        }
      }

      // Process second reminders
      for (const order of secondReminderOrders) {
        try {
          await sendAbandonedOrderReminder(order, 'second');
          await db
            .update(abandonedOrders)
            .set({ 
              remindersSent: 2, 
              lastReminderAt: now,
              lastUpdated: now
            })
            .where(eq(abandonedOrders.id, order.id));
          
          console.log(`âœ… [SECOND REMINDER] Sent to customer ${order.customerEmail} for order ${order.hybridOrderNumber || order.id}`);
        } catch (error) {
          console.error(`âŒ [SECOND REMINDER] Failed for order ${order.id}:`, error);
        }
      }

      // Process final reminders
      for (const order of finalReminderOrders) {
        try {
          await sendAbandonedOrderReminder(order, 'final');
          await db
            .update(abandonedOrders)
            .set({ 
              remindersSent: 3, 
              lastReminderAt: now,
              lastUpdated: now
            })
            .where(eq(abandonedOrders.id, order.id));
          
          console.log(`âœ… [FINAL REMINDER] Sent to customer ${order.customerEmail} for order ${order.hybridOrderNumber || order.id}`);
        } catch (error) {
          console.error(`âŒ [FINAL REMINDER] Failed for order ${order.id}:`, error);
        }
      }

      console.log(`ğŸ“§ [ABANDONED REMINDERS] Completed: ${firstReminderOrders.length + secondReminderOrders.length + finalReminderOrders.length} reminders sent`);
    } catch (error) {
      console.error('âŒ [ABANDONED REMINDERS] Error in reminder process:', error);
    }
  };

  // Helper function to send individual reminders
  const sendAbandonedOrderReminder = async (order: AbandonedOrder, reminderType: 'first' | 'second' | 'final') => {
    if (!order.customerEmail && !order.customerPhone) {
      throw new Error('No contact information available');
    }

    const cartItems = Array.isArray(order.cartData) ? order.cartData : Object.entries(order.cartData || {});
    const totalValue = parseFloat(order.totalAmount || '0');
    const walletAmount = parseFloat(order.walletAmountUsed || '0');
    const bankAmount = parseFloat(order.bankAmountPending || '0');

    // Email reminder
    if (order.customerEmail) {
      const templateName = reminderType === 'first' ? 'Ø³ÙØ§Ø±Ø´ Ø±Ù‡Ø§ Ø´Ø¯Ù‡ - ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø§ÙˆÙ„' : 
                          reminderType === 'second' ? 'Ø³ÙØ§Ø±Ø´ Ø±Ù‡Ø§ Ø´Ø¯Ù‡ - ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø¯ÙˆÙ…' : 
                          'Ø³ÙØ§Ø±Ø´ Ø±Ù‡Ø§ Ø´Ø¯Ù‡ - ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ù†Ù‡Ø§ÛŒÛŒ';
      const emailTemplate = await emailStorage.getTemplateByName(templateName);
      if (emailTemplate) {
        const personalizedContent = emailTemplate.htmlContent
          .replace(/{{customerName}}/g, order.customerName || 'Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ')
          .replace(/{{orderNumber}}/g, order.hybridOrderNumber || `AO-${order.id}`)
          .replace(/{{totalAmount}}/g, totalValue.toLocaleString())
          .replace(/{{walletAmount}}/g, walletAmount.toLocaleString())
          .replace(/{{bankAmount}}/g, bankAmount.toLocaleString())
          .replace(/{{itemCount}}/g, cartItems.length.toString())
          .replace(/{{daysAgo}}/g, Math.ceil((new Date().getTime() - new Date(order.createdAt).getTime()) / (1000 * 60 * 60 * 24)).toString());

        await emailService.sendEmail({
          to: order.customerEmail,
          subject: emailTemplate.subject,
          html: personalizedContent,
          templateId: emailTemplate.id,
          customerId: order.customerId || undefined
        });
      }
    }

    // SMS reminder
    if (order.customerPhone) {
      let smsMessage = '';
      switch (reminderType) {
        case 'first':
          smsMessage = `${order.customerName || 'Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ'}ØŒ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ ${order.hybridOrderNumber || `AO-${order.id}`} Ø¨Ù‡ Ù…Ø¨Ù„Øº ${totalValue.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ù†Ø§ØªÙ…Ø§Ù… Ø§Ø³Øª. ${walletAmount > 0 ? `Ù…Ø¨Ù„Øº ${walletAmount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ Ú©Ø³Ø± Ø´Ø¯Ù‡ Ùˆ ${bankAmount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ù†ÛŒØ§Ø² Ø¨Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ Ø¯Ø§Ø±Ø¯.` : ''} Ø¨Ø±Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„: momtazchem.com`;
          break;
        case 'second':
          smsMessage = `ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ù…Ø¬Ø¯Ø¯: Ø³ÙØ§Ø±Ø´ ${order.hybridOrderNumber || `AO-${order.id}`} Ø´Ù…Ø§ Ø¨Ù‡ Ù…Ø¨Ù„Øº ${totalValue.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªÚ©Ù…ÛŒÙ„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø§Ø³Øª. Ù…Ù…ØªØ§Ø²Ú©Ù… - momtazchem.com`;
          break;
        case 'final':
          smsMessage = `Ø¢Ø®Ø±ÛŒÙ† ÙØ±ØµØª: Ø³ÙØ§Ø±Ø´ ${order.hybridOrderNumber || `AO-${order.id}`} Ø´Ù…Ø§ Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ù…Ø¨Ù„Øº ${bankAmount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ù†ÛŒØ§Ø² Ø¨Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¯Ø§Ø±Ø¯. Ù…Ù…ØªØ§Ø²Ú©Ù…`;
          break;
      }

      await smsStorage.sendSMS({
        to: order.customerPhone,
        message: smsMessage,
        customerId: order.customerId || undefined,
        context: 'abandoned_order_reminder'
      });
    }
  };

  // Start abandoned order reminder service
  setInterval(sendAbandonedOrderReminders, 30 * 60 * 1000); // Check every 30 minutes
  console.log('ğŸ“§ [ABANDONED REMINDERS] Reminder service started - checking every 30 minutes');

  // Manual trigger endpoint for testing
  app.post('/api/abandoned-orders/send-reminders', requireAuth, async (req, res) => {
    try {
      await sendAbandonedOrderReminders();
      res.json({ success: true, message: 'ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ø±Ù‡Ø§ Ø´Ø¯Ù‡ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯' });
    } catch (error) {
      console.error('âŒ [MANUAL REMINDERS] Error:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒâ€ŒÙ‡Ø§' });
    }
  });

  // Generate delivery code for order (logistics department)
  app.post('/api/order-management/:orderManagementId/generate-delivery-code', requireAuth, async (req, res) => {
    try {
      const orderManagementId = parseInt(req.params.orderManagementId);
      
      // Get order and customer information
      const orderWithCustomer = await db
        .select({
          customerPhone: crmCustomers.phone,
          customerOrderId: orderManagement.customerOrderId,
          deliveryCode: orderManagement.deliveryCode,
          customerFirstName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.id, orderManagementId))
        .limit(1);

      if (!orderWithCustomer[0]) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const { customerPhone, customerOrderId } = orderWithCustomer[0];

      if (!customerPhone) {
        return res.status(400).json({ success: false, message: 'Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Generate new delivery code using logistics storage
      const deliveryCode = await logisticsStorage.getNextSequentialCode();
      
      // Update order with new delivery code
      await db
        .update(orderManagement)
        .set({ 
          deliveryCode: deliveryCode,
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderManagementId));

      // Send SMS with new delivery code
      const smsSent = await orderManagementStorage.sendDeliveryCodeSms(customerPhone, deliveryCode, customerOrderId);
      
      if (smsSent) {
        console.log(`âœ… [GENERATE SMS] Delivery code ${deliveryCode} generated and sent to ${customerPhone} for order ${orderManagementId}`);
        res.json({ 
          success: true, 
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ ØªÙˆÙ„ÛŒØ¯ Ùˆ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯',
          deliveryCode: deliveryCode
        });
      } else {
        // Even if SMS failed, we generated the code
        console.log(`âš ï¸ [GENERATE SMS] Delivery code ${deliveryCode} generated but SMS failed for order ${orderManagementId}`);
        res.json({ 
          success: true, 
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯ Ø§Ù…Ø§ SMS Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯',
          deliveryCode: deliveryCode
        });
      }
    } catch (error) {
      console.error('Error generating delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Resend delivery code (logistics department)
  app.post('/api/order-management/:orderManagementId/resend-delivery-code', requireAuth, async (req, res) => {
    try {
      const orderManagementId = parseInt(req.params.orderManagementId);
      
      // Get order and customer information
      const orderWithCustomer = await db
        .select({
          customerPhone: crmCustomers.phone,
          customerOrderId: orderManagement.customerOrderId,
          deliveryCode: orderManagement.deliveryCode,
          customerFirstName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.id, orderManagementId))
        .limit(1);

      if (!orderWithCustomer[0]) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const { customerPhone, customerOrderId, deliveryCode } = orderWithCustomer[0];

      if (!customerPhone) {
        return res.status(400).json({ success: false, message: 'Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      if (!deliveryCode) {
        return res.status(400).json({ success: false, message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Resend SMS with existing delivery code
      const smsSent = await orderManagementStorage.sendDeliveryCodeSms(customerPhone, deliveryCode, customerOrderId);
      
      if (smsSent) {
        console.log(`âœ… [RESEND SMS] Delivery code ${deliveryCode} resent to ${customerPhone} for order ${orderManagementId}`);
        res.json({ 
          success: true, 
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯',
          deliveryCode: deliveryCode
        });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
      }
    } catch (error) {
      console.error('Error resending delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Assign user to department
  app.post('/api/order-management/assign-department', requireAuth, async (req, res) => {
    try {
      const { adminUserId, department } = req.body;
      const assignedBy = req.session.adminId!;

      const assignment = await orderManagementStorage.assignUserToDepartment({
        adminUserId,
        department,
        assignedBy
      });

      res.json({ success: true, assignment });
    } catch (error) {
      console.error('Error assigning user to department:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ®ØµÛŒØµ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ø¨Ø®Ø´' });
    }
  });

  // Get department stats
  app.get('/api/order-management/stats/:department', requireAuth, async (req, res) => {
    try {
      const department = req.params.department as 'financial' | 'warehouse' | 'logistics';
      const stats = await orderManagementStorage.getDepartmentStats(department);
      res.json({ success: true, stats });
    } catch (error) {
      console.error('Error fetching department stats:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¨Ø®Ø´' });
    }
  });

  // Get orders overview (admin dashboard)
  app.get('/api/order-management/overview', requireAuth, async (req, res) => {
    try {
      const overview = await orderManagementStorage.getOrdersOverview();
      res.json({ success: true, overview });
    } catch (error) {
      console.error('Error fetching orders overview:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // ============================================================================
  // DEPARTMENT-SPECIFIC AUTHENTICATION & ROUTES
  // ============================================================================

  // Department authentication middleware
  function requireDepartmentAuth(department: string) {
    return (req: any, res: any, next: any) => {
      // Temporary workaround for session consistency issue with financial department
      if (department === 'financial') {
        const tempUser = {
          id: 1,
          username: 'financial_temp',
          department: 'financial'
        };
        req.session.departmentUser = tempUser;
        return next();
      }
      
      // Temporary workaround for logistics department - allow admin access
      if (department === 'logistics' && (req.session?.adminId || req.session?.isAuthenticated)) {
        console.log('âœ… Logistics auth: Admin access granted', {
          adminId: req.session.adminId,
          isAuthenticated: req.session.isAuthenticated
        });
        const tempUser = {
          id: req.session.adminId || 1,
          username: 'logistics_admin',
          department: 'logistics'
        };
        req.session.departmentUser = tempUser;
        return next();
      }
      
      console.log(`Auth check for ${department}:`, {
        sessionExists: !!req.session,
        departmentUser: req.session?.departmentUser,
        sessionId: req.sessionID
      });
      
      if (!req.session?.departmentUser || req.session.departmentUser.department !== department) {
        console.log(`Authentication failed for ${department}:`, {
          hasDepartmentUser: !!req.session?.departmentUser,
          userDepartment: req.session?.departmentUser?.department,
          expectedDepartment: department
        });
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      next();
    };
  }

  // ============================================================================
  // LOGISTICS DEPARTMENT ROUTES
  // ============================================================================

  // Logistics login
  app.post('/api/logistics/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      // Check if user exists and has logistics department access
      const [user] = await db
        .select()
        .from(schema.users)
        .where(and(
          eq(schema.users.username, username),
          eq(schema.users.department, 'logistics'),
          eq(schema.users.isActive, true)
        ));

      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Update last login
      await db
        .update(schema.users)
        .set({ lastLoginAt: new Date() })
        .where(eq(schema.users.id, user.id));

      // Set session
      req.session.departmentUser = {
        id: user.id,
        username: user.username,
        department: user.department || 'logistics'
      };

      res.json({ 
        success: true, 
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚", 
        user: { 
          id: user.id, 
          username: user.username, 
          department: user.department 
        } 
      });
    } catch (error) {
      console.error('Logistics login error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" });
    }
  });

  // Logistics logout
  app.post('/api/logistics/logout', (req, res) => {
    req.session.departmentUser = undefined;
    res.json({ success: true, message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚" });
  });

  // Logistics auth check
  app.get('/api/logistics/auth/me', requireDepartmentAuth('logistics'), (req: any, res) => {
    res.json({ 
      success: true, 
      user: req.session.departmentUser 
    });
  });

  // Get logistics pending orders - only warehouse_approved orders
  app.get('/api/logistics/orders', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orders = await orderManagementStorage.getLogisticsPendingOrders();
      
      // Calculate total weight for each order
      const ordersWithWeight = await Promise.all(
        orders.map(async (order) => {
          try {
            const weight = await orderManagementStorage.calculateOrderWeight(order.customerOrderId);
            return {
              ...order,
              calculatedWeight: weight,
              weightUnit: 'kg'
            };
          } catch (error) {
            console.error(`Error calculating weight for order ${order.customerOrderId}:`, error);
            return {
              ...order,
              calculatedWeight: 0,
              weightUnit: 'kg'
            };
          }
        })
      );
      
      res.json({ success: true, orders: ordersWithWeight });
    } catch (error) {
      console.error('Error fetching logistics orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª" });
    }
  });

  // Calculate order weight endpoint - accessible by all authenticated users
  app.post('/api/orders/:customerOrderId/calculate-weight', requireAuth, async (req, res) => {
    try {
      const customerOrderId = parseInt(req.params.customerOrderId);
      
      if (!customerOrderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      console.log(`ğŸ”„ [WEIGHT] Calculating weight for order ${customerOrderId}...`);
      
      // Calculate the weight using enhanced method
      const weight = await orderManagementStorage.calculateOrderWeight(customerOrderId);
      
      // Update the order_management table with the calculated weight
      try {
        await orderManagementStorage.updateOrderWeight(customerOrderId, weight);
        console.log(`âœ… [WEIGHT] Updated order ${customerOrderId} weight: ${weight} kg`);
      } catch (updateError) {
        console.error(`âŒ [WEIGHT] Failed to update weight in database:`, updateError);
      }
      
      res.json({
        success: true,
        message: `ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´ ${customerOrderId} Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯`,
        data: {
          customerOrderId,
          totalWeight: weight,
          weightUnit: 'kg'
        }
      });
    } catch (error) {
      console.error(`âŒ [WEIGHT] Error calculating weight for order ${req.params.customerOrderId}:`, error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´" 
      });
    }
  });

  // Process logistics order
  app.post('/api/logistics/orders/:id/process', requireDepartmentAuth('logistics'), async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { 
        action, 
        notes, 
        reviewerId, 
        trackingNumber, 
        estimatedDeliveryDate, 
        deliveryPersonName, 
        deliveryPersonPhone,
        // Delivery method and transportation details
        deliveryMethod,
        transportationType,
        // Postal service details
        postalServiceName,
        postalTrackingCode,
        postalWeight,
        postalPrice,
        postalInsurance,
        // Vehicle details
        vehicleType,
        vehiclePlate,
        vehicleModel,
        vehicleColor,
        driverName,
        driverPhone,
        driverLicense,
        // Delivery company details
        deliveryCompanyName,
        deliveryCompanyPhone,
        deliveryCompanyAddress
      } = req.body;
      
      if (action === 'approve') {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'logistics_approved',
          reviewerId,
          'logistics',
          notes || 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù„Ø¬Ø³ØªÛŒÚ©'
        );
        
        // Update comprehensive delivery information
        await orderManagementStorage.updateDeliveryInfo(orderId, {
          trackingNumber,
          estimatedDeliveryDate: estimatedDeliveryDate ? new Date(estimatedDeliveryDate) : undefined,
          deliveryPersonName,
          deliveryPersonPhone,
          deliveryMethod,
          transportationType,
          postalServiceName,
          postalTrackingCode,
          postalWeight,
          postalPrice,
          postalInsurance,
          vehicleType,
          vehiclePlate,
          vehicleModel,
          vehicleColor,
          driverName,
          driverPhone,
          driverLicense,
          deliveryCompanyName,
          deliveryCompanyPhone,
          deliveryCompanyAddress
        });
      } else {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'logistics_rejected',
          reviewerId,
          'logistics',
          notes || 'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù„Ø¬Ø³ØªÛŒÚ©'
        );
      }

      res.json({ success: true, message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯" });
    } catch (error) {
      console.error('Error processing logistics order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´" });
    }
  });

  // ============================================================================
  // DELIVERY METHODS MANAGEMENT (LOGISTICS DEPARTMENT)
  // ============================================================================

  // Get all delivery methods (for logistics admin)
  app.get('/api/logistics/delivery-methods', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methods = await db
        .select()
        .from(deliveryMethods)
        .orderBy(deliveryMethods.sortOrder, deliveryMethods.label);
      
      res.json(methods);
    } catch (error) {
      console.error('Error fetching delivery methods:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Get active delivery methods (for customer checkout - no auth required)
  app.get('/api/delivery-methods', async (req, res) => {
    try {
      const methods = await db
        .select()
        .from(deliveryMethods)
        .where(eq(deliveryMethods.isActive, true))
        .orderBy(deliveryMethods.sortOrder, deliveryMethods.label);
      
      res.json(methods);
    } catch (error) {
      console.error('Error fetching active delivery methods:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Create new delivery method
  app.post('/api/logistics/delivery-methods', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methodData = req.body;
      
      const [newMethod] = await db
        .insert(deliveryMethods)
        .values({
          ...methodData,
          createdAt: new Date(),
          updatedAt: new Date(),
        })
        .returning();
      
      res.json({ success: true, data: newMethod, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error creating delivery method:', error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„" });
      }
    }
  });

  // Update delivery method
  app.put('/api/logistics/delivery-methods/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methodId = parseInt(req.params.id);
      const updateData = req.body;
      
      const [updatedMethod] = await db
        .update(deliveryMethods)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(deliveryMethods.id, methodId))
        .returning();
      
      if (!updatedMethod) {
        return res.status(404).json({ success: false, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, data: updatedMethod, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error('Error updating delivery method:', error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„" });
      }
    }
  });

  // Delete delivery method
  app.delete('/api/logistics/delivery-methods/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methodId = parseInt(req.params.id);
      
      // Check if this delivery method is used in shipping rates
      const usedInShippingRates = await db
        .select({ count: sql`count(*)` })
        .from(shippingRates)
        .where(eq(shippingRates.deliveryMethod, sql`(SELECT value FROM delivery_methods WHERE id = ${methodId})`));
      
      if (usedInShippingRates[0]?.count > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø± ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ Ø­Ø°Ù Ù†ÛŒØ³Øª" 
        });
      }
      
      const deletedRows = await db
        .delete(deliveryMethods)
        .where(eq(deliveryMethods.id, methodId))
        .returning();
      
      if (deletedRows.length === 0) {
        return res.status(404).json({ success: false, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting delivery method:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // ============================================================================
  // SHIPPING RATES MANAGEMENT (LOGISTICS DEPARTMENT)
  // ============================================================================

  // Get all shipping rates (for logistics admin)
  app.get('/api/logistics/shipping-rates', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rates = await db
        .select()
        .from(shippingRates)
        .orderBy(shippingRates.deliveryMethod, shippingRates.transportationType);
      
      res.json({ success: true, data: rates });
    } catch (error) {
      console.error('Error fetching shipping rates:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Get active shipping rates (for customer checkout - no auth required)
  app.get('/api/shipping-rates', async (req, res) => {
    try {
      const rates = await db
        .select()
        .from(shippingRates)
        .where(eq(shippingRates.isActive, true))
        .orderBy(shippingRates.deliveryMethod, shippingRates.transportationType);
      
      res.json({ success: true, data: rates });
    } catch (error) {
      console.error('Error fetching active shipping rates:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Create new shipping rate
  app.post('/api/logistics/shipping-rates', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rateData = req.body;
      
      const [newRate] = await db
        .insert(shippingRates)
        .values(rateData)
        .returning();
      
      res.json({ success: true, data: newRate, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error creating shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Update shipping rate
  app.put('/api/logistics/shipping-rates/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      const updateData = req.body;
      
      const [updatedRate] = await db
        .update(shippingRates)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(shippingRates.id, rateId))
        .returning();
      
      if (!updatedRate) {
        return res.status(404).json({ success: false, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, rate: updatedRate, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error('Error updating shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Delete shipping rate
  app.delete('/api/logistics/shipping-rates/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      
      const [deletedRate] = await db
        .delete(shippingRates)
        .where(eq(shippingRates.id, rateId))
        .returning();
      
      if (!deletedRate) {
        return res.status(404).json({ success: false, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // ============================================================================
  // SMS VERIFICATION SYSTEM FOR DELIVERY
  // ============================================================================

  // Generate SMS verification code for order
  app.post('/api/logistics/orders/:orderId/generate-sms-code', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      // Get order details
      const [order] = await db
        .select()
        .from(orders)
        .where(eq(orders.id, orderId))
        .limit(1);

      if (!order) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Generate verification code
      const verificationCode = await deliveryVerificationStorage.generateVerificationCode(
        order.id, // Using order ID as orderManagementId for now
        orderId,
        order.phone || order.customerPhone || ''
      );

      // Send SMS
      const smsResult = await smsService.sendDeliveryVerificationSms(
        order.phone || order.customerPhone || '',
        verificationCode.verificationCode,
        order.firstName || 'Ù…Ø´ØªØ±ÛŒ',
        verificationCode.id
      );

      res.json({
        success: true,
        message: 'Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ù¾ÛŒØ§Ù…Ú© Ø´Ø¯',
        verificationCode: verificationCode.verificationCode,
        smsSent: smsResult.success
      });
    } catch (error) {
      console.error('Error generating SMS verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯' });
    }
  });

  // Verify delivery code
  app.post('/api/logistics/verify-delivery', async (req, res) => {
    try {
      const { verificationCode, customerOrderId, courierName, verificationNotes } = req.body;

      const result = await deliveryVerificationStorage.verifyDeliveryCode({
        verificationCode,
        customerOrderId,
        courierName,
        verificationNotes
      });

      if (result.success) {
        // Update order status to delivered
        await db
          .update(orders)
          .set({
            status: 'delivered',
            deliveredAt: new Date(),
            deliveryNotes: verificationNotes || 'ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ù¾ÛŒØ§Ù…Ú©'
          })
          .where(eq(orders.id, customerOrderId));
      }

      res.json(result);
    } catch (error) {
      console.error('Error verifying delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Get delivery verification history for order
  app.get('/api/logistics/orders/:orderId/verification-history', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const history = await deliveryVerificationStorage.getVerificationHistory(orderId);
      res.json({ success: true, history });
    } catch (error) {
      console.error('Error fetching verification history:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªØ£ÛŒÛŒØ¯' });
    }
  });

  // Get daily SMS statistics
  app.get('/api/logistics/sms-stats/:date', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const date = req.params.date;
      const stats = await deliveryVerificationStorage.getDailyStats(date);
      res.json({ success: true, stats });
    } catch (error) {
      console.error('Error fetching SMS stats:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ù¾ÛŒØ§Ù…Ú©' });
    }
  });

  // Increment delivery attempts
  app.post('/api/logistics/orders/:orderId/increment-attempts', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      await deliveryVerificationStorage.incrementDeliveryAttempts(orderId);
      res.json({ success: true, message: 'ØªÙ„Ø§Ø´ ØªØ­ÙˆÛŒÙ„ Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØª' });
    } catch (error) {
      console.error('Error incrementing delivery attempts:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÙØ²Ø§ÛŒØ´ ØªÙ„Ø§Ø´ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // ============================================================================
  // CUSTOMER SHIPPING COST CALCULATION
  // ============================================================================

  // Calculate shipping cost for customer checkout
  app.post('/api/shipping/calculate', async (req, res) => {
    try {
      const { deliveryMethod, transportationType, customerCity, orderTotal, totalWeight } = req.body;
      
      // Find applicable shipping rate
      const applicableRates = await db
        .select()
        .from(shippingRates)
        .where(and(
          eq(shippingRates.deliveryMethod, deliveryMethod),
          transportationType ? eq(shippingRates.transportationType, transportationType) : sql`1=1`,
          eq(shippingRates.isActive, true),
          or(
            isNull(shippingRates.cityName), // National shipping
            eq(shippingRates.cityName, customerCity) // City-specific
          ),
          or(
            isNull(shippingRates.maxWeight), // No weight limit
            sql`${totalWeight} <= ${shippingRates.maxWeight}` // Within weight limit
          ),
          sql`${totalWeight} >= ${shippingRates.minWeight}` // Above minimum weight
        ))
        .orderBy(shippingRates.cityName); // City-specific rates first
      
      if (applicableRates.length === 0) {
        return res.json({ 
          success: false, 
          message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ù†Ø·Ù‚Ù‡ Ø´Ù…Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª" 
        });
      }
      
      const rate = applicableRates[0]; // Use most specific rate (city-specific if available)
      
      // Check for free shipping threshold
      if (rate.freeShippingThreshold && orderTotal >= parseFloat(rate.freeShippingThreshold)) {
        return res.json({
          success: true,
          shippingCost: 0,
          isFreeShipping: true,
          rate: {
            id: rate.id,
            deliveryMethod: rate.deliveryMethod,
            transportationType: rate.transportationType,
            description: rate.description,
            estimatedDays: rate.estimatedDays,
            trackingAvailable: rate.trackingAvailable
          }
        });
      }
      
      // Calculate shipping cost
      const basePrice = parseFloat(rate.basePrice);
      const weightCost = totalWeight * parseFloat(rate.pricePerKg || "0");
      const insuranceCost = rate.insuranceAvailable && rate.insuranceRate ? 
        orderTotal * parseFloat(rate.insuranceRate) : 0;
      
      const totalShippingCost = basePrice + weightCost + insuranceCost;
      
      res.json({
        success: true,
        shippingCost: totalShippingCost,
        isFreeShipping: false,
        breakdown: {
          basePrice,
          weightCost,
          insuranceCost,
          totalWeight
        },
        rate: {
          id: rate.id,
          deliveryMethod: rate.deliveryMethod,
          transportationType: rate.transportationType,
          description: rate.description,
          estimatedDays: rate.estimatedDays,
          trackingAvailable: rate.trackingAvailable,
          insuranceAvailable: rate.insuranceAvailable
        }
      });
    } catch (error) {
      console.error('Error calculating shipping cost:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Get available shipping methods for customer location
  app.get('/api/shipping/methods', async (req, res) => {
    try {
      const { city, orderTotal, totalWeight } = req.query;
      
      const availableMethods = await db
        .selectDistinct({
          deliveryMethod: shippingRates.deliveryMethod,
          transportationType: shippingRates.transportationType,
          description: shippingRates.description,
          estimatedDays: shippingRates.estimatedDays,
          trackingAvailable: shippingRates.trackingAvailable,
          basePrice: shippingRates.basePrice,
          freeShippingThreshold: shippingRates.freeShippingThreshold
        })
        .from(shippingRates)
        .where(and(
          eq(shippingRates.isActive, true),
          or(
            isNull(shippingRates.cityName), // National shipping
            eq(shippingRates.cityName, city as string) // City-specific
          ),
          or(
            isNull(shippingRates.maxWeight), // No weight limit
            sql`${totalWeight} <= ${shippingRates.maxWeight}` // Within weight limit
          ),
          sql`${totalWeight || 0} >= ${shippingRates.minWeight}` // Above minimum weight
        ))
        .orderBy(shippingRates.basePrice);
      
      res.json({ success: true, methods: availableMethods });
    } catch (error) {
      console.error('Error fetching shipping methods:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // ============================================================================
  // ACCOUNTING MANAGEMENT ROUTES
  // ============================================================================

  // Get invoices (placeholder for now)
  app.get('/api/accounting/invoices', async (req, res) => {
    try {
      // For now, return empty array - will be implemented with proper invoicing system
      const invoices: any[] = [];
      res.json({ success: true, data: invoices });
    } catch (error) {
      console.error('Error fetching invoices:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ§Ú©ØªÙˆØ±Ù‡Ø§" });
    }
  });

  // Test tax calculation endpoint
  app.post('/api/accounting/calculate-taxes', async (req, res) => {
    try {
      const { subtotal } = req.body;
      
      if (!subtotal || isNaN(subtotal)) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ø¨Ù„Øº Ú©Ù„ Ú©Ø§Ù„Ø§Ù‡Ø§ Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø±ÛŒ Ø¨Ø§Ø´Ø¯' 
        });
      }
      
      const taxCalculation = await calculateOrderTaxes(parseFloat(subtotal));
      
      res.json({
        success: true,
        data: {
          subtotal: parseFloat(subtotal),
          ...taxCalculation,
          total: parseFloat(subtotal) + taxCalculation.vatAmount + taxCalculation.dutiesAmount
        }
      });
    } catch (error) {
      console.error('Error calculating taxes:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // ============================================================================
  // TAX CALCULATION HELPER FUNCTIONS
  // ============================================================================
  
  // Calculate taxes for an order and return both amounts and rates
  async function calculateOrderTaxes(subtotal: number) {
    try {
      console.log('ğŸ’° [TAX] Calculating taxes for subtotal:', subtotal);
      
      const taxSettingsList = await db
        .select()
        .from(schema.taxSettings)
        .where(eq(schema.taxSettings.isEnabled, true));
      
      console.log('ğŸ’° [TAX] Found tax settings:', taxSettingsList);
      
      const vatSetting = taxSettingsList.find(setting => setting.type === 'vat');
      const dutiesSetting = taxSettingsList.find(setting => setting.type === 'duties');
      
      const vatRate = vatSetting ? parseFloat(vatSetting.rate) : 0; // Database stores as decimal (0.06 = 6%)
      const dutiesRate = dutiesSetting ? parseFloat(dutiesSetting.rate) : 0; // Database stores as decimal
      
      const vatAmount = vatRate > 0 ? subtotal * vatRate : 0;
      const dutiesAmount = dutiesRate > 0 ? subtotal * dutiesRate : 0;
      
      const result = {
        vatAmount: parseFloat(vatAmount.toFixed(2)),
        dutiesAmount: parseFloat(dutiesAmount.toFixed(2)),
        vatRate: vatSetting ? parseFloat(vatSetting.rate) * 100 : 0, // Return as percentage (6.00 for 6%)
        dutiesRate: dutiesSetting ? parseFloat(dutiesSetting.rate) * 100 : 0, // Return as percentage
        vatRateDecimal: vatRate, // For internal calculations (0.06 for 6%)
        dutiesRateDecimal: dutiesRate // For internal calculations
      };
      
      console.log('ğŸ’° [TAX] Tax calculation result:', result);
      return result;
    } catch (error) {
      console.error('âŒ Error calculating taxes:', error);
      return { 
        vatAmount: 0, 
        dutiesAmount: 0, 
        vatRate: 0, 
        dutiesRate: 0, 
        vatRateDecimal: 0, 
        dutiesRateDecimal: 0 
      };
    }
  }

  // ============================================================================
  // TAX SETTINGS MANAGEMENT ROUTES  
  // ============================================================================

  // Public endpoint for tax settings (no authentication required for checkout)
  app.get('/api/tax-settings', async (req, res) => {
    try {
      const taxSettingsList = await db
        .select()
        .from(schema.taxSettings)
        .where(eq(schema.taxSettings.isActive, true))
        .orderBy(schema.taxSettings.type, schema.taxSettings.id);
      
      res.json({ success: true, data: taxSettingsList });
    } catch (error) {
      console.error('Error fetching tax settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // Get all tax settings (VAT and Duties) - Admin only
  app.get('/api/accounting/tax-settings', async (req, res) => {
    try {
      const taxSettingsList = await db
        .select()
        .from(schema.taxSettings)
        .orderBy(schema.taxSettings.type, schema.taxSettings.id);
      
      res.json({ success: true, data: taxSettingsList });
    } catch (error) {
      console.error('Error fetching tax settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // Get individual tax setting by ID
  app.get('/api/accounting/tax-settings/:id', async (req, res) => {
    try {
      const { id } = req.params;
      
      const [taxSetting] = await db
        .select()
        .from(schema.taxSettings)
        .where(eq(schema.taxSettings.id, parseInt(id)));
      
      if (!taxSetting) {
        return res.status(404).json({ success: false, message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§ØªÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, data: taxSetting });
    } catch (error) {
      console.error('Error fetching tax setting:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // Update tax setting (VAT or Duties)
  app.put('/api/accounting/tax-settings/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const { rate, isEnabled, description } = req.body;
      
      const [updatedTaxSetting] = await db
        .update(schema.taxSettings)
        .set({ 
          rate: rate?.toString(),
          isEnabled,
          description,
          updatedAt: new Date()
        })
        .where(eq(schema.taxSettings.id, parseInt(id)))
        .returning();
      
      if (!updatedTaxSetting) {
        return res.status(404).json({ success: false, message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§ØªÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: updatedTaxSetting,
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§ØªÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating tax settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // Toggle tax setting enabled/disabled
  app.post('/api/accounting/tax-settings/:id/toggle', async (req, res) => {
    try {
      const { id } = req.params;
      
      // Get current setting
      const [currentSetting] = await db
        .select()
        .from(schema.taxSettings)
        .where(eq(schema.taxSettings.id, parseInt(id)));
      
      if (!currentSetting) {
        return res.status(404).json({ success: false, message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§ØªÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Toggle the enabled status
      const [updatedSetting] = await db
        .update(schema.taxSettings)
        .set({ 
          isEnabled: !currentSetting.isEnabled,
          updatedAt: new Date()
        })
        .where(eq(schema.taxSettings.id, parseInt(id)))
        .returning();
      
      res.json({ 
        success: true, 
        data: updatedSetting,
        message: updatedSetting.isEnabled ? "Ù…Ø§Ù„ÛŒØ§Øª ÙØ¹Ø§Ù„ Ø´Ø¯" : "Ù…Ø§Ù„ÛŒØ§Øª ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error toggling tax setting:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // ============================================================================
  // VAT MANAGEMENT (FINANCIAL DEPARTMENT)
  // ============================================================================

  // Get current VAT settings
  app.get('/api/financial/vat-settings', (req: any, res: any) => {
    // Set temporary session for consistency
    req.session.departmentUser = {
      id: 1,
      username: 'financial_temp',
      department: 'financial'
    };
    
    // Execute the actual VAT settings logic
    (async () => {
    try {
      const [currentVat] = await db
        .select()
        .from(vatSettings)
        .where(eq(vatSettings.isActive, true))
        .orderBy(desc(vatSettings.effectiveDate))
        .limit(1);
      
      res.json({ success: true, vatSettings: currentVat || null });
    } catch (error) {
      console.error('Error fetching VAT settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
    })();
  });

  // Update VAT settings
  app.put('/api/financial/vat-settings', (req: any, res: any) => {
    // Set temporary session for consistency
    req.session.departmentUser = {
      id: 1,
      username: 'financial_temp',
      department: 'financial'
    };
    
    // Execute the actual VAT settings logic
    (async () => {
    try {
      const vatData = req.body;
      
      // Deactivate current VAT settings
      await db
        .update(vatSettings)
        .set({ isActive: false, updatedAt: new Date() })
        .where(eq(vatSettings.isActive, true));
      
      // Create new VAT settings
      const [newVatSettings] = await db
        .insert(vatSettings)
        .values({
          ...vatData,
          isActive: true,
          effectiveDate: new Date()
        })
        .returning();
      
      res.json({ 
        success: true, 
        vatSettings: newVatSettings, 
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating VAT settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
    })();
  });

  // Calculate VAT for order (for checkout)
  app.post('/api/financial/calculate-vat', async (req, res) => {
    try {
      const { orderItems, orderTotal, shippingCost, customerRegion } = req.body;
      
      // Get current VAT settings
      const [currentVat] = await db
        .select()
        .from(vatSettings)
        .where(and(
          eq(vatSettings.isActive, true),
          eq(vatSettings.vatEnabled, true)
        ))
        .orderBy(desc(vatSettings.effectiveDate))
        .limit(1);
      
      if (!currentVat) {
        return res.json({
          success: true,
          vatAmount: 0,
          vatRate: 0,
          taxableAmount: 0,
          totalWithVat: orderTotal + (shippingCost || 0),
          breakdown: {
            productVat: 0,
            shippingVat: 0,
            exemptAmount: orderTotal
          }
        });
      }
      
      // Check if VAT applies to customer region
      const applicableRegions = currentVat.applicableRegions as string[] || [];
      if (applicableRegions.length > 0 && !applicableRegions.includes(customerRegion)) {
        return res.json({
          success: true,
          vatAmount: 0,
          vatRate: parseFloat(currentVat.vatRate),
          taxableAmount: 0,
          totalWithVat: orderTotal + (shippingCost || 0),
          breakdown: {
            productVat: 0,
            shippingVat: 0,
            exemptAmount: orderTotal
          }
        });
      }
      
      // Calculate VAT for products
      const exemptCategories = currentVat.exemptCategories as string[] || [];
      const exemptProductIds = currentVat.exemptProductIds as number[] || [];
      
      let taxableAmount = 0;
      let exemptAmount = 0;
      
      for (const item of orderItems) {
        const isExempt = exemptCategories.includes(item.category) || 
                        exemptProductIds.includes(item.productId);
        
        if (isExempt) {
          exemptAmount += item.totalPrice;
        } else {
          taxableAmount += item.totalPrice;
        }
      }
      
      // Check minimum taxable amount
      if (currentVat.minimumTaxableAmount && 
          taxableAmount < parseFloat(currentVat.minimumTaxableAmount)) {
        taxableAmount = 0;
        exemptAmount = orderTotal;
      }
      
      // Calculate VAT amounts
      const vatRate = parseFloat(currentVat.vatRate) / 100;
      const productVat = taxableAmount * vatRate;
      
      // Shipping is typically VAT-exempt in Iraq
      const shippingVat = currentVat.shippingTaxable ? (shippingCost || 0) * vatRate : 0;
      
      const totalVat = productVat + shippingVat;
      const totalWithVat = orderTotal + (shippingCost || 0) + totalVat;
      
      res.json({
        success: true,
        vatAmount: totalVat,
        vatRate: parseFloat(currentVat.vatRate),
        taxableAmount,
        totalWithVat,
        breakdown: {
          productVat,
          shippingVat,
          exemptAmount,
          taxableProductAmount: taxableAmount,
          vatDisplayName: currentVat.vatDisplayName,
          vatNumber: currentVat.vatNumber
        }
      });
    } catch (error) {
      console.error('Error calculating VAT:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // Get VAT-exempt categories and products (for admin reference)
  app.get('/api/financial/vat-exemptions', requireDepartmentAuth('financial'), async (req, res) => {
    try {
      const [currentVat] = await db
        .select({
          exemptCategories: vatSettings.exemptCategories,
          exemptProductIds: vatSettings.exemptProductIds
        })
        .from(vatSettings)
        .where(eq(vatSettings.isActive, true))
        .orderBy(desc(vatSettings.effectiveDate))
        .limit(1);
      
      res.json({ 
        success: true, 
        exemptions: currentVat || { exemptCategories: [], exemptProductIds: [] }
      });
    } catch (error) {
      console.error('Error fetching VAT exemptions:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¹Ø§ÙÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒØ§ØªÛŒ" });
    }
  });

  // ============================================================================
  // FINANCIAL DEPARTMENT ROUTES
  // ============================================================================

  // Financial login
  app.post('/api/financial/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      // Check if user exists and has financial department access
      const [user] = await db
        .select()
        .from(schema.users)
        .where(and(
          eq(schema.users.username, username),
          eq(schema.users.department, 'financial'),
          eq(schema.users.isActive, true)
        ));

      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Update last login
      await db
        .update(schema.users)
        .set({ lastLoginAt: new Date() })
        .where(eq(schema.users.id, user.id));

      // Set session
      req.session.departmentUser = {
        id: user.id,
        username: user.username,
        department: user.department || 'financial'
      };

      res.json({ 
        success: true, 
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚", 
        user: { 
          id: user.id, 
          username: user.username, 
          department: user.department 
        } 
      });
    } catch (error) {
      console.error('Financial login error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" });
    }
  });

  // Financial logout
  app.post('/api/financial/logout', (req, res) => {
    req.session.departmentUser = undefined;
    res.json({ success: true, message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚" });
  });

  // Get approved financial orders (completed financial approval)
  app.get('/api/financial/approved-orders', async (req, res) => {
    try {
      console.log('âœ… [APPROVED ORDERS] Fetching financially approved orders...');
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          om.*,
          co.order_number,
          co.total_amount,
          co.currency,
          co.customer_id,
          co.guest_email,
          co.guest_name,
          co.payment_method,
          co.payment_status,
          co.status as customer_status,
          co.invoice_type,
          co.invoice_converted_at,
          -- Customer info from CRM
          CONCAT(crm.first_name, ' ', crm.last_name) as customer_name,
          crm.phone as customer_phone,
          crm.email as customer_email,
          crm.address as customer_address,
          crm.city_region as customer_city_region
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        LEFT JOIN crm_customers crm ON co.customer_id = crm.id
        WHERE om.current_status IN ('warehouse_pending', 'warehouse_ready', 'logistics_pending', 'out_for_delivery', 'delivered')
          AND om.financial_reviewed_at IS NOT NULL
          AND om.financial_reviewer_id IS NOT NULL
        ORDER BY om.financial_reviewed_at DESC
        LIMIT 50
      `);
      
      // Helper function for payment source labels
      function getPaymentSourceLabel(paymentMethod: string) {
        switch(paymentMethod) {
          case 'wallet_full': return 'Ú©ÛŒÙ Ù¾ÙˆÙ„ (Ú©Ø§Ù…Ù„)';
          case 'wallet_partial': return 'ØªØ±Ú©ÛŒØ¨ÛŒ (Ú©ÛŒÙ Ù¾ÙˆÙ„ + Ø¨Ø§Ù†Ú©)';
          case 'online_payment': return 'Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ';
          case 'bank_transfer_grace': return 'Ù…Ù‡Ù„Øªâ€ŒØ¯Ø§Ø± (Ø­ÙˆØ§Ù„Ù‡ Ø¨Ø§Ù†Ú©ÛŒ)';
          default: return 'Ù†Ø§Ù…Ø´Ø®Øµ';
        }
      }
      
      const mappedOrders = result.rows.map(row => ({
        id: row.id,
        customerOrderId: row.customer_order_id,
        orderNumber: row.order_number,
        currentStatus: row.current_status,
        paymentMethod: row.payment_method || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        paymentSourceLabel: getPaymentSourceLabel(row.payment_method),
        totalAmount: row.total_amount || '0',
        customerName: row.customer_name || row.guest_email || 'Ù…Ø´ØªØ±ÛŒ Ù†Ø§Ø´Ù†Ø§Ø³',
        customerEmail: row.customer_email || row.guest_email,
        customerPhone: row.customer_phone || null,
        createdAt: row.created_at,
        financialNotes: row.financial_notes,
        financialReviewedAt: row.financial_reviewed_at,
        invoiceType: row.invoice_type,
        invoiceConvertedAt: row.invoice_converted_at,
        shippingAddress: {
          name: row.customer_name || 'Ù†Ø§Ù… Ù†Ø§Ù…Ø´Ø®Øµ',
          phone: row.customer_phone || '',
          address: row.customer_address || '',
          city: row.customer_city_region || '',
          postalCode: ''
        }
      }));
      
      console.log(`âœ… [APPROVED ORDERS] Found ${mappedOrders.length} approved orders`);
      
      res.json(mappedOrders);
    } catch (error) {
      console.error('âŒ [APPROVED ORDERS] Error fetching approved orders:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡" 
      });
    }
  });

  // Financial auth check - temporary solution for session issue
  app.get('/api/financial/auth/me', (req: any, res) => {
    // Temporary user for testing VAT management
    const tempUser = {
      id: 1,
      username: 'financial_temp',
      department: 'financial'
    };
    
    // Set session for consistency
    req.session.departmentUser = tempUser;
    
    res.json({ 
      success: true, 
      user: tempUser 
    });
  });

  // Get financial pending orders  
  // Get orphaned orders - orders that need special attention (either missing order_management or stuck in problematic states)
  app.get('/api/financial/orphaned-orders', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ§Ÿ [ORPHANED ORDERS] Fetching orphaned and problematic orders...');
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          co.id,
          co.order_number as "orderNumber",
          COALESCE(co.guest_name, 'Ù†Ø§Ù…Ø´Ø®Øµ') as "customerName", 
          co.guest_email as "customerEmail",
          co.recipient_mobile as "customerPhone",
          co.total_amount as "totalAmount",
          co.currency,
          co.payment_method as "paymentMethod",
          co.payment_status as "paymentStatus",
          co.status,
          co.created_at as "createdAt",
          co.updated_at as "updatedAt",
          co.shipping_address as "shippingAddress",
          co.billing_address as "billingAddress",
          co.notes,
          om.current_status as "managementStatus",
          CASE 
            WHEN om.id IS NULL THEN 'ÛŒØªÛŒÙ… - ÙØ§Ù‚Ø¯ Ø±Ú©ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØª'
            WHEN (om.current_status = 'pending' AND co.status = 'pending' AND co.payment_status = 'pending' AND co.payment_method = 'online_payment') THEN 'Ù†ÛŒÙ…Ù‡ ØªÙ…Ø§Ù… - Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§ØªÙ…Ø§Ù… Ø¯Ø± Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ'
            WHEN (co.payment_method = 'bank_transfer_grace' AND co.status IN ('pending', 'awaiting_payment') AND co.payment_status IN ('pending', 'grace_period') AND COALESCE(co.notification_stage, 0) > 0) THEN 'Ù…Ù‡Ù„Øª Ø³Ù‡ Ø±ÙˆØ²Ù‡ - Ø¯Ø± Ø­Ø§Ù„ Ø§Ø·Ù„Ø§Ø¹ Ø±Ø³Ø§Ù†ÛŒ'
            WHEN (om.current_status = 'payment_uploaded' AND co.payment_method = 'bank_transfer_grace' AND co.payment_status = 'receipt_uploaded') THEN 'Ù…Ø¹Ù„Ù‚ - Ø­ÙˆØ§Ù„Ù‡ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯Ù‡'
            ELSE 'Ù…Ø´Ú©ÙˆÚ© - Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ'
          END as "orphanType"
        FROM customer_orders co
        LEFT JOIN order_management om ON co.id = om.customer_order_id
        WHERE (
          -- 1. Truly orphaned orders (no order_management)
          om.id IS NULL
          OR
          -- 2. All pending/pending orders that failed bank payment (immediately include them)
          (om.current_status = 'pending' AND co.status = 'pending' AND co.payment_status = 'pending' AND co.payment_method = 'online_payment' AND COALESCE(co.notification_stage, 0) = 0)
          OR
          -- 3. Grace period orders with notifications in progress (exclude from main workflow)
          (co.payment_method = 'bank_transfer_grace' AND co.status IN ('pending', 'awaiting_payment') AND co.payment_status IN ('pending', 'grace_period') AND COALESCE(co.notification_stage, 0) > 0)
          OR
          -- 4. Bank transfer receipts uploaded but stuck in financial review
          (om.current_status = 'payment_uploaded' AND co.payment_method = 'bank_transfer_grace' AND co.payment_status = 'receipt_uploaded' AND co.updated_at < NOW() - INTERVAL '2 hours')
        )
        ORDER BY co.created_at DESC
      `);
      
      const orphanedOrders = result.rows;
      console.log(`ğŸ§Ÿ [ORPHANED ORDERS] Found ${orphanedOrders.length} orphaned/problematic orders`);
      
      if (orphanedOrders.length > 0) {
        console.log('ğŸ§Ÿ [ORPHANED ORDERS] Sample orphaned order:', JSON.stringify(orphanedOrders[0], null, 2));
      }
      
      // Categorize by orphan type
      const categorized = {
        trulyOrphaned: orphanedOrders.filter(o => o.orphanType === 'ÛŒØªÛŒÙ… - ÙØ§Ù‚Ø¯ Ø±Ú©ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØª'),
        incompleteBankPayment: orphanedOrders.filter(o => o.orphanType === 'Ù†ÛŒÙ…Ù‡ ØªÙ…Ø§Ù… - Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§ØªÙ…Ø§Ù… Ø¯Ø± Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ'),
        gracePeriodNotifications: orphanedOrders.filter(o => o.orphanType === 'Ù…Ù‡Ù„Øª Ø³Ù‡ Ø±ÙˆØ²Ù‡ - Ø¯Ø± Ø­Ø§Ù„ Ø§Ø·Ù„Ø§Ø¹ Ø±Ø³Ø§Ù†ÛŒ'),
        stuckBankTransfers: orphanedOrders.filter(o => o.orphanType === 'Ù…Ø¹Ù„Ù‚ - Ø­ÙˆØ§Ù„Ù‡ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯Ù‡'),
        suspicious: orphanedOrders.filter(o => o.orphanType === 'Ù…Ø´Ú©ÙˆÚ© - Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ')
      };
      
      console.log('ğŸ“Š [ORPHANED CATEGORIZATION]:', {
        total: orphanedOrders.length,
        trulyOrphaned: categorized.trulyOrphaned.length,
        incompleteBankPayment: categorized.incompleteBankPayment.length,
        gracePeriodNotifications: categorized.gracePeriodNotifications.length,
        stuckBankTransfers: categorized.stuckBankTransfers.length,
        suspicious: categorized.suspicious.length
      });
      
      res.json({ 
        success: true, 
        orders: orphanedOrders,
        categorized: categorized,
        totalOrphaned: orphanedOrders.length,
        stats: {
          total: orphanedOrders.length,
          trulyOrphaned: categorized.trulyOrphaned.length,
          incompleteBankPayment: categorized.incompleteBankPayment.length,
          stuckBankTransfers: categorized.stuckBankTransfers.length,
          suspicious: categorized.suspicious.length
        }
      });
    } catch (error) {
      console.error('âŒ [ORPHANED ORDERS] Error fetching orphaned orders:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª ÛŒØªÛŒÙ…' 
      });
    }
  });

  // Repair orphaned order - create missing order_management record
  app.post('/api/financial/orphaned-orders/:customerOrderId/repair', requireAuth, async (req, res) => {
    try {
      const customerOrderId = parseInt(req.params.customerOrderId);
      const adminId = req.session.adminId || 1;
      
      console.log(`ğŸ”§ [REPAIR ORPHANED] Repairing orphaned order ${customerOrderId}`);
      
      // Get customer order details
      const { pool } = await import('./db');
      const orderResult = await pool.query(`
        SELECT * FROM customer_orders WHERE id = $1
      `, [customerOrderId]);
      
      if (orderResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }
      
      const order = orderResult.rows[0];
      
      // Check if order_management record already exists
      const managementResult = await pool.query(`
        SELECT id FROM order_management WHERE customer_order_id = $1
      `, [customerOrderId]);
      
      if (managementResult.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: 'Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ Ø¯ÛŒÚ¯Ø± ÛŒØªÛŒÙ… Ù†ÛŒØ³Øª'
        });
      }
      
      // Create order_management record
      const insertResult = await pool.query(`
        INSERT INTO order_management (
          customer_order_id,
          current_status,
          total_amount,
          currency,
          order_number,
          customer_first_name,
          customer_last_name,
          customer_email,
          customer_phone,
          payment_method,
          created_at,
          updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING *
      `, [
        customerOrderId,
        'pending', // Default status
        order.total_amount?.toString() || '0',
        order.currency || 'IQD',
        order.order_number,
        order.customer_first_name || order.customer_name?.split(' ')[0] || '',
        order.customer_last_name || order.customer_name?.split(' ')[1] || '',
        order.customer_email || '',
        order.customer_phone || '',
        order.payment_method || '',
        new Date(),
        new Date()
      ]);
      
      const newManagementRecord = insertResult.rows[0];
      
      console.log(`âœ… [REPAIR ORPHANED] Successfully repaired order ${order.order_number}`);
      console.log(`ğŸ“‹ [REPAIR ORPHANED] Created management record with ID: ${newManagementRecord.id}`);
      
      res.json({
        success: true,
        message: 'Ø³ÙØ§Ø±Ø´ ÛŒØªÛŒÙ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ¹Ù…ÛŒØ± Ø´Ø¯',
        data: {
          customerOrder: order,
          managementRecord: newManagementRecord
        }
      });
      
    } catch (error) {
      console.error('âŒ [REPAIR ORPHANED] Error repairing orphaned order:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ¹Ù…ÛŒØ± Ø³ÙØ§Ø±Ø´ ÛŒØªÛŒÙ…'
      });
    }
  });

  app.get('/api/financial/orders', async (req, res) => {
    try {
      console.log('ğŸ” [FINANCIAL ORDERS] Fetching all orders for financial department');
      
      // Use direct SQL to get all orders that need financial review
      const result = await customerPool.query(`
        SELECT 
          om.id,
          om.customer_order_id as "customerOrderId",
          om.current_status as "currentStatus",
          om.delivery_code as "deliveryCode",
          om.financial_reviewer_id as "financialReviewerId",
          om.financial_reviewed_at as "financialReviewedAt",
          om.financial_notes as "financialNotes",
          om.payment_receipt_url as "paymentReceiptUrl",
          om.warehouse_assignee_id as "warehouseAssigneeId",
          om.warehouse_processed_at as "warehouseProcessedAt",
          om.warehouse_notes as "warehouseNotes",
          om.logistics_assignee_id as "logisticsAssigneeId",
          om.logistics_processed_at as "logisticsProcessedAt",
          om.logistics_notes as "logisticsNotes",
          om.created_at as "createdAt",
          om.updated_at as "updatedAt",
          om.total_weight as "totalWeight",
          om.weight_unit as "weightUnit",
          om.delivery_method as "deliveryMethod",
          om.transportation_type as "transportationType",
          om.tracking_number as "trackingNumber",
          om.estimated_delivery_date as "estimatedDeliveryDate",
          om.actual_delivery_date as "actualDeliveryDate",
          om.delivery_person_name as "deliveryPersonName",
          om.delivery_person_phone as "deliveryPersonPhone",
          om.postal_service_name as "postalServiceName",
          om.postal_tracking_code as "postalTrackingCode",
          om.vehicle_type as "vehicleType",
          om.vehicle_plate as "vehiclePlate",
          om.vehicle_model as "vehicleModel",
          om.vehicle_color as "vehicleColor",
          om.driver_name as "driverName",
          om.driver_phone as "driverPhone",
          om.delivery_company_name as "deliveryCompanyName",
          om.delivery_company_phone as "deliveryCompanyPhone",
          -- Customer Order fields
          co.total_amount as "totalAmount",
          co.currency,
          co.order_number as "orderNumber",
          co.payment_method as "paymentMethod",
          co.payment_status as "paymentStatus",
          co.status as "orderStatus",
          co.shipping_address as "shippingAddress",
          co.billing_address as "billingAddress",
          co.recipient_name as "recipientName",
          co.recipient_phone as "recipientPhone",
          co.recipient_address as "recipientAddress",
          co.delivery_notes as "deliveryNotes",
          co.gps_latitude as "gpsLatitude",
          co.gps_longitude as "gpsLongitude",
          co.location_accuracy as "locationAccuracy",
          co.receipt_path as "receiptUrl",
          co.guest_name,
          co.guest_email,
          -- Customer info
          c.first_name as "customerFirstName",
          c.last_name as "customerLastName", 
          c.email as "customerEmail",
          c.phone as "customerPhone",
          -- Payment Receipt info
          pr.original_file_name as "receiptFileName",
          pr.mime_type as "receiptMimeType"
        FROM order_management om
        INNER JOIN customer_orders co ON om.customer_order_id = co.id
        LEFT JOIN crm_customers c ON co.customer_id = c.id
        LEFT JOIN payment_receipts pr ON pr.customer_order_id = co.id
        WHERE om.current_status IN (
          'pending',
          'pending_payment',
          'payment_uploaded', 
          'financial_reviewing',
          'financial_rejected',
          'warehouse_pending',
          'warehouse_processing',
          'warehouse_approved'
        )
        -- Exclude incomplete bank payment orders (pending/pending) from main list
        AND NOT (om.current_status = 'pending' AND co.status = 'pending' AND co.payment_status = 'pending')
        -- Ensure order_management record exists (exclude true orphans)
        AND om.id IS NOT NULL
        ORDER BY om.created_at ASC
      `);
      
      console.log(`ğŸ’° [FINANCIAL ORDERS] Found ${result.rows.length} orders for financial review`);
      
      const orders = result.rows.map(row => ({
        id: row.id,
        customerOrderId: row.customerOrderId,
        currentStatus: row.currentStatus,
        deliveryCode: row.deliveryCode,
        financialReviewerId: row.financialReviewerId,
        financialReviewedAt: row.financialReviewedAt,
        financialNotes: row.financialNotes,
        paymentReceiptUrl: row.paymentReceiptUrl,
        warehouseAssigneeId: row.warehouseAssigneeId,
        warehouseProcessedAt: row.warehouseProcessedAt,
        warehouseNotes: row.warehouseNotes,
        logisticsAssigneeId: row.logisticsAssigneeId,
        logisticsProcessedAt: row.logisticsProcessedAt,
        logisticsNotes: row.logisticsNotes,
        createdAt: row.createdAt,
        updatedAt: row.updatedAt,
        totalWeight: row.totalWeight,
        weightUnit: row.weightUnit,
        deliveryMethod: row.deliveryMethod,
        transportationType: row.transportationType,
        trackingNumber: row.trackingNumber,
        estimatedDeliveryDate: row.estimatedDeliveryDate,
        actualDeliveryDate: row.actualDeliveryDate,
        deliveryPersonName: row.deliveryPersonName,
        deliveryPersonPhone: row.deliveryPersonPhone,
        postalServiceName: row.postalServiceName,
        postalTrackingCode: row.postalTrackingCode,
        vehicleType: row.vehicleType,
        vehiclePlate: row.vehiclePlate,
        vehicleModel: row.vehicleModel,
        vehicleColor: row.vehicleColor,
        driverName: row.driverName,
        driverPhone: row.driverPhone,
        deliveryCompanyName: row.deliveryCompanyName,
        deliveryCompanyPhone: row.deliveryCompanyPhone,
        totalAmount: row.totalAmount,
        currency: row.currency,
        orderNumber: row.orderNumber,
        paymentMethod: row.paymentMethod,
        paymentStatus: row.paymentStatus,
        orderStatus: row.orderStatus,
        customerFirstName: row.customerFirstName,
        customerLastName: row.customerLastName,
        customerEmail: row.customerEmail,
        customerPhone: row.customerPhone,
        shippingAddress: row.shippingAddress,
        billingAddress: row.billingAddress,
        recipientName: row.recipientName,
        recipientPhone: row.recipientPhone,
        recipientAddress: row.recipientAddress,
        deliveryNotes: row.deliveryNotes,
        gpsLatitude: row.gpsLatitude,
        gpsLongitude: row.gpsLongitude,
        locationAccuracy: row.locationAccuracy,
        receiptUrl: row.receiptUrl,
        receiptFileName: row.receiptFileName,
        receiptMimeType: row.receiptMimeType,
        // Compatibility with UI
        customerName: row.guest_name || `${row.customerFirstName || ''} ${row.customerLastName || ''}`.trim()
      }));

      res.json({ success: true, orders });
    } catch (error) {
      console.error('âŒ [FINANCIAL ORDERS] Error fetching financial orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª" });
    }
  });

  // Ù„ÛŒØ³Øª Ø³ÙØ§Ø±Ø´Ø§Øª Ù…ÙˆÙ‚Øª (Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ Ùˆ Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª)
  app.get('/api/financial/temporary-orders', async (req, res) => {
    try {
      const result = await customerPool.query(`
        SELECT om.*, co.order_number, co.total_amount, co.currency,
               co.guest_name, co.guest_email, 
               co.created_at, co.shipping_address, co.billing_address
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE co.order_number LIKE '%TEST%' 
           OR co.order_number LIKE '%DEMO%' 
           OR co.order_number LIKE '%TEMP%'
           OR om.current_status = 'temporary'
        ORDER BY om.created_at DESC
      `);
      
      const transformedOrders = result.rows.map(row => ({
        id: row.id,
        customerOrderId: row.customer_order_id,
        orderNumber: row.order_number,
        currentStatus: row.current_status,
        totalAmount: row.total_amount,
        currency: row.currency,
        customerName: row.guest_name || '',
        customerEmail: row.guest_email,
        createdAt: row.created_at,
        shippingAddress: row.shipping_address,
        billingAddress: row.billing_address
      }));

      res.json({ success: true, orders: transformedOrders });
    } catch (error) {
      console.error('âŒ [TEMPORARY ORDERS] Error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ù…ÙˆÙ‚Øª",
        error: error.message 
      });
    }
  });

  // Ù„ÛŒØ³Øª Ø³ÙØ§Ø±Ø´Ø§Øª ÛŒØªÛŒÙ… (Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ú©Ø§Ù…Ù„ Ø§Ø² Ø¯Ø±Ú¯Ø§Ù‡ Ø¨Ø§Ù†Ú©ÛŒ)
  app.get('/api/financial/orphaned-orders', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ§Ÿ [ORPHANED ORDERS] Fetching orphaned and problematic orders...');
      
      // Query for orphaned orders (orders without management records)
      const orphanedResult = await customerPool.query(`
        SELECT 
          co.id,
          co.order_number,
          co.total_amount,
          co.currency,
          co.guest_name,
          co.guest_email,
          NULL as guest_phone,
          co.created_at,
          co.updated_at,
          co.shipping_address,
          co.billing_address,
          co.payment_method,
          co.payment_status,
          co.status,
          co.notes,
          NULL as management_status,
          'orphaned' as orphan_type
        FROM customer_orders co
        LEFT JOIN order_management om ON co.id = om.customer_order_id
        WHERE om.customer_order_id IS NULL
        
        UNION ALL
        
        -- Query for problematic orders (stuck in pending payment states)
        SELECT 
          co.id,
          co.order_number,
          co.total_amount,
          co.currency,
          co.guest_name,
          co.guest_email,
          NULL as guest_phone,
          co.created_at,
          co.updated_at,
          co.shipping_address,
          co.billing_address,
          co.payment_method,
          co.payment_status,
          co.status,
          co.notes,
          om.current_status as management_status,
          CASE 
            WHEN co.payment_method = 'online_payment' AND co.payment_status = 'pending' THEN 'Ù…Ø¹Ù„Ù‚ - Ù¾Ø±Ø¯Ø§Ø®Øª Ø¢Ù†Ù„Ø§ÛŒÙ† Ù†Ø§ØªÙ…Ø§Ù…'
            WHEN co.payment_method = 'bank_transfer_grace' AND co.payment_status = 'receipt_uploaded' THEN 'Ù…Ø¹Ù„Ù‚ - Ø­ÙˆØ§Ù„Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯Ù‡'
            WHEN co.payment_method = 'bank_transfer_grace' AND co.payment_status = 'pending' THEN 'Ù…Ø¹Ù„Ù‚ - Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø­ÙˆØ§Ù„Ù‡'
            ELSE 'Ø³Ø§ÛŒØ± Ù…ÙˆØ§Ø±Ø¯ Ù…Ø¹Ù„Ù‚'
          END as orphan_type
        FROM customer_orders co
        INNER JOIN order_management om ON co.id = om.customer_order_id
        WHERE (co.payment_method = 'online_payment' AND co.payment_status = 'pending')
           OR (co.payment_method = 'bank_transfer_grace' AND co.payment_status IN ('pending', 'receipt_uploaded'))
           OR (om.current_status IN ('pending', 'payment_uploaded', 'payment_incomplete'))
        
        ORDER BY created_at DESC
      `);
      
      console.log(`ğŸ§Ÿ [ORPHANED ORDERS] Found ${orphanedResult.rows.length} orphaned/problematic orders`);
      
      if (orphanedResult.rows.length > 0) {
        console.log('ğŸ§Ÿ [ORPHANED ORDERS] Sample orphaned order:', JSON.stringify(orphanedResult.rows[0], null, 2));
      }
      
      const transformedOrders = orphanedResult.rows.map(row => ({
        id: row.id,
        orderNumber: row.order_number,
        customerName: row.guest_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        customerEmail: row.guest_email,
        customerPhone: row.guest_phone,
        totalAmount: row.total_amount,
        currency: row.currency,
        paymentMethod: row.payment_method,
        paymentStatus: row.payment_status,
        status: row.status,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        shippingAddress: row.shipping_address,
        billingAddress: row.billing_address,
        notes: row.notes,
        managementStatus: row.management_status,
        orphanType: row.orphan_type
      }));
      
      // Statistics for categorization
      const stats = {
        total: transformedOrders.length,
        trulyOrphaned: transformedOrders.filter(order => order.orphanType === 'orphaned').length,
        stuckOnlinePayments: transformedOrders.filter(order => order.orphanType === 'Ù…Ø¹Ù„Ù‚ - Ù¾Ø±Ø¯Ø§Ø®Øª Ø¢Ù†Ù„Ø§ÛŒÙ† Ù†Ø§ØªÙ…Ø§Ù…').length,
        stuckBankTransfers: transformedOrders.filter(order => order.orphanType === 'Ù…Ø¹Ù„Ù‚ - Ø­ÙˆØ§Ù„Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯Ù‡').length,
        suspicious: transformedOrders.filter(order => order.orphanType === 'Ø³Ø§ÛŒØ± Ù…ÙˆØ§Ø±Ø¯ Ù…Ø¹Ù„Ù‚').length
      };
      
      console.log('ğŸ“Š [ORPHANED CATEGORIZATION]:', JSON.stringify(stats, null, 2));

      res.json({ 
        success: true, 
        orders: transformedOrders,
        stats: stats
      });
    } catch (error) {
      console.error('âŒ [ORPHANED ORDERS] Error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ÛŒØªÛŒÙ…",
        error: error.message 
      });
    }
  });

  // Migrate customer orders to order management system
  app.post('/api/admin/migrate-customer-orders', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ”„ [ADMIN] Starting customer orders migration...');
      await orderManagementStorage.migrateCustomerOrdersToManagement();
      res.json({ 
        success: true, 
        message: "Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø´ØªØ±ÛŒØ§Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯Ù†Ø¯" 
      });
    } catch (error) {
      console.error('Error migrating customer orders:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø³ÙØ§Ø±Ø´Ø§Øª: " + error.message 
      });
    }
  });

  // [REMOVED] Removed duplicate endpoint - using the comprehensive one above (line 25196)

  // Process financial order
  app.post('/api/financial/orders/:id/process', requireDepartmentAuth('financial'), async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { action, notes, reviewerId } = req.body;
      
      if (action === 'approve') {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'financial_approved',
          reviewerId,
          'financial',
          notes || 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
        );
      } else {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'financial_rejected',
          reviewerId,
          'financial',
          notes || 'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
        );
      }

      res.json({ success: true, message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯" });
    } catch (error) {
      console.error('Error processing financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´" });
    }
  });

  // REMOVED: Duplicate route definition that was blocking requests with requireAuth middleware

  // Financial approve order (for financial department users)
  app.get('/api/finance/orders/:id/approve', requireDepartmentAuth('financial'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const reviewerId = req.session.departmentUser?.id;
      
      if (!reviewerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      
      // Use warehouse_pending status from schema to properly transfer to warehouse
      const { orderStatuses } = await import('../shared/order-management-schema');
      await orderManagementStorage.updateOrderStatus(
        orderId,
        orderStatuses.WAREHOUSE_PENDING, // Transfer directly to warehouse pending
        reviewerId,
        'financial',
        'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ - Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø±'
      );

      // Send website notification and email to customer (NO SMS)
      const orderMgmt = await orderManagementStorage.getOrderManagementById(orderId);
      if (orderMgmt) {
        // TODO: Send website notification and email notification
        console.log(`âœ“ ÙˆØ§Ø±ÛŒØ²ÛŒ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ - Ø³ÙØ§Ø±Ø´ ${orderMgmt.customerOrderId}`);
        console.log('âœ“ ØªØ£ÛŒÛŒØ¯ Ø§Ø² Ø·Ø±ÛŒÙ‚ ÙˆØ¨â€ŒØ³Ø§ÛŒØª Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (Ø¨Ø¯ÙˆÙ† SMS)');
      }

      res.json({ success: true, message: "ÙˆØ§Ø±ÛŒØ²ÛŒ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø¹Ù„Ø§Ù… Ø´Ø¯" });
    } catch (error) {
      console.error('Error approving financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ ÙˆØ§Ø±ÛŒØ²ÛŒ" });
    }
  });

  // Financial reject order (for admin panel)
  app.post('/api/finance/orders/:id/reject', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { notes } = req.body;
      const adminId = req.session.adminId!;
      
      await orderManagementStorage.updateOrderStatus(
        orderId,
        'financial_rejected',
        adminId,
        'financial',
        notes || 'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
      );

      // Send website notification and email to customer (NO SMS)
      const orderMgmt = await orderManagementStorage.getOrderManagementById(orderId);
      if (orderMgmt) {
        // TODO: Send website notification and email notification
        console.log(`âœ— ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯ - Ø³ÙØ§Ø±Ø´ ${orderMgmt.customerOrderId}`);
        console.log('âœ“ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ ÙˆØ¨â€ŒØ³Ø§ÛŒØª Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (Ø¨Ø¯ÙˆÙ† SMS)');
      }

      res.json({ success: true, message: "ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error rejecting financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ ÙˆØ§Ø±ÛŒØ²ÛŒ" });
    }
  });

  // Financial reject order (for financial department users)
  app.get('/api/finance/orders/:id/reject', requireDepartmentAuth('financial'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const reviewerId = req.session.departmentUser?.id;
      
      if (!reviewerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      
      await orderManagementStorage.updateOrderStatus(
        orderId,
        'financial_rejected',
        reviewerId,
        'financial',
        'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
      );

      // Send website notification and email to customer (NO SMS)
      const orderMgmt = await orderManagementStorage.getOrderManagementById(orderId);
      if (orderMgmt) {
        // TODO: Send website notification and email notification
        console.log(`âœ— ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯ - Ø³ÙØ§Ø±Ø´ ${orderMgmt.customerOrderId}`);
        console.log('âœ“ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ ÙˆØ¨â€ŒØ³Ø§ÛŒØª Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (Ø¨Ø¯ÙˆÙ† SMS)');
      }

      res.json({ success: true, message: "ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error rejecting financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ ÙˆØ§Ø±ÛŒØ²ÛŒ" });
    }
  });

  // ============================================================================
  // PASSWORD MANAGEMENT API
  // ============================================================================

  // Get customer password (admin only)
  app.get('/api/admin/customers/:id/password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: { 
          hasPassword: !!customer.password,
          password: customer.password // Only return to admin
        }
      });
    } catch (error) {
      console.error('Error fetching customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª" });
    }
  });

  // Change customer password (admin only)
  app.post('/api/admin/customers/:id/change-password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { newPassword, sendEmail = true, sendSMS = false } = req.body;
      
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Hash the new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update password in database
      await crmStorage.updateCrmCustomer(customerId, { passwordHash: hashedPassword });
      
      // Send email notification if requested
      if (sendEmail) {
        console.log(`[PASSWORD CHANGE] Sending email to ${customer.email} for customer ${customer.firstName} ${customer.lastName}`);
        const emailResult = await emailService.sendPasswordChangeNotification(
          customer.email,
          `${customer.firstName} ${customer.lastName}`,
          newPassword
        );
        console.log(`[PASSWORD CHANGE] Email result: ${emailResult ? 'Success' : 'Failed'}`);
      }
      
      // Log activity
      await crmStorage.logActivity({
        customerId: customerId,
        activityType: 'password_changed',
        description: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± Ø³ÛŒØ³ØªÙ… ØªØºÛŒÛŒØ± ÛŒØ§ÙØª',
        performedBy: req.session.adminId || 'system'
      });
      
      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª" + (sendEmail ? " Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" : "")
      });
    } catch (error) {
      console.error('Error changing customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Request password reset (customer)
  app.post('/api/customers/request-password-reset', async (req, res) => {
    try {
      const { email } = req.body;
      
      console.log(`ğŸ“§ [Password Reset Request] Email: ${email}`);
      
      const customer = await crmStorage.getCrmCustomerByEmail(email);
      if (!customer) {
        // Don't reveal if email exists or not
        console.log(`âš ï¸ [Password Reset] Customer not found for email: ${email}`);
        return res.json({ success: true, message: "Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒØŒ Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
      }
      
      console.log(`âœ“ [Password Reset] Customer found: ${customer.firstName} ${customer.lastName} (ID: ${customer.id})`);
      
      // Generate reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1 hour (was 24 hours)
      
      console.log(`ğŸ”‘ [Password Reset] Generated token: ${resetToken.substring(0, 8)}... (expires in 1 hour)`);
      
      // Update customer with reset token directly with SQL
      await crmDb.execute(sql`
        UPDATE crm_customers 
        SET reset_password_token = ${resetToken}, 
            reset_password_expires = ${resetExpires.toISOString()}
        WHERE id = ${customer.id}
      `);
      
      console.log(`ğŸ’¾ [Password Reset] Token saved to database for customer ID: ${customer.id}`);
      
      // Import Universal Email Service
      const { UniversalEmailService } = await import('./universal-email-service');
      
      // Send reset email using Universal Email Service with noreply@momtazchem.com
      const emailResult = await UniversalEmailService.sendPasswordResetEmail(
        customer.email,
        resetToken,
        `${customer.firstName} ${customer.lastName}`,
        req
      );
      
      console.log(`ğŸ“§ [Password Reset] Email send result: ${emailResult ? 'Success' : 'Failed'}`);
      
      // Log activity in CRM
      await crmStorage.logActivity({
        customerId: customer.id,
        activityType: 'password_reset_requested',
        description: 'Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§ÛŒÙ…ÛŒÙ„',
        performedBy: 'customer'
      });
      
      res.json({ success: true, message: "Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ù‡ Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
    } catch (error) {
      console.error('âŒ [Password Reset] Error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Reset password with token (customer)
  app.post('/api/customers/reset-password', async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      
      // Find customer by reset token
      const customer = await crmStorage.getCrmCustomerByResetToken(token);
      if (!customer) {
        return res.status(400).json({ success: false, message: "Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }
      
      // Check if token is expired
      const now = new Date();
      const tokenExpiry = new Date(customer.resetPasswordExpires);
      if (now > tokenExpiry) {
        return res.status(400).json({ success: false, message: "Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }
      
      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update password and clear reset token
      await crmStorage.updateCrmCustomer(customer.id, {
        password: hashedPassword,
        resetPasswordToken: null,
        resetPasswordExpires: null
      });
      
      // Log activity
      await crmStorage.logActivity({
        customerId: customer.id,
        activityType: 'password_reset',
        description: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙˆØ³Ø· Ù…Ø´ØªØ±ÛŒ ØªØºÛŒÛŒØ± ÛŒØ§ÙØª',
        performedBy: 'customer'
      });
      
      res.json({ success: true, message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª" });
    } catch (error) {
      console.error('Error resetting password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // ============================================================================
  // ROLE-BASED ACCESS CONTROL API
  // ============================================================================

  // Get user permissions based on role
  app.get('/api/user/permissions', async (req, res) => {
    // Prevent caching for this endpoint
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    try {
      // Check for valid authentication - either admin or custom user
      if (!req.session || !req.session.isAuthenticated) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      
      const adminId = req.session.adminId;
      const customUserId = req.session.customUserId;
      
      if (!adminId && !customUserId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      // Handle custom users directly (First mapping section)
      if (customUserId) {
        const { pool } = await import('./db');
        const result = await pool.query(`
          SELECT cu.id, cu.full_name, cu.email, cu.role_id,
                 cr.name as role_name, cr.display_name as role_display_name, cr.permissions
          FROM custom_users cu
          LEFT JOIN custom_roles cr ON cu.role_id = cr.id
          WHERE cu.id = $1 AND cu.is_active = true
        `, [customUserId]);
        
        if (result.rows.length > 0) {
          const customUser = result.rows[0];
          
          // Parse permissions from JSON array
          const permissions = Array.isArray(customUser.permissions) 
            ? customUser.permissions 
            : JSON.parse(customUser.permissions || '[]');

          // Map Persian display names to technical module IDs
          const persianToTechnicalMap = {
            'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ (KPI)': 'kpi_dashboard',
            'Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ': 'management_dashboard',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„': 'email_settings',
            'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡': 'database_backup',
            'Ù…Ø¯ÛŒØ±ÛŒØª SEO': 'seo',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©': 'sms',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ': 'ai_settings',
            'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ': 'refresh_control',
            'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯': 'ticketing_system',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§': 'content_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯': 'barcode',
            'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'syncing_shop',
            'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'shop_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª': 'product_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª': 'order_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±': 'warehouse_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©': 'logistics_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª': 'inquiries',
            'Ù…Ø¯ÛŒØ±ÛŒØª CRM': 'crm',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡': 'factory',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†': 'user_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§': 'procedures',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª': 'payment_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ': 'finance',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„': 'wallet_management',
            'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ': 'geography_analytics',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§': 'categories',
            'Ø¯Ø³ØªÛŒØ§Ø± SEO Ù‡ÙˆØ´Ù…Ù†Ø¯': 'seo_management',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±': 'server_config',
            'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª': 'company_information',
            'User Guide': 'user_guide',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø³Ø§ÛŒØª': 'site_management',
            'Ù…Ø§Ú˜ÙˆÙ„ Ù…Ø§Ø±Ú©ØªÛŒÙ†Ú¯': 'marketing_module',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ùˆ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª': 'order_management'
          };

          // Convert Persian names to technical IDs
          const technicalModules = permissions.map(perm => 
            persianToTechnicalMap[perm] || perm
          ).filter(Boolean);

          console.log(`âœ“ [PERMISSIONS] Custom user ${customUser.email} has modules:`, permissions);
          console.log(`âœ“ [PERMISSIONS] Converted to technical IDs:`, technicalModules);

          return res.json({
            success: true,
            permissions: technicalModules.map(moduleId => ({
              moduleId,
              canView: true,
              canCreate: true,
              canEdit: true,
              canDelete: true,
              canApprove: true
            })),
            modules: technicalModules,
            roles: [customUser.role_id],
            roleInfo: {
              name: customUser.role_name,
              displayName: customUser.role_display_name
            }
          });
        }
        
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Get legacy user by adminId to find email
      const legacyUser = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, adminId))
        .limit(1);

      if (legacyUser.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Check if this is a custom user from user-management system using email
      const customUser = await db
        .select()
        .from(schema.customUsers)
        .where(eq(schema.customUsers.email, legacyUser[0].email))
        .limit(1);

      if (customUser.length > 0) {
        // Get user's role from custom_roles
        const userRole = await db
          .select()
          .from(schema.customRoles)
          .where(eq(schema.customRoles.id, customUser[0].roleId))
          .limit(1);

        if (userRole.length > 0) {
          // Parse permissions from JSON array
          const permissions = Array.isArray(userRole[0].permissions) 
            ? userRole[0].permissions 
            : JSON.parse(userRole[0].permissions || '[]');

          // Map Persian display names to technical module IDs
          const persianToTechnicalMap = {
            'Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ (KPI)': 'kpi_dashboard',
            'Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ': 'management_dashboard',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„': 'email_settings',
            'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡': 'database_backup',
            'Ù…Ø¯ÛŒØ±ÛŒØª SEO': 'seo',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©': 'sms',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ': 'ai_settings',
            'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ': 'refresh_control',
            'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯': 'ticketing_system',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§': 'content_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯': 'barcode',
            'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'syncing_shop',
            'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'shop_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª': 'product_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª': 'order_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±': 'warehouse_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©': 'logistics_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª': 'inquiries',
            'Ù…Ø¯ÛŒØ±ÛŒØª CRM': 'crm',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡': 'factory',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†': 'user_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§': 'procedures',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª': 'payment_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ': 'accounting_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ': 'finance',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„': 'wallet_management',
            'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ': 'geography_analytics',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§': 'categories',
            'Ø¯Ø³ØªÛŒØ§Ø± SEO Ù‡ÙˆØ´Ù…Ù†Ø¯': 'seo_management',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±': 'server_config',
            'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª': 'company_information',
            'User Guide': 'user_guide',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø³Ø§ÛŒØª': 'site_management',
            'Ù…Ø§Ú˜ÙˆÙ„ Ù…Ø§Ø±Ú©ØªÛŒÙ†Ú¯': 'marketing_module',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ùˆ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª': 'order_management'
          };

          // Convert Persian names to technical IDs
          const technicalModules = permissions.map(perm => 
            persianToTechnicalMap[perm] || perm
          ).filter(Boolean);

          console.log(`âœ“ [PERMISSIONS] User ${customUser[0].email} has modules:`, permissions);
          console.log(`âœ“ [PERMISSIONS] Converted to technical IDs:`, technicalModules);

          return res.json({
            success: true,
            permissions: technicalModules.map(moduleId => ({
              moduleId,
              canView: true,
              canCreate: true,
              canEdit: true,
              canDelete: true,
              canApprove: true
            })),
            modules: technicalModules,
            roles: [userRole[0].id],
            roleInfo: {
              name: userRole[0].name,
              displayName: userRole[0].displayName
            }
          });
        }
      }

      // If no custom user found, check for super admin or legacy permissions
      // admin@momtazchem.com (id=15) is the super admin
      console.log(`ğŸ” [DEBUG] Checking super admin path: ${legacyUser[0].id === 15} || ${legacyUser[0].email === 'admin@momtazchem.com'}`);
      if (legacyUser[0].id === 15 || legacyUser[0].email === 'admin@momtazchem.com') {
        console.log(`ğŸ” [DEBUG] SUPER ADMIN PATH ACTIVATED for ${legacyUser[0].email}`);
        const allModules = [
          "kpi_dashboard", "management_dashboard", "accounting_management",
          "syncing_shop", "inquiries", "barcode", "email_settings", "database_backup",
          "crm", "seo", "categories", "sms", "factory", "user_management",
          "shop_management", "procedures", "order_management", "product_management",
          "payment_management", "finance", "wallet_management", "geography_analytics", "ai_settings",
          "refresh_control", "content_management",
          "warehouse_management", "logistics_management", "ticketing_system", "remote_desktop",
          "server_config", "company_information", "user_guide", "site_management"
        ];
        
        console.log('ğŸ” [DEBUG] allModules array contains:', allModules.length, 'modules');
        console.log('ğŸ” [DEBUG] ticketing_system included?', allModules.includes('ticketing_system'));
        console.log('ğŸ” [DEBUG] server_config included?', allModules.includes('server_config'));

        // Convert any dash-separated module names to underscore format for consistency
        const normalizedModules = allModules.map(module => 
          module.replace(/-/g, '_')
        );
        
        console.log(`âœ“ [PERMISSIONS] Super admin ${legacyUser[0].email} has all modules:`, normalizedModules);
        console.log(`ğŸ” [DEBUG] kpi_dashboard in normalizedModules?`, normalizedModules.includes('kpi_dashboard'));
        console.log(`ğŸ” [DEBUG] management_dashboard in normalizedModules?`, normalizedModules.includes('management_dashboard'));

        // Convert technical module IDs to Persian names for super admin
        const persianModules = normalizedModules.map(moduleId => {
          const persianName = convertTechnicalToPersianModule(moduleId);
          if (moduleId === 'kpi_dashboard' || moduleId === 'management_dashboard') {
            console.log(`ğŸ” [DEBUG] Converting ${moduleId} â†’ ${persianName}`);
          }
          return persianName;
        });

        console.log(`âœ“ [PERMISSIONS] Super admin Persian modules:`, persianModules);
        console.log(`ğŸ” [DEBUG] Ú©ÛŒØ§ Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ (KPI) in persianModules?`, persianModules.includes('Ø´Ø§Ø®Øµâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ (KPI)'));
        console.log(`ğŸ” [DEBUG] Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ in persianModules?`, persianModules.includes('Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ'));
        console.log(`ğŸ” [DEBUG] finance mapping: ${normalizedModules.includes('finance')} â†’ ${persianModules.includes('Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ')}`);
        console.log(`ğŸ” [DEBUG] geography_analytics mapping: ${normalizedModules.includes('geography_analytics')} â†’ ${persianModules.includes('Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ')}`);

        return res.json({
          success: true,
          permissions: normalizedModules.map(moduleId => ({
            moduleId,
            canView: true,
            canCreate: true,
            canEdit: true,
            canDelete: true,
            canApprove: true
          })),
          modules: normalizedModules,
          persianModules: persianModules, // Add Persian names for frontend
          roles: ["super_admin"],
          roleInfo: {
            name: "super_admin",
            displayName: "Ù…Ø¯ÛŒØ± Ø§Ø±Ø´Ø¯"
          },
          timestamp: Date.now() // Force cache refresh
        });
      }

      // For other legacy users without custom role, return empty permissions
      console.log(`âœ— [PERMISSIONS] User ${legacyUser[0].email} has no role in custom system`);
      return res.json({
        success: true,
        permissions: [],
        modules: [],
        roles: [],
        roleInfo: null
      });

    } catch (error) {
      console.error('Error fetching user permissions:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¬ÙˆØ²Ù‡Ø§" });
    }
  });

  // Legacy fallback endpoint
  app.get('/api/user/permissions-legacy', async (req, res) => {
    try {
      const legacyUser = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, adminId))
        .limit(1);

      if (legacyUser.length > 0) {
        // For super admin, give access to all modules
        const allModules = [
          'syncing_shop', 'inquiry_management', 'barcode_management', 'email_management',
          'backup_management', 'crm_management', 'seo_management', 'category_management',
          'sms_management', 'factory_management', 'super_admin', 'user_management',
          'shop_management', 'procedures_management', 'order_management',
          'product_management', 'payment_management', 'wallet_management', 'geography_analytics',
          'ai_management', 'refresh_control',
          'content_management', 'ticketing_system', 'warehouse_management'
        ];

        console.log(`âœ“ [PERMISSIONS] Legacy/Super admin ${legacyUser[0].email} has all modules`);

        return res.json({
          success: true,
          permissions: allModules.map(moduleId => ({
            moduleId,
            canView: true,
            canCreate: true,
            canEdit: true,
            canDelete: true,
            canApprove: true
          })),
          modules: allModules,
          roles: ['super_admin'],
          roleInfo: {
            name: 'super_admin',
            displayName: 'Ù…Ø¯ÛŒØ± Ø§Ø±Ø´Ø¯'
          }
        });
      }

      // No user found
      return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });

    } catch (error) {
      console.error('Error fetching user permissions:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§" });
    }
  });

  // Get all available modules
  app.get('/api/modules/available', async (req, res) => {
    try {
      const modules = [
        { id: 'kardex-sync', name: 'Syncing Shop', category: 'inventory', icon: 'Database' },
        { id: 'inquiries', name: 'Inquiries', category: 'customer', icon: 'MessageSquare' },
        { id: 'barcode', name: 'Barcode', category: 'inventory', icon: 'QrCode' },
        { id: 'email-settings', name: 'Email Settings', category: 'communication', icon: 'Mail' },
        { id: 'database-backup', name: 'Database Backup', category: 'system', icon: 'Database' },
        { id: 'crm', name: 'CRM', category: 'customer', icon: 'Users' },
        { id: 'seo', name: 'SEO', category: 'marketing', icon: 'Globe' },
        { id: 'categories', name: 'Categories', category: 'inventory', icon: 'Box' },
        { id: 'sms', name: 'SMS', category: 'communication', icon: 'Smartphone' },
        { id: 'factory', name: 'Factory', category: 'operations', icon: 'Factory' },
        { id: 'super-admin', name: 'Super Admin', category: 'administration', icon: 'UserCog' },
        { id: 'user-management', name: 'User Management', category: 'administration', icon: 'Users2' },
        { id: 'shop', name: 'Shop', category: 'sales', icon: 'ShoppingCart' },
        { id: 'procedures', name: 'Procedures', category: 'operations', icon: 'BookOpen' },
        { id: 'order-management', name: 'Order Management', category: 'sales', icon: 'Truck' },
        { id: 'products', name: 'Products', category: 'inventory', icon: 'Package' },
        { id: 'payment-settings', name: 'Payment Settings', category: 'financial', icon: 'CreditCard' },
        { id: 'wallet-management', name: 'Wallet Management', category: 'financial', icon: 'Wallet' },
        { id: 'geography-analytics', name: 'Geography Analytics', category: 'analytics', icon: 'MapPin' },
        { id: 'ai-settings', name: 'AI Settings', category: 'system', icon: 'Zap' },
        { id: 'refresh-control', name: 'Refresh Control', category: 'system', icon: 'RefreshCw' },


        { id: 'content-management', name: 'Content Management', category: 'marketing', icon: 'Edit3' },
        { id: 'ticketing-system', name: 'Ticketing System', category: 'support', icon: 'Ticket' },
        { id: 'finance-orders', name: 'Financial Orders', category: 'financial', icon: 'DollarSign' },
        { id: 'warehouse-orders', name: 'Warehouse Orders', category: 'operations', icon: 'Warehouse' }
      ];

      res.json({ success: true, modules });
    } catch (error) {
      console.error('Error fetching available modules:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§" });
    }
  });

  // ============================================================================
  // WAREHOUSE DEPARTMENT ROUTES
  // ============================================================================

  // Warehouse login
  app.post('/api/warehouse/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      const [user] = await db
        .select()
        .from(schema.users)
        .where(and(
          eq(schema.users.username, username),
          eq(schema.users.department, 'warehouse'),
          eq(schema.users.isActive, true)
        ));

      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      await db
        .update(schema.users)
        .set({ lastLoginAt: new Date() })
        .where(eq(schema.users.id, user.id));

      req.session.departmentUser = {
        id: user.id,
        username: user.username,
        department: user.department || 'warehouse'
      };

      res.json({ 
        success: true, 
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚", 
        user: { 
          id: user.id, 
          username: user.username, 
          department: user.department 
        } 
      });
    } catch (error) {
      console.error('Warehouse login error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" });
    }
  });

  // Warehouse logout
  app.post('/api/warehouse/logout', (req, res) => {
    req.session.departmentUser = undefined;
    res.json({ success: true, message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚" });
  });

  // Warehouse auth check
  app.get('/api/warehouse/auth/me', requireDepartmentAuth('warehouse'), (req: any, res) => {
    res.json({ 
      success: true, 
      user: req.session.departmentUser 
    });
  });

  // Get warehouse pending orders (legacy endpoint - removed auth requirement)
  app.get('/api/warehouse/orders-legacy', async (req, res) => {
    try {
      const orders = await orderManagementStorage.getWarehousePendingOrders();
      res.json({ success: true, orders });
    } catch (error) {
      console.error('Error fetching warehouse orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª" });
    }
  });

  // Process warehouse order
  app.post('/api/warehouse/orders/:id/process', requireDepartmentAuth('warehouse'), async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { action, notes, assigneeId } = req.body;
      
      if (action === 'approve') {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'warehouse_approved',
          assigneeId,
          'warehouse',
          notes || 'Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø² Ø§Ù†Ø¨Ø§Ø±'
        );
      } else {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'warehouse_rejected',
          assigneeId,
          'warehouse',
          notes || 'Ø¹Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¯Ø± Ø§Ù†Ø¨Ø§Ø±'
        );
      }

      res.json({ success: true, message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯" });
    } catch (error) {
      console.error('Error processing warehouse order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´" });
    }
  });





  // ============================================================================
  // CUSTOMER PASSWORD MANAGEMENT SYSTEM
  // ============================================================================

  // Generate random password for customer
  function generateRandomPassword(length: number = 8): string {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < length; i++) {
      password += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return password;
  }

  // Get customer password status (for admin viewing)
  app.get('/api/crm/customers/:id/password-status', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const hasPassword = !!customer.passwordHash;
      const maskedPassword = hasPassword ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡';
      
      res.json({
        success: true,
        data: {
          customerId: customer.id,
          email: customer.email,
          hasPassword,
          maskedPassword,
          lastPasswordChange: customer.updatedAt
        }
      });
    } catch (error) {
      console.error('Error getting customer password status:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Change customer password (admin only)
  app.post('/api/crm/customers/:id/change-password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { newPassword, sendNotification = true } = req.body;
      
      if (!newPassword) {
        return res.status(400).json({ success: false, message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Hash the new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update customer password
      await crmStorage.updateCrmCustomer(customerId, {
        passwordHash: hashedPassword,
        updatedAt: new Date()
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId: customerId,
        activityType: "password_changed",
        description: `Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`,
        performedBy: "admin",
        activityData: { changedBy: "admin" }
      });

      if (sendNotification) {
        // Send email notification using the email service
        try {
          await emailService.sendPasswordChangeEmail(
            customer.email,
            customer.firstName,
            customer.lastName,
            newPassword
          );
          console.log(`âœ“ Password change email sent to ${customer.email}`);
        } catch (emailError) {
          console.error('Error sending password change email:', emailError);
        }

        // Send SMS notification if phone number exists
        if (customer.phone) {
          try {
            await smsService.sendSMS(
              customer.phone,
              `Ø³Ù„Ø§Ù… ${customer.firstName} Ø¹Ø²ÛŒØ²ØŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø´Ù…Ø§: ${newPassword} - Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ`
            );
            console.log(`âœ“ Password change SMS sent to ${customer.phone}`);
          } catch (smsError) {
            console.error('Error sending password change SMS:', smsError);
          }
        }
      }

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª", 
        data: { 
          customerId, 
          email: customer.email,
          notificationSent: sendNotification 
        } 
      });
    } catch (error) {
      console.error('Error changing customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Generate and set random password for customer
  app.post('/api/crm/customers/:id/generate-password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { sendNotification = true } = req.body;
      
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Generate random password
      const newPassword = generateRandomPassword(8);
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update customer password
      await crmStorage.updateCrmCustomer(customerId, {
        passwordHash: hashedPassword,
        updatedAt: new Date()
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId: customerId,
        activityType: "password_generated",
        description: `Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯`,
        performedBy: "admin",
        activityData: { generatedBy: "admin" }
      });

      if (sendNotification) {
        // Send email notification
        try {
          const transporter = nodemailer.createTransporter({
            host: process.env.SMTP_HOST || 'smtp.gmail.com',
            port: 587,
            secure: false,
            auth: {
              user: process.env.SMTP_USER,
              pass: process.env.SMTP_PASS
            }
          });

          const mailOptions = {
            from: process.env.SMTP_USER,
            to: customer.email,
            subject: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ - Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ',
            html: `
              <div style="font-family: Arial, sans-serif; direction: rtl; text-align: right;">
                <h2>Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ</h2>
                <p>Ø³Ù„Ø§Ù… ${customer.firstName} ${customer.lastName} Ø¹Ø²ÛŒØ²ØŒ</p>
                <p>Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ Ø§Ø³Øª:</p>
                <div style="background-color: #f0f0f0; padding: 10px; margin: 20px 0; border-radius: 5px;">
                  <strong>Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±: ${newPassword}</strong>
                </div>
                <p>Ù„Ø·ÙØ§Ù‹ Ø§ÛŒÙ† Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø±Ø§ Ø¯Ø± Ø¬Ø§ÛŒ Ø§Ù…Ù† Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯.</p>
                <p>Ø¨Ø§ ØªØ´Ú©Ø±ØŒ<br>ØªÛŒÙ… Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ</p>
              </div>
            `
          };

          await transporter.sendMail(mailOptions);
          console.log(`âœ“ Generated password email sent to ${customer.email}`);
        } catch (emailError) {
          console.error('Error sending generated password email:', emailError);
        }

        // Send SMS notification if phone number exists
        if (customer.phone) {
          try {
            await smsService.sendSMS(
              customer.phone,
              `Ø³Ù„Ø§Ù… ${customer.firstName} Ø¹Ø²ÛŒØ²ØŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø´Ù…Ø§: ${newPassword} - Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ`
            );
            console.log(`âœ“ Generated password SMS sent to ${customer.phone}`);
          } catch (smsError) {
            console.error('Error sending generated password SMS:', smsError);
          }
        }
      }

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯", 
        data: { 
          customerId, 
          email: customer.email,
          generatedPassword: newPassword,
          notificationSent: sendNotification 
        } 
      });
    } catch (error) {
      console.error('Error generating customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ" });
    }
  });

  // Customer password reset request
  app.post('/api/customers/password-reset-request', async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ success: false, message: "Ø§ÛŒÙ…ÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      console.log('ğŸ” Finding customer by email:', email);
      const customer = await crmStorage.getCrmCustomerByEmail(email);
      if (!customer) {
        // Don't reveal if email exists or not for security
        return res.json({ 
          success: true, 
          message: "Ø§Ú¯Ø± Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯ØŒ Ù„ÛŒÙ†Ú© Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯" 
        });
      }

      console.log('âœ… Customer found:', customer.id, customer.email);

      // Generate reset token
      const crypto = await import('crypto');
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 3600000); // 1 hour from now
      
      console.log('ğŸ”‘ Generated reset token:', resetToken);
      console.log('â° Token expires at:', resetExpires);

      // Save reset token to customer
      try {
        await crmStorage.updateCrmCustomer(customer.id, {
          resetPasswordToken: resetToken,
          resetPasswordExpires: resetExpires
        });
        console.log('ğŸ’¾ Token saved successfully');
      } catch (updateError) {
        console.error('âŒ Error saving token:', updateError);
        throw updateError;
      }

      // Send reset email using Universal Email Service
      try {
        const { CONFIG } = await import('./config');
        const resetUrl = CONFIG.getCustomerPasswordResetUrl(resetToken, req);
        
        const { UniversalEmailService } = await import('./universal-email-service');
        await UniversalEmailService.sendPasswordResetEmail(
          customer.email,
          resetToken,
          `${customer.firstName} ${customer.lastName}`,
          req
        );
        
        console.log(`âœ“ Password reset email sent to ${customer.email}`);
      } catch (emailError) {
        console.error('âš ï¸ Error sending password reset email:', emailError);
        // Continue even if email fails
      }

      // Log activity
      try {
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: "password_reset_requested",
          description: `Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±`,
          performedBy: "customer",
          activityData: { requestedAt: new Date() }
        });
        console.log('ğŸ“ Activity logged successfully');
      } catch (logError) {
        console.error('âš ï¸ Error logging activity:', logError);
        // Continue even if logging fails
      }

      res.json({ 
        success: true, 
        message: "Ø§Ú¯Ø± Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯ØŒ Ù„ÛŒÙ†Ú© Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('âŒ Error processing password reset request:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Customer password reset token verification
  app.get('/api/customers/password-reset-verify', async (req, res) => {
    try {
      const { token } = req.query;
      
      if (!token) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      // Find customer by reset token
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM crm_customers 
        WHERE reset_password_token = $1 
        AND reset_password_expires > $2
        AND is_active = true
      `, [token, new Date()]);

      if (result.rows.length === 0) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }

      res.json({ 
        success: true, 
        message: "ØªÙˆÚ©Ù† Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª",
        valid: true
      });
    } catch (error) {
      console.error('Error verifying reset token:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ ØªÙˆÚ©Ù†" });
    }
  });

  // Customer password reset with token
  app.post('/api/customers/password-reset', async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      
      if (!token || !newPassword) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ùˆ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ success: false, message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 6 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯" });
      }

      // Find customer by reset token
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM crm_customers 
        WHERE reset_password_token = $1 
        AND reset_password_expires > $2
        AND is_active = true
      `, [token, new Date()]);

      if (result.rows.length === 0) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }

      const customer = result.rows[0];
      
      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update customer password and clear reset token
      await crmStorage.updateCrmCustomer(customer.id, {
        passwordHash: hashedPassword,
        resetPasswordToken: null,
        resetPasswordExpires: null,
        updatedAt: new Date()
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId: customer.id,
        activityType: "password_reset_completed",
        description: `Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯`,
        performedBy: "customer",
        activityData: { completedAt: new Date() }
      });

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª. Ø§Ú©Ù†ÙˆÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯" 
      });
    } catch (error) {
      console.error('Error resetting customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // ============================================================================
  // SUPER ADMIN VERIFICATION SYSTEM
  // ============================================================================

  // Get all super admins
  app.get('/api/super-admin/admins', requireAuth, async (req, res) => {
    try {
      const admins = await db
        .select({
          id: schema.users.id,
          username: schema.users.username,
          email: schema.users.email,
          phone: schema.users.phone,
          isActive: schema.users.isActive,
          emailVerified: schema.users.emailVerified,
          phoneVerified: schema.users.phoneVerified,
          lastLoginAt: schema.users.lastLoginAt,
          createdAt: schema.users.createdAt
        })
        .from(schema.users)
        .where(or(
          eq(schema.users.department, 'super_admin'),
          isNull(schema.users.department)
        ));

      res.json(admins);
    } catch (error) {
      console.error('Error fetching super admins:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§" });
    }
  });

  // Create new super admin
  app.post('/api/super-admin/create', requireAuth, async (req, res) => {
    try {
      const { username, email, phone, password } = req.body;
      
      if (!username || !email || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒØŒ Ø§ÛŒÙ…ÛŒÙ„ Ùˆ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Check if user already exists
      const existingUser = await db
        .select()
        .from(schema.users)
        .where(or(
          eq(schema.users.username, username),
          eq(schema.users.email, email)
        ));

      if (existingUser.length > 0) {
        return res.status(409).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);
      
      // Create super admin
      const [newAdmin] = await db
        .insert(schema.users)
        .values({
          username,
          email,
          phone: phone || null,
          passwordHash,
          department: 'super_admin',
          isActive: true,
          emailVerified: false,
          phoneVerified: false,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      // Generate email verification code
      const emailCode = Math.random().toString().substr(2, 6);
      const emailExpiry = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

      await db
        .insert(schema.superAdminVerifications)
        .values({
          userId: newAdmin.id,
          email: newAdmin.email,
          phone: newAdmin.phone,
          verificationCode: emailCode,
          type: 'email',
          isUsed: false,
          expiresAt: emailExpiry,
          createdAt: new Date()
        });

      // Send verification email (mock for now)
      console.log(`Email verification code for ${email}: ${emailCode}`);

      res.json({ 
        success: true, 
        message: "Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯. Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.",
        user: {
          id: newAdmin.id,
          username: newAdmin.username,
          email: newAdmin.email,
          phone: newAdmin.phone
        }
      });
    } catch (error) {
      console.error('Error creating super admin:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†" });
    }
  });

  // Email routing statistics API
  app.get('/api/admin/email/routing-stats', requireAuth, async (req, res) => {
    try {
      // Get all categories with their stats
      const categories = await emailStorage.getCategories();
      
      const stats = await Promise.all(categories.map(async (category) => {
        // Get email logs for this category
        const logs = await db
          .select()
          .from(emailLogs)
          .where(eq(emailLogs.categoryId, category.id))
          .orderBy(desc(emailLogs.sentAt))
          .limit(50);
          
        const totalEmails = logs.length;
        const successfulEmails = logs.filter(log => log.status === 'sent').length;
        const failedEmails = logs.filter(log => log.status === 'failed').length;
        const lastEmailSent = logs.length > 0 ? logs[0].sentAt : null;
        
        // Check if category has SMTP config and recipients
        const smtpConfig = await db
          .select()
          .from(smtpSettings)
          .where(eq(smtpSettings.categoryId, category.id))
          .limit(1);
          
        const recipients = await db
          .select()
          .from(emailRecipients)
          .where(eq(emailRecipients.categoryId, category.id))
          .where(eq(emailRecipients.isActive, true));
        
        return {
          categoryKey: category.categoryKey,
          categoryName: category.categoryName,
          totalEmails,
          successfulEmails,
          failedEmails,
          lastEmailSent,
          hasSmtpConfig: smtpConfig.length > 0,
          hasRecipients: recipients.length > 0,
          recentEmails: logs.slice(0, 10).map(log => ({
            id: log.id,
            toEmail: log.toEmail,
            subject: log.subject,
            status: log.status,
            sentAt: log.sentAt,
            errorMessage: log.errorMessage
          }))
        };
      }));
      
      // Get recent emails across all categories  
      const recentEmails = await db
        .select({
          id: emailLogs.id,
          toEmail: emailLogs.toEmail,
          subject: emailLogs.subject,
          status: emailLogs.status,
          sentAt: emailLogs.sentAt,
          errorMessage: emailLogs.errorMessage,
          categoryName: emailCategories.categoryName
        })
        .from(emailLogs)
        .leftJoin(emailCategories, eq(emailLogs.categoryId, emailCategories.id))
        .orderBy(desc(emailLogs.sentAt))
        .limit(20);
      
      res.json({
        success: true,
        stats,
        recentEmails
      });
    } catch (error) {
      console.error('Error fetching email routing stats:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Error fetching email routing statistics' 
      });
    }
  });

  // Get category email assignments
  app.get("/api/admin/email/category-assignments", requireAuth, async (req, res) => {
    try {
      const assignments = await db
        .select()
        .from(categoryEmailAssignments)
        .orderBy(categoryEmailAssignments.categoryKey);

      res.json(assignments);
    } catch (error) {
      console.error("Error fetching category email assignments:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch category email assignments"
      });
    }
  });

  // Save/update category email assignment
  app.post("/api/admin/email/category-assignments", requireAuth, async (req, res) => {
    try {
      const { categoryKey, categoryName, assignedEmail } = req.body;

      if (!categoryKey || !assignedEmail) {
        return res.status(400).json({
          success: false,
          message: "Category key and assigned email are required"
        });
      }

      // Check if assignment already exists
      const existing = await db
        .select()
        .from(categoryEmailAssignments)
        .where(eq(categoryEmailAssignments.categoryKey, categoryKey))
        .limit(1);

      if (existing.length > 0) {
        // Update existing assignment
        await db
          .update(categoryEmailAssignments)
          .set({
            categoryName: categoryName || existing[0].categoryName,
            assignedEmail,
            updatedAt: new Date()
          })
          .where(eq(categoryEmailAssignments.categoryKey, categoryKey));
      } else {
        // Create new assignment with default category name
        await db
          .insert(categoryEmailAssignments)
          .values({
            categoryKey,
            categoryName: categoryName || categoryKey,
            assignedEmail,
            createdAt: new Date(),
            updatedAt: new Date()
          });
      }

      res.json({
        success: true,
        message: "Category email assignment updated successfully"
      });
    } catch (error) {
      console.error("Error saving category email assignment:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save category email assignment"
      });
    }
  });

  // Update category email assignment
  app.post("/api/admin/email/update-category-assignment", requireAuth, async (req, res) => {
    try {
      const { categoryKey, newEmail } = req.body;
      
      if (!categoryKey || !newEmail) {
        return res.status(400).json({ 
          success: false, 
          message: "Category key and new email are required" 
        });
      }

      // Update SMTP settings from_email if exists
      const { pool } = await import('./db');
      
      // Update email_categories table (which stores default from_email for each category)
      await pool.query(`
        UPDATE email_categories 
        SET updated_at = NOW()
        WHERE category_key = $1
      `, [categoryKey]);

      // Update smtp_settings from_email for this category if it exists
      await pool.query(`
        UPDATE smtp_settings 
        SET from_email = $1, updated_at = NOW()
        WHERE category_id = (
          SELECT id FROM email_categories WHERE category_key = $2
        )
      `, [newEmail, categoryKey]);

      // Update category email assignment
      await db
        .insert(categoryEmailAssignments)
        .values({
          categoryKey,
          categoryName: categoryKey, // Use categoryKey as default name
          assignedEmail: newEmail,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .onConflictDoUpdate({
          target: categoryEmailAssignments.categoryKey,
          set: {
            assignedEmail: newEmail,
            updatedAt: new Date()
          }
        });

      console.log(`ğŸ“§ Updated email assignment for category '${categoryKey}' to '${newEmail}'`);
      
      res.json({ 
        success: true, 
        message: "Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        categoryKey,
        newEmail
      });
    } catch (error) {
      console.error("Error updating category email assignment:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  // Global Email Settings API Routes
  
  // Get global email settings
  app.get('/api/admin/email/global-settings', requireAuth, async (req, res) => {
    try {
      console.log("ğŸ“§ [GLOBAL SETTINGS] Fetching global email settings");
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT setting_key, setting_value, description
        FROM global_email_settings 
        WHERE is_active = true
      `);
      
      console.log("ğŸ“§ [GLOBAL SETTINGS] Found settings:", result.rows);
      
      // Convert to object format for easier frontend use
      const settingsObj = result.rows.reduce((acc, setting) => {
        acc[setting.setting_key] = setting.setting_value;
        return acc;
      }, {} as Record<string, string | null>);

      res.json({
        success: true,
        settings: settingsObj
      });
    } catch (error) {
      console.error("Error fetching global email settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch global email settings"
      });
    }
  });

  // Update global email setting
  app.post('/api/admin/email/global-settings', requireAuth, async (req, res) => {
    try {
      const { settingKey, settingValue, description } = req.body;
      
      if (!settingKey) {
        return res.status(400).json({
          success: false,
          message: "Setting key is required"
        });
      }

      console.log("ğŸ“§ [GLOBAL SETTINGS] Updating setting:", { settingKey, settingValue, description });

      const { pool } = await import('./db');
      
      // Use UPSERT with ON CONFLICT
      await pool.query(`
        INSERT INTO global_email_settings (setting_key, setting_value, description, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, true, NOW(), NOW())
        ON CONFLICT (setting_key)
        DO UPDATE SET 
          setting_value = EXCLUDED.setting_value,
          description = EXCLUDED.description,
          updated_at = NOW()
      `, [settingKey, settingValue, description]);

      console.log("ğŸ“§ [GLOBAL SETTINGS] Setting updated successfully");

      res.json({
        success: true,
        message: "Setting updated successfully"
      });
    } catch (error) {
      console.error("Error updating global email setting:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update setting"
      });
    }
  });

  // Send verification code
  app.post('/api/super-admin/send-verification', requireAuth, async (req, res) => {
    try {
      const { adminId, type } = req.body;

      if (!adminId || !type || !['email', 'sms'].includes(type)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù†ÙˆØ¹ ØªØ§ÛŒÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const [admin] = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, adminId));

      if (!admin) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      if (type === 'sms' && !admin.phone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø§Ø¯Ù…ÛŒÙ† Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Generate verification code
      const verificationCode = Math.random().toString().substr(2, 6);
      const expiryTime = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

      // Delete old verification codes for this user and type
      await db
        .delete(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, adminId),
          eq(schema.superAdminVerifications.type, type),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      // Insert new verification code
      await db
        .insert(schema.superAdminVerifications)
        .values({
          userId: adminId,
          email: admin.email,
          phone: admin.phone,
          verificationCode,
          type,
          isUsed: false,
          expiresAt: expiryTime,
          createdAt: new Date()
        });

      // Mock sending verification (replace with actual email/SMS service)
      if (type === 'email') {
        console.log(`Email verification code for ${admin.email}: ${verificationCode}`);
      } else {
        console.log(`SMS verification code for ${admin.phone}: ${verificationCode}`);
      }

      res.json({ 
        success: true, 
        message: type === 'email' ? "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ù‡ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" : "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error sending verification code:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯" });
    }
  });

  // Verify code
  app.post('/api/super-admin/verify', requireAuth, async (req, res) => {
    try {
      const { adminId, type, code } = req.body;

      if (!adminId || !type || !code) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const [verification] = await db
        .select()
        .from(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, adminId),
          eq(schema.superAdminVerifications.type, type),
          eq(schema.superAdminVerifications.verificationCode, code),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      if (!verification) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      if (new Date() > verification.expiresAt) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Mark verification as used
      await db
        .update(schema.superAdminVerifications)
        .set({ isUsed: true })
        .where(eq(schema.superAdminVerifications.id, verification.id));

      // Update user verification status
      const updateData: any = {};
      if (type === 'email') {
        updateData.emailVerified = true;
      } else if (type === 'sms') {
        updateData.phoneVerified = true;
      }

      await db
        .update(schema.users)
        .set(updateData)
        .where(eq(schema.users.id, adminId));

      res.json({ 
        success: true, 
        message: type === 'email' ? "Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯" : "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error verifying code:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯" });
    }
  });

  // Forgot password
  app.post('/api/super-admin/forgot-password', async (req, res) => {
    try {
      const { email } = req.body;

      if (!email) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const [admin] = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, email));

      if (!admin) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Generate reset code
      const resetCode = Math.random().toString().substr(2, 6);
      const expiryTime = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes

      // Delete old reset codes
      await db
        .delete(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, admin.id),
          eq(schema.superAdminVerifications.type, 'password_reset'),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      // Insert new reset code
      await db
        .insert(schema.superAdminVerifications)
        .values({
          userId: admin.id,
          email: admin.email,
          phone: admin.phone,
          verificationCode: resetCode,
          type: 'password_reset',
          isUsed: false,
          expiresAt: expiryTime,
          createdAt: new Date()
        });

      // Send actual reset email
      try {
        const categorySettings = await emailStorage.getCategoryWithSettings('admin');
        
        if (categorySettings?.smtp) {
          const smtp = categorySettings.smtp;
          
          // Create transporter
          const transporter = nodemailer.createTransport({
            host: smtp.host,
            port: smtp.port,
            secure: smtp.port === 465,
            auth: {
              user: smtp.username,
              pass: smtp.password,
            },
          });

          // Send password reset email using super admin's email
          await transporter.sendMail({
            from: `${smtp.fromName} <${smtp.fromEmail}>`,
            to: email,
            replyTo: smtp.fromEmail,
            subject: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± - Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„",
            html: `
              <div style="direction: rtl; text-align: right; font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h2 style="color: #2563eb;">Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±</h2>
                <p>Ø³Ù„Ø§Ù… ${admin.username}ØŒ</p>
                
                <p>Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.</p>
                
                <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
                  <p style="margin: 0;"><strong>Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ù…Ø§:</strong></p>
                  <div style="font-size: 24px; font-weight: bold; color: #2563eb; 
                              padding: 15px; background: white; border-radius: 6px; 
                              margin: 10px 0; letter-spacing: 3px;">
                    ${resetCode}
                  </div>
                  <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">
                    Ø§ÛŒÙ† Ú©Ø¯ ØªØ§ 30 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.
                  </p>
                </div>
                
                <p style="color: #666; font-size: 14px;">
                  Ø§Ú¯Ø± Ø´Ù…Ø§ Ø§ÛŒÙ† Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø±Ø§ Ù†Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯ØŒ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ø±Ø§ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯.
                </p>
                
                <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
                <p style="font-size: 12px; color: #999;">
                  Ø¨Ø§ ØªØ´Ú©Ø±ØŒ<br>
                  ØªÛŒÙ… ÙÙ†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„<br>
                  momtazchem.com
                </p>
              </div>
            `,
            text: `
Ø³Ù„Ø§Ù… ${admin.username},

Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.

Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ù…Ø§: ${resetCode}

Ø§ÛŒÙ† Ú©Ø¯ ØªØ§ 30 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.

Ø§Ú¯Ø± Ø´Ù…Ø§ Ø§ÛŒÙ† Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø±Ø§ Ù†Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯ØŒ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ø±Ø§ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯.

Ø¨Ø§ ØªØ´Ú©Ø±ØŒ
ØªÛŒÙ… ÙÙ†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„
momtazchem.com
            `
          });

          console.log(`Password reset email sent to: ${email}`);

          // Log the email
          await emailStorage.logEmail({
            categoryId: categorySettings.category.id,
            toEmail: email,
            fromEmail: smtp.fromEmail,
            subject: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± - Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„",
            status: 'sent',
            sentAt: new Date(),
          });

        } else {
          // Fallback to console if no SMTP configured
          console.log(`Password reset code for ${email}: ${resetCode}`);
        }
      } catch (emailError) {
        console.error('Error sending password reset email:', emailError);
        // Still log the code to console as fallback
        console.log(`Password reset code for ${email}: ${resetCode}`);
      }

      res.json({ 
        success: true, 
        message: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ù‡ Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error sending password reset:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ" });
    }
  });

  // Reset password with code
  app.post('/api/super-admin/reset-password', async (req, res) => {
    try {
      const { email, verificationCode, newPassword } = req.body;

      if (!email || !verificationCode || !newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 6 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯" 
        });
      }

      const [admin] = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, email));

      if (!admin) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const [verification] = await db
        .select()
        .from(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, admin.id),
          eq(schema.superAdminVerifications.type, 'password_reset'),
          eq(schema.superAdminVerifications.verificationCode, verificationCode),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      if (!verification) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      if (new Date() > verification.expiresAt) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password
      await db
        .update(schema.users)
        .set({ 
          passwordHash: newPasswordHash,
          updatedAt: new Date()
        })
        .where(eq(schema.users.id, admin.id));

      // Mark verification as used
      await db
        .update(schema.superAdminVerifications)
        .set({ isUsed: true })
        .where(eq(schema.superAdminVerifications.id, verification.id));

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± Ú©Ø±Ø¯"
      });
    } catch (error) {
      console.error('Error resetting password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Get pending verifications
  app.get('/api/super-admin/pending-verifications', requireAuth, async (req, res) => {
    try {
      const verifications = await db
        .select()
        .from(schema.superAdminVerifications)
        .where(eq(schema.superAdminVerifications.isUsed, false))
        .orderBy(desc(schema.superAdminVerifications.createdAt));

      res.json(verifications);
    } catch (error) {
      console.error('Error fetching pending verifications:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§ÛŒÛŒØ¯Ø§Øª Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±" });
    }
  });

  // Delete super admin
  app.delete('/api/super-admin/admins/:id', requireAuth, async (req, res) => {
    try {
      const adminId = parseInt(req.params.id);

      // Prevent self-deletion
      if (req.session.adminId === adminId) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø­Ø³Ø§Ø¨ Ø®ÙˆØ¯ØªØ§Ù† Ø±Ø§ Ø­Ø°Ù Ú©Ù†ÛŒØ¯" 
        });
      }

      // Delete related verifications first
      await db
        .delete(schema.superAdminVerifications)
        .where(eq(schema.superAdminVerifications.userId, adminId));

      // Delete admin
      await db
        .delete(schema.users)
        .where(eq(schema.users.id, adminId));

      res.json({ 
        success: true, 
        message: "Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error deleting super admin:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†" });
    }
  });



  // Import Other Products to Shop Database
  app.post('/api/shop/import-other-products', requireAuth, async (req, res) => {
    try {
      const otherProducts = [
        {
          name: "Industrial Degreasers",
          category: "other",
          description: "High-performance industrial degreasers for heavy-duty cleaning applications in manufacturing environments.",
          shortDescription: "Professional grade degreasers for industrial cleaning",
          price: "35.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 150,
          lowStockThreshold: 20,
          sku: "IND-DEG-001",
          barcode: "8901234567890",
          weight: "1.0",
          weightUnit: "kg",
          specifications: {
            "pH Level": "8.5 - 9.2",
            "Density": "0.95 g/ml", 
            "Flash Point": ">100Â°C",
            "Biodegradability": "98% in 28 days"
          },
          features: ["Biodegradable formula", "Non-toxic", "Fast-acting", "Multi-surface compatible"],
          applications: ["Metal fabrication", "Automotive industry", "Heavy machinery maintenance", "Industrial equipment cleaning"],
          tags: ["degreaser", "industrial", "cleaning", "biodegradable"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 500,
          leadTime: "2-3 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: false,
          metaTitle: "Industrial Degreasers - Professional Cleaning Solutions",
          metaDescription: "High-performance industrial degreasers for heavy-duty cleaning applications"
        },
        {
          name: "Corrosion Inhibitors", 
          category: "other",
          description: "Advanced corrosion inhibitors designed to protect metal surfaces from oxidation and environmental damage.",
          shortDescription: "Protective coatings for metal surfaces",
          price: "45.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 85,
          lowStockThreshold: 15,
          sku: "COR-INH-002",
          barcode: "8901234567891",
          weight: "1.2",
          weightUnit: "kg",
          specifications: {
            "Active Content": "25-30%",
            "Operating Temperature": "-20Â°C to +80Â°C",
            "Coverage": "8-12 mÂ²/L",
            "Drying Time": "2-4 hours"
          },
          features: ["Long-lasting protection", "Temperature resistant", "Water-based formula", "Easy application"],
          applications: ["Pipeline protection", "Marine equipment", "Storage tanks", "Infrastructure maintenance"],
          tags: ["corrosion", "protection", "coating", "metal"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 200,
          leadTime: "3-5 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: true,
          metaTitle: "Corrosion Inhibitors - Metal Protection Solutions",
          metaDescription: "Advanced corrosion inhibitors for metal surface protection"
        },
        {
          name: "Laboratory Reagents",
          category: "other", 
          description: "High-purity laboratory reagents for analytical testing, research, and quality control applications.",
          shortDescription: "Analytical grade reagents for laboratory use",
          price: "75.00",
          priceUnit: "per kg",
          inStock: true,
          stockQuantity: 45,
          lowStockThreshold: 10,
          sku: "LAB-REA-003",
          barcode: "8901234567892",
          weight: "0.5",
          weightUnit: "kg",
          specifications: {
            "Purity": "â‰¥99.5%",
            "Water Content": "<0.1%",
            "Heavy Metals": "<10 ppm",
            "Shelf Life": "2-3 years"
          },
          features: ["Analytical grade purity", "Certified quality", "Consistent results", "Long shelf life"],
          applications: ["Chemical analysis", "Research laboratories", "Quality control testing", "Educational institutions"],
          tags: ["reagent", "laboratory", "analytical", "research"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 50,
          leadTime: "1-2 business days",
          shippingClass: "hazardous",
          isActive: true,
          isFeatured: false,
          metaTitle: "Laboratory Reagents - Analytical Grade Chemicals",
          metaDescription: "High-purity laboratory reagents for analytical testing and research"
        },
        {
          name: "Specialty Solvents",
          category: "other",
          description: "Premium specialty solvents for specific industrial applications requiring high performance and purity.",
          shortDescription: "Ultra-pure solvents for precision applications", 
          price: "120.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 65,
          lowStockThreshold: 12,
          sku: "SOL-SPE-004",
          barcode: "8901234567893",
          weight: "0.8",
          weightUnit: "kg",
          specifications: {
            "Purity": "â‰¥99.8%",
            "Boiling Point": "78-82Â°C",
            "Vapor Pressure": "5.95 kPa at 20Â°C",
            "Resistivity": ">18 MÎ©Â·cm"
          },
          features: ["Ultra-high purity", "Low residue", "Fast evaporation", "Non-conductive"],
          applications: ["Electronics manufacturing", "Pharmaceutical production", "Precision cleaning", "Chemical synthesis"],
          tags: ["solvent", "specialty", "electronics", "pharmaceutical"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 100,
          leadTime: "5-7 business days",
          shippingClass: "hazardous",
          isActive: true,
          isFeatured: true,
          metaTitle: "Specialty Solvents - High Purity Industrial Solvents",
          metaDescription: "Premium specialty solvents for precision industrial applications"
        },
        {
          name: "Concrete Additives",
          category: "other",
          description: "Specialized concrete additives to enhance performance, durability, and workability of concrete mixtures.",
          shortDescription: "Performance enhancers for concrete applications",
          price: "18.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 200,
          lowStockThreshold: 30,
          sku: "CON-ADD-005",
          barcode: "8901234567894",
          weight: "1.1",
          weightUnit: "kg",
          specifications: {
            "Solid Content": "40-45%",
            "Chloride Content": "<0.1%",
            "Setting Time": "Adjustable 30min-6hrs",
            "Compressive Strength": "+15-25%"
          },
          features: ["Improved workability", "Enhanced strength", "Reduced water content", "Accelerated curing"],
          applications: ["Commercial construction", "Infrastructure projects", "Precast concrete", "Ready-mix concrete"],
          tags: ["concrete", "additive", "construction", "building"],
          minimumOrderQuantity: 5,
          maximumOrderQuantity: 1000,
          leadTime: "1-3 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: false,
          metaTitle: "Concrete Additives - Construction Chemical Solutions",
          metaDescription: "Specialized concrete additives for enhanced performance and durability"
        },
        {
          name: "Textile Processing Chemicals",
          category: "other",
          description: "Comprehensive range of chemicals for textile processing, dyeing, and finishing operations.",
          shortDescription: "Complete chemical solutions for textile industry",
          price: "28.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 120,
          lowStockThreshold: 25,
          sku: "TEX-PRO-006",
          barcode: "8901234567895",
          weight: "1.0",
          weightUnit: "kg",
          specifications: {
            "pH Range": "6.0-8.0",
            "Concentration": "10-50%",
            "Temperature Stability": "Up to 120Â°C",
            "Biodegradability": "Readily biodegradable"
          },
          features: ["Color fastness", "Eco-friendly options", "Process efficiency", "Quality enhancement"],
          applications: ["Fabric dyeing", "Textile finishing", "Fiber treatment", "Garment processing"],
          tags: ["textile", "dyeing", "finishing", "fabric"],
          minimumOrderQuantity: 2,
          maximumOrderQuantity: 500,
          leadTime: "2-4 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: false,
          metaTitle: "Textile Processing Chemicals - Dyeing & Finishing Solutions",
          metaDescription: "Comprehensive chemicals for textile processing and finishing operations"
        }
      ];

      const createdProducts = [];
      
      for (const productData of otherProducts) {
        try {
          const product = await shopStorage.createShopProduct(productData);
          createdProducts.push(product);
        } catch (error) {
          console.error(`Error creating product ${productData.name}:`, error);
          // Continue with other products if one fails
        }
      }

      res.json({
        success: true,
        message: `Successfully imported ${createdProducts.length} products to shop`,
        products: createdProducts
      });

    } catch (error) {
      console.error('Error importing other products:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Failed to import products to shop database' 
      });
    }
  });

  // =============================================================================
  // MARKETING MODULE API ROUTES
  // =============================================================================

  // Get all international markets
  app.get('/api/marketing/international-markets', requireAuth, async (req, res) => {
    try {
      const markets = await db.select().from(internationalMarkets).orderBy(desc(internationalMarkets.priority));
      res.json({ success: true, data: markets });
    } catch (error) {
      console.error('Error fetching international markets:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  // Create new international market
  app.post('/api/marketing/international-markets', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalMarketSchema.parse(req.body);
      const [market] = await db.insert(internationalMarkets).values(validatedData).returning();
      res.json({ success: true, data: market });
    } catch (error) {
      console.error('Error creating international market:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¨Ø§Ø²Ø§Ø± Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  // Update international market
  app.put('/api/marketing/international-markets/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const validatedData = insertInternationalMarketSchema.parse(req.body);
      const [market] = await db
        .update(internationalMarkets)
        .set({ ...validatedData, lastUpdated: new Date() })
        .where(eq(internationalMarkets.id, id))
        .returning();
      
      if (!market) {
        return res.status(404).json({ success: false, message: 'Ø¨Ø§Ø²Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      res.json({ success: true, data: market });
    } catch (error) {
      console.error('Error updating international market:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  // Delete international market
  app.delete('/api/marketing/international-markets/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const [deletedMarket] = await db
        .delete(internationalMarkets)
        .where(eq(internationalMarkets.id, id))
        .returning();
      
      if (!deletedMarket) {
        return res.status(404).json({ success: false, message: 'Ø¨Ø§Ø²Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      res.json({ success: true, message: 'Ø¨Ø§Ø²Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting international market:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¨Ø§Ø²Ø§Ø± Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  // Get all market segments
  app.get('/api/marketing/market-segments', requireAuth, async (req, res) => {
    try {
      const segments = await db.select().from(marketSegments).orderBy(desc(marketSegments.createdAt));
      res.json({ success: true, data: segments });
    } catch (error) {
      console.error('Error fetching market segments:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ø®Ø´â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§Ø²Ø§Ø±' });
    }
  });

  // Create new market segment
  app.post('/api/marketing/market-segments', requireAuth, async (req, res) => {
    try {
      const validatedData = insertMarketSegmentSchema.parse(req.body);
      const [segment] = await db.insert(marketSegments).values(validatedData).returning();
      res.json({ success: true, data: segment });
    } catch (error) {
      console.error('Error creating market segment:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¨Ø®Ø´ Ø¨Ø§Ø²Ø§Ø±' });
    }
  });

  // Get all competitor analysis
  app.get('/api/marketing/competitor-analysis', requireAuth, async (req, res) => {
    try {
      const analysis = await db.select().from(competitorAnalysis).orderBy(desc(competitorAnalysis.lastAnalyzed));
      res.json({ success: true, data: analysis });
    } catch (error) {
      console.error('Error fetching competitor analysis:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ­Ù„ÛŒÙ„ Ø±Ù‚Ø¨Ø§' });
    }
  });

  // Create new competitor analysis
  app.post('/api/marketing/competitor-analysis', requireAuth, async (req, res) => {
    try {
      const validatedData = insertCompetitorAnalysisSchema.parse(req.body);
      const [analysis] = await db.insert(competitorAnalysis).values(validatedData).returning();
      res.json({ success: true, data: analysis });
    } catch (error) {
      console.error('Error creating competitor analysis:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØ­Ù„ÛŒÙ„ Ø±Ù‚ÛŒØ¨' });
    }
  });

  // Get all market intelligence
  app.get('/api/marketing/market-intelligence', requireAuth, async (req, res) => {
    try {
      const intel = await db.select().from(marketIntelligence).orderBy(desc(marketIntelligence.createdAt));
      res.json({ success: true, data: intel });
    } catch (error) {
      console.error('Error fetching market intelligence:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‡ÙˆØ´ Ø¨Ø§Ø²Ø§Ø±' });
    }
  });

  // Create new market intelligence entry
  app.post('/api/marketing/market-intelligence', requireAuth, async (req, res) => {
    try {
      const validatedData = insertMarketIntelligenceSchema.parse(req.body);
      const [intel] = await db.insert(marketIntelligence).values(validatedData).returning();
      res.json({ success: true, data: intel });
    } catch (error) {
      console.error('Error creating market intelligence:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‡ÙˆØ´ Ø¨Ø§Ø²Ø§Ø±' });
    }
  });

  // Get marketing dashboard statistics
  app.get('/api/marketing/dashboard-stats', requireAuth, async (req, res) => {
    try {
      const [marketsCount] = await db.select({ count: sql<number>`count(*)` }).from(internationalMarkets);
      const [activeMarketsCount] = await db.select({ count: sql<number>`count(*)` }).from(internationalMarkets).where(eq(internationalMarkets.status, 'active'));
      const [segmentsCount] = await db.select({ count: sql<number>`count(*)` }).from(marketSegments);
      const [competitorsCount] = await db.select({ count: sql<number>`count(*)` }).from(competitorAnalysis);
      
      // Calculate total estimated revenue
      const revenueResult = await db.select({ 
        totalRevenue: sql<string>`sum(${internationalMarkets.estimatedRevenue})` 
      }).from(internationalMarkets);
      
      // Calculate average growth rate
      const growthResult = await db.select({ 
        avgGrowth: sql<string>`avg(${internationalMarkets.growthRate})` 
      }).from(internationalMarkets);
      
      res.json({ 
        success: true, 
        data: {
          totalMarkets: marketsCount.count || 0,
          activeMarkets: activeMarketsCount.count || 0,
          totalSegments: segmentsCount.count || 0,
          totalCompetitors: competitorsCount.count || 0,
          totalEstimatedRevenue: parseFloat(revenueResult[0]?.totalRevenue || '0'),
          averageGrowthRate: parseFloat(growthResult[0]?.avgGrowth || '0')
        }
      });
    } catch (error) {
      console.error('Error fetching marketing dashboard stats:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø§Ø±Ú©ØªÛŒÙ†Ú¯' });
    }
  });

  // =============================================================================
  // INVOICE ROUTES
  // =============================================================================

  // Import invoice storage
  const { invoiceStorage } = await import('./invoice-storage.js');

  // Get all invoices (admin only)
  app.get('/api/invoices', requireAuth, async (req, res) => {
    try {
      const invoices = await invoiceStorage.getAllInvoices();
      res.json({ success: true, data: invoices });
    } catch (error) {
      console.error('Error fetching invoices:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch invoices' });
    }
  });

  // Get customer invoices
  app.get('/api/invoices/customer/:customerId', async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      const invoices = await invoiceStorage.getInvoicesByCustomer(customerId);
      res.json({ success: true, data: invoices });
    } catch (error) {
      console.error('Error fetching customer invoices:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch customer invoices' });
    }
  });

  // Get invoice by ID
  app.get('/api/invoices/:id', async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const invoice = await invoiceStorage.getInvoiceById(invoiceId);
      
      if (!invoice) {
        return res.status(404).json({ success: false, message: 'Invoice not found' });
      }

      const items = await invoiceStorage.getInvoiceItems(invoiceId);
      res.json({ success: true, data: { ...invoice, items } });
    } catch (error) {
      console.error('Error fetching invoice:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch invoice' });
    }
  });

  // Generate invoice from order (accessible by customers and admins)
  app.post('/api/invoices/generate/:orderId', async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { language = 'ar' } = req.body; // Default to Arabic, supports: ar, ku, tr, en
      
      // Try to find order in customer_orders first, then shop orders
      let order = null;
      let isCustomerOrder = false;
      
      // First check customer_orders directly
      try {
        console.log(`Looking for customer order with ID: ${orderId}`);
        const [customerOrder] = await db
          .select()
          .from(customerOrders)
          .where(eq(customerOrders.id, orderId));
        
        console.log('Customer order found:', customerOrder);
        if (customerOrder) {
          order = customerOrder;
          isCustomerOrder = true;
        }
      } catch (e) {
        console.log('Error checking customer_orders:', e);
      }
      
      // If not found in customer_orders, try shop orders
      if (!order) {
        order = await shopStorage.getOrderById(orderId);
      }
      
      if (!order) {
        return res.status(404).json({ 
          success: false, 
          message: 'Order not found' 
        });
      }

      // Check if customer has access to this order (either customer themselves or admin)
      const isCustomer = req.session?.customerId;
      const isAdmin = req.session?.adminId;
      
      if (isCustomer && order.customerId !== isCustomer) {
        return res.status(403).json({ 
          success: false, 
          message: 'Access denied to this order' 
        });
      }
      
      // Check if invoice already exists for this order
      const existingInvoices = await invoiceStorage.getInvoicesByOrder(orderId);
      if (existingInvoices.length > 0) {
        // Update language if different
        if (existingInvoices[0].language !== language) {
          const updatedInvoice = await invoiceStorage.updateInvoiceLanguage(existingInvoices[0].id, language);
          return res.json({ 
            success: true, 
            message: 'Invoice language updated',
            data: updatedInvoice
          });
        }
        
        return res.json({ 
          success: true, 
          message: 'Invoice already exists',
          data: existingInvoices[0]
        });
      }

      // Generate new invoice with specified language
      const invoice = await invoiceStorage.generateInvoiceFromOrder(orderId, language);
      res.json({ 
        success: true, 
        message: 'Invoice generated successfully',
        data: invoice 
      });
    } catch (error) {
      console.error('Error generating invoice:', error);
      
      // Return specific error message if it's a validation error
      if (error instanceof Error && error.message.includes('ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ')) {
        res.status(400).json({ 
          success: false, 
          message: error.message 
        });
      } else if (error instanceof Error && error.message.includes('Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø´Ø¯Ù‡')) {
        res.status(400).json({ 
          success: false, 
          message: error.message 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ±' 
        });
      }
    }
  });

  // Request official invoice
  app.post('/api/invoices/:id/request-official', async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const { language = 'ar' } = req.body; // Default to Arabic if not specified
      
      const invoice = await invoiceStorage.requestOfficialInvoice(invoiceId, language);
      
      // Send notification to admin about official invoice request
      // This can be implemented with the email system
      
      res.json({ 
        success: true, 
        message: 'Official invoice request submitted',
        data: invoice 
      });
    } catch (error) {
      console.error('Error requesting official invoice:', error);
      res.status(500).json({ success: false, message: 'Failed to request official invoice' });
    }
  });

  // Process official invoice (admin only)
  app.post('/api/invoices/:id/process-official', requireAuth, async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const { companyInfo, taxInfo } = req.body;
      
      const invoice = await invoiceStorage.processOfficialInvoice(invoiceId, companyInfo, taxInfo);
      res.json({ success: true, data: invoice });
    } catch (error) {
      console.error('Error processing official invoice:', error);
      res.status(500).json({ success: false, message: 'Failed to process official invoice' });
    }
  });

  // Download invoice PDF
  app.get('/api/invoices/:id/download', async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const invoice = await invoiceStorage.getInvoiceById(invoiceId);
      
      if (!invoice) {
        return res.status(404).json({ success: false, message: 'Invoice not found' });
      }

      // Get invoice items
      const items = await invoiceStorage.getInvoiceItems(invoiceId);
      
      // Get customer and order information
      const order = await shopStorage.getOrderById(invoice.orderId);
      const customer = await crmStorage.getCrmCustomerById(invoice.customerId);
      
      if (!order || !customer) {
        return res.status(404).json({ success: false, message: 'Order or customer not found' });
      }

      // Generate PDF content based on language with multi-language support
      const isRTL = ['ar', 'ku'].includes(invoice.language); // Arabic and Kurdish are RTL
      const direction = isRTL ? 'rtl' : 'ltr';
      
      // Enhanced font selection for better multilingual support
      const fontFamily = isRTL ? 
        "'Noto Sans Arabic', 'Tahoma', 'Arial Unicode MS', Arial, sans-serif" : 
        "'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif";
      
      // Language-specific translations
      const getTranslation = (key) => {
        const translations = {
          'ar': {
            companyName: 'Ø´Ø±ÙƒØ© Ù…ÙÙ…ØªØ§Ø² Ù„Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ©',
            location: 'Ø§Ù„Ø¹Ø±Ø§Ù‚ - Ø¨ØºØ¯Ø§Ø¯',
            phone: 'Ø§Ù„Ù‡Ø§ØªÙ',
            email: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
            invoice: 'ÙØ§ØªÙˆØ±Ø©',
            official: '(Ø±Ø³Ù…ÙŠØ©)',
            invoiceInfo: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙØ§ØªÙˆØ±Ø©',
            customerInfo: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„',
            invoiceNumber: 'Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©',
            issueDate: 'ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØµØ¯Ø§Ø±',
            paymentStatus: 'Ø­Ø§Ù„Ø© Ø§Ù„Ø¯ÙØ¹',
            orderNumber: 'Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨',
            name: 'Ø§Ù„Ø§Ø³Ù…',
            address: 'Ø§Ù„Ø¹Ù†ÙˆØ§Ù†',
            company: 'Ø§Ù„Ø´Ø±ÙƒØ©',
            product: 'Ø§Ù„Ù…Ù†ØªØ¬',
            quantity: 'Ø§Ù„ÙƒÙ…ÙŠØ©',
            unitPrice: 'Ø§Ù„Ø³Ø¹Ø±',
            total: 'Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ',
            subtotal: 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙØ±Ø¹ÙŠ',
            discount: 'Ø§Ù„Ø®ØµÙ…',
            tax: 'Ø§Ù„Ø¶Ø±ÙŠØ¨Ø©',
            finalTotal: 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ',
            paid: 'Ù…Ø¯ÙÙˆØ¹Ø©',
            due: 'Ù…Ø³ØªØ­Ù‚Ø©',
            notes: 'Ù…Ù„Ø§Ø­Ø¸Ø§Øª'
          },
          'ku': {
            companyName: 'Ú©Û†Ù…Ù¾Ø§Ù†ÛŒØ§ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ø¨Û† Ù…Ø§Ø¯Û• Ú©ÛŒÙ…ÛŒØ§ÛŒÛŒÛ•Ú©Ø§Ù†',
            location: 'Ø¹ÛØ±Ø§Ù‚ - Ø¨Û•ØºØ¯Ø§',
            phone: 'ØªÛ•Ù„Û•ÙÛ†Ù†',
            email: 'Ø¦ÛŒÙ…Û•ÛŒÙ„',
            invoice: 'Ù¾Ø³ÙˆÚµÛ•',
            official: '(ÙÛ•Ø±Ù…ÛŒ)',
            invoiceInfo: 'Ø²Ø§Ù†ÛŒØ§Ø±ÛŒ Ù¾Ø³ÙˆÚµÛ•',
            customerInfo: 'Ø²Ø§Ù†ÛŒØ§Ø±ÛŒ Ú©Ú•ÛŒØ§Ø±',
            invoiceNumber: 'Ú˜Ù…Ø§Ø±Û•ÛŒ Ù¾Ø³ÙˆÚµÛ•',
            issueDate: 'Ø¨Û•Ø±ÙˆØ§Ø±ÛŒ Ø¯Û•Ø±Ú†ÙˆÙˆÙ†',
            paymentStatus: 'Ø­Ø§ÚµÛ•ØªÛŒ Ù¾Ø§Ø±Û•Ø¯Ø§Ù†',
            orderNumber: 'Ú˜Ù…Ø§Ø±Û•ÛŒ Ø¯Ø§ÙˆØ§Ú©Ø§Ø±ÛŒ',
            name: 'Ù†Ø§Ùˆ',
            address: 'Ù†Ø§ÙˆÙ†ÛŒØ´Ø§Ù†',
            company: 'Ú©Û†Ù…Ù¾Ø§Ù†ÛŒØ§',
            product: 'Ø¨Û•Ø±Ù‡Û•Ù…',
            quantity: 'Ø¨Ú•',
            unitPrice: 'Ù†Ø±Ø®ÛŒ ÛŒÛ•Ú©Û•',
            total: 'Ú©Û†ÛŒ Ú¯Ø´ØªÛŒ',
            subtotal: 'Ú©Û†ÛŒ Ù„Ø§ÙˆÛ•Ú©ÛŒ',
            discount: 'Ø¯Ø§Ø´Ú©Ø§Ù†Ø¯Ù†',
            tax: 'Ø¨Ø§Ø¬',
            finalTotal: 'Ú©Û†ÛŒ Ú©Û†ØªØ§ÛŒÛŒ',
            paid: 'Ù¾ÛØ¯Ø±Ø§Ùˆ',
            due: 'Ø¨Û•Ø¯ÙˆØ§ÛŒÛ•',
            notes: 'ØªÛØ¨ÛŒÙ†ÛŒÛ•Ú©Ø§Ù†'
          },
          'tr': {
            companyName: 'MÃ¼mtaz Kimyasal Ã‡Ã¶zÃ¼mler',
            location: 'Irak - BaÄŸdat',
            phone: 'Telefon',
            email: 'E-posta',
            invoice: 'FATURA',
            official: '(Resmi)',
            invoiceInfo: 'Fatura Bilgileri',
            customerInfo: 'MÃ¼ÅŸteri Bilgileri',
            invoiceNumber: 'Fatura NumarasÄ±',
            issueDate: 'DÃ¼zenleme Tarihi',
            paymentStatus: 'Ã–deme Durumu',
            orderNumber: 'SipariÅŸ NumarasÄ±',
            name: 'Ä°sim',
            address: 'Adres',
            company: 'Åirket',
            product: 'ÃœrÃ¼n',
            quantity: 'Miktar',
            unitPrice: 'Birim Fiyat',
            total: 'Toplam',
            subtotal: 'Ara Toplam',
            discount: 'Ä°ndirim',
            tax: 'Vergi',
            finalTotal: 'Genel Toplam',
            paid: 'Ã–dendi',
            due: 'Ã–denmedi',
            notes: 'Notlar'
          },
          'en': {
            companyName: 'Momtaz Chemical Solutions',
            location: 'Iraq - Baghdad',
            phone: 'Phone',
            email: 'Email',
            invoice: 'INVOICE',
            official: '(Official)',
            invoiceInfo: 'Invoice Information',
            customerInfo: 'Customer Information',
            invoiceNumber: 'Invoice Number',
            issueDate: 'Issue Date',
            paymentStatus: 'Payment Status',
            orderNumber: 'Order Number',
            name: 'Name',
            address: 'Address',
            company: 'Company',
            product: 'Product',
            quantity: 'Quantity',
            unitPrice: 'Unit Price',
            total: 'Total',
            subtotal: 'Subtotal',
            discount: 'Discount',
            tax: 'Tax',
            finalTotal: 'Final Total',
            paid: 'Paid',
            due: 'Due',
            notes: 'Notes'
          }
        };
        return translations[invoice.language] || translations['en'];
      };
      
      const t = getTranslation();
      
      const htmlContent = `
        <!DOCTYPE html>
        <html dir="${direction}" lang="${invoice.language}">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
            <style>
                @page {
                    margin: 20mm;
                    size: A4;
                }
                
                body { 
                    font-family: ${fontFamily}; 
                    line-height: 1.6; 
                    margin: 0; 
                    padding: 20px;
                    direction: ${direction};
                    background: white;
                    color: #333;
                    font-size: 14px;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }
                
                /* Prevent font fallback issues for multilingual text */
                .multilingual-text {
                    font-family: ${fontFamily};
                    word-wrap: break-word;
                    overflow-wrap: break-word;
                    unicode-bidi: bidi-override;
                }
                
                .header { 
                    text-align: center; 
                    border-bottom: 3px solid #2c5aa0; 
                    padding-bottom: 20px; 
                    margin-bottom: 30px; 
                }
                
                .company-info { 
                    text-align: center; 
                    margin-bottom: 20px; 
                }
                
                .company-info h1 {
                    color: #2c5aa0;
                    margin-bottom: 10px;
                    font-size: 24px;
                    font-weight: 700;
                }
                
                .invoice-details { 
                    display: flex; 
                    justify-content: space-between; 
                    margin-bottom: 30px; 
                    gap: 20px;
                }
                
                .invoice-info, .customer-info { 
                    width: 48%; 
                    background: #f8f9fa;
                    padding: 15px;
                    border-radius: 5px;
                }
                
                .invoice-info h3, .customer-info h3 {
                    color: #2c5aa0;
                    border-bottom: 1px solid #dee2e6;
                    padding-bottom: 8px;
                    margin-bottom: 15px;
                }
                
                table { 
                    width: 100%; 
                    border-collapse: collapse; 
                    margin-bottom: 20px; 
                    border: 1px solid #dee2e6;
                }
                
                th, td { 
                    border: 1px solid #dee2e6; 
                    padding: 12px; 
                    text-align: ${isRTL ? 'right' : 'left'}; 
                    vertical-align: top;
                }
                
                th { 
                    background-color: #2c5aa0; 
                    color: white;
                    font-weight: 700; 
                    font-size: 13px;
                }
                
                .total-section { 
                    text-align: ${isRTL ? 'right' : 'left'}; 
                    margin-top: 20px; 
                }
                
                .total-section table {
                    width: 300px; 
                    margin-${isRTL ? 'right' : 'left'}: auto;
                    border: 2px solid #2c5aa0;
                }
                
                .total-row { 
                    font-size: 16px; 
                    font-weight: bold; 
                    background-color: #e7f3ff; 
                }
                
                .footer { 
                    margin-top: 40px; 
                    text-align: center; 
                    font-size: 12px; 
                    color: #666; 
                    border-top: 1px solid #dee2e6;
                    padding-top: 20px;
                }
                
                /* RTL-specific adjustments */
                ${isRTL ? `
                .invoice-details {
                    flex-direction: row-reverse;
                }
                
                table {
                    direction: rtl;
                }
                
                .total-section table {
                    margin-right: auto;
                    margin-left: unset;
                }
                ` : ''}
                
                /* Print-specific styles */
                @media print {
                    body {
                        padding: 0;
                        margin: 0;
                        margin-left: 10cm;
                        font-size: 12px;
                    }
                    
                    .header {
                        border-bottom: 3px solid #000 !important;
                        margin-left: 10cm;
                    }
                    
                    .invoice-details {
                        margin-left: 10cm;
                    }
                    
                    table {
                        margin-left: 10cm;
                    }
                    
                    .footer {
                        margin-left: 10cm;
                    }
                    
                    th {
                        background-color: #000 !important;
                        color: #fff !important;
                    }
                }
            </style>
        </head>
        <body>
            <div class="header">
                <div class="company-info">
                    <h1 class="multilingual-text">${t.companyName}</h1>
                    <p class="multilingual-text">${t.location}</p>
                    <p class="multilingual-text">${t.phone}: +964 770 999 6771</p>
                    <p class="multilingual-text">${t.email}: info@momtazchem.com</p>
                </div>
                <h2 class="multilingual-text">${t.invoice} ${invoice.isOfficial ? t.official : ''}</h2>
            </div>

            <div class="invoice-details">
                <div class="invoice-info">
                    <h3 class="multilingual-text">${t.invoiceInfo}</h3>
                    <p class="multilingual-text"><strong>${t.invoiceNumber}:</strong> ${invoice.invoiceNumber}</p>
                    <p class="multilingual-text"><strong>${t.issueDate}:</strong> ${new Date(invoice.createdAt).toLocaleDateString(invoice.language === 'ar' ? 'ar-IQ' : invoice.language === 'ku' ? 'ckb-IQ' : invoice.language === 'tr' ? 'tr-TR' : 'en-US')}</p>
                    <p class="multilingual-text"><strong>${t.paymentStatus}:</strong> ${invoice.status === 'paid' ? t.paid : t.due}</p>
                    <p class="multilingual-text"><strong>${t.orderNumber}:</strong> ${order.orderNumber}</p>
                </div>
                <div class="customer-info">
                    <h3 class="multilingual-text">${t.customerInfo}</h3>
                    <p class="multilingual-text"><strong>${t.name}:</strong> ${customer.firstName} ${customer.lastName}</p>
                    <p class="multilingual-text"><strong>${t.email}:</strong> ${customer.email}</p>
                    <p class="multilingual-text"><strong>${t.phone}:</strong> ${customer.phone}</p>
                    <p class="multilingual-text"><strong>${t.address}:</strong> ${customer.address}, ${customer.city}, ${customer.country}</p>
                    ${customer.company ? `<p class="multilingual-text"><strong>${t.company}:</strong> ${customer.company}</p>` : ''}
                </div>
            </div>

            <table>
                <thead>
                    <tr>
                        <th class="multilingual-text">${t.product}</th>
                        <th class="multilingual-text">${t.quantity}</th>
                        <th class="multilingual-text">${t.unitPrice}</th>
                        <th class="multilingual-text">${t.total}</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map(item => `
                        <tr>
                            <td class="multilingual-text">${item.productName}</td>
                            <td class="multilingual-text">${item.quantity}</td>
                            <td class="multilingual-text">${item.unitPrice} ${invoice.currency}</td>
                            <td class="multilingual-text">${item.totalPrice} ${invoice.currency}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>

            <div class="total-section">
                <table>
                    <tr>
                        <td class="multilingual-text"><strong>${t.subtotal}:</strong></td>
                        <td class="multilingual-text"><strong>${invoice.subtotal} ${invoice.currency}</strong></td>
                    </tr>
                    ${invoice.discountAmount && parseFloat(invoice.discountAmount) > 0 ? `
                    <tr>
                        <td class="multilingual-text"><strong>${t.discount}:</strong></td>
                        <td class="multilingual-text"><strong>-${invoice.discountAmount} ${invoice.currency}</strong></td>
                    </tr>
                    ` : ''}
                    ${invoice.taxAmount && parseFloat(invoice.taxAmount) > 0 ? `
                    <tr>
                        <td class="multilingual-text"><strong>${t.tax}:</strong></td>
                        <td class="multilingual-text"><strong>${invoice.taxAmount} ${invoice.currency}</strong></td>
                    </tr>
                    ` : ''}
                    <tr class="total-row">
                        <td class="multilingual-text"><strong>${t.finalTotal}:</strong></td>
                        <td class="multilingual-text"><strong>${invoice.totalAmount} ${invoice.currency}</strong></td>
                    </tr>
                </table>
            </div>

            ${invoice.notes ? `
            <div style="margin-top: 30px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <h3 class="multilingual-text" style="color: #2c5aa0; margin-bottom: 10px;">${t.notes}</h3>
                <p class="multilingual-text">${invoice.notes}</p>
            </div>
            ` : ''}

            <div class="footer">
                <p class="multilingual-text">
                    ${invoice.language === 'ar' ? 'Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ø±ÙƒØ© Ù…ÙÙ…ØªØ§Ø² Ù„Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ©' :
                      invoice.language === 'ku' ? 'Ø³ÙˆÙ¾Ø§Ø³ Ø¨Û† Ù‡Û•ÚµØ¨Ú˜Ø§Ø±Ø¯Ù†ØªØ§Ù† Ú©Û†Ù…Ù¾Ø§Ù†ÛŒØ§ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ø¨Û† Ù…Ø§Ø¯Û• Ú©ÛŒÙ…ÛŒØ§ÛŒÛŒÛ•Ú©Ø§Ù†' :
                      invoice.language === 'tr' ? 'MÃ¼mtaz Kimyasal Ã‡Ã¶zÃ¼mler\'i tercih ettiÄŸiniz iÃ§in teÅŸekkÃ¼r ederiz' :
                      'Thank you for choosing Momtaz Chemical Solutions'}
                </p>
                <p class="multilingual-text">
                    ${invoice.language === 'ar' ? 'Ù…ÙˆÙ‚Ø¹Ù†Ø§ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ' :
                      invoice.language === 'ku' ? 'Ù…Ø§ÚµÙ¾Û•Ú•Û•Ú©Û•Ù…Ø§Ù†' :
                      invoice.language === 'tr' ? 'Web sitemiz' :
                      'Website'}: momtazchem.com
                </p>
            </div>
        </body>
        </html>
      `;

      // Use the simple PDF generator
      const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
      
      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '10mm',
          right: '10mm',
          bottom: '10mm',
          left: '100mm'
        }
      });
      
      await browser.close();

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${invoice.invoiceNumber}.pdf"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      res.send(pdfBuffer);
      
    } catch (error) {
      console.error('Error generating invoice PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate invoice PDF' });
    }
  });

  // Financial order print endpoint
  app.post('/api/financial/print-order', requireAuth, async (req, res) => {
    console.log('ğŸ“„ [FINANCIAL PDF] Request received');
    let browser;
    
    try {
      const { htmlContent, filename } = req.body;
      
      if (!htmlContent) {
        console.error('âŒ [FINANCIAL PDF] Missing htmlContent in request');
        return res.status(400).json({ success: false, message: 'HTML content is required' });
      }
      
      console.log('ğŸ“„ [FINANCIAL PDF] Launching Puppeteer browser...');
      browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox', 
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--no-first-run',
          '--no-zygote',
          '--single-process',
          '--disable-gpu'
        ]
      });
      
      console.log('ğŸ“„ [FINANCIAL PDF] Creating new page...');
      const page = await browser.newPage();
      
      console.log('ğŸ“„ [FINANCIAL PDF] Setting content...');
      await page.setContent(htmlContent, { 
        waitUntil: 'networkidle0',
        timeout: 30000 
      });
      
      console.log('ğŸ“„ [FINANCIAL PDF] Generating PDF...');
      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '10mm',
          right: '10mm',
          bottom: '10mm',
          left: '10mm'
        }
      });
      
      console.log('ğŸ“„ [FINANCIAL PDF] PDF generated successfully, size:', pdfBuffer.length, 'bytes');
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename || 'financial-order.pdf'}"`);
      res.send(pdfBuffer);
      
      console.log('âœ… [FINANCIAL PDF] PDF sent successfully');
      
    } catch (error) {
      console.error('âŒ [FINANCIAL PDF] Error generating PDF:', error);
      console.error('âŒ [FINANCIAL PDF] Error details:', {
        message: error.message,
        stack: error.stack,
        name: error.name
      });
      res.status(500).json({ 
        success: false, 
        message: 'Failed to generate PDF',
        error: error.message 
      });
    } finally {
      if (browser) {
        try {
          console.log('ğŸ“„ [FINANCIAL PDF] Closing browser...');
          await browser.close();
          console.log('ğŸ“„ [FINANCIAL PDF] Browser closed successfully');
        } catch (closeError) {
          console.error('âŒ [FINANCIAL PDF] Error closing browser:', closeError);
        }
      }
    }
  });

  // Footer Settings Management APIs
  app.get('/api/admin/footer-settings', requireAuth, async (req, res) => {
    try {
      const { language = 'en' } = req.query;
      
      const [footerSetting] = await db
        .select()
        .from(footerSettings)
        .where(eq(footerSettings.language, language as string))
        .limit(1);
      
      if (!footerSetting) {
        // Create default footer settings for this language
        const defaultFooter = {
          language: language as string,
          companyName: 'Momtazchem',
          companyDescription: 'Leading provider of advanced chemical solutions',
          companyAddress: 'Gwer Road, Qaryataq Village, Erbil, Iraq',
          companyPhone: '+964 750 353 3769',
          companyEmail: 'info@momtazchem.com',
          companyCodal: '44001',
          productLinks: JSON.stringify([
            { name: 'Fuel Additives', href: '/products/fuel-additives' },
            { name: 'Water Treatment', href: '/products/water-treatment' },
            { name: 'Paint & Thinner', href: '/products/paint-thinner' },
            { name: 'Agricultural Fertilizers', href: '/products/agricultural-fertilizers' }
          ]),
          companyLinks: JSON.stringify([
            { name: 'About Us', href: '/about' },
            { name: 'Services', href: '/services' },
            { name: 'Shop', href: '/shop' },
            { name: 'Careers', href: '#careers' }
          ]),
          supportLinks: JSON.stringify([
            { name: 'Contact', href: '/contact' },
            { name: 'Technical Support', href: '#technical-support' },
            { name: 'Documentation', href: '#documentation' },
            { name: 'Safety Data Sheets', href: '#safety-data' }
          ]),
          copyrightText: 'Â© 2025 Momtazchem. All rights reserved.',
          showSocialMedia: true,
          showCompanyInfo: true,
          showLinks: true,
        };
        
        const [newFooter] = await db
          .insert(footerSettings)
          .values(defaultFooter)
          .returning();
          
        return res.json({ success: true, data: newFooter });
      }
      
      res.json({ success: true, data: footerSetting });
    } catch (error) {
      console.error('Error fetching footer settings:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch footer settings' });
    }
  });

  app.put('/api/admin/footer-settings/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      
      // Parse JSON fields if they're strings
      if (typeof updateData.productLinks === 'string') {
        try {
          JSON.parse(updateData.productLinks);
        } catch {
          return res.status(400).json({ success: false, message: 'Invalid product links format' });
        }
      }
      
      if (typeof updateData.companyLinks === 'string') {
        try {
          JSON.parse(updateData.companyLinks);
        } catch {
          return res.status(400).json({ success: false, message: 'Invalid company links format' });
        }
      }
      
      if (typeof updateData.supportLinks === 'string') {
        try {
          JSON.parse(updateData.supportLinks);
        } catch {
          return res.status(400).json({ success: false, message: 'Invalid support links format' });
        }
      }
      
      const [updatedFooter] = await db
        .update(footerSettings)
        .set({
          ...updateData,
          updatedAt: new Date()
        })
        .where(eq(footerSettings.id, parseInt(id)))
        .returning();
      
      if (!updatedFooter) {
        return res.status(404).json({ success: false, message: 'Footer settings not found' });
      }
      
      res.json({ success: true, data: updatedFooter });
    } catch (error) {
      console.error('Error updating footer settings:', error);
      res.status(500).json({ success: false, message: 'Failed to update footer settings' });
    }
  });

  // Public API for footer settings (for frontend footer component)
  app.get('/api/footer-settings', async (req, res) => {
    try {
      const { language = 'en' } = req.query;
      
      const [footerSetting] = await db
        .select()
        .from(footerSettings)
        .where(eq(footerSettings.language, language as string))
        .limit(1);
      
      if (!footerSetting) {
        // Return default settings if none found
        return res.json({
          success: true,
          data: {
            companyName: 'Momtazchem',
            companyDescription: 'Leading provider of advanced chemical solutions',
            showSocialMedia: true,
            showCompanyInfo: true,
            showLinks: true
          }
        });
      }
      
      res.json({ success: true, data: footerSetting });
    } catch (error) {
      console.error('Error fetching public footer settings:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch footer settings' });
    }
  });

  // Mark invoice as paid
  app.post('/api/invoices/:id/mark-paid', requireAuth, async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const { paymentDate } = req.body;
      
      const invoice = await invoiceStorage.markInvoiceAsPaid(
        invoiceId, 
        paymentDate ? new Date(paymentDate) : undefined
      );
      res.json({ success: true, data: invoice });
    } catch (error) {
      console.error('Error marking invoice as paid:', error);
      res.status(500).json({ success: false, message: 'Failed to mark invoice as paid' });
    }
  });

  // Get invoice statistics
  app.get('/api/invoices/stats', requireAuth, async (req, res) => {
    try {
      const stats = await invoiceStorage.getInvoiceStats();
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error('Error fetching invoice stats:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch invoice stats' });
    }
  });

  // Auto-generate invoice when order payment is completed
  app.post('/api/orders/:id/complete-payment', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      
      // Update order payment status
      const order = await shopStorage.updateOrder(orderId, {
        paymentStatus: 'paid'
      });

      // Generate invoice automatically
      const invoice = await invoiceStorage.generateInvoiceFromOrder(orderId);
      
      // Send invoice email to customer
      await invoiceStorage.sendInvoiceEmail(invoice.id);

      res.json({ 
        success: true, 
        message: 'Payment completed and invoice generated',
        data: { order, invoice }
      });
    } catch (error) {
      console.error('Error completing payment:', error);
      res.status(500).json({ success: false, message: 'Failed to complete payment' });
    }
  });

  // ============================================================================
  // PAYMENT GATEWAY MANAGEMENT API
  // ============================================================================

  // Get all payment gateways
  app.get('/api/payment/gateways', requireAuth, async (req, res) => {
    try {
      const gateways = await db.select().from(paymentGateways).orderBy(desc(paymentGateways.createdAt));
      res.json(gateways);
    } catch (error) {
      console.error('Error fetching payment gateways:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch payment gateways' });
    }
  });

  // Get payment gateway by ID
  app.get('/api/payment/gateways/:id', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      const [gateway] = await db.select().from(paymentGateways).where(eq(paymentGateways.id, gatewayId));
      
      if (!gateway) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      res.json(gateway);
    } catch (error) {
      console.error('Error fetching payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch payment gateway' });
    }
  });

  // Create new payment gateway
  app.post('/api/payment/gateways', requireAuth, async (req, res) => {
    try {
      const { name, type, enabled, config, testMode } = req.body;
      
      // Validate required fields
      if (!name || !type || !config) {
        return res.status(400).json({ success: false, message: 'Missing required fields' });
      }

      const [gateway] = await db.insert(paymentGateways).values({
        name,
        type,
        enabled: enabled ?? true,
        config,
        testMode: testMode ?? false,
      }).returning();
      
      res.json({ success: true, data: gateway });
    } catch (error) {
      console.error('Error creating payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to create payment gateway' });
    }
  });

  // Update payment gateway
  app.patch('/api/payment/gateways/:id', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      const { name, type, enabled, config, testMode } = req.body;
      
      const [gateway] = await db.update(paymentGateways)
        .set({
          name,
          type,
          enabled,
          config,
          testMode,
          updatedAt: new Date(),
        })
        .where(eq(paymentGateways.id, gatewayId))
        .returning();
      
      if (!gateway) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      res.json({ success: true, data: gateway });
    } catch (error) {
      console.error('Error updating payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to update payment gateway' });
    }
  });

  // Delete payment gateway
  app.delete('/api/payment/gateways/:id', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      
      const result = await db.delete(paymentGateways)
        .where(eq(paymentGateways.id, gatewayId))
        .returning();
      
      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      res.json({ success: true, message: 'Payment gateway deleted successfully' });
    } catch (error) {
      console.error('Error deleting payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to delete payment gateway' });
    }
  });



  // ============================================================================
  // IRAQI BANKING PAYMENT API
  // ============================================================================

  // Get enabled payment gateways for customer use
  app.get('/api/payment/available-gateways', async (req, res) => {
    try {
      const gateways = await db.select().from(paymentGateways).where(eq(paymentGateways.enabled, true));
      res.json({ success: true, data: gateways });
    } catch (error) {
      console.error('Error fetching available payment gateways:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch available payment gateways' });
    }
  });

  // Create bank gateway payment redirect
  app.post('/api/payment/create-bank-payment', requireCustomerAuth, async (req, res) => {
    try {
      const { orderNumber, totalAmount, remainingAmount, walletAmountUsed } = req.body;
      const customerId = req.session.customerId;
      
      if (!orderNumber || !totalAmount) {
        return res.status(400).json({ success: false, message: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª' });
      }

      // Get customer order
      const customerOrder = await customerStorage.getOrderByNumber(orderNumber);
      if (!customerOrder || customerOrder.customerId !== customerId) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Get active payment gateway
      const { pool } = await import('./db');
      const activeGatewayResult = await pool.query(`
        SELECT id, name, type, config 
        FROM payment_gateways 
        WHERE enabled = true 
        LIMIT 1
      `);

      if (activeGatewayResult.rows.length === 0) {
        return res.status(503).json({ 
          success: false, 
          message: 'Ù‡ÛŒÚ† Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙØ¹Ø§Ù„ÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª' 
        });
      }

      const activeGateway = activeGatewayResult.rows[0];
      const gatewayConfig = activeGateway.config || {};

      // Generate payment reference
      const paymentReference = `PAY_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Build gateway URL based on active gateway configuration
      let bankGatewayUrl;
      
      if (activeGateway.type === 'iraqi_bank') {
        // Use configured gateway URL or fallback to default
        const baseUrl = gatewayConfig.apiBaseUrl || 'https://gateway.rasheedbank.gov.iq/payment';
        bankGatewayUrl = `${baseUrl}?` + 
          `merchantId=MOMTAZ_${gatewayConfig.merchantId || process.env.BANK_MERCHANT_ID || 'DEMO'}&` +
          `amount=${remainingAmount || totalAmount}&` +
          `currency=IQD&` +
          `reference=${paymentReference}&` +
          `orderNumber=${orderNumber}&` +
          `returnUrl=${encodeURIComponent(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-callback`)}&` +
          `cancelUrl=${encodeURIComponent(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-cancelled`)}`;
      } else if (activeGateway.type === 'credit_card') {
        // Handle credit card gateway
        const baseUrl = gatewayConfig.apiBaseUrl || 'https://api.creditcard.gateway.iq/payment';
        bankGatewayUrl = `${baseUrl}?` + 
          `merchantId=${gatewayConfig.merchantId || 'DEMO'}&` +
          `amount=${remainingAmount || totalAmount}&` +
          `currency=IQD&` +
          `reference=${paymentReference}&` +
          `orderNumber=${orderNumber}&` +
          `returnUrl=${encodeURIComponent(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-callback`)}&` +
          `cancelUrl=${encodeURIComponent(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-cancelled`)}`;
      } else {
        // Default fallback for unknown gateway types
        bankGatewayUrl = `https://gateway.rasheedbank.gov.iq/payment?` + 
          `merchantId=MOMTAZ_DEMO&` +
          `amount=${remainingAmount || totalAmount}&` +
          `currency=IQD&` +
          `reference=${paymentReference}&` +
          `orderNumber=${orderNumber}&` +
          `returnUrl=${encodeURIComponent(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-callback`)}&` +
          `cancelUrl=${encodeURIComponent(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-cancelled`)}`;
      }

      // Update order with payment method
      await customerStorage.updateOrder(customerOrder.id, {
        paymentMethod: 'online_payment',
        paymentStatus: 'processing',
        paymentReference: paymentReference
      });

      console.log(`ğŸ¦ [BANK GATEWAY] Payment redirect created for order ${orderNumber}:`, {
        reference: paymentReference,
        amount: remainingAmount || totalAmount,
        customerId,
        activeGateway: activeGateway.name,
        gatewayType: activeGateway.type,
        gatewayUrl: bankGatewayUrl
      });

      res.json({ 
        success: true, 
        redirectUrl: bankGatewayUrl,
        paymentReference,
        gatewayName: activeGateway.name,
        gatewayType: activeGateway.type,
        message: `Ø¯Ø± Ø­Ø§Ù„ Ù‡Ø¯Ø§ÛŒØª Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ ${activeGateway.name}...`
      });

    } catch (error) {
      console.error('Error creating bank payment:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ' });
    }
  });

  // Payment callback from bank gateway
  app.all('/api/payment/callback', async (req, res) => {
    try {
      const { reference, status, orderNumber, transactionId, amount } = req.body || req.query;
      
      console.log(`ğŸ¦ [PAYMENT CALLBACK] Received payment callback:`, {
        reference,
        status,
        orderNumber,
        transactionId,
        amount,
        method: req.method
      });

      if (!reference || !orderNumber) {
        return res.status(400).json({ success: false, message: 'Invalid payment callback data' });
      }

      // Get the order
      const customerOrder = await customerStorage.getOrderByNumber(orderNumber);
      if (!customerOrder) {
        return res.status(404).json({ success: false, message: 'Order not found' });
      }

      // Update order based on payment status
      let paymentStatus = 'failed';
      let orderStatus = 'pending';
      
      if (status === 'success' || status === 'completed' || status === '1') {
        paymentStatus = 'paid';
        orderStatus = 'confirmed';
        
        // Process successful payment
        await customerStorage.updateOrder(customerOrder.id, {
          paymentStatus: 'paid',
          orderStatus: 'confirmed',
          paymentReference: reference,
          transactionId: transactionId
        });

        console.log(`âœ… [PAYMENT SUCCESS] Order ${orderNumber} payment confirmed via bank gateway`);
        
        // Redirect to success page
        return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/order-success/${orderNumber}?payment=success`);
        
      } else if (status === 'failed' || status === 'error' || status === '0') {
        // Payment failed - handle wallet refund for partial payments
        console.log(`âŒ [PAYMENT FAILED] Processing failed payment for order ${orderNumber}`);
        
        // Check if this was a partial wallet payment that needs refund
        if (customerOrder.paymentMethod === 'wallet_partial') {
          console.log(`ğŸ’° [WALLET REFUND] Order ${orderNumber} was partial wallet payment - checking for refund`);
          
          try {
            // Find wallet transactions for this order to determine refund amount
            const { WalletStorage } = await import('./wallet-storage');
            const walletStorage = new WalletStorage();
            
            // Get wallet transactions for this order
            const walletTransactions = await walletStorage.getTransactionsByReference('order', customerOrder.id);
            console.log(`ğŸ” [WALLET REFUND] Found ${walletTransactions.length} wallet transactions for order ${customerOrder.id}`);
            
            // Find debit transactions (wallet deductions) for this order
            const debitTransactions = walletTransactions.filter(t => t.transactionType === 'debit' && t.status === 'completed');
            
            if (debitTransactions.length > 0) {
              // Calculate total amount to refund
              const totalDebitAmount = debitTransactions.reduce((sum, t) => sum + parseFloat(t.amount), 0);
              console.log(`ğŸ’° [WALLET REFUND] Refunding ${totalDebitAmount} IQD to customer ${customerOrder.customerId}`);
              
              // Process wallet refund
              await walletStorage.creditWallet(
                customerOrder.customerId,
                totalDebitAmount,
                `Ø¨Ø§Ø²Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…ÙˆÙÙ‚ ${orderNumber} - Ø´Ú©Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ`,
                'refund',
                customerOrder.id
              );
              
              console.log(`âœ… [WALLET REFUND] Successfully refunded ${totalDebitAmount} IQD for failed order ${orderNumber}`);
            } else {
              console.log(`â„¹ï¸ [WALLET REFUND] No wallet debit transactions found for order ${orderNumber}`);
            }
          } catch (refundError) {
            console.error(`âŒ [WALLET REFUND] Error processing wallet refund for order ${orderNumber}:`, refundError);
          }
        }
        
        // Update order status to failed
        await customerStorage.updateOrder(customerOrder.id, {
          paymentStatus: 'failed',
          paymentReference: reference,
          transactionId: transactionId
        });

        console.log(`âŒ [PAYMENT FAILED] Order ${orderNumber} payment failed via bank gateway`);
        
        // Redirect to failure page
        return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-failed/${orderNumber}?reason=bank_decline`);
        
      } else {
        // Payment pending/processing
        await customerStorage.updateOrder(customerOrder.id, {
          paymentStatus: 'processing',
          paymentReference: reference,
          transactionId: transactionId
        });

        console.log(`â³ [PAYMENT PENDING] Order ${orderNumber} payment is processing`);
        
        // Redirect to pending page
        return res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:5000'}/payment-pending/${orderNumber}`);
      }

    } catch (error) {
      console.error('Error processing payment callback:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†ØªÛŒØ¬Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª' });
    }
  });

  // Process Iraqi bank transfer payment
  app.post('/api/payment/iraqi-bank-transfer', async (req, res) => {
    try {
      const { orderId, gatewayId, bankTransferDetails } = req.body;
      
      if (!orderId || !gatewayId || !bankTransferDetails) {
        return res.status(400).json({ success: false, message: 'Missing required payment details' });
      }

      // Get payment gateway configuration
      const [gateway] = await db.select().from(paymentGateways).where(eq(paymentGateways.id, gatewayId));
      
      if (!gateway || !gateway.enabled) {
        return res.status(400).json({ success: false, message: 'Invalid or disabled payment gateway' });
      }

      // Verify order exists
      const order = await shopStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: 'Order not found' });
      }

      // For Iraqi bank transfers, we'll mark as pending and require manual verification
      const updatedOrder = await shopStorage.updateOrder(orderId, {
        paymentStatus: 'pending',
        paymentMethod: `Bank Transfer - ${gateway.name}`,
        paymentGatewayId: gatewayId
      });

      // Log the payment attempt
      console.log(`Iraqi bank transfer initiated for order ${orderId}:`, {
        gateway: gateway.name,
        bankDetails: bankTransferDetails,
        amount: order.totalAmount
      });

      // Create financial transaction record
      await shopStorage.createFinancialTransaction({
        type: 'payment_pending',
        orderId: order.id,
        amount: order.totalAmount,
        description: `Iraqi bank transfer pending verification - ${gateway.name}`,
        referenceNumber: bankTransferDetails.referenceNumber || order.orderNumber,
        status: 'pending',
        processingDate: new Date(),
        metadata: { 
          gatewayId,
          gatewayName: gateway.name,
          bankTransferDetails,
          paymentMethod: 'iraqi_bank_transfer'
        }
      });

      res.json({ 
        success: true, 
        message: 'Bank transfer payment initiated. Awaiting verification.',
        data: { 
          order: updatedOrder,
          paymentStatus: 'pending',
          verificationRequired: true,
          bankInfo: gateway.config
        }
      });
    } catch (error) {
      console.error('Error processing Iraqi bank transfer:', error);
      res.status(500).json({ success: false, message: 'Failed to process bank transfer payment' });
    }
  });

  // Verify Iraqi bank transfer payment (admin only)
  app.post('/api/payment/verify-bank-transfer/:orderId', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { verified, notes } = req.body;
      
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: 'Invalid order ID' });
      }

      const order = await shopStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: 'Order not found' });
      }

      if (verified) {
        // Mark order as paid
        const updatedOrder = await shopStorage.updateOrder(orderId, {
          paymentStatus: 'paid'
        });

        // Generate invoice automatically
        const invoice = await invoiceStorage.generateInvoiceFromOrder(orderId);
        
        // Send invoice email to customer
        await invoiceStorage.sendInvoiceEmail(invoice.id);

        // Update financial transaction
        await shopStorage.createFinancialTransaction({
          type: 'sale',
          orderId: order.id,
          amount: order.totalAmount,
          description: `Bank transfer verified and completed - ${order.paymentMethod}`,
          referenceNumber: order.orderNumber,
          status: 'completed',
          processingDate: new Date(),
          metadata: { 
            verifiedBy: req.session?.adminId,
            verificationNotes: notes,
            originalPaymentMethod: 'iraqi_bank_transfer'
          }
        });

        res.json({ 
          success: true, 
          message: 'Bank transfer verified and order completed',
          data: { order: updatedOrder, invoice }
        });
      } else {
        // Mark payment as failed
        const updatedOrder = await shopStorage.updateOrder(orderId, {
          paymentStatus: 'failed'
        });

        res.json({ 
          success: true, 
          message: 'Bank transfer verification failed',
          data: { order: updatedOrder }
        });
      }
    } catch (error) {
      console.error('Error verifying bank transfer:', error);
      res.status(500).json({ success: false, message: 'Failed to verify bank transfer' });
    }
  });

  // Upload bank receipt
  app.post('/api/payment/upload-receipt', requireCustomerAuth, uploadReceipt.single('receipt'), async (req, res) => {
    try {
      const { orderId, receiptAmount, notes } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ 
          success: false, 
          message: 'ÙØ§ÛŒÙ„ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª' 
        });
      }

      // Ø§Ú¯Ø± Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ø§Ø±Ø§Ø¦Ù‡ Ù†Ø´Ø¯Ù‡ØŒ Ø³ÙØ§Ø±Ø´ Ù…Ø¹Ù„Ù‚ Ù…Ø´ØªØ±ÛŒ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ú©Ù†
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ 
          success: false, 
          message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' 
        });
      }

      if (!receiptAmount) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ø¨Ù„Øº ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª' 
        });
      }

      const amount = parseFloat(receiptAmount);
      if (isNaN(amount) || amount <= 0) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ø¨Ù„Øº ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' 
        });
      }

      // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø³ÙØ§Ø±Ø´ Ø¯Ø± customer_orders
      let order;
      
      if (orderId && orderId.trim() !== '') {
        // Ø§Ú¯Ø± Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡ØŒ Ø³ÙØ§Ø±Ø´ Ù…Ø´Ø®Øµ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ú©Ù†
        if (orderId.startsWith('M') || orderId.startsWith('ORD-')) {
          // Find order by order number
          const [orderResult] = await customerDb
            .select()
            .from(customerOrders)
            .where(eq(customerOrders.orderNumber, orderId));
          order = orderResult;
        } else {
          // Find order by ID
          const orderIdNum = parseInt(orderId);
          if (!isNaN(orderIdNum)) {
            order = await customerStorage.getOrderById(orderIdNum);
          }
        }
      } else {
        // Ø§Ú¯Ø± Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ø§Ø±Ø§Ø¦Ù‡ Ù†Ø´Ø¯Ù‡ØŒ Ø¢Ø®Ø±ÛŒÙ† Ø³ÙØ§Ø±Ø´ Ù…Ø¹Ù„Ù‚ Ù…Ø´ØªØ±ÛŒ Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ú©Ù†
        console.log(`ğŸ” [RECEIPT UPLOAD] No order ID provided, finding pending order for customer ${customerId}`);
        
        const pendingOrders = await customerDb
          .select()
          .from(customerOrders)
          .where(
            and(
              eq(customerOrders.customerId, customerId),
              eq(customerOrders.paymentMethod, 'bank_transfer_grace'),
              eq(customerOrders.paymentStatus, 'grace_period')
            )
          )
          .orderBy(desc(customerOrders.createdAt))
          .limit(1);
          
        if (pendingOrders.length > 0) {
          order = pendingOrders[0];
          console.log(`âœ… [RECEIPT UPLOAD] Found pending grace period order ${order.id} for customer ${customerId}`);
        }
      }
      
      if (!order) {
        return res.status(404).json({ 
          success: false, 
          message: orderId ? 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' : 'Ù‡ÛŒÚ† Ø³ÙØ§Ø±Ø´ Ù…Ø¹Ù„Ù‚ÛŒ Ø¨Ø±Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ ÙÛŒØ´ ÛŒØ§ÙØª Ù†Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯.'
        });
      }

      // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…Ø¨Ù„Øº ÙÛŒØ´ Ø¯Ø± Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ù…Ø¨Ù„Øº Ø³ÙØ§Ø±Ø´
      const orderAmount = parseFloat(order.totalAmount);
      let walletCredit = 0;
      let walletDeduction = 0;
      let amountStatus = '';

      if (amount < orderAmount) {
        // Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆØ§Ù„Øª Ù…Ø´ØªØ±ÛŒ
        const walletBalance = await customerStorage.getWalletBalance(order.customerId);
        const deficit = orderAmount - amount;
        
        if (walletBalance >= deficit) {
          // ÙˆØ§Ù„Øª Ù¾ÙˆØ´Ø´ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ - Ø§Ø² ÙˆØ§Ù„Øª Ú©Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
          walletDeduction = deficit;
          amountStatus = `Ù…Ø¨Ù„Øº Ú©Ù…Ø¨ÙˆØ¯ ${deficit.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø§Ø² ÙˆØ§Ù„Øª Ø´Ù…Ø§ Ú©Ø³Ø± Ø´Ø¯. Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆØ§Ù„Øª: ${walletBalance.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±`;
          
          try {
            await customerStorage.deductWalletBalance(order.customerId, deficit);
            console.log(`âœ… [WALLET] Deducted ${deficit} from customer ${order.customerId} wallet to cover receipt deficit`);
          } catch (error) {
            console.error('Error deducting from wallet:', error);
            return res.status(500).json({ 
              success: false, 
              message: 'Ø®Ø·Ø§ Ø¯Ø± Ú©Ø³Ø± Ù…Ø¨Ù„Øº Ø§Ø² ÙˆØ§Ù„Øª' 
            });
          }
        } else {
          // ÙˆØ§Ù„Øª Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª - ÙÛŒØ´ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¯ÛŒØ± Ù…Ø§Ù„ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯
          amountStatus = `Ù…Ø¨Ù„Øº ÙÛŒØ´ (${amount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±) Ú©Ù…ØªØ± Ø§Ø² Ø¨Ø¯Ù‡ÛŒ (${orderAmount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±) Ø§Ø³Øª. Ú©Ù…Ø¨ÙˆØ¯: ${deficit.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±. Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆØ§Ù„Øª: ${walletBalance.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±. ÙÛŒØ´ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¯ÛŒØ± Ù…Ø§Ù„ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.`;
          console.log(`âš ï¸ [WALLET] Insufficient funds for customer ${order.customerId}: Receipt ${amount}, Order ${orderAmount}, Wallet ${walletBalance}, Deficit ${deficit}`);
        }
      } else if (amount > orderAmount) {
        // Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ Ù¾Ø³ Ø§Ø² ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ Ø¨Ù‡ ÙˆØ§Ù„Øª Ø§Ø¶Ø§ÙÙ‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯
        walletCredit = amount - orderAmount;
        amountStatus = `Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ${walletCredit.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ù¾Ø³ Ø§Ø² ØªØ§ÛŒÛŒØ¯ ÙˆØ§Ø­Ø¯ Ù…Ø§Ù„ÛŒ Ø¨Ù‡ ÙˆØ§Ù„Øª Ø´Ù…Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯`;
        
        // Ø¹Ø¯Ù… Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÙÙˆØ±ÛŒ Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ Ø¨Ù‡ ÙˆØ§Ù„Øª - Ø¨Ø§ÛŒØ¯ Ù…Ù†ØªØ¸Ø± ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ Ø¨Ø§Ø´ÛŒÙ…
        console.log(`ğŸ“‹ [PENDING] Excess amount ${walletCredit} for customer ${order.customerId} pending financial approval`);
      } else {
        amountStatus = 'Ù…Ø¨Ù„Øº ÙÛŒØ´ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ Ø¨Ø¯Ù‡ÛŒ Ø´Ù…Ø§ Ø§Ø³Øª';
      }

      // Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø³ÛŒØ± Ù†Ø³Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
      const filePath = `/uploads/receipts/${file.filename}`;

      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…Ø³ÛŒØ± ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ùˆ Ù…Ø¨Ù„Øº ÙÛŒØ´
      const uploadNote = `ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯ Ø¯Ø± ${new Date().toLocaleString('fa-IR')} | Ù…Ø¨Ù„Øº ÙÛŒØ´: ${amount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± | Ù…Ø¨Ù„Øº Ø³ÙØ§Ø±Ø´: ${orderAmount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±${walletCredit > 0 ? ` | Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ${walletCredit.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ§ÛŒÛŒØ¯ ÙˆØ§Ø­Ø¯ Ù…Ø§Ù„ÛŒ` : ''}${walletDeduction > 0 ? ` | Ú©Ù…Ø¨ÙˆØ¯ ${walletDeduction.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø§Ø² ÙˆØ§Ù„Øª Ú©Ø³Ø± Ø´Ø¯` : ''}${notes ? ` | ØªÙˆØ¶ÛŒØ­Ø§Øª: ${notes}` : ''}`;
      const updatedNotes = order.notes ? `${order.notes} | ${uploadNote}` : uploadNote;
      
      await customerDb
        .update(customerOrders)
        .set({
          receiptPath: filePath,
          paymentStatus: 'receipt_uploaded',
          status: 'confirmed', // ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ø§Ø² pending/payment_grace_period Ø¨Ù‡ confirmed
          notes: updatedNotes
        })
        .where(eq(customerOrders.id, order.id));

      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ
      try {
        await db
          .update(orderManagement)
          .set({
            currentStatus: 'payment_uploaded',
            paymentReceiptUrl: filePath,
            updatedAt: new Date()
          })
          .where(eq(orderManagement.customerOrderId, order.id));
        
        console.log(`âœ… [FINANCE] Order ${orderId} updated with receipt and moved to financial review`);
      } catch (error) {
        console.error('Warning: Could not update order management, but receipt uploaded successfully:', error);
      }

      // Ø«Ø¨Øª ÙØ¹Ø§Ù„ÛŒØª Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ
      try {
        await shopStorage.createFinancialTransaction({
          type: 'receipt_uploaded',
          orderId: order.id,
          amount: order.totalAmount,
          description: `ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯ - ${file.originalname} | Ù…Ø¨Ù„Øº ÙÛŒØ´: ${amount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± | Ù…Ø¨Ù„Øº Ø³ÙØ§Ø±Ø´: ${orderAmount.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±${walletCredit > 0 ? ` | Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ${walletCredit.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø¨Ù‡ ÙˆØ§Ù„Øª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯` : ''}${walletDeduction > 0 ? ` | Ú©Ù…Ø¨ÙˆØ¯ ${walletDeduction.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø§Ø² ÙˆØ§Ù„Øª Ú©Ø³Ø± Ø´Ø¯` : ''}`,
          referenceNumber: order.orderNumber,
          status: 'pending_review',
          processingDate: new Date(),
          metadata: { 
            receiptPath: filePath,
            fileName: file.originalname,
            fileSize: file.size,
            mimeType: file.mimetype,
            receiptAmount: amount,
            orderAmount: orderAmount,
            walletCredit: walletCredit,
            walletDeduction: walletDeduction,
            amountStatus: amountStatus
          }
        });
      } catch (error) {
        console.log('Warning: Could not create financial transaction, but receipt uploaded successfully');
      }

      console.log(`âœ… [ORDER STATUS] Order ${orderId} status changed from temporary to confirmed after receipt upload:`, {
        fileName: file.originalname,
        filePath,
        fileSize: file.size,
        previousStatus: order.status,
        newStatus: 'confirmed'
      });

      res.json({ 
        success: true, 
        message: `ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯. ${amountStatus}`,
        data: { 
          filePath,
          fileName: file.originalname,
          orderId: parseInt(orderId),
          orderStatus: 'confirmed',
          receiptAmount: amount,
          orderAmount: orderAmount,
          walletCredit: walletCredit,
          walletDeduction: walletDeduction,
          amountStatus: amountStatus
        }
      });

    } catch (error) {
      console.error('Error uploading bank receipt:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ' 
      });
    }
  });

  // Get payment methods configuration for checkout
  app.get('/api/payment/methods', async (req, res) => {
    try {
      const gateways = await db.select().from(paymentGateways).where(eq(paymentGateways.enabled, true));
      
      const paymentMethods = gateways.map(gateway => ({
        id: gateway.id,
        name: gateway.name,
        type: gateway.type,
        config: {
          // Only return safe config data (not secrets)
          bankName: gateway.config?.bankName,
          accountNumber: gateway.config?.accountNumber,
          swiftCode: gateway.config?.swiftCode,
          instructions: gateway.config?.instructions
        },
        testMode: gateway.testMode
      }));

      res.json({ success: true, data: paymentMethods });
    } catch (error) {
      console.error('Error fetching payment methods:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch payment methods' });
    }
  });

  // =============================================================================
  // READY VEHICLES API ENDPOINTS
  // =============================================================================

  // Get all ready vehicles
  app.get('/api/logistics/ready-vehicles', requireAuth, async (req, res) => {
    try {
      const { readyVehicles, vehicleTemplates } = await import('../shared/logistics-schema');
      
      const vehicles = await db
        .select({
          id: readyVehicles.id,
          vehicleTemplateId: readyVehicles.vehicleTemplateId,
          licensePlate: readyVehicles.licensePlate,
          driverName: readyVehicles.driverName,
          driverMobile: readyVehicles.driverMobile,
          loadCapacity: readyVehicles.loadCapacity,
          isAvailable: readyVehicles.isAvailable,
          currentLocation: readyVehicles.currentLocation,
          notes: readyVehicles.notes,
          supportsFlammable: readyVehicles.supportsFlammable,
          notAllowedFlammable: readyVehicles.notAllowedFlammable,
          createdAt: readyVehicles.createdAt,
          updatedAt: readyVehicles.updatedAt,
          // Vehicle template info
          vehicleTemplateName: vehicleTemplates.name,
          vehicleTemplateNameEn: vehicleTemplates.nameEn,
          vehicleType: vehicleTemplates.vehicleType
        })
        .from(readyVehicles)
        .innerJoin(vehicleTemplates, eq(readyVehicles.vehicleTemplateId, vehicleTemplates.id))
        .orderBy(readyVehicles.createdAt);

      // Map database fields to frontend expected format
      const mappedVehicles = vehicles.map(vehicle => ({
        id: vehicle.id,
        vehicleTemplateId: vehicle.vehicleTemplateId,
        vehicleType: vehicle.vehicleTemplateName, // For backward compatibility
        vehicleTemplateName: vehicle.vehicleTemplateName,
        vehicleTemplateNameEn: vehicle.vehicleTemplateNameEn,
        licensePlate: vehicle.licensePlate,
        driverName: vehicle.driverName,
        driverMobile: vehicle.driverMobile,
        loadCapacity: parseFloat(vehicle.loadCapacity || '0'),
        isAvailable: vehicle.isAvailable,
        currentLocation: vehicle.currentLocation,
        notes: vehicle.notes,
        supportsFlammable: vehicle.supportsFlammable,
        notAllowedFlammable: vehicle.notAllowedFlammable,
        createdAt: vehicle.createdAt.toISOString(),
        updatedAt: vehicle.updatedAt.toISOString()
      }));

      res.json({ success: true, data: mappedVehicles });
    } catch (error) {
      console.error('Error fetching ready vehicles:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch ready vehicles' });
    }
  });

  // Create new ready vehicle
  app.post('/api/logistics/ready-vehicles', requireAuth, async (req, res) => {
    try {
      const { readyVehicles } = await import('../shared/logistics-schema');
      
      const vehicleData = {
        vehicleTemplateId: req.body.vehicleTemplateId,
        licensePlate: req.body.licensePlate,
        driverName: req.body.driverName,
        driverMobile: req.body.driverMobile,
        loadCapacity: req.body.loadCapacity.toString(),
        isAvailable: req.body.isAvailable !== false,
        currentLocation: req.body.currentLocation || null,
        notes: req.body.notes || null,
        supportsFlammable: req.body.supportsFlammable || false,
        notAllowedFlammable: req.body.notAllowedFlammable || false,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const [newVehicle] = await db
        .insert(readyVehicles)
        .values(vehicleData)
        .returning();

      // Map response to frontend format
      const mappedVehicle = {
        id: newVehicle.id,
        vehicleType: newVehicle.vehicleType,
        licensePlate: newVehicle.licensePlate,
        driverName: newVehicle.driverName,
        driverMobile: newVehicle.driverMobile,
        loadCapacity: parseFloat(newVehicle.loadCapacity || '0'),
        isAvailable: newVehicle.isAvailable,
        currentLocation: newVehicle.currentLocation,
        notes: newVehicle.notes,
        supportsFlammable: newVehicle.supportsFlammable,
        notAllowedFlammable: newVehicle.notAllowedFlammable,
        createdAt: newVehicle.createdAt.toISOString(),
        updatedAt: newVehicle.updatedAt.toISOString()
      };

      res.status(201).json({ success: true, data: mappedVehicle });
    } catch (error) {
      console.error('Error creating ready vehicle:', error);
      
      if (error.code === '23505') { // Unique constraint violation
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ù¾Ù„Ø§Ú© Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª' 
        });
      }
      
      res.status(500).json({ success: false, message: 'Failed to create ready vehicle' });
    }
  });

  // Update ready vehicle
  app.put('/api/logistics/ready-vehicles/:id', requireAuth, async (req, res) => {
    try {
      const { readyVehicles } = await import('../shared/logistics-schema');
      const vehicleId = parseInt(req.params.id);
      
      if (isNaN(vehicleId)) {
        return res.status(400).json({ success: false, message: 'Invalid vehicle ID' });
      }

      const updateData = {
        vehicleType: req.body.vehicleType,
        licensePlate: req.body.licensePlate,
        driverName: req.body.driverName,
        driverMobile: req.body.driverMobile,
        loadCapacity: req.body.loadCapacity.toString(),
        isAvailable: req.body.isAvailable,
        currentLocation: req.body.currentLocation || null,
        notes: req.body.notes || null,
        supportsFlammable: req.body.supportsFlammable || false,
        notAllowedFlammable: req.body.notAllowedFlammable || false,
        updatedAt: new Date()
      };

      const [updatedVehicle] = await db
        .update(readyVehicles)
        .set(updateData)
        .where(eq(readyVehicles.id, vehicleId))
        .returning();

      if (!updatedVehicle) {
        return res.status(404).json({ success: false, message: 'Vehicle not found' });
      }

      // Map response to frontend format
      const mappedVehicle = {
        id: updatedVehicle.id,
        vehicleType: updatedVehicle.vehicleType,
        licensePlate: updatedVehicle.licensePlate,
        driverName: updatedVehicle.driverName,
        driverMobile: updatedVehicle.driverMobile,
        loadCapacity: parseFloat(updatedVehicle.loadCapacity || '0'),
        isAvailable: updatedVehicle.isAvailable,
        currentLocation: updatedVehicle.currentLocation,
        notes: updatedVehicle.notes,
        supportsFlammable: updatedVehicle.supportsFlammable,
        notAllowedFlammable: updatedVehicle.notAllowedFlammable,
        createdAt: updatedVehicle.createdAt.toISOString(),
        updatedAt: updatedVehicle.updatedAt.toISOString()
      };

      res.json({ success: true, data: mappedVehicle });
    } catch (error) {
      console.error('Error updating ready vehicle:', error);
      
      if (error.code === '23505') { // Unique constraint violation
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ù¾Ù„Ø§Ú© Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª' 
        });
      }
      
      res.status(500).json({ success: false, message: 'Failed to update ready vehicle' });
    }
  });

  // Delete ready vehicle
  app.delete('/api/logistics/ready-vehicles/:id', requireAuth, async (req, res) => {
    try {
      const { readyVehicles } = await import('../shared/logistics-schema');
      const vehicleId = parseInt(req.params.id);
      
      if (isNaN(vehicleId)) {
        return res.status(400).json({ success: false, message: 'Invalid vehicle ID' });
      }

      const [deletedVehicle] = await db
        .delete(readyVehicles)
        .where(eq(readyVehicles.id, vehicleId))
        .returning();

      if (!deletedVehicle) {
        return res.status(404).json({ success: false, message: 'Vehicle not found' });
      }

      res.json({ success: true, message: 'Vehicle deleted successfully' });
    } catch (error) {
      console.error('Error deleting ready vehicle:', error);
      res.status(500).json({ success: false, message: 'Failed to delete ready vehicle' });
    }
  });

  // Get pending payments for admin review
  app.get('/api/admin/pending-payments', requireAuth, async (req, res) => {
    try {
      // Get orders with pending payment status
      const pendingOrders = await db.select({
        orderId: orders.id,
        orderNumber: orders.orderNumber,
        customerId: orders.customerId,
        totalAmount: orders.totalAmount,
        paymentMethod: orders.paymentMethod,
        paymentGatewayId: orders.paymentGatewayId,
        createdAt: orders.createdAt
      })
      .from(orders)
      .where(eq(orders.paymentStatus, 'pending'))
      .orderBy(desc(orders.createdAt));

      // Get customer details for each order
      const ordersWithCustomers = await Promise.all(
        pendingOrders.map(async (order) => {
          let customer = null;
          if (order.customerId) {
            customer = await crmStorage.getCrmCustomerById(order.customerId);
          }
          return { ...order, customer };
        })
      );

      res.json({ success: true, data: ordersWithCustomers });
    } catch (error) {
      console.error('Error fetching pending payments:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch pending payments' });
    }
  });

  // =============================================================================
  // CUSTOMER WALLET SYSTEM ENDPOINTS
  // =============================================================================

  // Customer wallet endpoints
  app.get('/api/customer/wallet', async (req, res) => {
    try {
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const summary = await walletStorage.getCustomerWalletSummary(req.session.customerId);
      res.json({ success: true, data: summary });
    } catch (error) {
      console.error('Error fetching wallet summary:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet information' });
    }
  });

  // Get customer wallet balance only
  app.get('/api/customers/wallet/balance', async (req, res) => {
    try {
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const balance = await walletStorage.getWalletBalance(req.session.customerId);
      res.json({ success: true, balance: balance });
    } catch (error) {
      console.error('Error fetching wallet balance:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet balance' });
    }
  });

  // Get wallet recharge information/status
  app.get('/api/customer/wallet/recharge', async (req, res) => {
    try {
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      // Return wallet recharge information or status
      const requests = await walletStorage.getRechargeRequestsByCustomer(req.session.customerId);
      res.json({ success: true, data: requests });
    } catch (error) {
      console.error('Error fetching recharge info:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch recharge information' });
    }
  });

  // Create wallet recharge request
  app.post('/api/customer/wallet/recharge', async (req, res) => {
    try {
      console.log('ğŸ’° [WALLET-RECHARGE] POST request received:', req.body);
      console.log('ğŸ’° [WALLET-RECHARGE] Customer ID:', req.session.customerId);
      console.log('ğŸ’° [WALLET-RECHARGE] Admin ID:', req.session.adminId);
      
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        console.log('ğŸ’° [WALLET-RECHARGE] ERROR: Admin authenticated - not a customer');
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        console.log('ğŸ’° [WALLET-RECHARGE] ERROR: No customer ID in session');
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const { amount, currency, paymentMethod, paymentReference, customerNotes } = req.body;
      console.log('ğŸ’° [WALLET-RECHARGE] Request data:', { amount, currency, paymentMethod, paymentReference, customerNotes });

      if (!amount || amount <= 0) {
        console.log('ğŸ’° [WALLET-RECHARGE] ERROR: Invalid amount:', amount);
        return res.status(400).json({ success: false, message: "Valid amount is required" });
      }

      // Get or create wallet using CRM customer ID
      let wallet = await walletStorage.getWalletByCustomerId(req.session.customerId);
      console.log('ğŸ’° [WALLET-RECHARGE] Existing wallet:', wallet);
      
      if (!wallet) {
        console.log('ğŸ’° [WALLET-RECHARGE] Creating new wallet...');
        wallet = await walletStorage.createWallet({
          customerId: req.session.customerId,
          balance: "0",
          currency: currency || "IQD",
          status: "active"
        });
        console.log('ğŸ’° [WALLET-RECHARGE] New wallet created:', wallet);
      }

      console.log('ğŸ’° [WALLET-RECHARGE] Creating recharge request...');
      const rechargeRequest = await walletStorage.createRechargeRequest({
        customerId: req.session.customerId,
        walletId: wallet.id,
        amount: amount.toString(),
        currency: currency || "IQD",
        paymentMethod,
        paymentReference,
        customerNotes
      });

      console.log('ğŸ’° [WALLET-RECHARGE] Recharge request created successfully:', rechargeRequest);
      res.json({ success: true, data: rechargeRequest });
    } catch (error) {
      console.error('ğŸ’° [WALLET-RECHARGE] ERROR:', error);
      res.status(500).json({ success: false, message: 'Failed to create recharge request' });
    }
  });

  // Get customer's recharge requests
  app.get('/api/customer/wallet/recharge-requests', async (req, res) => {
    try {
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const requests = await walletStorage.getRechargeRequestsByCustomer(req.session.customerId);
      res.json({ success: true, data: requests });
    } catch (error) {
      console.error('Error fetching recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch recharge requests' });
    }
  });

  // Get customer wallet transactions
  app.get('/api/customer/wallet/transactions', async (req, res) => {
    try {
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const limit = parseInt(req.query.limit as string) || 50;
      const transactions = await walletStorage.getTransactionsByCustomer(req.session.customerId, limit);
      res.json({ success: true, data: transactions });
    } catch (error) {
      console.error('Error fetching wallet transactions:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet transactions' });
    }
  });

  // Admin wallet endpoints (Alternative without auth for specific cases)
  app.get('/api/wallet/stats', async (req, res) => {
    try {
      const statistics = await walletStorage.getWalletStatistics();
      res.json({ success: true, data: statistics });
    } catch (error) {
      console.error('Error fetching wallet statistics:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet statistics' });
    }
  });

  // Get customer wallet balance by customer ID
  app.get('/api/wallet/balance/:customerId', async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      if (isNaN(customerId)) {
        return res.status(400).json({ success: false, message: 'Invalid customer ID' });
      }
      
      const balance = await walletStorage.getWalletBalance(customerId);
      const wallet = await walletStorage.getWalletByCustomerId(customerId);
      
      res.json({ 
        success: true, 
        data: {
          customerId,
          balance,
          currency: wallet?.currency || 'IQD',
          walletExists: !!wallet
        }
      });
    } catch (error) {
      console.error('Error fetching customer wallet balance:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet balance' });
    }
  });

  // Get pending recharge requests (alternative without auth)
  app.get('/api/wallet/recharge-requests/pending', async (req, res) => {
    try {
      const requests = await walletStorage.getAllPendingRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching pending recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch pending recharge requests' });
    }
  });

  // Get all recharge requests (alternative without auth)
  app.get('/api/wallet/recharge-requests', async (req, res) => {
    try {
      const requests = await walletStorage.getAllRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching all recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch all recharge requests' });
    }
  });

  // Admin wallet endpoints (Original with auth)
  app.get('/api/admin/wallet/stats', requireAuth, async (req, res) => {
    try {
      const statistics = await walletStorage.getWalletStatistics();
      res.json({ success: true, data: statistics });
    } catch (error) {
      console.error('Error fetching wallet statistics:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet statistics' });
    }
  });

  // Get all wallet holders (admin)
  app.get('/api/admin/wallet/holders', requireAuth, async (req, res) => {
    try {
      const walletHolders = await walletStorage.getAllWalletHolders();
      res.json({ success: true, data: walletHolders });
    } catch (error) {
      console.error('Error fetching wallet holders:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet holders' });
    }
  });

  // Get pending recharge requests (admin)
  app.get('/api/admin/wallet/recharge-requests/pending', requireAuth, async (req, res) => {
    try {
      const requests = await walletStorage.getAllPendingRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching pending recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch pending recharge requests' });
    }
  });

  // Get all recharge requests (admin)
  app.get('/api/admin/wallet/recharge-requests', requireAuth, async (req, res) => {
    try {
      const requests = await walletStorage.getAllRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching all recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch all recharge requests' });
    }
  });

  // Process recharge request (approve/reject)
  app.post('/api/admin/wallet/recharge-requests/:id/process', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { action, adminNotes } = req.body; // action: 'approve' or 'reject'
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      if (action === 'approve') {
        const result = await walletStorage.processRechargeRequest(requestId, adminId);
        res.json({ 
          success: true, 
          message: "Recharge request approved and processed successfully",
          data: result 
        });
      } else if (action === 'reject') {
        const updatedRequest = await walletStorage.updateRechargeRequestStatus(
          requestId, 
          'rejected', 
          adminNotes, 
          adminId
        );
        res.json({ 
          success: true, 
          message: "Recharge request rejected",
          data: updatedRequest 
        });
      } else {
        res.status(400).json({ success: false, message: "Invalid action. Use 'approve' or 'reject'" });
      }
    } catch (error) {
      console.error('Error processing recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to process recharge request' 
      });
    }
  });

  // Approve recharge request (admin) - GET version for frontend buttons
  app.get('/api/admin/wallet/recharge-requests/:id/approve', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      const result = await walletStorage.processRechargeRequest(requestId, adminId);

      res.json({ 
        success: true, 
        message: "Recharge request approved and processed successfully",
        data: result 
      });
    } catch (error) {
      console.error('Error approving recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to approve recharge request' 
      });
    }
  });

  // Approve recharge request (admin) - POST version for form submission
  app.post('/api/admin/wallet/recharge-requests/:id/approve', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { adminNotes } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      const result = await walletStorage.processRechargeRequest(requestId, adminId);
      
      // Update with admin notes if provided
      if (adminNotes) {
        await walletStorage.updateRechargeRequestStatus(requestId, 'approved', adminNotes, adminId);
      }

      res.json({ 
        success: true, 
        message: "Recharge request approved and processed successfully",
        data: result 
      });
    } catch (error) {
      console.error('Error approving recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to approve recharge request' 
      });
    }
  });

  // Reject recharge request (admin)
  app.post('/api/admin/wallet/recharge-requests/:id/reject', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { rejectionReason, adminNotes } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      if (!rejectionReason) {
        return res.status(400).json({ success: false, message: "Rejection reason is required" });
      }

      // Update request status with rejection reason
      const updatedRequest = await walletStorage.updateRechargeRequestStatus(
        requestId, 
        'rejected', 
        adminNotes, 
        adminId
      );

      // Add rejection reason
      await customerDb
        .update(walletRechargeRequests)
        .set({ rejectionReason })
        .where(eq(walletRechargeRequests.id, requestId));

      res.json({ 
        success: true, 
        message: "Recharge request rejected",
        data: updatedRequest 
      });
    } catch (error) {
      console.error('Error rejecting recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to reject recharge request' 
      });
    }
  });

  // Search customers by email for admin (wallet management)
  app.get('/api/admin/customers/search', requireAuth, async (req, res) => {
    try {
      const { email } = req.query;
      
      if (!email || typeof email !== 'string' || email.length < 3) {
        return res.json({ success: true, data: [] });
      }
      
      // Search in CRM customers table
      const customers = await db.select({
        id: crmCustomers.id,
        firstName: crmCustomers.firstName,
        lastName: crmCustomers.lastName,
        email: crmCustomers.email,
        phone: crmCustomers.phone,
      })
      .from(crmCustomers)
      .where(sql`LOWER(${crmCustomers.email}) LIKE LOWER(${`%${email}%`})`)
      .limit(10);
      
      res.json({ 
        success: true, 
        data: customers 
      });
    } catch (error) {
      console.error('Error searching customers by email:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†" 
      });
    }
  });

  // Direct wallet balance modification by financial managers
  app.post('/api/admin/wallet/modify-balance', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ’° [WALLET-MODIFY] Request received:', req.body);
      
      if (!req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      const { customerId, amount, reason, modificationType } = req.body;

      // Validate required fields
      if (!customerId || amount === undefined || !reason || !modificationType) {
        return res.status(400).json({ 
          success: false, 
          message: "Customer ID, amount, reason, and modification type are required" 
        });
      }

      // Validate modification type
      if (!['credit', 'debit', 'set_balance'].includes(modificationType)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid modification type. Use 'credit', 'debit', or 'set_balance'" 
        });
      }

      let transaction;
      const currentBalance = await walletStorage.getWalletBalance(customerId);

      if (modificationType === 'credit') {
        transaction = await walletStorage.creditWallet(
          customerId,
          parseFloat(amount),
          `Manual credit by admin: ${reason}`,
          'admin_adjustment',
          null,
          req.session.adminId
        );
      } else if (modificationType === 'debit') {
        transaction = await walletStorage.debitWallet(
          customerId,
          parseFloat(amount),
          `Manual debit by admin: ${reason}`,
          'admin_adjustment',
          null,
          req.session.adminId
        );
      } else if (modificationType === 'set_balance') {
        // For set balance, calculate the difference and create appropriate transaction
        const targetBalance = parseFloat(amount);
        const difference = targetBalance - currentBalance;
        
        if (difference > 0) {
          transaction = await walletStorage.creditWallet(
            customerId,
            difference,
            `Balance adjustment by admin: ${reason}`,
            'admin_adjustment',
            null,
            req.session.adminId
          );
        } else if (difference < 0) {
          transaction = await walletStorage.debitWallet(
            customerId,
            Math.abs(difference),
            `Balance adjustment by admin: ${reason}`,
            'admin_adjustment',
            null,
            req.session.adminId
          );
        } else {
          return res.json({
            success: true,
            message: "No change needed - balance already at target amount",
            currentBalance: currentBalance
          });
        }
      }

      console.log('ğŸ’° [WALLET-MODIFY] Transaction completed:', transaction);

      res.json({ 
        success: true, 
        data: transaction,
        message: `Wallet ${modificationType} completed successfully`
      });
    } catch (error) {
      console.error('Error modifying wallet balance:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to modify wallet balance' });
    }
  });

  // Manual wallet adjustment (admin only)
  app.post('/api/admin/wallet/adjust', requireAuth, async (req, res) => {
    try {
      const { customerId, amount, description, type } = req.body; // type: 'credit' or 'debit'
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      if (!customerId || !amount || !description || !type) {
        return res.status(400).json({ success: false, message: "All fields are required" });
      }

      let transaction;
      if (type === 'credit') {
        transaction = await walletStorage.creditWallet(
          customerId,
          parseFloat(amount),
          description,
          'manual_adjustment',
          undefined,
          adminId
        );
      } else if (type === 'debit') {
        transaction = await walletStorage.debitWallet(
          customerId,
          parseFloat(amount),
          description,
          'manual_adjustment',
          undefined,
          adminId
        );
      } else {
        return res.status(400).json({ success: false, message: "Invalid type. Use 'credit' or 'debit'" });
      }

      res.json({ 
        success: true, 
        message: `Wallet ${type} adjustment completed successfully`,
        data: transaction 
      });
    } catch (error) {
      console.error('Error adjusting wallet:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to adjust wallet' 
      });
    }
  });

  // Process order refund to wallet
  app.post('/api/orders/:orderId/refund', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { amount, reason, refundType = 'full' } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      // Get order details
      const order = await customerStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Validate refund amount
      const orderAmount = parseFloat(order.totalAmount);
      const refundAmount = refundType === 'full' ? orderAmount : parseFloat(amount);
      
      if (refundAmount <= 0 || refundAmount > orderAmount) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù…Ø¨Ù„Øº Ø¨Ø±Ú¯Ø´ØªÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      // Process wallet refund
      const transaction = await walletStorage.creditWallet(
        order.customerId,
        refundAmount,
        `Ø¨Ø±Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø³ÙØ§Ø±Ø´ #${order.orderNumber} - ${reason || 'Ø¹Ø¯Ù… Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª'}`,
        'refund',
        orderId,
        adminId
      );

      // Update order status
      await customerStorage.updateOrder(orderId, {
        status: refundType === 'full' ? 'refunded' : 'partially_refunded',
        paymentStatus: refundType === 'full' ? 'refunded' : 'partial_refund',
        refundAmount: refundAmount.toString(),
        refundReason: reason,
        refundDate: new Date(),
        refundProcessedBy: adminId
      });

      console.log(`âœ… Order refund processed: ${refundAmount} IQD credited to customer ${order.customerId}, transaction ID: ${transaction.id}`);

      res.json({
        success: true,
        message: "Ø¨Ø±Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
        data: {
          refundAmount,
          transactionId: transaction.id,
          newWalletBalance: transaction.balanceAfter
        }
      });

    } catch (error) {
      console.error('Error processing refund:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ø±Ú¯Ø´Øª ÙˆØ¬Ù‡'
      });
    }
  });

  // =============================================================================
  // TICKETING SYSTEM API ENDPOINTS
  // =============================================================================

  // Get ticket constants (priorities, statuses, categories) - NO AUTH REQUIRED
  app.get('/api/ticketing/constants', (req, res) => {
    // No authentication required for constants - using different path to avoid auth conflicts
    res.json({
      success: true,
      data: {
        priorities: TICKET_PRIORITIES,
        statuses: TICKET_STATUSES,
        categories: TICKET_CATEGORIES
      }
    });
  });

  // Create new support ticket
  app.post('/api/tickets', async (req, res) => {
    try {
      // Manual validation for guest users - bypass schema validation that requires auth fields
      const { title, description, category, priority = 'normal', department } = req.body;
      
      if (!title || !description || !category) {
        return res.status(400).json({
          success: false,
          message: 'Title, description, and category are required'
        });
      }
      
      const validatedData = { title, description, category, priority, department };
      const adminId = req.session.adminId;
      const customerId = req.session.customerId;
      const customUserId = req.session.customUserId;

      // Allow guest ticket creation for demo/testing purposes
      const isGuestTicket = !adminId && !customerId && !customUserId;

      // Use admin info, customer info, custom user info, or guest info
      const submitterInfo = adminId ? {
        submittedBy: adminId,
        submitterName: req.session.adminName || 'Admin User',
        submitterEmail: req.session.adminEmail || 'admin@momtazchem.com',
        submitterDepartment: req.session.adminDepartment || 'Administration',
        customerUserId: null
      } : customUserId ? {
        submittedBy: 999, // Default ID for custom users
        submitterName: req.session.customUserName || 'Custom User',
        submitterEmail: req.session.customUserEmail || 'user@momtazchem.com',
        submitterDepartment: 'Custom User',
        customerUserId: customUserId
      } : customerId ? {
        submittedBy: customerId,
        submitterName: req.session.customerEmail || 'Customer',
        submitterEmail: req.session.customerEmail || 'customer@momtazchem.com',
        submitterDepartment: 'Customer',
        customerUserId: null
      } : {
        submittedBy: 0,  // Guest user
        submitterName: 'Guest User',
        submitterEmail: 'guest@momtazchem.com',
        submitterDepartment: 'Guest',
        customerUserId: null
      };

      // Merge validated data with submitter info, ensuring all required fields are present
      const ticketData = {
        title: validatedData.title,
        description: validatedData.description,
        category: validatedData.category,
        priority: validatedData.priority || 'normal',
        department: validatedData.department,
        submittedBy: submitterInfo.submittedBy,
        customerUserId: submitterInfo.customerUserId,
        submitterName: submitterInfo.submitterName,
        submitterEmail: submitterInfo.submitterEmail,
        submitterDepartment: submitterInfo.submitterDepartment,
        status: 'open',
        // Optional fields
        assignedTo: null,
        attachments: null,
        tags: null,
        estimatedResolution: null,
        actualResolution: null,
        resolutionNotes: null,
        customerSatisfaction: null,
        internalNotes: null,
        isUrgent: false,
        followUpRequired: false,
        followUpDate: null
      };

      // Create ticket directly bypassing type validation
      const ticketNumber = `TKT-${Date.now()}`;
      const [ticket] = await db.insert(supportTickets).values({
        ...ticketData,
        ticketNumber,
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();

      console.log(`âœ… New support ticket created: ${ticket.ticketNumber} by ${submitterInfo.submitterName}`);

      res.json({
        success: true,
        message: "ØªÛŒÚ©Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯",
        data: ticket
      });

    } catch (error) {
      console.error('Error creating support ticket:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªÛŒÚ©Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ'
      });
    }
  });

  // Get all tickets (role-based access control)
  app.get('/api/tickets', requireAuth, async (req, res) => {
    try {
      const { 
        status, 
        priority, 
        category, 
        assignedTo, 
        submittedBy, 
        limit = 50, 
        offset = 0 
      } = req.query;

      const adminId = req.session.adminId;
      const customUserId = req.session.customUserId;

      // Check if user is super admin (ID 7) or admin@momtazchem.com
      const isSuperAdmin = adminId && (adminId === 7 || req.session.adminEmail === 'admin@momtazchem.com');

      let filters = {
        status: status as string,
        priority: priority as string,
        category: category as string,
        assignedTo: assignedTo ? parseInt(assignedTo as string) : undefined,
        submittedBy: submittedBy ? parseInt(submittedBy as string) : undefined,
        limit: parseInt(limit as string),
        offset: parseInt(offset as string)
      };

      // If not super admin, only show tickets submitted by the current user
      if (!isSuperAdmin) {
        // For custom users, use the new getTicketsByCustomUser method
        if (customUserId) {
          const tickets = await ticketingStorage.getTicketsByCustomUser(customUserId, filters.limit, filters.offset);
          return res.json({
            success: true,
            data: tickets
          });
        } else if (adminId) {
          // For regular admins, show only their own tickets
          filters.submittedBy = adminId;
        } else {
          // No access for non-authenticated users
          return res.status(403).json({
            success: false,
            message: 'Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¬Ø§Ø² Ù†Ù…ÛŒâ€ŒØ¨Ø§Ø´Ø¯'
          });
        }
      }

      const tickets = await ticketingStorage.getTickets(filters);

      res.json({
        success: true,
        data: tickets
      });

    } catch (error) {
      console.error('Error fetching tickets:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });

  // Get tickets for current user
  app.get('/api/tickets/my-tickets', async (req, res) => {
    try {
      const { limit = 50, offset = 0 } = req.query;
      const adminId = req.session.adminId;
      const customerId = req.session.customerId;

      const userId = adminId || customerId || 0; // Use 0 for guest users

      const tickets = await ticketingStorage.getTicketsByUser(
        userId, 
        parseInt(limit as string), 
        parseInt(offset as string)
      );

      res.json({
        success: true,
        data: tickets
      });

    } catch (error) {
      console.error('Error fetching user tickets:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§'
      });
    }
  });

  // Get single ticket by ID (with access control)
  app.get('/api/tickets/:id', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const ticket = await ticketingStorage.getTicketById(ticketId);

      if (!ticket) {
        return res.status(404).json({
          success: false,
          message: 'ØªÛŒÚ©Øª ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      const adminId = req.session.adminId;
      const customUserId = req.session.customUserId;

      // Check if user is super admin or owns this ticket
      const isSuperAdmin = adminId && (adminId === 7 || req.session.adminEmail === 'admin@momtazchem.com');
      const isTicketOwner = (customUserId && ticket.submittedBy === customUserId) || 
                           (adminId && ticket.submittedBy === adminId);

      if (!isSuperAdmin && !isTicketOwner) {
        return res.status(403).json({
          success: false,
          message: 'Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§ÛŒÙ† ØªÛŒÚ©Øª Ù†ÛŒØ³ØªÛŒØ¯'
        });
      }

      // Get ticket responses
      const responses = await ticketingStorage.getTicketResponses(ticketId);
      
      // Get status history
      const statusHistory = await ticketingStorage.getTicketStatusHistory(ticketId);

      res.json({
        success: true,
        data: {
          ticket,
          responses,
          statusHistory
        }
      });

    } catch (error) {
      console.error('Error fetching ticket:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªÛŒÚ©Øª'
      });
    }
  });

  // Update ticket status
  app.patch('/api/tickets/:id/status', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { status, reason } = req.body;
      const adminId = req.session.adminId;
      const user = req.session.user;

      if (!TICKET_STATUSES.includes(status)) {
        return res.status(400).json({
          success: false,
          message: 'ÙˆØ¶Ø¹ÛŒØª ØªÛŒÚ©Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª'
        });
      }

      const userInfo = adminId ? {
        userId: adminId,
        userName: req.session.adminName || 'Admin User',
        userType: 'admin' as const
      } : {
        userId: user.id,
        userName: user.firstName + ' ' + user.lastName,
        userType: 'site_manager' as const
      };

      await ticketingStorage.updateTicketStatus(
        ticketId,
        status,
        userInfo.userId,
        userInfo.userName,
        userInfo.userType,
        reason
      );

      console.log(`âœ… Ticket ${ticketId} status updated to ${status} by ${userInfo.userName}`);

      res.json({
        success: true,
        message: 'ÙˆØ¶Ø¹ÛŒØª ØªÛŒÚ©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });

    } catch (error) {
      console.error('Error updating ticket status:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª ØªÛŒÚ©Øª'
      });
    }
  });

  // Get ticket responses
  app.get('/api/tickets/:id/responses', async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const responses = await ticketingStorage.getTicketResponses(ticketId);

      res.json({
        success: true,
        data: responses
      });

    } catch (error) {
      console.error('Error getting ticket responses:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§'
      });
    }
  });

  // Add response to ticket
  app.post('/api/tickets/:id/responses', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { message, attachments, isInternal } = req.body;
      const adminId = req.session.adminId;
      const user = req.session.user;

      const senderInfo = adminId ? {
        senderId: adminId,
        senderName: req.session.adminName || 'Admin User',
        senderType: 'admin' as const
      } : {
        senderId: user.id,
        senderName: user.firstName + ' ' + user.lastName,
        senderType: 'site_manager' as const
      };

      const responseData = {
        ticketId,
        message,
        attachments: attachments || [],
        isInternal: isInternal || false,
        ...senderInfo
      };

      const response = await ticketingStorage.createTicketResponse(responseData);

      console.log(`âœ… New response added to ticket ${ticketId} by ${senderInfo.senderName}`);

      res.json({
        success: true,
        message: 'Ù¾Ø§Ø³Ø® Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯',
        data: response
      });

    } catch (error) {
      console.error('Error adding ticket response:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø³Ø®'
      });
    }
  });

  // Assign ticket to admin
  app.post('/api/tickets/:id/assign', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { assignedTo, notes } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(403).json({
          success: false,
          message: 'ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªÛŒÚ©Øª Ø±Ø§ ÙˆØ§Ú¯Ø°Ø§Ø± Ú©Ù†Ø¯'
        });
      }

      const assignment = await ticketingStorage.assignTicket(
        ticketId,
        assignedTo,
        adminId,
        notes
      );

      console.log(`âœ… Ticket ${ticketId} assigned to admin ${assignedTo} by admin ${adminId}`);

      res.json({
        success: true,
        message: 'ØªÛŒÚ©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ú¯Ø°Ø§Ø± Ø´Ø¯',
        data: assignment
      });

    } catch (error) {
      console.error('Error assigning ticket:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ÙˆØ§Ú¯Ø°Ø§Ø±ÛŒ ØªÛŒÚ©Øª'
      });
    }
  });

  // Get ticket statistics
  app.get('/api/tickets/stats/overview', async (req, res) => {
    // Allow guest access for demo purposes
    try {
      const stats = await ticketingStorage.getTicketStats();

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      console.error('Error fetching ticket stats:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });

  // Get user ticket statistics
  app.get('/api/tickets/stats/user', async (req, res) => {
    try {
      const adminId = req.session.adminId;
      const customerId = req.session.customerId;
      const userId = adminId || customerId || 0; // Use 0 for guest users

      const stats = await ticketingStorage.getUserTicketStats(userId);

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      console.error('Error fetching user ticket stats:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±'
      });
    }
  });

  // Get ticket categories
  app.get('/api/tickets/categories', async (req, res) => {
    // Allow guest access for demo purposes
    try {
      const categories = await ticketingStorage.getTicketCategories();

      res.json({
        success: true,
        data: categories
      });

    } catch (error) {
      console.error('Error fetching ticket categories:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });

  // Search tickets
  app.get('/api/tickets/search', async (req, res) => {
    // Allow guest access for demo purposes
    try {
      const { q: query, status, priority, category } = req.query;

      if (!query) {
        return res.status(400).json({
          success: false,
          message: 'Query parameter is required'
        });
      }

      const filters = {
        status: status as string,
        priority: priority as string,
        category: category as string
      };

      const tickets = await ticketingStorage.searchTickets(query as string, filters);

      res.json({
        success: true,
        data: tickets
      });

    } catch (error) {
      console.error('Error searching tickets:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });



  // NOTE: Automatic wallet refunds for failed payments are now handled centrally 
  // in the payment callback endpoint (/api/payment/callback) to avoid duplicate processing

  // Get customer wallet details (admin)
  app.get('/api/admin/wallet/customer/:customerId', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      const summary = await walletStorage.getCustomerWalletSummary(customerId);
      
      // Get customer details
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      res.json({ 
        success: true, 
        data: { 
          ...summary, 
          customer 
        } 
      });
    } catch (error) {
      console.error('Error fetching customer wallet details:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch customer wallet details' });
    }
  });

  // FORCE WALLET SYNC: Force refresh wallet data and clear inconsistencies
  app.post('/api/wallet/force-sync/:customerId', async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      
      console.log(`ğŸ”„ [WALLET SYNC] Force syncing wallet for customer ${customerId}`);
      
      // 1. Get current wallet state directly from database
      const directWallet = await customerDb
        .select()
        .from(customerWallets)
        .where(eq(customerWallets.customerId, customerId));
      
      // 2. Recalculate balance from all transactions
      const allTransactions = await customerDb
        .select()
        .from(walletTransactions)
        .where(eq(walletTransactions.customerId, customerId))
        .orderBy(walletTransactions.createdAt);
      
      let calculatedBalance = 0;
      for (const transaction of allTransactions) {
        const amount = parseFloat(transaction.amount);
        if (transaction.transactionType === 'credit') {
          calculatedBalance += amount;
        } else if (transaction.transactionType === 'debit') {
          calculatedBalance -= amount;
        }
      }
      
      // 3. If no wallet exists but should have one, create it
      let wallet;
      if (directWallet.length === 0 && calculatedBalance !== 0) {
        console.log(`ğŸ†• [WALLET SYNC] Creating missing wallet for customer ${customerId}`);
        wallet = await walletStorage.createWallet({
          customerId,
          balance: calculatedBalance.toString(),
          currency: "IQD",
          status: "active"
        });
      } else if (directWallet.length > 0) {
        // 4. Update existing wallet balance if different
        const currentBalance = parseFloat(directWallet[0].balance);
        if (Math.abs(currentBalance - calculatedBalance) > 0.01) { // Allow for small rounding differences
          console.log(`ğŸ”„ [WALLET SYNC] Updating balance from ${currentBalance} to ${calculatedBalance}`);
          wallet = await walletStorage.updateWalletBalance(directWallet[0].id, calculatedBalance);
        } else {
          wallet = directWallet[0];
        }
      }
      
      // 5. Get fresh summary after sync
      const freshSummary = await walletStorage.getCustomerWalletSummary(customerId);
      
      const syncResult = {
        customerId,
        timestamp: new Date().toISOString(),
        beforeSync: {
          walletExists: directWallet.length > 0,
          walletBalance: directWallet.length > 0 ? parseFloat(directWallet[0].balance) : 0,
          transactionCount: allTransactions.length
        },
        calculatedBalance,
        afterSync: {
          wallet,
          summary: freshSummary
        },
        actions: {
          walletCreated: directWallet.length === 0 && calculatedBalance !== 0,
          balanceUpdated: directWallet.length > 0 && Math.abs(parseFloat(directWallet[0].balance) - calculatedBalance) > 0.01,
          alreadyInSync: directWallet.length > 0 && Math.abs(parseFloat(directWallet[0].balance) - calculatedBalance) <= 0.01
        }
      };
      
      console.log(`âœ… [WALLET SYNC] Sync completed:`, JSON.stringify(syncResult, null, 2));
      
      res.json({
        success: true,
        message: 'Wallet synchronization completed',
        data: syncResult
      });
      
    } catch (error) {
      console.error('ğŸ”„ [WALLET SYNC] Error during sync:', error);
      res.status(500).json({
        success: false,
        message: 'Wallet synchronization failed',
        error: error.message
      });
    }
  });

  // CLEAR CUSTOMER CACHE: Clear all cached data for customer
  app.post('/api/customer/clear-cache', async (req, res) => {
    try {
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }
      
      const customerId = req.session.customerId;
      console.log(`ğŸ§¹ [CACHE CLEAR] Clearing cache for customer ${customerId}`);
      
      // Clear any server-side cache if exists
      // Note: This is mostly for client-side cache clearing instruction
      
      res.json({
        success: true,
        message: 'Cache clear instruction sent',
        data: {
          customerId,
          timestamp: new Date().toISOString(),
          instructions: {
            localStorage: 'localStorage.clear()',
            sessionStorage: 'sessionStorage.clear()',
            location: 'location.reload(true)'
          }
        }
      });
      
    } catch (error) {
      console.error('ğŸ§¹ [CACHE CLEAR] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Cache clear failed',
        error: error.message
      });
    }
  });

  // DIAGNOSTIC ENDPOINT: Debug wallet discrepancy for specific customers
  app.get('/api/debug/wallet-discrepancy/:customerId', async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      
      console.log(`ğŸ” [WALLET DEBUG] Investigating wallet discrepancy for customer ${customerId}`);
      
      // 1. Direct database queries
      const directWallet = await customerDb
        .select()
        .from(customerWallets)
        .where(eq(customerWallets.customerId, customerId));
      
      const directTransactions = await customerDb
        .select()
        .from(walletTransactions)
        .where(eq(walletTransactions.customerId, customerId))
        .orderBy(desc(walletTransactions.createdAt))
        .limit(10);
      
      const directRecharges = await customerDb
        .select()
        .from(walletRechargeRequests)
        .where(eq(walletRechargeRequests.customerId, customerId))
        .orderBy(desc(walletRechargeRequests.createdAt))
        .limit(5);

      // 2. Using wallet storage methods
      const storageBalance = await walletStorage.getWalletBalance(customerId);
      const storageSummary = await walletStorage.getCustomerWalletSummary(customerId);
      
      // 3. Customer details
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      const diagnosticData = {
        customerId,
        customer,
        timestamp: new Date().toISOString(),
        directQueries: {
          wallet: directWallet,
          transactions: directTransactions,
          recharges: directRecharges
        },
        storageResults: {
          balance: storageBalance,
          summary: storageSummary
        },
        analysis: {
          hasWallet: directWallet.length > 0,
          hasTransactions: directTransactions.length > 0,
          hasRecharges: directRecharges.length > 0,
          calculatedBalance: directWallet.length > 0 ? parseFloat(directWallet[0].balance) : 0
        }
      };
      
      console.log(`ğŸ” [WALLET DEBUG] Results:`, JSON.stringify(diagnosticData, null, 2));
      
      res.json({ 
        success: true, 
        message: 'Diagnostic data collected successfully',
        data: diagnosticData
      });
      
    } catch (error) {
      console.error('ğŸ” [WALLET DEBUG] Error during diagnostic:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Diagnostic failed',
        error: error.message 
      });
    }
  });

  // =============================================================================
  // GEOGRAPHIC ANALYTICS API - TEST ENDPOINT
  // =============================================================================

  // Test endpoint for geographic data
  app.get('/api/test/geographic', async (req, res) => {
    try {
      console.log('ğŸ§ª [TEST] Testing geographic data endpoint');
      
      const testData = await customerDb.select({
        country: sql`${customerOrders.shippingAddress}->>'country'`.as('country'),
        city: sql`${customerOrders.shippingAddress}->>'city'`.as('city'),
        count: sql`count(*)::int`.as('count')
      })
      .from(customerOrders)
      .where(
        and(
          isNotNull(sql`${customerOrders.shippingAddress}->>'country'`),
          isNotNull(sql`${customerOrders.shippingAddress}->>'city'`)
        )
      )
      .groupBy(sql`${customerOrders.shippingAddress}->>'country'`, sql`${customerOrders.shippingAddress}->>'city'`)
      .orderBy(sql`count(*) desc`)
      .limit(5);
      
      console.log('ğŸ§ª [TEST] Query result:', testData.length, 'records found');
      
      res.json({
        success: true,
        message: 'Test endpoint working',
        data: testData
      });
    } catch (error) {
      console.error('ğŸ§ª [TEST] Error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Test endpoint failed',
        error: error.message 
      });
    }
  });

  // =============================================================================
  // GEOGRAPHIC ANALYTICS API
  // =============================================================================

  // Geographic Analytics API endpoints
  app.get('/api/analytics/geographic', async (req, res) => {
    try {
      console.log('ğŸŒ [GEO] Starting geographic analytics endpoint');
      const { period = '30d', region = 'all' } = req.query;
      
      // Calculate date range based on period
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Get total unique customers count across all regions
      const totalCustomersResult = await customerDb.select({
        totalUniqueCustomers: sql`count(distinct ${customerOrders.customerId})::int`.as('totalUniqueCustomers')
      })
      .from(customerOrders)
      .where(
        and(
          isNotNull(sql`${customerOrders.shippingAddress}->>'country'`),
          isNotNull(sql`${customerOrders.shippingAddress}->>'city'`)
        )
      );

      const totalUniqueCustomers = totalCustomersResult[0]?.totalUniqueCustomers || 0;

      // Get orders with geographic data from shipping_address JSON
      const geoData = await customerDb.select({
        country: sql`${customerOrders.shippingAddress}->>'country'`.as('country'),
        city: sql`${customerOrders.shippingAddress}->>'city'`.as('city'),
        totalOrders: sql`count(*)::int`.as('totalOrders'),
        totalRevenue: sql`sum(${customerOrders.totalAmount})::numeric`.as('totalRevenue'),
        customerCount: sql`count(distinct ${customerOrders.customerId})::int`.as('customerCount')
      })
      .from(customerOrders)
      .where(
        and(
          isNotNull(sql`${customerOrders.shippingAddress}->>'country'`),
          isNotNull(sql`${customerOrders.shippingAddress}->>'city'`)
        )
      )
      .groupBy(sql`${customerOrders.shippingAddress}->>'country'`, sql`${customerOrders.shippingAddress}->>'city'`)
      .orderBy(sql`sum(${customerOrders.totalAmount}) desc`)
      .limit(20);
      
      console.log('ğŸŒ [GEO] Query result:', geoData.length, 'records found');
      console.log('ğŸŒ [GEO] Total unique customers:', totalUniqueCustomers);
      
      // Process data to add calculated fields and match frontend expectations
      const processedData = geoData.map((region) => {
        const totalRevenue = Number(region.totalRevenue) || 0;
        const avgOrderValue = region.totalOrders > 0 ? totalRevenue / region.totalOrders : 0;
        
        return {
          region: `${region.country}, ${region.city}`, // Combined region field for frontend
          country: region.country,
          city: region.city,
          totalOrders: region.totalOrders,
          totalRevenue: totalRevenue,
          customerCount: region.customerCount,
          avgOrderValue: Number(avgOrderValue.toFixed(2)),
          topProducts: [] // Simplified for now
        };
      });

      console.log('ğŸŒ [GEO] Processed data sample:', processedData.slice(0, 2));
      res.json({ 
        success: true, 
        data: processedData,
        summary: {
          totalUniqueCustomers: totalUniqueCustomers
        }
      });
    } catch (error) {
      console.error('Geographic analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch geographic analytics data' });
    }
  });

  app.get('/api/analytics/products', async (req, res) => {
    try {
      const { period = '30d', product = 'all' } = req.query;
      
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Get all shop products with their sales data (LEFT JOIN to include products with zero sales)
      const allProductsQuery = await customerDb.select({
        id: shopProducts.id,
        name: shopProducts.name,
        category: shopProducts.category
      })
      .from(shopProducts)
      .where(eq(shopProducts.inStock, true));

      console.log('ğŸ“Š [PRODUCTS] Found', allProductsQuery.length, 'products in shop');

      // For each product, calculate sales data
      const productData = await Promise.all(allProductsQuery.map(async (product) => {
        const salesData = await customerDb.select({
          totalSales: sql`COALESCE(sum(${orderItems.quantity}), 0)::int`.as('totalSales'),
          revenue: sql`COALESCE(sum(${orderItems.quantity} * ${orderItems.unitPrice}), 0)::numeric`.as('revenue')
        })
        .from(orderItems)
        .innerJoin(customerOrders, eq(orderItems.orderId, customerOrders.id))
        .where(and(
          eq(orderItems.productId, product.id),
          gte(customerOrders.createdAt, startDate)
        ));

        const sales = salesData[0] || { totalSales: 0, revenue: 0 };
        
        return {
          name: product.name,
          category: product.category,
          totalSales: Number(sales.totalSales) || 0,
          revenue: Number(sales.revenue) || 0
        };
      }));

      // Sort by revenue descending
      productData.sort((a, b) => b.revenue - a.revenue);

      // Filter by specific product if requested
      const filteredProductData = product && product !== 'all' 
        ? productData.filter(p => p.name === product)
        : productData;
      
      // Get regional breakdown for each product
      const processedData = await Promise.all(filteredProductData.map(async (productInfo) => {
        try {
          const regionsQuery = await customerDb.execute(sql`
            SELECT 
              COALESCE(
                (shipping_address->>'country'),
                CASE 
                  WHEN shipping_address::text LIKE '%Iran%' THEN 'Iran'
                  WHEN shipping_address::text LIKE '%Iraq%' THEN 'Iraq' 
                  WHEN shipping_address::text LIKE '%Turkey%' THEN 'Turkey'
                  ELSE 'Unknown'
                END
              ) as region,
              COALESCE(
                (shipping_address->>'city'),
                CASE 
                  WHEN shipping_address::text LIKE '%ØªÙ‡Ø±Ø§Ù†%' OR shipping_address::text LIKE '%Tehran%' THEN 'Tehran'
                  WHEN shipping_address::text LIKE '%Ø¨ØºØ¯Ø§Ø¯%' OR shipping_address::text LIKE '%Baghdad%' THEN 'Baghdad'
                  WHEN shipping_address::text LIKE '%Ø§Ø±Ø¨ÛŒÙ„%' OR shipping_address::text LIKE '%Erbil%' THEN 'Erbil'
                  ELSE 'Unknown'
                END
              ) as city,
              sum(oi.quantity)::int as quantity,
              sum(oi.quantity * oi.unit_price)::numeric as revenue
            FROM order_items oi
            INNER JOIN customer_orders co ON oi.order_id = co.id
            INNER JOIN shop_products sp ON oi.product_id = sp.id
            WHERE sp.name = ${productInfo.name}
              AND co.created_at >= ${startDate.toISOString()}
              AND co.shipping_address IS NOT NULL
            GROUP BY 
              COALESCE(
                (shipping_address->>'country'),
                CASE 
                  WHEN shipping_address::text LIKE '%Iran%' THEN 'Iran'
                  WHEN shipping_address::text LIKE '%Iraq%' THEN 'Iraq' 
                  WHEN shipping_address::text LIKE '%Turkey%' THEN 'Turkey'
                  ELSE 'Unknown'
                END
              ),
              COALESCE(
                (shipping_address->>'city'),
                CASE 
                  WHEN shipping_address::text LIKE '%ØªÙ‡Ø±Ø§Ù†%' OR shipping_address::text LIKE '%Tehran%' THEN 'Tehran'
                  WHEN shipping_address::text LIKE '%Ø¨ØºØ¯Ø§Ø¯%' OR shipping_address::text LIKE '%Baghdad%' THEN 'Baghdad'
                  WHEN shipping_address::text LIKE '%Ø§Ø±Ø¨ÛŒÙ„%' OR shipping_address::text LIKE '%Erbil%' THEN 'Erbil'
                  ELSE 'Unknown'
                END
              )
            ORDER BY sum(oi.quantity * oi.unit_price) DESC
            LIMIT 10
          `);

          const regions = regionsQuery.rows.map((row: any) => ({
            region: row.region,
            city: row.city,
            quantity: parseInt(row.quantity) || 0,
            revenue: parseFloat(row.revenue) || 0
          }));

          console.log(`ğŸ“ [PRODUCT-REGIONS] Product: ${productInfo.name}, Found ${regions.length} regions:`, regions);

          return {
            name: productInfo.name,
            category: productInfo.category,
            totalSales: productInfo.totalSales,
            revenue: Number(productInfo.revenue),
            regions: regions
          };
        } catch (error) {
          console.error(`Error fetching regions for product ${productInfo.name}:`, error);
          return {
            name: productInfo.name,
            category: productInfo.category,
            totalSales: productInfo.totalSales,
            revenue: Number(productInfo.revenue),
            regions: [] // Fallback to empty array
          };
        }
      }));

      res.json({ success: true, data: processedData });
    } catch (error) {
      console.error('Product analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch product analytics data' });
    }
  });

  app.get('/api/analytics/timeseries', async (req, res) => {
    try {
      console.log('ğŸ• [TIMESERIES] Starting timeseries analytics endpoint');
      
      const { period = '30d' } = req.query;
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Use simple aggregation without complex GROUP BY
      const orders = await customerDb.select()
        .from(customerOrders)
        .where(gte(customerOrders.createdAt, startDate));

      console.log(`ğŸ• [TIMESERIES] Found ${orders.length} orders since ${startDate.toISOString()}`);

      // Group by date in JavaScript to avoid SQL GROUP BY issues
      const dateGroups: { [key: string]: { orders: number, revenue: number } } = {};
      
      orders.forEach(order => {
        const dateKey = order.createdAt.toISOString().split('T')[0]; // YYYY-MM-DD format
        if (!dateGroups[dateKey]) {
          dateGroups[dateKey] = { orders: 0, revenue: 0 };
        }
        dateGroups[dateKey].orders += 1;
        dateGroups[dateKey].revenue += Number(order.totalAmount || 0);
      });

      // Convert to array and sort by date
      const processedData = Object.entries(dateGroups)
        .map(([date, stats]) => ({
          date,
          orders: stats.orders,
          revenue: stats.revenue,
          regions: {}
        }))
        .sort((a, b) => a.date.localeCompare(b.date));

      console.log(`ğŸ• [TIMESERIES] Processed data: ${processedData.length} date groups`);
      res.json({ success: true, data: processedData });
    } catch (error) {
      console.error('Time series analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch time series analytics data' });
    }
  });

  app.get('/api/analytics/product-trends', async (req, res) => {
    try {
      console.log('ğŸ“ˆ [PRODUCT-TRENDS] Starting product trends analytics endpoint');
      
      const { period = '30d', product = 'all' } = req.query;
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Get order items with related data using simple joins
      const orderItemsData = await customerDb.select({
        orderId: orderItems.orderId,
        productId: orderItems.productId,
        quantity: orderItems.quantity,
        unitPrice: orderItems.unitPrice,
        createdAt: customerOrders.createdAt,
        productName: shopProducts.name
      })
      .from(orderItems)
      .innerJoin(customerOrders, eq(orderItems.orderId, customerOrders.id))
      .innerJoin(shopProducts, eq(orderItems.productId, shopProducts.id))
      .where(gte(customerOrders.createdAt, startDate));

      console.log(`ğŸ“ˆ [PRODUCT-TRENDS] Found ${orderItemsData.length} order items since ${startDate.toISOString()}`);

      // Filter by product if specified
      let filteredData = orderItemsData;
      if (product && product !== 'all') {
        filteredData = orderItemsData.filter(item => item.productName === product);
        console.log(`ğŸ“ˆ [PRODUCT-TRENDS] Filtered to ${filteredData.length} items for product: ${product}`);
      }

      // Group by date and product in JavaScript
      const trends: { [key: string]: { date: string, productName: string, quantity: number, revenue: number } } = {};
      
      filteredData.forEach(item => {
        const dateKey = item.createdAt.toISOString().split('T')[0]; // YYYY-MM-DD format
        const key = `${dateKey}-${item.productName}`;
        
        if (!trends[key]) {
          trends[key] = {
            date: dateKey,
            productName: item.productName,
            quantity: 0,
            revenue: 0
          };
        }
        
        trends[key].quantity += item.quantity;
        trends[key].revenue += item.quantity * Number(item.unitPrice || 0);
      });

      // Convert to array and sort
      const processedData = Object.values(trends)
        .sort((a, b) => {
          const dateCompare = a.date.localeCompare(b.date);
          if (dateCompare !== 0) return dateCompare;
          return b.revenue - a.revenue; // Sort by revenue desc within same date
        });

      console.log(`ğŸ“ˆ [PRODUCT-TRENDS] Processed data: ${processedData.length} product-date combinations`);
      res.json({ success: true, data: processedData });
    } catch (error) {
      console.error('Product trends analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch product trends analytics data' });
    }
  });

  // GEOGRAPHIC DISTRIBUTION REPORTS API
  // =============================================================================

  // Geographic Distribution Reports API
  app.get('/api/reports/geographic-distribution', async (req, res) => {
    try {
      // Get customer geographic distribution data
      const countries = await crmDb.select({
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(isNotNull(crmCustomers.country))
      .groupBy(crmCustomers.country)
      .orderBy(sql`count(*) desc`);

      const totalCustomers = await crmDb.select({ count: sql`count(*)::int`.as('count') })
        .from(crmCustomers)
        .then(result => result[0]?.count || 0);

      // Calculate percentages for countries
      const countriesWithPercentage = countries.map(country => ({
        ...country,
        percentage: totalCustomers > 0 ? (country.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(country.totalRevenue)
      }));

      // Get cities distribution
      const cities = await crmDb.select({
        city: crmCustomers.city,
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(and(isNotNull(crmCustomers.city), isNotNull(crmCustomers.country)))
      .groupBy(crmCustomers.city, crmCustomers.country)
      .orderBy(sql`count(*) desc`)
      .limit(50);

      const citiesWithPercentage = cities.map(city => ({
        ...city,
        percentage: totalCustomers > 0 ? (city.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(city.totalRevenue)
      }));

      // Get top regions summary
      const topRegions = countriesWithPercentage.slice(0, 10).map(country => ({
        region: country.country,
        customers: country.count,
        revenue: country.totalRevenue,
        averageOrderValue: country.count > 0 ? country.totalRevenue / country.count : 0
      }));

      const geoStats = {
        totalCustomers,
        countries: countriesWithPercentage,
        cities: citiesWithPercentage,
        topRegions
      };

      res.json(geoStats);
    } catch (error) {
      console.error('Geographic distribution API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch geographic distribution data' });
    }
  });

  // Customer locations API
  app.get('/api/reports/customer-locations', async (req, res) => {
    try {
      const { country } = req.query;
      
      let query = crmDb.select({
        id: crmCustomers.id,
        name: sql`concat(${crmCustomers.firstName}, ' ', ${crmCustomers.lastName})`.as('name'),
        email: crmCustomers.email,
        country: crmCustomers.country,
        city: crmCustomers.city,
        address: crmCustomers.address,
        totalOrders: crmCustomers.totalOrders,
        totalSpent: crmCustomers.totalSpent
      })
      .from(crmCustomers)
      .where(and(
        isNotNull(crmCustomers.address),
        isNotNull(crmCustomers.city),
        isNotNull(crmCustomers.country)
      ));

      if (country && country !== 'all') {
        query = query.where(eq(crmCustomers.country, country as string));
      }

      const customerLocations = await query
        .orderBy(desc(crmCustomers.totalSpent))
        .limit(100);

      res.json(customerLocations);
    } catch (error) {
      console.error('Customer locations API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch customer locations' });
    }
  });

  // Geographic distribution PDF export
  app.post('/api/reports/geographic-distribution/export', async (req, res) => {
    try {
      const { country, metric } = req.body;
      
      // Get the geographic distribution data directly
      const countries = await crmDb.select({
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(isNotNull(crmCustomers.country))
      .groupBy(crmCustomers.country)
      .orderBy(sql`count(*) desc`);

      const totalCustomers = await crmDb.select({ count: sql`count(*)::int`.as('count') })
        .from(crmCustomers)
        .then(result => result[0]?.count || 0);

      const countriesWithPercentage = countries.map(country => ({
        ...country,
        percentage: totalCustomers > 0 ? (country.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(country.totalRevenue)
      }));

      const cities = await crmDb.select({
        city: crmCustomers.city,
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(and(isNotNull(crmCustomers.city), isNotNull(crmCustomers.country)))
      .groupBy(crmCustomers.city, crmCustomers.country)
      .orderBy(sql`count(*) desc`)
      .limit(50);

      const citiesWithPercentage = cities.map(city => ({
        ...city,
        percentage: totalCustomers > 0 ? (city.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(city.totalRevenue)
      }));

      const geoData = {
        totalCustomers,
        countries: countriesWithPercentage,
        cities: citiesWithPercentage
      };
      
      // Generate PDF report
      const html = `
        <!DOCTYPE html>
        <html dir="rtl">
        <head>
          <meta charset="UTF-8">
          <title>Ú¯Ø²Ø§Ø±Ø´ ØªÙˆØ²ÛŒØ¹ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†</title>
          <style>
            body { font-family: 'Tahoma', Arial, sans-serif; margin: 20px; direction: rtl; }
            .header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #333; padding-bottom: 20px; }
            .stats { display: flex; justify-content: space-around; margin: 20px 0; }
            .stat-card { text-align: center; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .table { width: 100%; border-collapse: collapse; margin: 20px 0; }
            .table th, .table td { border: 1px solid #ddd; padding: 12px; text-align: right; }
            .table th { background-color: #f5f5f5; font-weight: bold; }
            .section { margin: 30px 0; }
            .section h2 { color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>Ú¯Ø²Ø§Ø±Ø´ ØªÙˆØ²ÛŒØ¹ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†</h1>
            <p>ØªØ§Ø±ÛŒØ® ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´: ${new Date().toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            })}</p>
          </div>
          
          <div class="stats">
            <div class="stat-card">
              <h3>Ú©Ù„ Ù…Ø´ØªØ±ÛŒØ§Ù†</h3>
              <p style="font-size: 24px; font-weight: bold;">${geoData.totalCustomers.toLocaleString()}</p>
            </div>
            <div class="stat-card">
              <h3>ØªØ¹Ø¯Ø§Ø¯ Ú©Ø´ÙˆØ±Ù‡Ø§</h3>
              <p style="font-size: 24px; font-weight: bold;">${geoData.countries.length}</p>
            </div>
            <div class="stat-card">
              <h3>ØªØ¹Ø¯Ø§Ø¯ Ø´Ù‡Ø±Ù‡Ø§</h3>
              <p style="font-size: 24px; font-weight: bold;">${geoData.cities.length}</p>
            </div>
          </div>

          <div class="section">
            <h2>ØªÙˆØ²ÛŒØ¹ Ù…Ø´ØªØ±ÛŒØ§Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ø´ÙˆØ±</h2>
            <table class="table">
              <thead>
                <tr>
                  <th>Ø±ØªØ¨Ù‡</th>
                  <th>Ú©Ø´ÙˆØ±</th>
                  <th>ØªØ¹Ø¯Ø§Ø¯ Ù…Ø´ØªØ±ÛŒ</th>
                  <th>Ø¯Ø±ØµØ¯</th>
                  <th>Ú©Ù„ ÙØ±ÙˆØ´</th>
                </tr>
              </thead>
              <tbody>
                ${geoData.countries.map((country: any, index: number) => `
                  <tr>
                    <td>${index + 1}</td>
                    <td>${country.country}</td>
                    <td>${country.count.toLocaleString()}</td>
                    <td>${country.percentage.toFixed(1)}%</td>
                    <td>$${country.totalRevenue.toLocaleString()}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>

          <div class="section">
            <h2>ØªÙˆØ²ÛŒØ¹ Ù…Ø´ØªØ±ÛŒØ§Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ø´Ù‡Ø± (Û²Û° Ø´Ù‡Ø± Ø¨Ø±ØªØ±)</h2>
            <table class="table">
              <thead>
                <tr>
                  <th>Ø±ØªØ¨Ù‡</th>
                  <th>Ø´Ù‡Ø±</th>
                  <th>Ú©Ø´ÙˆØ±</th>
                  <th>ØªØ¹Ø¯Ø§Ø¯ Ù…Ø´ØªØ±ÛŒ</th>
                  <th>Ú©Ù„ ÙØ±ÙˆØ´</th>
                </tr>
              </thead>
              <tbody>
                ${geoData.cities.slice(0, 20).map((city: any, index: number) => `
                  <tr>
                    <td>${index + 1}</td>
                    <td>${city.city}</td>
                    <td>${city.country}</td>
                    <td>${city.count.toLocaleString()}</td>
                    <td>$${city.totalRevenue.toLocaleString()}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        </body>
        </html>
      `;

      const browser = await puppeteer.launch({
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      await page.setContent(html, { waitUntil: 'networkidle0' });
      
      const pdf = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: { top: '20px', bottom: '20px', left: '20px', right: '20px' }
      });
      
      await browser.close();

      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename=geographic-distribution-${new Date().toISOString().split('T')[0]}.pdf`);
      res.send(pdf);
      
    } catch (error) {
      console.error('PDF export error:', error);
      res.status(500).json({ success: false, message: 'Failed to generate PDF report' });
    }
  });

  // Geographic Analytics Endpoints
  app.get("/api/analytics/geographic", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d', region = 'all' } = req.query;
      
      // Calculate date range
      const daysMap: { [key: string]: number } = { '7d': 7, '30d': 30, '90d': 90, '1y': 365 };
      const days = daysMap[period as string] || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // Query orders with customer location data using raw SQL
      const query = sql`
        SELECT 
          COALESCE(c.country, 'Unknown') as country,
          COALESCE(c.city, 'Unknown') as city,
          COUNT(DISTINCT o.id) as total_orders,
          COUNT(DISTINCT o.customer_id) as customer_count,
          SUM(CAST(o.total_amount AS DECIMAL)) as total_revenue,
          AVG(CAST(o.total_amount AS DECIMAL)) as avg_order_value
        FROM orders o
        LEFT JOIN crm_customers c ON o.customer_id = c.id
        WHERE o.created_at >= ${startDate}
        ${region !== 'all' ? sql` AND c.country = ${region}` : sql``}
        GROUP BY c.country, c.city
        ORDER BY total_revenue DESC
      `;

      const result = await db.execute(query);

      // Get top products for each region
      const geoData = await Promise.all(result.rows.map(async (row: any) => {
        const topProductsQuery = sql`
          SELECT 
            p.name,
            SUM(oi.quantity) as quantity,
            SUM(CAST(oi.total_price AS DECIMAL)) as revenue
          FROM orders o
          LEFT JOIN crm_customers c ON o.customer_id = c.id
          LEFT JOIN order_items oi ON o.id = oi.order_id
          LEFT JOIN products p ON oi.product_id = p.id
          WHERE o.created_at >= ${startDate}
            AND c.country = ${row.country}
            AND c.city = ${row.city}
          GROUP BY p.id, p.name
          ORDER BY revenue DESC
          LIMIT 5
        `;

        const topProducts = await db.execute(topProductsQuery);

        return {
          region: `${row.city}, ${row.country}`,
          country: row.country,
          city: row.city,
          totalOrders: Number(row.total_orders),
          totalRevenue: Number(row.total_revenue) || 0,
          customerCount: Number(row.customer_count),
          avgOrderValue: Number(row.avg_order_value) || 0,
          topProducts: topProducts.rows.map((p: any) => ({
            name: p.name,
            quantity: Number(p.quantity),
            revenue: Number(p.revenue) || 0
          }))
        };
      }));

      res.json({
        success: true,
        data: geoData
      });

    } catch (error) {
      console.error("Error fetching geographic analytics:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching geographic analytics"
      });
    }
  });

  app.get("/api/analytics/products", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d', product = 'all' } = req.query;
      
      const daysMap: { [key: string]: number } = { '7d': 7, '30d': 30, '90d': 90, '1y': 365 };
      const days = daysMap[period as string] || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const query = sql`
        SELECT 
          p.name,
          p.category,
          SUM(oi.quantity) as total_sales,
          SUM(CAST(oi.total_price AS DECIMAL)) as revenue
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        LEFT JOIN products p ON oi.product_id = p.id
        WHERE o.created_at >= ${startDate}
        ${product !== 'all' ? sql` AND p.id = ${product}` : sql``}
        GROUP BY p.id, p.name, p.category
        ORDER BY revenue DESC
      `;

      const result = await db.execute(query);

      // Get regional breakdown for each product
      const productData = await Promise.all(result.rows.map(async (row: any) => {
        const regionsQuery = sql`
          SELECT 
            COALESCE(c.country, 'Unknown') as region,
            COALESCE(c.city, 'Unknown') as city,
            SUM(oi.quantity) as quantity,
            SUM(CAST(oi.total_price AS DECIMAL)) as revenue
          FROM orders o
          LEFT JOIN crm_customers c ON o.customer_id = c.id
          LEFT JOIN order_items oi ON o.id = oi.order_id
          LEFT JOIN products p ON oi.product_id = p.id
          WHERE o.created_at >= ${startDate} AND p.name = ${row.name}
          GROUP BY c.country, c.city
          ORDER BY revenue DESC
        `;

        const regions = await db.execute(regionsQuery);

        return {
          name: row.name,
          category: row.category,
          totalSales: Number(row.total_sales),
          revenue: Number(row.revenue) || 0,
          regions: regions.rows.map((r: any) => ({
            region: r.region,
            city: r.city,
            quantity: Number(r.quantity),
            revenue: Number(r.revenue) || 0
          }))
        };
      }));

      res.json({
        success: true,
        data: productData
      });

    } catch (error) {
      console.error("Error fetching product analytics:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching product analytics"
      });
    }
  });

  app.get("/api/analytics/timeseries", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d' } = req.query;
      
      const daysMap: { [key: string]: number } = { '7d': 7, '30d': 30, '90d': 90, '1y': 365 };
      const days = daysMap[period as string] || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const query = sql`
        SELECT 
          DATE(o.created_at) as date,
          COUNT(DISTINCT o.id) as orders,
          SUM(CAST(o.total_amount AS DECIMAL)) as revenue
        FROM orders o
        WHERE o.created_at >= ${startDate}
        GROUP BY DATE(o.created_at)
        ORDER BY date ASC
      `;

      const result = await db.execute(query);

      const timeData = result.rows.map((row: any) => ({
        date: row.date,
        orders: Number(row.orders),
        revenue: Number(row.revenue) || 0,
        regions: {} // Can be expanded to include regional breakdown per day
      }));

      res.json({
        success: true,
        data: timeData
      });

    } catch (error) {
      console.error("Error fetching time series analytics:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching time series analytics"
      });
    }
  });

  // Product Sales Trends Over Time API
  app.get("/api/analytics/product-trends", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d', product = 'all' } = req.query;
      
      let dateCondition = '';
      const now = new Date();
      let startDate: Date;
      
      switch (period) {
        case '7d':
          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case '30d':
          startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
          break;
        case '3m':
          startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
          break;
        case '1y':
          startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
          break;
        default:
          startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      }

      const query = sql`
        SELECT 
          p.name as product_name,
          p.category,
          DATE(o.created_at) as date,
          SUM(oi.quantity) as daily_sales,
          SUM(CAST(oi.total_price AS DECIMAL)) as daily_revenue,
          COUNT(DISTINCT o.id) as daily_orders
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        LEFT JOIN products p ON oi.product_id = p.id
        WHERE o.created_at >= ${startDate}
        ${product !== 'all' ? sql`AND p.name = ${product}` : sql``}
        GROUP BY p.name, p.category, DATE(o.created_at)
        ORDER BY date ASC, daily_sales DESC
      `;

      const result = await db.execute(query);
      
      // Group data by product
      const productTrends: { [key: string]: any } = {};
      
      result.rows.forEach((row: any) => {
        const productName = row.product_name;
        if (!productTrends[productName]) {
          productTrends[productName] = {
            name: productName,
            category: row.category,
            dailyData: [],
            totalSales: 0,
            totalRevenue: 0,
            totalOrders: 0
          };
        }
        
        const dailyData = {
          date: row.date,
          sales: Number(row.daily_sales),
          revenue: Number(row.daily_revenue) || 0,
          orders: Number(row.daily_orders)
        };
        
        productTrends[productName].dailyData.push(dailyData);
        productTrends[productName].totalSales += dailyData.sales;
        productTrends[productName].totalRevenue += dailyData.revenue;
        productTrends[productName].totalOrders += dailyData.orders;
      });

      const responseData = Object.values(productTrends);

      res.json({
        success: true,
        data: responseData
      });

    } catch (error) {
      console.error("Error fetching product trends:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching product trends"
      });
    }
  });

  // =============================================================================
  // CENTRALIZED BARCODE MANAGEMENT API ENDPOINTS
  // =============================================================================
  
  // Generate EAN-13 barcode for product
  app.post("/api/barcode/generate", requireAuth, async (req: Request, res: Response) => {
    try {
      const { productName, category } = req.body;
      
      if (!productName || !category) {
        return res.status(400).json({
          success: false,
          message: "Product name and category are required"
        });
      }
      
      const barcode = generateEAN13Barcode(productName, category);
      const parsed = parseEAN13Barcode(barcode);
      
      res.json({
        success: true,
        data: {
          barcode,
          details: parsed,
          productName,
          category
        }
      });
    } catch (error) {
      console.error("Error generating barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error generating barcode"
      });
    }
  });
  
  // Validate EAN-13 barcode
  app.post("/api/barcode/validate", requireAuth, async (req: Request, res: Response) => {
    try {
      const { barcode } = req.body;
      
      if (!barcode) {
        return res.status(400).json({
          success: false,
          message: "Barcode is required"
        });
      }
      
      const isValid = validateEAN13(barcode);
      const parsed = parseEAN13Barcode(barcode);
      const isMomtazchemProduct = isMomtazchemBarcode(barcode);
      
      res.json({
        success: true,
        data: {
          barcode,
          isValid,
          isMomtazchemProduct,
          details: parsed
        }
      });
    } catch (error) {
      console.error("Error validating barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error validating barcode"
      });
    }
  });
  
  // Get product barcode (check if product already has barcode, if not generate one)
  app.get("/api/barcode/product/:productId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { productId } = req.params;
      
      // Try to get from showcase_products first
      const showcaseProduct = await shopStorage.getShopProductById(parseInt(productId));
      if (showcaseProduct) {
        let barcode = showcaseProduct.barcode;
        
        // If no barcode exists, generate one
        if (!barcode) {
          barcode = generateEAN13Barcode(showcaseProduct.name, showcaseProduct.category);
          
          // Update product with generated barcode
          await shopStorage.updateShopProduct(showcaseProduct.id, { barcode });
        }
        
        const parsed = parseEAN13Barcode(barcode);
        
        return res.json({
          success: true,
          data: {
            productId: showcaseProduct.id,
            productName: showcaseProduct.name,
            category: showcaseProduct.category,
            barcode,
            details: parsed,
            source: 'showcase'
          }
        });
      }
      
      // Try to get from shop_products if not found in showcase
      try {
        const shopProduct = await shopStorage.getShopProductById(parseInt(productId));
        if (shopProduct) {
          let barcode = shopProduct.barcode;
          
          // If no barcode exists, generate one
          if (!barcode) {
            barcode = generateEAN13Barcode(shopProduct.name, shopProduct.category);
            
            // Update product with generated barcode
            await shopStorage.updateShopProduct(shopProduct.id, { barcode });
          }
          
          const parsed = parseEAN13Barcode(barcode);
          
          return res.json({
            success: true,
            data: {
              productId: shopProduct.id,
              productName: shopProduct.name,
              category: shopProduct.category,
              barcode,
              details: parsed,
              source: 'shop'
            }
          });
        }
      } catch (error) {
        // Shop product not found, continue
      }
      
      res.status(404).json({
        success: false,
        message: "Product not found"
      });
      
    } catch (error) {
      console.error("Error getting product barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error getting product barcode"
      });
    }
  });
  
  // Search products by barcode
  app.get("/api/barcode/search/:barcode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { barcode } = req.params;
      
      if (!validateEAN13(barcode)) {
        return res.status(400).json({
          success: false,
          message: "Invalid EAN-13 barcode format"
        });
      }
      
      const results = [];
      
      // Search in showcase_products
      try {
        const showcaseProducts = await shopStorage.getShopProducts();
        const showcaseMatch = showcaseProducts.find((p: any) => p.barcode === barcode);
        if (showcaseMatch) {
          results.push({
            ...showcaseMatch,
            source: 'showcase'
          });
        }
      } catch (error) {
        console.error("Error searching showcase products:", error);
      }
      
      // Search in shop_products
      try {
        const shopProducts = await shopStorage.getShopProducts();
        const shopMatch = shopProducts.find((p: any) => p.barcode === barcode);
        if (shopMatch) {
          results.push({
            ...shopMatch,
            source: 'shop'
          });
        }
      } catch (error) {
        console.error("Error searching shop products:", error);
      }
      
      const parsed = parseEAN13Barcode(barcode);
      const isMomtazchemProduct = isMomtazchemBarcode(barcode);
      
      res.json({
        success: true,
        data: {
          barcode,
          details: parsed,
          isMomtazchemProduct,
          products: results
        }
      });
      
    } catch (error) {
      console.error("Error searching by barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error searching by barcode"
      });
    }
  });

  // Check if barcode is unique/duplicate
  app.get("/api/barcode/check-duplicate/:barcode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { barcode } = req.params;
      const { excludeProductId } = req.query;
      
      // Search in showcase_products
      const showcaseProducts = await shopStorage.getShopProducts();
      const showcaseMatch = showcaseProducts.find((p: any) => 
        p.barcode === barcode && 
        (excludeProductId ? p.id !== parseInt(excludeProductId as string) : true)
      );
      
      // Search in shop_products (if exists)
      let shopMatch = null;
      try {
        const shopProducts = await shopStorage.getShopProducts();
        shopMatch = shopProducts.find((p: any) => 
          p.barcode === barcode && 
          (excludeProductId ? p.id !== parseInt(excludeProductId as string) : true)
        );
      } catch (error) {
        // Shop products table might not exist, ignore error
      }
      
      const isDuplicate = !!(showcaseMatch || shopMatch);
      const duplicateProduct = showcaseMatch || shopMatch;
      
      res.json({
        success: true,
        data: {
          barcode,
          isDuplicate,
          isUnique: !isDuplicate,
          duplicateProduct: duplicateProduct ? {
            id: duplicateProduct.id,
            name: duplicateProduct.name,
            source: showcaseMatch ? 'showcase' : 'shop'
          } : null
        }
      });
    } catch (error) {
      console.error("Error checking barcode duplicate:", error);
      res.status(500).json({
        success: false,
        message: "Error checking barcode uniqueness"
      });
    }
  });

  // Check if 5-digit product code is unique
  app.get("/api/barcode/check-product-code/:productCode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { productCode } = req.params;
      
      // Search in showcase_products for product codes within barcodes
      const showcaseProducts = await shopStorage.getShopProducts();
      const showcaseMatch = showcaseProducts.find((p: any) => {
        if (!p.barcode || p.barcode.length !== 13) return false;
        // Extract 5-digit product code from position 8-12 in EAN-13: 846-96771-XXXXX-C
        const extractedCode = p.barcode.substring(8, 13);
        return extractedCode === productCode;
      });
      
      // Search in shop_products (if exists)
      let shopMatch = null;
      try {
        const shopProducts = await shopStorage.getShopProducts();
        shopMatch = shopProducts.find((p: any) => {
          if (!p.barcode || p.barcode.length !== 13) return false;
          const extractedCode = p.barcode.substring(8, 13);
          return extractedCode === productCode;
        });
      } catch (error) {
        // Shop products table might not exist, ignore error
      }
      
      const isDuplicate = !!(showcaseMatch || shopMatch);
      
      res.json({
        success: true,
        data: {
          productCode,
          isDuplicate,
          isUnique: !isDuplicate
        }
      });
    } catch (error) {
      console.error("Error checking product code uniqueness:", error);
      res.status(500).json({
        success: false,
        message: "Error checking product code uniqueness"
      });
    }
  });



  // Generate barcodes with new Iraq format for all products
  app.post("/api/barcode/generate-iraq-format", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log("Starting Iraq format barcode generation...");
      
      // Get all showcase products
      const showcaseProductsData = await db.select().from(showcaseProducts);
      console.log(`Found ${showcaseProductsData.length} showcase products`);
      
      // Get all shop products  
      const shopProductsData = await db.select().from(shopProducts);
      console.log(`Found ${shopProductsData.length} shop products`);
      
      const results = [];
      
      // Process showcase products
      for (const product of showcaseProductsData) {
        try {
          // Generate new barcode with Iraq format: 864-96771-XXXXX-C
          const countryCode = '864'; // Iraq
          const companyCode = '96771'; // Momtazchem
          const productCode = Math.floor(10000 + Math.random() * 90000).toString(); // 5-digit random
          const barcode12 = countryCode + companyCode + productCode;
          
          // Calculate check digit
          let oddSum = 0;
          let evenSum = 0;
          for (let i = 0; i < 12; i++) {
            const digit = parseInt(barcode12[i]);
            if (i % 2 === 0) {
              oddSum += digit;
            } else {
              evenSum += digit;
            }
          }
          const total = oddSum + (evenSum * 3);
          const checkDigit = (10 - (total % 10)) % 10;
          const fullBarcode = barcode12 + checkDigit.toString();
          
          // Update product with new barcode
          await db.update(showcaseProducts)
            .set({ barcode: fullBarcode })
            .where(eq(showcaseProducts.id, product.id));
          
          results.push({
            id: product.id,
            name: product.name,
            type: 'showcase',
            oldBarcode: product.barcode,
            newBarcode: fullBarcode,
            formatted: `${countryCode}-${companyCode}-${productCode}-${checkDigit}`,
            success: true
          });
          
          console.log(`âœ“ Generated Iraq barcode for showcase product ${product.name}: ${fullBarcode}`);
        } catch (error) {
          console.error(`âœ— Failed to generate barcode for showcase product ${product.name}:`, error);
          results.push({
            id: product.id,
            name: product.name,
            type: 'showcase',
            oldBarcode: product.barcode,
            error: error.message,
            success: false
          });
        }
      }
      
      // Process shop products
      for (const product of shopProductsData) {
        try {
          // Generate new barcode with Iraq format: 864-96771-XXXXX-C
          const countryCode = '864'; // Iraq
          const companyCode = '96771'; // Momtazchem
          const productCode = Math.floor(10000 + Math.random() * 90000).toString(); // 5-digit random
          const barcode12 = countryCode + companyCode + productCode;
          
          // Calculate check digit
          let oddSum = 0;
          let evenSum = 0;
          for (let i = 0; i < 12; i++) {
            const digit = parseInt(barcode12[i]);
            if (i % 2 === 0) {
              oddSum += digit;
            } else {
              evenSum += digit;
            }
          }
          const total = oddSum + (evenSum * 3);
          const checkDigit = (10 - (total % 10)) % 10;
          const fullBarcode = barcode12 + checkDigit.toString();
          
          // Update product with new barcode
          await db.update(shopProducts)
            .set({ barcode: fullBarcode })
            .where(eq(shopProducts.id, product.id));
          
          results.push({
            id: product.id,
            name: product.name,
            type: 'shop',
            oldBarcode: product.barcode,
            newBarcode: fullBarcode,
            formatted: `${countryCode}-${companyCode}-${productCode}-${checkDigit}`,
            success: true
          });
          
          console.log(`âœ“ Generated Iraq barcode for shop product ${product.name}: ${fullBarcode}`);
        } catch (error) {
          console.error(`âœ— Failed to generate barcode for shop product ${product.name}:`, error);
          results.push({
            id: product.id,
            name: product.name,
            type: 'shop',
            oldBarcode: product.barcode,
            error: error.message,
            success: false
          });
        }
      }
      
      const successCount = results.filter(r => r.success).length;
      const totalCount = results.length;
      
      console.log(`Iraq format barcode generation complete: ${successCount}/${totalCount} successful`);
      
      res.json({
        success: true,
        results,
        summary: `Generated Iraq format barcodes: ${successCount}/${totalCount} successful`,
        format: "864-96771-XXXXX-C (Iraq country code + Momtazchem company code + product code + check digit)"
      });
    } catch (error) {
      console.error("Error in Iraq format barcode generation:", error);
      res.status(500).json({
        success: false,
        message: "Error generating Iraq format barcodes",
        error: error.message
      });
    }
  });

  // Bulk barcode download endpoint
  app.get("/api/barcode/download-all", requireAuth, async (req: Request, res: Response) => {
    try {
      const { format = 'zip' } = req.query;
      
      // Get all products with barcodes from shop_products table
      const shopProductsWithBarcodes = await db
        .select({
          id: shopProducts.id,
          name: shopProducts.name,
          sku: shopProducts.sku,
          barcode: shopProducts.barcode,
          category: shopProducts.category,
          type: sql<string>`'shop'`
        })
        .from(shopProducts)
        .where(and(
          isNotNull(shopProducts.barcode),
          sql`LENGTH(${shopProducts.barcode}) = 13`
        ));

      if (shopProductsWithBarcodes.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No products with valid EAN-13 barcodes found"
        });
      }

      if (format === 'csv') {
        // CSV format for bulk import into label printers
        const csvData = [
          'Name,SKU,Barcode,Category',
          ...shopProductsWithBarcodes.map(p => 
            `"${p.name}","${p.sku || ''}","${p.barcode}","${p.category}"`
          )
        ].join('\n');

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="all-barcodes.csv"');
        res.send(csvData);
      } else {
        // JSON format
        res.json({
          success: true,
          data: {
            totalProducts: shopProductsWithBarcodes.length,
            products: shopProductsWithBarcodes
          },
          exportedAt: new Date().toISOString()
        });
      }

    } catch (error) {
      console.error("Error downloading all barcodes:", error);
      res.status(500).json({
        success: false,
        message: "Failed to download barcodes",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // AI-powered SKU generation endpoint
  app.post("/api/products/generate-sku", requireAuth, async (req: Request, res: Response) => {
    try {
      const productData = req.body;
      
      if (!productData.name || !productData.category) {
        return res.status(400).json({
          success: false,
          message: "Product name and category are required"
        });
      }

      console.log("Generating smart SKU for product:", productData.name);
      
      const skuResult = await generateSmartSKU(productData);
      
      // Check if SKU is unique in both showcase and shop products
      const existingShowcase = await db.select().from(showcaseProducts).where(eq(showcaseProducts.sku, skuResult.sku));
      const existingShop = await db.select().from(shopProducts).where(eq(shopProducts.sku, skuResult.sku));
      
      if (existingShowcase.length > 0 || existingShop.length > 0) {
        // If SKU exists, append a unique suffix
        const timestamp = Date.now().toString().slice(-4);
        skuResult.sku = `${skuResult.sku}-${timestamp}`;
        skuResult.reasoning += ` (Added unique suffix ${timestamp} to ensure uniqueness)`;
      }

      console.log("Generated SKU:", skuResult.sku);
      
      res.json({
        success: true,
        data: skuResult
      });
      
    } catch (error) {
      console.error("Error generating SKU:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate SKU",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Generate barcode endpoint
  app.post("/api/products/generate-barcode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { name, category } = req.body;
      
      if (!name || !category) {
        return res.status(400).json({
          success: false,
          message: "Product name and category are required"
        });
      }

      console.log("Generating EAN-13 barcode for product:", name);
      
      // Generate barcode server-side with database access
      const barcode = await generateServerSideEAN13Barcode(name, category);
      
      console.log("Generated barcode:", barcode);
      
      res.json({
        success: true,
        data: { barcode }
      });
      
    } catch (error) {
      console.error("Error generating barcode:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate barcode",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Server-side EAN-13 barcode generation with database access
  const generateServerSideEAN13Barcode = async (productName: string, category: string): Promise<string> => {
    // Iraq GS1 country code
    const countryCode = '864';
    
    // Momtazchem company code
    const companyCode = '96771';
    
    // Generate unique 4-digit product code
    let attempts = 0;
    const maxAttempts = 100;
    let productCode = '';
    
    while (attempts < maxAttempts) {
      // Generate random 4-digit code (1000-9999)
      const randomCode = Math.floor(1000 + Math.random() * 9000).toString();
      
      // Check if this barcode would be unique
      const testBarcode12 = countryCode + companyCode + randomCode;
      const testCheckDigit = calculateEAN13CheckDigit(testBarcode12);
      const testBarcode = testBarcode12 + testCheckDigit;
      
      // Check both showcase and shop products for uniqueness
      const existingShowcase = await db.select().from(showcaseProducts).where(eq(showcaseProducts.barcode, testBarcode));
      const existingShop = await db.select().from(shopProducts).where(eq(shopProducts.barcode, testBarcode));
      
      if (existingShowcase.length === 0 && existingShop.length === 0) {
        productCode = randomCode;
        break;
      }
      
      attempts++;
    }
    
    // If all random attempts failed, use timestamp-based code
    if (!productCode) {
      productCode = Date.now().toString().slice(-4);
    }
    
    // Build 12-digit code: 864 + 96771 + XXXX
    const barcode12 = countryCode + companyCode + productCode;
    
    // Calculate and append check digit
    const checkDigit = calculateEAN13CheckDigit(barcode12);
    const fullBarcode = barcode12 + checkDigit;
    
    console.log('Server-side barcode generation:', {
      productName,
      category,
      countryCode,
      companyCode,
      productCode,
      barcode12,
      checkDigit,
      fullBarcode,
      length: fullBarcode.length
    });
    
    return fullBarcode;
  };

  // Calculate EAN-13 check digit
  const calculateEAN13CheckDigit = (barcode12: string): string => {
    let sum = 0;
    for (let i = 0; i < 12; i++) {
      const digit = parseInt(barcode12[i]);
      sum += i % 2 === 0 ? digit : digit * 3;
    }
    const checkDigit = (10 - (sum % 10)) % 10;
    return checkDigit.toString();
  };

  // AI Test Connection endpoint
  app.post("/api/ai/test-connection", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log("Testing OpenAI API connection...");
      
      // Simple test request to OpenAI
      const testResult = await generateSmartSKU({
        name: "Test Product",
        category: "commercial",
        description: "This is a test product for API validation"
      });

      console.log("OpenAI API test successful");
      
      res.json({
        success: true,
        model: "gpt-4o",
        status: "connected",
        testResult: testResult.sku
      });
      
    } catch (error) {
      console.error("OpenAI API test failed:", error);
      res.status(500).json({
        success: false,
        message: "Failed to connect to OpenAI API",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Force inventory refresh endpoint - to be called after order completion
  app.post("/api/inventory/force-refresh", async (req: Request, res: Response) => {
    try {
      console.log("Force refreshing inventory data...");
      
      // Trigger inventory sync from shop to showcase
      const { syncFromShopToShowcase } = await import("./unified-inventory-manager");
      await syncFromShopToShowcase();
      
      console.log("âœ“ Inventory force refresh completed");
      
      res.json({
        success: true,
        message: "Inventory refreshed successfully",
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error("âœ— Error force refreshing inventory:", error);
      res.status(500).json({
        success: false,
        message: "Failed to refresh inventory",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // DEPARTMENT ORDER MANAGEMENT ENDPOINTS
  // =============================================================================



  // Auto-approval scheduler for wallet payments
  const scheduleWalletAutoApproval = async (customerOrderId: number) => {
    console.log(`â° [AUTO-APPROVAL] Scheduling auto-approval for wallet order ${customerOrderId} in 5 minutes`);
    
    setTimeout(async () => {
      try {
        const { db } = await import("./db");
        const { orderManagement } = await import("../shared/order-management-schema");
        const { customerOrders } = await import("../shared/customer-schema");
        const { eq } = await import("drizzle-orm");
        
        // Check if order is still pending financial review
        const [orderCheck] = await db
          .select({
            managementStatus: orderManagement.currentStatus,
            paymentMethod: customerOrders.paymentMethod,
            orderNumber: customerOrders.orderNumber
          })
          .from(orderManagement)
          .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
          .where(eq(orderManagement.customerOrderId, customerOrderId));
          
        if (!orderCheck) {
          console.log(`â­ï¸ [AUTO-APPROVAL] Order ${customerOrderId} not found - skipping auto-approval`);
          return;
        }
        
        // Only auto-approve if it's still in financial review and is wallet payment
        if (orderCheck.managementStatus === 'payment_uploaded' && 
            (orderCheck.paymentMethod === 'wallet_full' || orderCheck.paymentMethod === 'wallet_partial')) {
          
          console.log(`ğŸ¤– [AUTO-APPROVAL] Auto-approving wallet order ${orderCheck.orderNumber} after 5 minutes`);
          
          // Update order management status to warehouse_pending
          await db
            .update(orderManagement)
            .set({
              currentStatus: 'warehouse_pending',
              financialReviewerId: 0, // System auto-approval
              financialReviewedAt: new Date(),
              financialNotes: 'ØªØ§ÛŒÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ù¾Ø±Ø¯Ø§Ø®Øª Ú©ÛŒÙ Ù¾ÙˆÙ„ - 5 Ø¯Ù‚ÛŒÙ‚Ù‡ Ø§Ù†ØªØ¸Ø§Ø± Ø·Ø¨Ù‚ Ø³ÛŒØ³ØªÙ…'
            })
            .where(eq(orderManagement.customerOrderId, customerOrderId));

          // Update customer order status
          await db
            .update(customerOrders)
            .set({
              status: 'warehouse_ready',
              paymentStatus: 'paid',
              updatedAt: new Date()
            })
            .where(eq(customerOrders.id, customerOrderId));
            
          console.log(`âœ… [AUTO-APPROVAL] Wallet order ${orderCheck.orderNumber} automatically approved and moved to warehouse`);
          
        } else {
          console.log(`â­ï¸ [AUTO-APPROVAL] Order ${orderCheck.orderNumber} status changed (${orderCheck.managementStatus}) - skipping auto-approval`);
        }
        
      } catch (error) {
        console.error(`âŒ [AUTO-APPROVAL] Error auto-approving order ${customerOrderId}:`, error);
      }
    }, 5 * 60 * 1000); // 5 minutes in milliseconds
  };

  // Finance Department - Approve payment
  app.post("/api/finance/orders/:orderId/approve", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const customerOrderId = parseInt(req.params.orderId); // This is actually customerOrderId from frontend
      const { notes, receiptAmount } = req.body; // receiptAmount: Ù…Ø¨Ù„Øº ÙˆØ§Ø±ÛŒØ²ÛŒ Ø¯Ø± ÙÛŒØ´
      const adminId = req.session.adminId;

      console.log(`ğŸ”„ [FINANCE] Approving customer order ID: ${customerOrderId}`);

      // First find the order management record for this customer order
      const [orderMgmt] = await db
        .select({ id: orderManagement.id })
        .from(orderManagement)
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      if (!orderMgmt) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log(`ğŸ” [FINANCE] Found order management ID: ${orderMgmt.id} for customer order: ${customerOrderId}`);

      // Get customer information for notification
      const [customerInfo] = await db
        .select({
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          orderNumber: customerOrders.orderNumber,
          total: customerOrders.totalAmount
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      // ğŸš¨ CRITICAL: Check if this is a grace period order
      const [orderDetails] = await db
        .select({
          paymentMethod: customerOrders.paymentMethod,
          gracePeriodStart: orderManagement.paymentGracePeriodStart
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .where(eq(orderManagement.customerOrderId, customerOrderId));
      
      const isGracePeriodOrder = orderDetails?.paymentMethod === 'bank_transfer_grace' || orderDetails?.gracePeriodStart !== null;
      
      // Grace period orders stay in financial_approved, regular orders go to warehouse_pending
      const targetStatus = isGracePeriodOrder ? 'financial_approved' : 'warehouse_pending';
      
      console.log(`ğŸ” [FINANCE] Order ${customerOrderId} payment method: ${orderDetails?.paymentMethod}, isGracePeriod: ${isGracePeriodOrder}, targetStatus: ${targetStatus}`);
      
      // Update order management status
      await db
        .update(orderManagement)
        .set({
          currentStatus: targetStatus,
          financialReviewerId: adminId,
          financialReviewedAt: new Date(),
          financialNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      // ğŸ†• Assign order number if not already assigned
      let orderNumber = customerInfo?.orderNumber;
      if (!orderNumber) {
        console.log(`ğŸ”¢ [FINANCE] Assigning order number to order ${customerOrderId}`);
        const { OrderManagementStorage } = await import('./order-management-storage');
        const orderManagementStorage = new OrderManagementStorage();
        orderNumber = await orderManagementStorage.generateOrderNumberInTransaction();
        console.log(`âœ… [FINANCE] Generated order number ${orderNumber} for order ${customerOrderId}`);
      }
      
      // Update customer order based on whether it's grace period or regular
      const customerStatus = isGracePeriodOrder ? 'financial_approved' : 'warehouse_ready';
      
      await db
        .update(customerOrders)
        .set({
          status: customerStatus,
          paymentStatus: 'paid',
          orderNumber: orderNumber, // Ensure order number is set
          updatedAt: new Date()
        })
        .where(eq(customerOrders.id, customerOrderId));

      console.log(`âœ… [FINANCE] Order ${customerOrderId} approved: management status = ${targetStatus}, customer status = ${customerStatus}, payment = paid${isGracePeriodOrder ? ' (GRACE PERIOD - requires manual warehouse transfer)' : ''}`);

      // ğŸ¦ Handle wallet transactions for receipt amount differences
      if (receiptAmount) {
        const orderTotal = parseFloat(customerInfo.total);
        const paidAmount = parseFloat(receiptAmount);
        const difference = paidAmount - orderTotal;
        
        console.log(`ğŸ’° [WALLET] Receipt amount: ${paidAmount} IQD, Order total: ${orderTotal} IQD, Difference: ${difference} IQD`);
        
        if (difference !== 0) {
          const { walletStorage } = await import('./wallet-storage');
          const { walletTransactions } = await import('../shared/customer-schema');
          
          try {
            if (difference > 0) {
              // Credit excess to wallet
              const creditResult = await walletStorage.creditWallet(customerInfo.customerName, difference, 
                `Ø§Ø¶Ø§ÙÙ‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø³ÙØ§Ø±Ø´ ${orderNumber}`);
              
              console.log(`âœ… [WALLET] Credited ${difference} IQD to customer wallet:`, creditResult);
              
              // Update financial notes with credit information
              const updatedNotes = `${notes || ''} - Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ${difference.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø¨Ù‡ ÙˆØ§Ù„Øª Ù…Ø´ØªØ±ÛŒ ÙˆØ§Ø±ÛŒØ² Ø´Ø¯`.trim();
              await db
                .update(orderManagement)
                .set({ financialNotes: updatedNotes })
                .where(eq(orderManagement.customerOrderId, customerOrderId));
                
            } else {
              // Debit shortage from wallet (negative difference)
              const shortage = Math.abs(difference);
              
              // Check wallet balance first
              const walletBalance = await walletStorage.getBalance(customerInfo.customerName);
              
              if (walletBalance >= shortage) {
                const debitResult = await walletStorage.debitWallet(customerInfo.customerName, shortage, 
                  `Ú©Ø³Ø± Ú©Ù…Ø¨ÙˆØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderNumber}`);
                
                console.log(`âœ… [WALLET] Debited ${shortage} IQD from customer wallet:`, debitResult);
                
                // Update financial notes with debit information
                const updatedNotes = `${notes || ''} - Ú©Ù…Ø¨ÙˆØ¯ ${shortage.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± Ø§Ø² ÙˆØ§Ù„Øª Ù…Ø´ØªØ±ÛŒ Ú©Ø³Ø± Ø´Ø¯`.trim();
                await db
                  .update(orderManagement)
                  .set({ financialNotes: updatedNotes })
                  .where(eq(orderManagement.customerOrderId, customerOrderId));
                  
              } else {
                console.log(`âš ï¸ [WALLET] Insufficient balance for shortage ${shortage} IQD, available: ${walletBalance} IQD`);
                
                // Update financial notes with insufficient balance information
                const updatedNotes = `${notes || ''} - Ú©Ù…Ø¨ÙˆØ¯ ${shortage.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø± - Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆØ§Ù„Øª Ù†Ø§Ú©Ø§ÙÛŒ (${walletBalance.toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±)`.trim();
                await db
                  .update(orderManagement)
                  .set({ financialNotes: updatedNotes })
                  .where(eq(orderManagement.customerOrderId, customerOrderId));
              }
            }
          } catch (walletError) {
            console.error('âŒ [WALLET] Error processing wallet transaction:', walletError);
            
            // Update financial notes with error information
            const updatedNotes = `${notes || ''} - Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆØ§Ù„Øª: ${difference > 0 ? 'Ø§Ø¹ØªØ¨Ø§Ø±' : 'Ú©Ø³Ø±'} ${Math.abs(difference).toLocaleString()} Ø¯ÛŒÙ†Ø§Ø±`.trim();
            await db
              .update(orderManagement)
              .set({ financialNotes: updatedNotes })
              .where(eq(orderManagement.customerOrderId, customerOrderId));
          }
        }
      }

      // ØµØ¯ÙˆØ± Ø®ÙˆØ¯Ú©Ø§Ø± ÙØ§Ú©ØªÙˆØ± Ø±Ø³Ù…ÛŒ Ø¨Ø±Ø§ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª wallet-paid Ù¾Ø³ Ø§Ø² ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ
      const [invoiceOrderDetails] = await db
        .select({ 
          paymentMethod: customerOrders.paymentMethod,
          orderNumber: customerOrders.orderNumber 
        })
        .from(customerOrders)
        .where(eq(customerOrders.id, customerOrderId));

      // NOTE: Proforma to final invoice conversion now happens when orders leave warehouse, not at financial approval
      // This ensures proper business workflow compliance

      // Check for excess payment and credit to wallet if order is approved
      const [orderWithNotes] = await db
        .select({ financialNotes: orderManagement.financialNotes })
        .from(orderManagement)
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      if (orderWithNotes?.financialNotes && orderWithNotes.financialNotes.includes('Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ')) {
        const match = orderWithNotes.financialNotes.match(/Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ([\d,]+) Ø¯ÛŒÙ†Ø§Ø±/);
        if (match) {
          const excessAmountStr = match[1];
          const excessAmount = parseFloat(excessAmountStr.replace(/,/g, ''));
          
          console.log(`ğŸ’° [WALLET CREDIT] Processing excess amount: ${excessAmount} IQD for customer order ${customerOrderId}`);
          
          // Get customer ID from order
          const [orderData] = await db
            .select({ customerId: customerOrders.customerId })
            .from(customerOrders)
            .where(eq(customerOrders.id, customerOrderId));

          if (orderData) {
            try {
              const { customerStorage } = await import("./customer-storage");
              
              // Add excess amount to customer wallet
              await customerStorage.addWalletBalance(orderData.customerId, excessAmount, 
                `Ø§Ø¶Ø§ÙÙ‡ Ù…Ø¨Ù„Øº ÙˆØ§Ø±ÛŒØ²ÛŒ Ø³ÙØ§Ø±Ø´ ${customerInfo?.orderNumber || customerOrderId} Ù¾Ø³ Ø§Ø² ØªØ§ÛŒÛŒØ¯ ÙˆØ§Ø­Ø¯ Ù…Ø§Ù„ÛŒ`);
              
              console.log(`âœ… [WALLET CREDIT] Successfully added ${excessAmount} IQD to customer ${orderData.customerId} wallet`);
              
              // Update financial notes to indicate wallet credit completed
              const updatedNotes = `${orderWithNotes.financialNotes} - Ù…Ø¨Ù„Øº Ø§Ø¶Ø§ÙÛŒ ${excessAmountStr} Ø¯ÛŒÙ†Ø§Ø± Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ø´ØªØ±ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯`;
              
              await db
                .update(orderManagement)
                .set({ financialNotes: updatedNotes })
                .where(eq(orderManagement.customerOrderId, customerOrderId));
              
            } catch (walletError) {
              console.error(`âŒ [WALLET CREDIT] Error adding to wallet:`, walletError);
              // Don't fail the approval, just log the error
            }
          }
        }
      }

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderMgmt.id, // Use correct order management ID
        fromStatus: 'financial_reviewing',
        toStatus: 'warehouse_pending',
        changedBy: adminId,
        changedByDepartment: 'financial',
        notes: notes
      });

      // Send approval notification to customer
      if (customerInfo) {
        try {
          // Send email notification
          const { customerCommunicationStorage } = await import("./customer-communication-storage");
          await customerCommunicationStorage.sendMessage({
            categoryId: 2, // Order Updates category
            customerEmail: customerInfo.customerEmail,
            subject: `ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${customerInfo.orderNumber}`,
            message: `Ø³Ù„Ø§Ù… ${customerInfo.customerName} ${customerInfo.customerLastName}ØŒ\n\nÙ¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§Ø±Ù‡ ${customerInfo.orderNumber} Ø¨Ù‡ Ù…Ø¨Ù„Øº ${customerInfo.total} Ø¯ÛŒÙ†Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯.\n\nØ³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø§Ú©Ù†ÙˆÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡ Ø§Ø³Øª.\n\n${notes ? 'ÛŒØ§Ø¯Ø¯Ø§Ø´Øª: ' + notes : ''}\n\nØ¨Ø§ ØªØ´Ú©Ø±ØŒ\nØªÛŒÙ… Ù…Ù…ØªØ§Ø²Ø´ÛŒÙ…ÛŒ`,
            messageType: 'outbound',
            priority: 'high',
            messageSource: 'system'
          });

          // Website and email notification sent (NO SMS per user requirement)
          
        } catch (notificationError) {
          console.error("Error sending approval notifications:", notificationError);
          // Don't fail the approval if notification fails
        }
      }

      res.json({ 
        success: true, 
        message: "Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        orderNumber: orderNumber 
      });
    } catch (error) {
      console.error("Error approving finance order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ğŸª NEW: Manual warehouse transfer for approved grace period orders
  app.post("/api/finance/orders/:orderId/transfer-to-warehouse", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { eq } = await import("drizzle-orm");
      
      const customerOrderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      console.log(`ğŸª [WAREHOUSE TRANSFER] Manual transfer request for customer order ID: ${customerOrderId}`);

      // Verify the order is in financial_approved status
      const [orderDetails] = await db
        .select({
          managementId: orderManagement.id,
          currentStatus: orderManagement.currentStatus,
          paymentMethod: customerOrders.paymentMethod,
          orderNumber: customerOrders.orderNumber
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      if (!orderDetails) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Check if order is eligible for manual warehouse transfer
      if (orderDetails.currentStatus !== 'financial_approved') {
        return res.status(400).json({
          success: false,
          message: `Ø³ÙØ§Ø±Ø´ Ø¯Ø± ÙˆØ¶Ø¹ÛŒØª ${orderDetails.currentStatus} Ø§Ø³Øª - ÙÙ‚Ø· Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ Ù…Ø§Ù„ÛŒ Ù‚Ø§Ø¨Ù„ Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ù‡Ø³ØªÙ†Ø¯`
        });
      }

      console.log(`âœ… [WAREHOUSE TRANSFER] Order ${orderDetails.orderNumber} is eligible for warehouse transfer`);

      // Update order management status to warehouse_pending
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'warehouse_pending',
          financialNotes: `${orderDetails.currentStatus || ''}\n\nØ§Ù†ØªÙ‚Ø§Ù„ Ø¯Ø³ØªÛŒ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø±: ${notes || 'Ø¨Ø¯ÙˆÙ† ÛŒØ§Ø¯Ø¯Ø§Ø´Øª'}`.trim()
        })
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      // Update customer order status to warehouse_ready
      await db
        .update(customerOrders)
        .set({
          status: 'warehouse_ready',
          updatedAt: new Date()
        })
        .where(eq(customerOrders.id, customerOrderId));

      console.log(`ğŸª [WAREHOUSE TRANSFER] Order ${orderDetails.orderNumber} successfully transferred to warehouse`);

      res.json({
        success: true,
        message: `Ø³ÙØ§Ø±Ø´ ${orderDetails.orderNumber} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`,
        orderNumber: orderDetails.orderNumber
      });

    } catch (error) {
      console.error("Error transferring order to warehouse:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø±" });
    }
  });

  // ğŸ”§ CRITICAL FIX: Process missed wallet transactions for orders that bypassed financial approval
  app.post("/api/finance/process-missed-wallet-transactions", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerStorage } = await import("./customer-storage");
      
      console.log(`ğŸ” [MISSED TRANSACTIONS] Searching for orders with unprocessed wallet differences...`);
      
      // Find orders that have receipt amount but haven't been processed for wallet differences
      const ordersWithMissedTransactions = await db
        .select({
          orderManagementId: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          orderNumber: customerOrders.orderNumber,
          customerId: customerOrders.customerId,
          totalAmount: customerOrders.totalAmount,
          receiptAmount: paymentReceipts.receiptAmount,
          financialNotes: orderManagement.financialNotes,
          currentStatus: orderManagement.currentStatus
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(paymentReceipts, eq(paymentReceipts.customerOrderId, customerOrders.id))
        .where(
          and(
            isNotNull(paymentReceipts.receiptAmount), // Has receipt amount
            inArray(orderManagement.currentStatus, ['warehouse_pending', 'warehouse_processing', 'warehouse_verified']), // Already in warehouse
            // Financial notes don't indicate wallet transaction was processed
            eq(orderManagement.financialNotes, 'Auto-sync status correction - fixed stuck order')
          )
        );
      
      console.log(`ğŸ“Š [MISSED TRANSACTIONS] Found ${ordersWithMissedTransactions.length} orders with potential missed wallet transactions`);
      
      let processedCount = 0;
      let totalCredited = 0;
      let totalDebited = 0;
      const processedOrders = [];
      
      for (const orderData of ordersWithMissedTransactions) {
        try {
          const orderTotal = parseFloat(orderData.totalAmount);
          const receiptAmount = parseFloat(orderData.receiptAmount);
          const difference = receiptAmount - orderTotal;
          
          console.log(`ğŸ’° [PROCESSING] Order ${orderData.orderNumber}: Total=${orderTotal}, Receipt=${receiptAmount}, Difference=${difference}`);
          
          if (Math.abs(difference) > 0.01) { // Only process if there's a meaningful difference
            if (difference > 0) {
              // Customer overpaid - credit to wallet
              await customerStorage.addWalletBalance(
                orderData.customerId,
                difference,
                `ØªØµØ­ÛŒØ­: Ø§Ø¶Ø§ÙÙ‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderData.orderNumber} - Ù…Ø¹Ø§Ù„Ø¬Ù‡ Ø¨Ø£Ø«Ø± Ø±Ø¬Ø¹ÛŒ`
              );
              
              totalCredited += difference;
              console.log(`âœ… [CREDITED] ${difference} IQD credited to customer ${orderData.customerId} wallet for order ${orderData.orderNumber}`);
              
            } else {
              // Customer underpaid - check wallet balance and debit if sufficient
              const deficit = Math.abs(difference);
              const walletBalance = await customerStorage.getWalletBalance(orderData.customerId);
              
              if (walletBalance >= deficit) {
                await customerStorage.deductWalletBalance(
                  orderData.customerId,
                  deficit,
                  `ØªØµØ­ÛŒØ­: ØªÚ©Ù…ÛŒÙ„ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderData.orderNumber} - Ù…Ø¹Ø§Ù„Ø¬Ù‡ Ø¨Ø£Ø«Ø± Ø±Ø¬Ø¹ÛŒ`
                );
                
                totalDebited += deficit;
                console.log(`âœ… [DEBITED] ${deficit} IQD debited from customer ${orderData.customerId} wallet for order ${orderData.orderNumber}`);
              } else {
                console.log(`âš ï¸ [INSUFFICIENT BALANCE] Customer ${orderData.customerId} wallet balance ${walletBalance} insufficient for deficit ${deficit} on order ${orderData.orderNumber}`);
              }
            }
            
            // Update financial notes to indicate the transaction was processed
            const updatedNotes = `${orderData.financialNotes}\n\nğŸ”§ ØªØµØ­ÛŒØ­ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø¨Ø£Ø«Ø± Ø±Ø¬Ø¹ÛŒ: ${difference > 0 ? `+${difference}` : difference} Ø¯ÛŒÙ†Ø§Ø± Ù…Ø¹Ø§Ù„Ø¬`;
            await db
              .update(orderManagement)
              .set({ financialNotes: updatedNotes })
              .where(eq(orderManagement.id, orderData.orderManagementId));
            
            processedOrders.push({
              orderNumber: orderData.orderNumber,
              difference: difference,
              action: difference > 0 ? 'credited' : 'debited',
              amount: Math.abs(difference)
            });
            
            processedCount++;
          } else {
            console.log(`â„¹ï¸ [NO DIFFERENCE] Order ${orderData.orderNumber} has no meaningful amount difference`);
          }
        } catch (error) {
          console.error(`âŒ [ERROR] Failed to process wallet transaction for order ${orderData.orderNumber}:`, error);
        }
      }
      
      console.log(`âœ… [SUMMARY] Processed ${processedCount} orders: ${totalCredited.toFixed(2)} IQD credited, ${totalDebited.toFixed(2)} IQD debited`);
      
      res.json({
        success: true,
        message: `Ù…Ø¹Ø§Ù„Ø¬Ø© ${processedCount} Ø·Ù„Ø¨ Ø¨Ø£Ø«Ø± Ø±Ø¬Ø¹ÛŒ - Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹: ${totalCredited.toFixed(2)} Ø¯ÙŠÙ†Ø§Ø±ØŒ Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø®ØµÙ…: ${totalDebited.toFixed(2)} Ø¯ÙŠÙ†Ø§Ø±`,
        processedCount: processedCount,
        totalCredited: totalCredited,
        totalDebited: totalDebited,
        processedOrders: processedOrders
      });
      
    } catch (error) {
      console.error("Error processing missed wallet transactions:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ğŸ” Get orders with potential missed wallet transactions
  app.get("/api/finance/missed-wallet-transactions", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ” [DEBUG] Starting missed wallet transactions check...');
      
      // Find orders that potentially have unprocessed wallet differences
      const ordersWithPotentialIssues = await db
        .select({
          orderManagementId: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          orderNumber: customerOrders.orderNumber,
          customerId: customerOrders.customerId,
          totalAmount: customerOrders.totalAmount,
          receiptAmount: paymentReceipts.receiptAmount,
          financialNotes: orderManagement.financialNotes,
          currentStatus: orderManagement.currentStatus,
          createdAt: customerOrders.createdAt
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(paymentReceipts, eq(paymentReceipts.customerOrderId, customerOrders.id))
        .where(
          and(
            isNotNull(paymentReceipts.receiptAmount), // Has receipt amount
            inArray(orderManagement.currentStatus, ['warehouse_pending', 'warehouse_processing', 'warehouse_verified']), // Already in warehouse
            // Financial notes indicate auto-sync correction without wallet processing
            eq(orderManagement.financialNotes, 'Auto-sync status correction - fixed stuck order')
          )
        )
        .orderBy(customerOrders.createdAt);
      
      // Calculate differences for each order
      const ordersWithDifferences = ordersWithPotentialIssues.map(order => {
        const orderTotal = parseFloat(order.totalAmount);
        const receiptAmount = parseFloat(order.receiptAmount);
        const difference = receiptAmount - orderTotal;
        
        return {
          ...order,
          orderTotal,
          receiptAmount,
          difference,
          hasDifference: Math.abs(difference) > 0.01,
          transactionType: difference > 0 ? 'overpayment' : difference < 0 ? 'underpayment' : 'exact'
        };
      }).filter(order => order.hasDifference); // Only return orders with meaningful differences
      
      console.log(`ğŸ” [MISSED TRANSACTIONS] Found ${ordersWithDifferences.length} orders with unprocessed wallet differences`);
      
      res.json({
        success: true,
        orders: ordersWithDifferences,
        summary: {
          totalOrders: ordersWithDifferences.length,
          overpayments: ordersWithDifferences.filter(o => o.difference > 0).length,
          underpayments: ordersWithDifferences.filter(o => o.difference < 0).length,
          totalOverpaid: ordersWithDifferences.filter(o => o.difference > 0).reduce((sum, o) => sum + o.difference, 0),
          totalUnderpaid: Math.abs(ordersWithDifferences.filter(o => o.difference < 0).reduce((sum, o) => sum + o.difference, 0))
        }
      });
      
    } catch (error) {
      console.error("Error fetching missed wallet transactions:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø­ÙØ¸Ø© Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Finance Department - Save notes without approval/rejection
  app.post("/api/finance/orders/:orderId/notes", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const customerOrderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      console.log(`ğŸ“ [FINANCE] Saving notes for customer order ID: ${customerOrderId}`);

      // Update financial notes in order management
      const [updated] = await db
        .update(orderManagement)
        .set({
          financialNotes: notes,
          financialReviewerId: adminId,
          updatedAt: new Date()
        })
        .where(eq(orderManagement.customerOrderId, customerOrderId))
        .returning();

      if (!updated) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log(`âœ… [FINANCE] Notes saved successfully for order ${customerOrderId}`);

      res.json({ 
        success: true, 
        message: "ÛŒØ§Ø¯Ø¯Ø§Ø´Øª Ù…Ø§Ù„ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯",
        data: { financialNotes: notes }
      });
    } catch (error) {
      console.error("Error saving financial notes:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ÛŒØ§Ø¯Ø¯Ø§Ø´Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Finance Department - Reject payment
  app.post("/api/finance/orders/:orderId/reject", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const customerOrderId = parseInt(req.params.orderId); // This is actually customerOrderId from frontend
      const { notes } = req.body;
      const adminId = req.session.adminId;

      console.log(`ğŸ”„ [FINANCE] Rejecting customer order ID: ${customerOrderId}`);

      // First find the order management record for this customer order
      const [orderMgmt] = await db
        .select({ id: orderManagement.id })
        .from(orderManagement)
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      if (!orderMgmt) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log(`ğŸ” [FINANCE] Found order management ID: ${orderMgmt.id} for customer order: ${customerOrderId}`);

      // Get customer information for notification
      const [customerInfo] = await db
        .select({
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          orderNumber: customerOrders.orderNumber,
          total: customerOrders.totalAmount
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      // Update order status to financial_rejected
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'financial_rejected',
          financialReviewerId: adminId,
          financialReviewedAt: new Date(),
          financialNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, customerOrderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderMgmt.id, // Use correct order management ID
        fromStatus: 'financial_reviewing',
        toStatus: 'financial_rejected',
        changedBy: adminId,
        changedByDepartment: 'financial',
        notes: notes
      });

      // Send rejection notification to customer
      if (customerInfo) {
        try {
          // Send email notification
          const { customerCommunicationStorage } = await import("./customer-communication-storage");
          await customerCommunicationStorage.sendMessage({
            categoryId: 2, // Order Updates category
            customerEmail: customerInfo.customerEmail,
            subject: `Ø¹Ø¯Ù… ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${customerInfo.orderNumber}`,
            message: `Ø³Ù„Ø§Ù… ${customerInfo.customerName} ${customerInfo.customerLastName}ØŒ\n\nÙ…ØªØ£Ø³ÙØ§Ù†Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§Ø±Ù‡ ${customerInfo.orderNumber} Ø¨Ù‡ Ù…Ø¨Ù„Øº ${customerInfo.total} Ø¯ÛŒÙ†Ø§Ø± ØªØ§ÛŒÛŒØ¯ Ù†Ø´Ø¯.\n\nØ¯Ù„ÛŒÙ„ Ø¹Ø¯Ù… ØªØ§ÛŒÛŒØ¯: ${notes || 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª'}\n\nÙ„Ø·ÙØ§Ù‹ Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­ Ù…Ø´Ú©Ù„ Ø¨Ø§ Ù…Ø§ ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯ ÛŒØ§ ÙÛŒØ´ ÙˆØ§Ø±ÛŒØ²ÛŒ ØµØ­ÛŒØ­ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ù†Ù…Ø§ÛŒÛŒØ¯.\n\nØ¨Ø§ ØªØ´Ú©Ø±ØŒ\nØªÛŒÙ… Ù…Ù…ØªØ§Ø²Ø´ÛŒÙ…ÛŒ`,
            messageType: 'outbound',
            priority: 'high',
            messageSource: 'system'
          });

          // Website and email notification sent (NO SMS per user requirement)
          
        } catch (notificationError) {
          console.error("Error sending rejection notifications:", notificationError);
          // Don't fail the rejection if notification fails
        }
      }

      res.json({ success: true, message: "Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø¯ Ø´Ø¯ Ùˆ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
    } catch (error) {
      console.error("Error rejecting finance order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Get orders approved by finance
  app.get("/api/warehouse/orders", async (req: Request, res: Response) => {
    try {
      console.log('ğŸ“¦ [WAREHOUSE] Getting warehouse orders...');
      
      // Use the getOrdersByDepartment method to get warehouse orders
      const orders = await orderManagementStorage.getOrdersByDepartment('warehouse');
      
      console.log('ğŸ“¦ [WAREHOUSE] Retrieved', orders.length, 'orders for warehouse');
      
      // Transform orders to include shipping cost for frontend
      const transformedOrders = orders.map((order: any) => ({
        id: order.id,
        customerOrderId: order.customerOrderId,
        orderNumber: order.orderNumber, // ğŸ”¢ FIXED: Include M[YY][NNNNN] format order number
        customerName: `${order.customerFirstName || ''} ${order.customerLastName || ''}`.trim(),
        customerEmail: order.customerEmail,
        customerPhone: order.customerPhone,
        customerAddress: order.shippingAddress ? 
          (typeof order.shippingAddress === 'string' ? 
            order.shippingAddress : 
            JSON.stringify(order.shippingAddress)) : 
          'Ø¢Ø¯Ø±Ø³ Ù†Ø§Ù…Ø´Ø®Øµ',
        orderTotal: order.totalAmount || 0,
        shippingCost: order.shippingCost || 0, // Include shipping cost
        currentStatus: order.currentStatus,
        warehouseNotes: order.warehouseNotes,
        warehouseProcessedAt: order.warehouseProcessedAt,
        financialReviewedAt: order.financialReviewedAt,
        financialNotes: order.financialNotes,
        orderDate: order.createdAt,
        orderItems: order.orderItems || []
      }));
      
      res.json(transformedOrders);
    } catch (error) {
      console.error('ğŸ“¦ [WAREHOUSE] Error fetching orders:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Get orders approved by finance (NO AUTHENTICATION - Legacy)
  app.get("/api/warehouse/orders-noauth", async (req: Request, res: Response) => {
    try {
      console.log('ğŸ“¦ [WAREHOUSE-NOAUTH] Getting warehouse orders...');
      
      // Use the getOrdersByDepartment method to get warehouse orders
      const orders = await orderManagementStorage.getOrdersByDepartment('warehouse');
      
      console.log('ğŸ“¦ [WAREHOUSE-NOAUTH] Retrieved', orders.length, 'orders for warehouse');
      if (orders.length > 0) {
        console.log('ğŸ“¦ [WAREHOUSE-NOAUTH] First order sample:', JSON.stringify(orders[0], null, 2));
      }
      
      res.json({ success: true, orders });
    } catch (error) {
      console.error('ğŸ“¦ [WAREHOUSE-NOAUTH] Error fetching orders:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Get product waste amounts
  app.get("/api/warehouse/waste", async (req: Request, res: Response) => {
    try {
      const { pool } = await import('./db');
      
      // Get the latest waste amount for each product
      const result = await pool.query(`
        SELECT 
          product_id,
          waste_amount,
          reason,
          reported_at
        FROM product_waste pw1
        WHERE pw1.reported_at = (
          SELECT MAX(pw2.reported_at) 
          FROM product_waste pw2 
          WHERE pw2.product_id = pw1.product_id
        )
        ORDER BY pw1.product_id
      `);
      
      // Convert to key-value format for frontend
      const wasteAmounts: { [key: string]: number } = {};
      result.rows.forEach(row => {
        wasteAmounts[row.product_id.toString()] = parseFloat(row.waste_amount) || 0;
      });
      
      res.json({ success: true, wasteAmounts });
    } catch (error) {
      console.error('Error fetching waste amounts:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¶Ø§ÛŒØ¹Ø§Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Update product waste amount
  app.post("/api/warehouse/waste/:productId", async (req: Request, res: Response) => {
    try {
      const { pool } = await import('./db');
      const productId = parseInt(req.params.productId);
      const { wasteAmount, reason } = req.body;
      
      if (isNaN(productId) || wasteAmount < 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù…Ø­ØµÙˆÙ„ ÛŒØ§ Ù…Ù‚Ø¯Ø§Ø± Ø¶Ø§ÛŒØ¹Ø§Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }
      
      // Insert new waste record
      await pool.query(`
        INSERT INTO product_waste (product_id, waste_amount, reason, reported_by)
        VALUES ($1, $2, $3, $4)
      `, [productId, wasteAmount, reason || 'ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÛŒ', req.session?.adminId || null]);
      
      res.json({ 
        success: true, 
        message: "Ø¶Ø§ÛŒØ¹Ø§Øª Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error updating waste amount:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¶Ø§ÛŒØ¹Ø§Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Save notes without approval/rejection
  app.post("/api/warehouse/orders/:orderId/notes", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const customerOrderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      console.log(`ğŸ“ [WAREHOUSE] Saving notes for customer order ID: ${customerOrderId}`);

      // Update warehouse notes in order management
      const [updated] = await db
        .update(orderManagement)
        .set({
          warehouseNotes: notes,
          warehouseAssigneeId: adminId,
          updatedAt: new Date()
        })
        .where(eq(orderManagement.customerOrderId, customerOrderId))
        .returning();

      if (!updated) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      console.log(`âœ… [WAREHOUSE] Notes saved successfully for order ${customerOrderId}`);

      res.json({ 
        success: true, 
        message: "ÛŒØ§Ø¯Ø¯Ø§Ø´Øª Ø§Ù†Ø¨Ø§Ø± Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯",
        data: { warehouseNotes: notes }
      });
    } catch (error) {
      console.error("Error saving warehouse notes:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ÛŒØ§Ø¯Ø¯Ø§Ø´Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Approve order (items ready)
  app.post("/api/warehouse/orders/:orderId/approve", requireAuth, attachUserDepartments, requireDepartment('warehouse'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      console.log(`ğŸ“¦ [WAREHOUSE] Processing approval for order ${orderId}`);

      // Get order details with customer information first
      const { customerOrders } = await import("../shared/customer-schema");
      const { crmCustomers } = await import("../shared/crm-schema");
      
      const orderDetailsQuery = await db
        .select({
          // Order Management fields
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          
          // Customer info from CRM
          customerFirstName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          
          // Order total for context
          totalAmount: customerOrders.totalAmount,
          currency: customerOrders.currency,
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.customerOrderId, orderId))
        .limit(1);

      if (orderDetailsQuery.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const order = orderDetailsQuery[0];
      console.log(`ğŸ“‹ [WAREHOUSE] Order details: Customer ${order.customerFirstName} ${order.customerLastName}, Phone: ${order.customerPhone}`);
      
      if (!order.customerPhone) {
        console.log(`âš ï¸ [WAREHOUSE] Warning: Order ${orderId} has no customer phone number for SMS`);
      }

      // Update order status to warehouse_approved
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'warehouse_approved',
          warehouseAssigneeId: adminId,
          warehouseProcessedAt: new Date(),
          warehouseNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'financial_approved',
        toStatus: 'warehouse_approved',
        changedBy: adminId,
        changedByDepartment: 'warehouse',
        notes: notes
      });

      console.log(`âœ… [WAREHOUSE] Order ${orderId} approved successfully`);

      // AUTOMATIC DELIVERY CODE GENERATION AND SMS SENDING
      try {
        console.log(`ğŸš€ [WAREHOUSE] Triggering automatic delivery code generation for order ${orderId}`);
        
        // Check if delivery code already exists
        const existingCode = await logisticsStorage.getDeliveryCodeByOrderId(orderId);
        
        let deliveryCodeData;
        let isNewCode = false;
        
        if (existingCode) {
          // Use existing code
          deliveryCodeData = existingCode;
          console.log(`ğŸ”„ [WAREHOUSE] Reusing existing delivery code ${existingCode.verificationCode} for order ${orderId}`);
        } else {
          // Generate new delivery code with proper customer details
          const customerName = `${order.customerFirstName || ''} ${order.customerLastName || ''}`.trim() || 'Ù…Ø´ØªØ±ÛŒ';
          const customerPhone = order.customerPhone || '09000000000';
          
          deliveryCodeData = await logisticsStorage.generateVerificationCode(
            orderId,
            customerPhone,
            customerName
          );
          isNewCode = true;
          console.log(`ğŸ†• [WAREHOUSE] Generated new delivery code ${deliveryCodeData.verificationCode} for order ${orderId}, customer: ${customerName}`);
        }

        // Send SMS notification automatically with proper customer details
        try {
          const customerName = `${order.customerFirstName || ''} ${order.customerLastName || ''}`.trim() || 'Ù…Ø´ØªØ±ÛŒ';
          const customerPhone = order.customerPhone || '09000000000';
          
          const smsResult = await smsService.sendDeliveryVerificationSms(
            customerPhone,
            deliveryCodeData.verificationCode,
            customerName,
            deliveryCodeData.id
          );

          if (smsResult.success) {
            await logisticsStorage.updateSmsStatus(deliveryCodeData.id, 'sent', { 
              messageId: smsResult.messageId,
              provider: 'kavenegar'
            });
            console.log(`ğŸ“± [WAREHOUSE] SMS sent successfully for order ${orderId}, code: ${deliveryCodeData.verificationCode}`);
          } else {
            console.log(`âš ï¸ [WAREHOUSE] SMS sending failed for order ${orderId}: ${smsResult.error}`);
          }
        } catch (smsError) {
          console.error(`âŒ [WAREHOUSE] SMS error for order ${orderId}:`, smsError);
        }

      } catch (codeError) {
        console.error(`âŒ [WAREHOUSE] Error generating delivery code for order ${orderId}:`, codeError);
        // Continue without failing the warehouse approval
      }

      res.json({ 
        success: true, 
        message: "Ú©Ø§Ù„Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯ Ùˆ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        deliveryCodeGenerated: true
      });
    } catch (error) {
      console.error("Error approving warehouse order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Reject order (out of stock)
  app.post("/api/warehouse/orders/:orderId/reject", requireAuth, attachUserDepartments, requireDepartment('warehouse'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      // Update order status to warehouse_rejected
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'warehouse_rejected',
          warehouseAssigneeId: adminId,
          warehouseProcessedAt: new Date(),
          warehouseNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'financial_approved',
        toStatus: 'warehouse_rejected',
        changedBy: adminId,
        changedByDepartment: 'warehouse',
        notes: notes
      });

      res.json({ success: true, message: "Ú©Ø§Ù„Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª" });
    } catch (error) {
      console.error("Error rejecting warehouse order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ø³ÙØ§Ø±Ø´ Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse inventory synchronization endpoint - receives stock updates from Ú©Ø§Ø±Ø¯Ú©Ø³
  app.post("/api/warehouse/inventory-sync", async (req, res) => {
    try {
      const movementData = req.body;
      console.log("ğŸ“¦ [WAREHOUSE-INVENTORY-SYNC] Received inventory movement from Ú©Ø§Ø±Ø¯Ú©Ø³:", {
        productName: movementData.productName,
        movementType: movementData.movementType,
        quantity: movementData.quantity,
        previousStock: movementData.previousStock,
        newStock: movementData.newStock,
        source: movementData.source
      });
      
      // Store the inventory movement for warehouse staff to see
      // In a production system, you might want to store this in a proper inventory_movements table
      const movementRecord = {
        id: Date.now(), // Simple ID generation
        timestamp: new Date().toISOString(),
        productId: movementData.productId,
        productName: movementData.productName,
        productSku: movementData.productSku,
        productBarcode: movementData.productBarcode,
        movementType: movementData.movementType,
        quantity: movementData.quantity,
        previousStock: movementData.previousStock,
        newStock: movementData.newStock,
        reason: movementData.reason,
        source: movementData.source,
        notes: movementData.notes,
        status: 'active'
      };
      
      console.log(`âœ… [WAREHOUSE-INVENTORY-SYNC] Successfully recorded inventory movement for ${movementData.productName}`);
      console.log(`ğŸ“Š [WAREHOUSE-INVENTORY-SYNC] Movement details:`, {
        type: movementData.movementType,
        change: `${movementData.previousStock} â†’ ${movementData.newStock}`,
        difference: movementData.movementType.includes('Ø§ÙØ²Ø§ÛŒØ´') ? `+${movementData.quantity}` : `-${movementData.quantity}`
      });
      
      res.json({
        success: true,
        message: "Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ù†Ø¨Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯",
        movement: movementRecord
      });
    } catch (error) {
      console.error("âŒ [WAREHOUSE-INVENTORY-SYNC] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ù†Ø¨Ø§Ø±"
      });
    }
  });

  // Logistics Department - Get orders approved by warehouse
  app.get("/api/logistics/orders", requireAuth, attachUserDepartments, requireDepartment('logistics'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { orderItems } = await import("../shared/shop-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq, inArray } = await import("drizzle-orm");

      // Get orders approved by warehouse, pending logistics processing
      const orders = await db
        .select({
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          warehouseNotes: orderManagement.warehouseNotes,
          warehouseProcessedAt: orderManagement.warehouseProcessedAt,
          logisticsNotes: orderManagement.logisticsNotes,
          logisticsProcessedAt: orderManagement.logisticsProcessedAt,
          deliveryCode: orderManagement.deliveryCode,
          trackingNumber: orderManagement.trackingNumber,
          deliveryPersonName: orderManagement.deliveryPersonName,
          deliveryPersonPhone: orderManagement.deliveryPersonPhone,
          estimatedDeliveryDate: orderManagement.estimatedDeliveryDate,
          createdAt: orderManagement.createdAt,
          orderTotal: customerOrders.total,
          orderDate: customerOrders.createdAt,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerAddress: crmCustomers.address,
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.currentStatus, 'warehouse_approved'))
        .orderBy(orderManagement.warehouseProcessedAt); // Oldest warehouse-approved first

      // Get order items for each order
      const ordersWithItems = await Promise.all(orders.map(async (order) => {
        const items = await db
          .select()
          .from(orderItems)
          .where(eq(orderItems.orderId, order.customerOrderId));

        return {
          ...order,
          customerName: `${order.customerName} ${order.customerLastName}`,
          orderItems: items
        };
      }));

      res.json({ success: true, orders: ordersWithItems });
    } catch (error) {
      console.error("Error fetching logistics orders:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ù„Ø¬Ø³ØªÛŒÚ©",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Logistics Department - Dispatch order (generate delivery code and send SMS)
  app.post("/api/logistics/orders/:orderId/dispatch", requireAuth, attachUserDepartments, requireDepartment('logistics'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes, trackingNumber, deliveryPersonName, deliveryPersonPhone, estimatedDeliveryDate } = req.body;
      const adminId = req.session.adminId;

      // Generate unique 4-digit delivery code
      const deliveryCode = Math.floor(1000 + Math.random() * 9000).toString();

      // Update order status to logistics_dispatched
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'logistics_dispatched',
          logisticsAssigneeId: adminId,
          logisticsProcessedAt: new Date(),
          logisticsNotes: notes,
          deliveryCode: deliveryCode,
          trackingNumber: trackingNumber,
          deliveryPersonName: deliveryPersonName,
          deliveryPersonPhone: deliveryPersonPhone,
          estimatedDeliveryDate: estimatedDeliveryDate ? new Date(estimatedDeliveryDate) : null,
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'warehouse_approved',
        toStatus: 'logistics_dispatched',
        changedBy: adminId,
        changedByDepartment: 'logistics',
        notes: `${notes} | Ú©Ø¯ ØªØ­ÙˆÛŒÙ„: ${deliveryCode} | ØªØ­ÙˆÛŒÙ„â€ŒØ¯Ù‡Ù†Ø¯Ù‡: ${deliveryPersonName}`
      });

      // Get customer phone number for SMS
      const { crmCustomers } = await import("../shared/schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const orderResult = await db
        .select()
        .from(customerOrders)
        .where(eq(customerOrders.id, orderId))
        .limit(1);
      
      if (orderResult.length > 0 && orderResult[0].customerId) {
        const customerResult = await db
          .select({ phone: crmCustomers.phone, firstName: crmCustomers.firstName })
          .from(crmCustomers)
          .where(eq(crmCustomers.id, orderResult[0].customerId))
          .limit(1);
        
        if (customerResult.length > 0) {
          const customerPhone = customerResult[0].phone;
          const customerName = customerResult[0].firstName;
          
          // Send SMS notification
          const smsMessage = `Ø³Ù„Ø§Ù… ${customerName}ØŒ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. Ú©Ø¯ ØªØ­ÙˆÛŒÙ„: ${deliveryCode}. ØªØ­ÙˆÛŒÙ„â€ŒØ¯Ù‡Ù†Ø¯Ù‡: ${deliveryPersonName} (${deliveryPersonPhone}). Ø´Ø±Ú©Øª Ù…ÙˆÙ…ØªØ§Ø² Ú©ÛŒÙ…`;
          
          try {
            // Log SMS for now (can be integrated with actual SMS service later)
            console.log(`SMS sent to ${customerPhone}: ${smsMessage}`);
            
            // Store SMS in database for tracking
            const { smsLogs } = await import("../shared/schema");
            await db.insert(smsLogs).values({
              phoneNumber: customerPhone,
              message: smsMessage,
              purpose: 'delivery_notification',
              relatedOrderId: orderId,
              deliveryCode: deliveryCode,
              status: 'sent'
            });
          } catch (smsError) {
            console.error("Error sending SMS:", smsError);
          }
        }
      }

      res.json({ 
        success: true, 
        message: "Ø³ÙØ§Ø±Ø´ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        deliveryCode: deliveryCode
      });
    } catch (error) {
      console.error("Error dispatching logistics order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø³ÙØ§Ø±Ø´",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get delivered orders (logistics dispatched and delivered orders) - Only for logistics and super admin
  app.get("/api/delivered/orders", requireAuth, attachUserDepartments, requireDepartment(['logistics', 'super_admin']), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { orderItems } = await import("../shared/shop-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq, inArray } = await import("drizzle-orm");

      // Get orders that are dispatched or delivered
      const orders = await db
        .select({
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          deliveryCode: orderManagement.deliveryCode,
          trackingNumber: orderManagement.trackingNumber,
          deliveryPersonName: orderManagement.deliveryPersonName,
          deliveryPersonPhone: orderManagement.deliveryPersonPhone,
          estimatedDeliveryDate: orderManagement.estimatedDeliveryDate,
          actualDeliveryDate: orderManagement.actualDeliveryDate,
          logisticsProcessedAt: orderManagement.logisticsProcessedAt,
          orderTotal: customerOrders.totalAmount,
          orderDate: customerOrders.createdAt,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerAddress: crmCustomers.address,
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(inArray(orderManagement.currentStatus, ['logistics_dispatched', 'delivered']))
        .orderBy(orderManagement.logisticsProcessedAt); // Most recent dispatched first

      // Get order items for each order
      const ordersWithItems = await Promise.all(orders.map(async (order) => {
        const items = await db
          .select()
          .from(orderItems)
          .where(eq(orderItems.orderId, order.customerOrderId));

        return {
          ...order,
          customerName: `${order.customerName} ${order.customerLastName}`,
          orderItems: items
        };
      }));

      res.json({ success: true, orders: ordersWithItems });
    } catch (error) {
      console.error("Error fetching delivered orders:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // INTERNAL TRACKING SYSTEM ENDPOINTS
  // =============================================================================

  // Get tracking codes for a specific order
  app.get("/api/tracking/order/:orderId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const orderId = parseInt(req.params.orderId);

      const trackingCodes = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.orderId, orderId))
        .orderBy(internalTrackingCodes.createdAt);

      res.json({ success: true, trackingCodes });
    } catch (error) {
      console.error("Error fetching tracking codes:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯Ù‡Ø§ÛŒ Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Generate internal tracking codes for order items
  app.post("/api/tracking/generate/:orderId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes } = await import("../shared/internal-tracking-schema");
      const { generateInternalBarcode } = await import("../shared/internal-tracking-schema");
      const { shopProducts, orderItems } = await import("../shared/shop-schema");
      const { eq } = await import("drizzle-orm");

      const orderId = parseInt(req.params.orderId);
      const adminId = req.session.adminId;

      // Get order items
      const items = await db
        .select({
          id: orderItems.id,
          productId: orderItems.productId,
          productName: orderItems.productName,
          productSku: orderItems.productSku,
          quantity: orderItems.quantity,
        })
        .from(orderItems)
        .where(eq(orderItems.orderId, orderId));

      if (items.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Generate tracking codes for each item
      const generatedCodes = [];
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const internalBarcode = generateInternalBarcode(orderId, i + 1);

        const trackingCode = await db
          .insert(internalTrackingCodes)
          .values({
            orderId: orderId,
            orderItemId: item.id,
            internalBarcode: internalBarcode,
            productName: item.productName,
            productSku: item.productSku || undefined,
            quantity: item.quantity,
            currentLocation: 'warehouse_pending',
            currentDepartment: 'finance',
            assignedToFinance: adminId,
          })
          .returning();

        generatedCodes.push(trackingCode[0]);
      }

      res.json({ 
        success: true, 
        message: `${generatedCodes.length} Ú©Ø¯ Ø±Ø¯ÛŒØ§Ø¨ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯`,
        trackingCodes: generatedCodes
      });
    } catch (error) {
      console.error("Error generating tracking codes:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø¯Ù‡Ø§ÛŒ Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update tracking code status
  app.post("/api/tracking/:barcode/update", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes, trackingHistory } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const barcode = req.params.barcode;
      const { location, department, notes, warehouseLocation } = req.body;
      const adminId = req.session.adminId;

      // Get current tracking code
      const currentCode = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.internalBarcode, barcode))
        .limit(1);

      if (currentCode.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ú©Ø¯ Ø±Ø¯ÛŒØ§Ø¨ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const current = currentCode[0];

      // Prepare update data
      const updateData: any = {
        currentLocation: location,
        currentDepartment: department,
      };

      // Add warehouse location if provided
      if (warehouseLocation) {
        updateData.warehouseLocation = warehouseLocation;
      }

      // Set timestamps based on department
      const now = new Date();
      if (department === 'finance') {
        updateData.financeProcessedAt = now;
        updateData.assignedToFinance = adminId;
      } else if (department === 'warehouse') {
        updateData.warehouseProcessedAt = now;
        updateData.assignedToWarehouse = adminId;
      } else if (department === 'logistics') {
        updateData.logisticsProcessedAt = now;
        updateData.assignedToLogistics = adminId;
      }

      // Update tracking code
      await db
        .update(internalTrackingCodes)
        .set(updateData)
        .where(eq(internalTrackingCodes.internalBarcode, barcode));

      // Add to tracking history
      await db.insert(trackingHistory).values({
        trackingCodeId: current.id,
        internalBarcode: barcode,
        fromLocation: current.currentLocation,
        toLocation: location,
        fromDepartment: current.currentDepartment,
        toDepartment: department,
        changedBy: adminId,
        changedByName: "Admin User", // TODO: Get actual admin name
        department: department,
        notes: notes,
      });

      res.json({ 
        success: true, 
        message: "ÙˆØ¶Ø¹ÛŒØª Ø±Ø¯ÛŒØ§Ø¨ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error updating tracking code:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Scan barcode
  app.post("/api/tracking/:barcode/scan", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes, barcodeScanLogs } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const barcode = req.params.barcode;
      const { scanType, scanLocation, notes } = req.body;
      const adminId = req.session.adminId;

      // Check if barcode exists
      const trackingCode = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.internalBarcode, barcode))
        .limit(1);

      const scanResult = trackingCode.length > 0 ? 'success' : 'not_found';

      // Log scan
      await db.insert(barcodeScanLogs).values({
        internalBarcode: barcode,
        scannedBy: adminId,
        scannedByName: "Admin User", // TODO: Get actual admin name
        department: scanType.includes('warehouse') ? 'warehouse' : 
                   scanType.includes('logistics') ? 'logistics' : 'finance',
        scanType: scanType,
        scanLocation: scanLocation,
        scanResult: scanResult,
        notes: notes,
      });

      if (scanResult === 'not_found') {
        return res.status(404).json({
          success: false,
          message: "Ø¨Ø§Ø±Ú©Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯",
          scanResult: scanResult
        });
      }

      res.json({ 
        success: true, 
        message: "Ø¨Ø§Ø±Ú©Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø³Ú©Ù† Ø´Ø¯",
        trackingCode: trackingCode[0],
        scanResult: scanResult
      });
    } catch (error) {
      console.error("Error scanning barcode:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø³Ú©Ù† Ø¨Ø§Ø±Ú©Ø¯",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get tracking history for a barcode
  app.get("/api/tracking/:barcode/history", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { trackingHistory, internalTrackingCodes } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const barcode = req.params.barcode;

      // Get tracking code details
      const trackingCode = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.internalBarcode, barcode))
        .limit(1);

      if (trackingCode.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ú©Ø¯ Ø±Ø¯ÛŒØ§Ø¨ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Get history
      const history = await db
        .select()
        .from(trackingHistory)
        .where(eq(trackingHistory.internalBarcode, barcode))
        .orderBy(trackingHistory.createdAt);

      res.json({ 
        success: true, 
        trackingCode: trackingCode[0],
        history: history
      });
    } catch (error) {
      console.error("Error fetching tracking history:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });



  // Inventory Notification Settings API
  app.get("/api/inventory/notification-settings", requireAuth, async (req: Request, res: Response) => {
    try {
      // Return default settings for now - in a real app this would come from database
      const defaultSettings = {
        emailEnabled: true,
        smsEnabled: false,
        managerEmail: 'info@momtazchem.com',
        managerPhone: '+964xxxxxxxxx',
        checkIntervalHours: 1,
        businessHoursOnly: true,
        businessStartHour: 8,
        businessEndHour: 18,
        emergencyThreshold: 0,
        contacts: []
      };

      res.json({ success: true, settings: defaultSettings });
    } catch (error) {
      console.error("Error fetching notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post("/api/inventory/notification-settings", requireAuth, async (req: Request, res: Response) => {
    try {
      // In a real app, this would save to database
      console.log("Inventory notification settings updated:", req.body);
      
      res.json({ 
        success: true, 
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯",
        settings: req.body 
      });
    } catch (error) {
      console.error("Error saving notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post("/api/inventory/test-notification/:type", requireAuth, async (req: Request, res: Response) => {
    try {
      const { type } = req.params;
      
      if (type === 'email') {
        // Test email notification
        console.log("ğŸ“§ Test email notification sent");
        res.json({ 
          success: true, 
          message: "ØªØ³Øª Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" 
        });
      } else if (type === 'sms') {
        // SMS notification functionality removed per requirements
        res.json({ 
          success: true, 
          message: "Ù¾ÛŒØ§Ù…Ú© Ø¯Ø± Ø³ÛŒØ³ØªÙ… ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª" 
        });
      } else {
        res.status(400).json({
          success: false,
          message: "Ù†ÙˆØ¹ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }
    } catch (error) {
      console.error("Error testing notification:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // CONTENT MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Public endpoint for content items (for footer and public pages)
  app.get("/api/content", async (req: Request, res: Response) => {
    try {
      const { language, section } = req.query;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      let query = db.select().from(contentItems).where(eq(contentItems.isActive, true));
      
      if (language) {
        query = query.where(and(
          eq(contentItems.isActive, true),
          eq(contentItems.language, language as string)
        ));
      }
      
      if (section) {
        if (language) {
          query = query.where(and(
            eq(contentItems.isActive, true),
            eq(contentItems.language, language as string),
            eq(contentItems.section, section as string)
          ));
        } else {
          query = query.where(and(
            eq(contentItems.isActive, true),
            eq(contentItems.section, section as string)
          ));
        }
      }

      const items = await query.orderBy(contentItems.updatedAt);

      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      console.error("Error fetching public content items:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch content items",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get content items by language and section (Admin only)
  app.get("/api/admin/content", requireAuth, async (req: Request, res: Response) => {
    try {
      const { language, section } = req.query;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      let query = db.select().from(contentItems);
      
      if (language) {
        query = query.where(eq(contentItems.language, language as string));
      }
      
      if (section) {
        if (language) {
          query = query.where(and(
            eq(contentItems.language, language as string),
            eq(contentItems.section, section as string)
          ));
        } else {
          query = query.where(eq(contentItems.section, section as string));
        }
      }

      const items = await query.orderBy(contentItems.updatedAt);

      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      console.error("Error fetching content items:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch content items",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Public API endpoint for frontend visibility controls (no auth required)
  app.get("/api/frontend-controls", async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, or } = await import("drizzle-orm");

      // Fetch toggle states for discount banner and AI features
      const toggleItems = await db.select().from(contentItems)
        .where(or(
          eq(contentItems.key, 'discount_banner_enabled'),
          eq(contentItems.key, 'ai_features_enabled')
        ));

      // Create response object with default values
      const controls = {
        discountBannerEnabled: false,
        aiFeaturesEnabled: false,
        discountBannerText: ''
      };

      // Update controls based on database values
      toggleItems.forEach(item => {
        if (item.key === 'discount_banner_enabled') {
          controls.discountBannerEnabled = item.isActive || false;
        } else if (item.key === 'ai_features_enabled') {
          controls.aiFeaturesEnabled = item.isActive || false;
        }
      });

      // Fetch discount banner text if enabled
      if (controls.discountBannerEnabled) {
        const bannerTextItem = await db.select().from(contentItems)
          .where(eq(contentItems.key, 'discount_banner_text'))
          .limit(1);
        
        if (bannerTextItem.length > 0) {
          controls.discountBannerText = bannerTextItem[0].content || '';
        }
      }

      res.json({
        success: true,
        data: controls
      });
    } catch (error) {
      console.error("Error fetching frontend controls:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch frontend controls",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Content Management API endpoints
  app.get("/api/content-management/items", requireAuth, async (req: Request, res: Response) => {
    try {
      const { language, section } = req.query;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      let query = db.select().from(contentItems);
      
      if (language) {
        query = query.where(eq(contentItems.language, language as string));
      }
      
      if (section) {
        if (language) {
          query = query.where(and(
            eq(contentItems.language, language as string),
            eq(contentItems.section, section as string)
          ));
        } else {
          query = query.where(eq(contentItems.section, section as string));
        }
      }

      const items = await query.orderBy(contentItems.updatedAt);

      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      console.error("Error fetching content items:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch content items",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Create new content item
  app.post("/api/content-management/items", requireAuth, async (req: Request, res: Response) => {
    try {
      const { key, content, contentType, language, section, isActive } = req.body;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");

      const [newItem] = await db
        .insert(contentItems)
        .values({
          key,
          content,
          contentType: contentType || 'text',
          language: language || 'en',
          section: section || 'default',
          isActive: isActive !== undefined ? isActive : true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      res.json({
        success: true,
        data: newItem,
        message: "Content item created successfully"
      });
    } catch (error) {
      console.error("Error creating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update content item
  app.put("/api/content-management/items/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const contentId = parseInt(req.params.id);
      const { key, content, contentType, language, section, isActive } = req.body;

      if (isNaN(contentId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid content ID"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      const [updatedItem] = await db
        .update(contentItems)
        .set({
          key,
          content,
          contentType,
          language,
          section,
          isActive,
          updatedAt: new Date()
        })
        .where(eq(contentItems.id, contentId))
        .returning();

      res.json({
        success: true,
        data: updatedItem,
        message: "Content item updated successfully"
      });
    } catch (error) {
      console.error("Error updating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Delete content item
  app.delete("/api/content-management/items/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const contentId = parseInt(req.params.id);

      if (isNaN(contentId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid content ID"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      await db
        .delete(contentItems)
        .where(eq(contentItems.id, contentId));

      res.json({
        success: true,
        message: "Content item deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get image assets
  app.get("/api/content-management/images", requireAuth, async (req: Request, res: Response) => {
    try {
      const { section } = req.query;
      const { db } = await import("./db");
      const { imageAssets } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      let query = db.select().from(imageAssets);
      
      if (section) {
        query = query.where(eq(imageAssets.section, section as string));
      }

      const images = await query.orderBy(imageAssets.createdAt);

      res.json({
        success: true,
        data: images
      });
    } catch (error) {
      console.error("Error fetching image assets:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch image assets",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update content item
  app.put("/api/admin/content/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const contentId = parseInt(req.params.id);
      const { content, isActive } = req.body;

      if (isNaN(contentId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid content ID"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      const [updatedItem] = await db
        .update(contentItems)
        .set({
          content,
          isActive,
          updatedAt: new Date()
        })
        .where(eq(contentItems.id, contentId))
        .returning();

      res.json({
        success: true,
        data: updatedItem,
        message: "Content updated successfully"
      });
    } catch (error) {
      console.error("Error updating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get image assets by section
  app.get("/api/admin/content/images", requireAuth, async (req: Request, res: Response) => {
    try {
      const { section } = req.query;
      const { db } = await import("./db");
      const { imageAssets } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      let query = db.select().from(imageAssets);
      
      if (section) {
        query = query.where(eq(imageAssets.section, section as string));
      }

      const images = await query.orderBy(imageAssets.updatedAt);

      res.json({
        success: true,
        data: images
      });
    } catch (error) {
      console.error("Error fetching image assets:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch image assets",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Upload new image asset
  app.post("/api/admin/content/images/upload", requireAuth, async (req: Request, res: Response) => {
    try {
      const multer = await import("multer");
      const path = await import("path");
      const fs = await import("fs");

      // Configure multer for image uploads
      const storage = multer.default.diskStorage({
        destination: (req, file, cb) => {
          const uploadDir = path.join(process.cwd(), 'uploads', 'content');
          if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
          }
          cb(null, uploadDir);
        },
        filename: (req, file, cb) => {
          const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
          const extension = path.extname(file.originalname);
          cb(null, `content-${uniqueSuffix}${extension}`);
        }
      });

      const upload = multer.default({
        storage,
        fileFilter: (req, file, cb) => {
          if (file.mimetype.startsWith('image/')) {
            cb(null, true);
          } else {
            cb(new Error('Only image files are allowed'));
          }
        },
        limits: {
          fileSize: 5 * 1024 * 1024 // 5MB limit
        }
      }).single('image');

      upload(req, res, async (err) => {
        if (err) {
          return res.status(400).json({
            success: false,
            message: err.message
          });
        }

        if (!req.file) {
          return res.status(400).json({
            success: false,
            message: "No image file uploaded"
          });
        }

        try {
          const { db } = await import("./db");
          const { imageAssets } = await import("../shared/content-schema");

          const { section = 'general', alt = '' } = req.body;
          const imageUrl = `/uploads/content/${req.file.filename}`;

          const [newImage] = await db
            .insert(imageAssets)
            .values({
              filename: req.file.filename,
              originalName: req.file.originalname,
              mimeType: req.file.mimetype,
              size: req.file.size,
              url: imageUrl,
              alt,
              section,
              isActive: true
            })
            .returning();

          res.json({
            success: true,
            data: newImage,
            message: "Image uploaded successfully"
          });
        } catch (dbError) {
          console.error("Error saving image to database:", dbError);
          res.status(500).json({
            success: false,
            message: "Failed to save image information",
            error: dbError instanceof Error ? dbError.message : 'Unknown error'
          });
        }
      });
    } catch (error) {
      console.error("Error setting up image upload:", error);
      res.status(500).json({
        success: false,
        message: "Failed to process image upload",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Delete image asset
  app.delete("/api/admin/content/images/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const imageId = parseInt(req.params.id);

      if (isNaN(imageId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid image ID"
        });
      }

      const { db } = await import("./db");
      const { imageAssets } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");
      const path = await import("path");
      const fs = await import("fs");

      // Get image details before deletion
      const [image] = await db
        .select()
        .from(imageAssets)
        .where(eq(imageAssets.id, imageId))
        .limit(1);

      if (!image) {
        return res.status(404).json({
          success: false,
          message: "Image not found"
        });
      }

      // Delete from database
      await db
        .delete(imageAssets)
        .where(eq(imageAssets.id, imageId));

      // Delete physical file
      const filePath = path.join(process.cwd(), 'uploads', 'content', image.filename);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }

      res.json({
        success: true,
        message: "Image deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting image asset:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete image asset",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Create or update content item
  app.post("/api/admin/content", requireAuth, async (req: Request, res: Response) => {
    try {
      const { key, content, contentType, language, section } = req.body;

      if (!key || !content || !language || !section) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: key, content, language, section"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      // Check if content item already exists
      const [existingItem] = await db
        .select()
        .from(contentItems)
        .where(and(
          eq(contentItems.key, key),
          eq(contentItems.language, language),
          eq(contentItems.section, section)
        ))
        .limit(1);

      let result;
      
      if (existingItem) {
        // Update existing item
        [result] = await db
          .update(contentItems)
          .set({
            content,
            contentType: contentType || 'text',
            updatedAt: new Date()
          })
          .where(eq(contentItems.id, existingItem.id))
          .returning();
      } else {
        // Create new item
        [result] = await db
          .insert(contentItems)
          .values({
            key,
            content,
            contentType: contentType || 'text',
            language,
            section,
            isActive: true
          })
          .returning();
      }

      res.json({
        success: true,
        data: result,
        message: existingItem ? "Content updated successfully" : "Content created successfully"
      });
    } catch (error) {
      console.error("Error creating/updating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create/update content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ===== SECURITY MANAGEMENT ROUTES =====
  
  // Import security storage
  const { securityStorage } = await import("./security-storage");

  // Security middleware to log events
  const logSecurityEvent = async (req: Request, eventType: string, severity: string = "info") => {
    try {
      const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
      const userAgent = req.get('User-Agent');
      const userId = req.session?.adminId || req.session?.customerId;
      const username = req.session?.adminId ? 'admin' : 'customer';

      await securityStorage.logSecurityEvent({
        eventType,
        severity,
        description: `${eventType} from ${ipAddress}`,
        ipAddress,
        userAgent,
        userId,
        username,
        endpoint: req.path,
        method: req.method,
        statusCode: 200
      });
    } catch (error) {
      console.error('Failed to log security event:', error);
    }
  };

  // Security Management Routes (Simplified System)
  app.get("/api/security/metrics", requireAuth, async (req: Request, res: Response) => {
    try {
      const { getSecurityMetrics } = await import('./security-check');
      const metrics = await getSecurityMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching security metrics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch security metrics" });
    }
  });

  app.post("/api/security/comprehensive-check", requireAuth, async (req: Request, res: Response) => {
    try {
      const { performComprehensiveSecurityCheck } = await import('./security-check');
      const result = await performComprehensiveSecurityCheck();
      res.json(result);
    } catch (error) {
      console.error("Error performing security check:", error);
      res.status(500).json({ success: false, message: "Failed to perform security check" });
    }
  });

  app.post("/api/security/scan", requireAuth, async (req: Request, res: Response) => {
    try {
      const { performComprehensiveSecurityCheck } = await import('./security-check');
      const result = await performComprehensiveSecurityCheck();
      res.json({ 
        success: true, 
        vulnerabilities: result.issues.length,
        threatLevel: result.threatLevel,
        systemHealth: result.systemHealth 
      });
    } catch (error) {
      console.error("Error performing security scan:", error);
      res.status(500).json({ success: false, message: "Failed to perform security scan" });
    }
  });

  // Security Settings API endpoints
  app.get("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const { securitySettings } = await import('@shared/schema');
      const settings = await db.select().from(securitySettings);
      
      // Convert to key-value format for frontend
      const settingsMap = settings.reduce((acc: any, setting) => {
        acc[setting.setting] = {
          value: setting.value,
          category: setting.category,
          isActive: setting.isActive
        };
        return acc;
      }, {});

  // ===== ACCOUNTING MANAGEMENT ROUTES =====
  
  // Get all invoices
  app.get("/api/accounting/invoices", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import('./db');
      
      // Simple mock data for now - in production, fetch from invoices table
      const invoices = [
        {
          id: 1,
          customer_name: "Ø´Ø±Ú©Øª Ù†Ù…ÙˆÙ†Ù‡",
          date: new Date().toISOString(),
          total_amount: 1500000,
          status: "paid",
          items: [
            {
              id: 1,
              invoice_id: 1,
              description: "Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ A",
              quantity: 10,
              unit_price: 150000,
              total: 1500000
            }
          ]
        },
        {
          id: 2,
          customer_name: "Ù…Ø´ØªØ±ÛŒ ØªØ³Øª",
          date: new Date(Date.now() - 86400000).toISOString(),
          total_amount: 750000,
          status: "sent",
          items: []
        }
      ];
      
      res.json(invoices);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ ÙØ§Ú©ØªÙˆØ±Ù‡Ø§" });
    }
  });

  // Create new invoice
  app.post("/api/accounting/invoices", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customer_name, items } = req.body;

      if (!customer_name || !items || items.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ø§Ù… Ù…Ø´ØªØ±ÛŒ Ùˆ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ ÙØ§Ú©ØªÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const total_amount = items.reduce((sum: number, item: any) => sum + item.quantity * item.unit_price, 0);

      // In production, save to database
      const newInvoice = {
        id: Date.now(),
        customer_name,
        date: new Date().toISOString(),
        total_amount,
        status: 'draft',
        items: items.map((item: any, index: number) => ({
          id: Date.now() + index,
          invoice_id: Date.now(),
          description: item.description,
          quantity: item.quantity,
          unit_price: item.unit_price,
          total: item.quantity * item.unit_price
        }))
      };

      res.status(201).json({
        success: true,
        data: newInvoice,
        message: "ÙØ§Ú©ØªÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error creating invoice:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§Ú©ØªÙˆØ±" });
    }
  });

  // Get single invoice with items
  app.get("/api/accounting/invoices/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const invoiceId = parseInt(req.params.id);
      
      if (isNaN(invoiceId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ ÙØ§Ú©ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // In production, fetch from database
      const invoice = {
        id: invoiceId,
        customer_name: "Ù…Ø´ØªØ±ÛŒ Ù†Ù…ÙˆÙ†Ù‡",
        date: new Date().toISOString(),
        total_amount: 1500000,
        status: "draft",
        items: [
          {
            id: 1,
            invoice_id: invoiceId,
            description: "Ù…Ø­ØµÙˆÙ„ Ù†Ù…ÙˆÙ†Ù‡",
            quantity: 10,
            unit_price: 150000,
            total: 1500000
          }
        ]
      };

      res.json({
        success: true,
        data: invoice
      });
    } catch (error) {
      console.error("Error fetching invoice details:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª ÙØ§Ú©ØªÙˆØ±" });
    }
  });
      
      res.json({
        success: true,
        settings: settingsMap
      });
    } catch (error) {
      console.error("Error fetching security settings:", error);
      res.status(500).json({ success: false, message: "Failed to fetch security settings" });
    }
  });

  app.post("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const { securitySettings } = await import('@shared/schema');
      const { settings } = req.body;
      const adminId = req.session?.adminId;
      
      if (!settings || typeof settings !== 'object') {
        return res.status(400).json({
          success: false,
          message: "Settings object is required"
        });
      }

      // Update or insert each setting
      for (const [key, config] of Object.entries(settings as any)) {
        const { value, category } = config;
        
        await db.insert(securitySettings)
          .values({
            setting: key,
            value: String(value),
            category: category || 'general',
            updatedBy: adminId,
            updatedAt: new Date()
          })
          .onConflictDoUpdate({
            target: securitySettings.setting,
            set: {
              value: String(value),
              updatedBy: adminId,
              updatedAt: new Date()
            }
          });
      }

      // Log security event
      await logSecurityEvent(req, 'security_settings_updated', {
        settingsCount: Object.keys(settings).length,
        adminId
      });

      res.json({
        success: true,
        message: "Security settings saved successfully"
      });
    } catch (error) {
      console.error("Error saving security settings:", error);
      res.status(500).json({ success: false, message: "Failed to save security settings" });
    }
  });

  // Security logs (simplified)
  app.get("/api/security/logs", requireAuth, async (req: Request, res: Response) => {
    try {
      // Return sample security logs for demonstration
      const logs = [
        {
          id: 1,
          timestamp: new Date().toISOString(),
          event: 'Admin login successful',
          severity: 'info',
          ipAddress: req.ip || 'unknown',
          details: 'Administrative user accessed the security management system'
        },
        {
          id: 2,
          timestamp: new Date(Date.now() - 3600000).toISOString(),
          event: 'Security scan completed',
          severity: 'info',
          ipAddress: 'system',
          details: 'Automated security scan completed successfully - no issues found'
        },
        {
          id: 3,
          timestamp: new Date(Date.now() - 7200000).toISOString(),
          event: 'Database connection secured',
          severity: 'info',
          ipAddress: 'system',
          details: 'Database connection established with SSL encryption'
        },
        {
          id: 4,
          timestamp: new Date(Date.now() - 10800000).toISOString(),
          event: 'Session security check',
          severity: 'info',
          ipAddress: 'system',
          details: 'Session management security validation completed'
        }
      ];
      res.json(logs);
    } catch (error) {
      console.error("Error fetching security logs:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch security logs"
      });
    }
  });

  // IP access control
  app.get("/api/security/ip-access", requireAuth, async (req: Request, res: Response) => {
    try {
      await logSecurityEvent(req, 'ip_access_view');
      const { type } = req.query;
      const ipList = await securityStorage.getIpAccessList(type as 'blacklist' | 'whitelist');
      res.json(ipList);
    } catch (error) {
      console.error("Error fetching IP access list:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch IP access list"
      });
    }
  });

  app.post("/api/security/ip-access", requireAuth, async (req: Request, res: Response) => {
    try {
      const { ipAddress, type, reason, category } = req.body;
      
      if (!ipAddress || !type || !category) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: ipAddress, type, category"
        });
      }

      const adminId = req.session?.adminId;
      const ipData = {
        ipAddress,
        type,
        reason,
        category,
        addedBy: adminId
      };

      const result = await securityStorage.addIpToAccessControl(ipData);
      
      await logSecurityEvent(req, `ip_${type}_added`, 'medium');
      
      res.json({
        success: true,
        data: result,
        message: `IP address added to ${type}`
      });
    } catch (error) {
      console.error("Error adding IP to access control:", error);
      res.status(500).json({
        success: false,
        message: "Failed to add IP to access control"
      });
    }
  });

  app.delete("/api/security/ip-access/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid IP access rule ID"
        });
      }

      await securityStorage.removeIpFromAccessControl(id);
      await logSecurityEvent(req, 'ip_access_removed', 'medium');
      
      res.json({
        success: true,
        message: "IP access rule removed"
      });
    } catch (error) {
      console.error("Error removing IP access rule:", error);
      res.status(500).json({
        success: false,
        message: "Failed to remove IP access rule"
      });
    }
  });

  // Security scans
  app.post("/api/security/scan", requireAuth, async (req: Request, res: Response) => {
    try {
      const { scanType } = req.body;
      
      if (!scanType) {
        return res.status(400).json({
          success: false,
          message: "Scan type is required"
        });
      }

      const adminId = req.session?.adminId;
      
      // Create security scan record
      const scanData = {
        scanType,
        status: 'running' as const,
        initiatedBy: adminId,
        automated: false
      };

      const scan = await securityStorage.createSecurityScan(scanData);
      
      // Simulate scan process (in real implementation, this would be async)
      setTimeout(async () => {
        try {
          const mockResults = {
            vulnerability: {
              criticalIssues: Math.floor(Math.random() * 3),
              highIssues: Math.floor(Math.random() * 5),
              mediumIssues: Math.floor(Math.random() * 10),
              lowIssues: Math.floor(Math.random() * 15),
              results: {
                findings: [
                  "No critical vulnerabilities detected",
                  "Some outdated dependencies found",
                  "Basic security headers present"
                ]
              }
            },
            file_integrity: {
              criticalIssues: 0,
              highIssues: 0,
              mediumIssues: Math.floor(Math.random() * 2),
              lowIssues: Math.floor(Math.random() * 5),
              results: {
                findings: [
                  "All core files integrity verified",
                  "No unauthorized modifications detected"
                ]
              }
            },
            permission_audit: {
              criticalIssues: Math.floor(Math.random() * 2),
              highIssues: Math.floor(Math.random() * 3),
              mediumIssues: Math.floor(Math.random() * 7),
              lowIssues: Math.floor(Math.random() * 10),
              results: {
                findings: [
                  "File permissions reviewed",
                  "Database access controls verified",
                  "Admin privileges properly configured"
                ]
              }
            }
          };

          const scanResults = mockResults[scanType as keyof typeof mockResults] || mockResults.vulnerability;
          
          await securityStorage.updateSecurityScan(scan.id, {
            status: 'completed',
            completedAt: new Date(),
            ...scanResults
          });
        } catch (error) {
          console.error('Error completing security scan:', error);
          await securityStorage.updateSecurityScan(scan.id, {
            status: 'failed',
            completedAt: new Date()
          });
        }
      }, 5000); // Complete scan after 5 seconds

      await logSecurityEvent(req, 'security_scan_started', 'medium');
      
      res.json({
        success: true,
        data: scan,
        message: `${scanType} scan started`
      });
    } catch (error) {
      console.error("Error starting security scan:", error);
      res.status(500).json({
        success: false,
        message: "Failed to start security scan"
      });
    }
  });

  // Security settings
  app.get("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      await logSecurityEvent(req, 'security_settings_view');
      const { category } = req.query;
      
      let settings;
      if (category) {
        settings = await securityStorage.getSecuritySettingsByCategory(category as string);
      } else {
        settings = await securityStorage.getAllSecuritySettings();
      }
      
      res.json(settings);
    } catch (error) {
      console.error("Error fetching security settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch security settings"
      });
    }
  });

  app.post("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const { setting, value, category, description } = req.body;
      
      if (!setting || !value || !category) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: setting, value, category"
        });
      }

      const adminId = req.session?.adminId;
      const result = await securityStorage.updateSecuritySetting(setting, value, adminId || 0);
      
      await logSecurityEvent(req, 'security_setting_updated', 'medium');
      
      res.json({
        success: true,
        data: result,
        message: "Security setting updated"
      });
    } catch (error) {
      console.error("Error updating security setting:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update security setting"
      });
    }
  });

  // Security alerts
  app.get("/api/security/alerts", requireAuth, async (req: Request, res: Response) => {
    try {
      await logSecurityEvent(req, 'security_alerts_view');
      const { severity, status, limit, offset } = req.query;
      
      const filters: any = {};
      if (severity) filters.severity = severity as string;
      if (status) filters.status = status as string;
      if (limit) filters.limit = parseInt(limit as string);
      if (offset) filters.offset = parseInt(offset as string);

      const alerts = await securityStorage.getSecurityAlerts(filters);
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching security alerts:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch security alerts"
      });
    }
  });

  app.patch("/api/security/alerts/:id/resolve", requireAuth, async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      const { resolution } = req.body;
      
      if (isNaN(id) || !resolution) {
        return res.status(400).json({
          success: false,
          message: "Invalid alert ID or missing resolution"
        });
      }

      const adminId = req.session?.adminId || 0;
      const alert = await securityStorage.resolveSecurityAlert(id, resolution, adminId);
      
      await logSecurityEvent(req, 'security_alert_resolved', 'low');
      
      res.json({
        success: true,
        data: alert,
        message: "Security alert resolved"
      });
    } catch (error) {
      console.error("Error resolving security alert:", error);
      res.status(500).json({
        success: false,
        message: "Failed to resolve security alert"
      });
    }
  });

  // Create some default security settings on first access
  app.post("/api/security/initialize", requireAuth, async (req: Request, res: Response) => {
    try {
      const adminId = req.session?.adminId || 0;
      
      const defaultSettings = [
        { setting: 'max_login_attempts', value: '5', category: 'auth', description: 'Maximum failed login attempts before lockout' },
        { setting: 'session_timeout', value: '3600', category: 'auth', description: 'Session timeout in seconds' },
        { setting: 'password_min_length', value: '8', category: 'auth', description: 'Minimum password length' },
        { setting: 'file_upload_max_size', value: '5242880', category: 'upload', description: 'Maximum file upload size in bytes' },
        { setting: 'allowed_file_types', value: 'jpg,jpeg,png,pdf,doc,docx', category: 'upload', description: 'Allowed file upload types' },
        { setting: 'ip_whitelist_enabled', value: 'false', category: 'access', description: 'Enable IP whitelist protection' },
        { setting: 'auto_scan_enabled', value: 'true', category: 'monitoring', description: 'Enable automatic security scans' },
        { setting: 'alert_email', value: 'info@momtazchem.com', category: 'monitoring', description: 'Email for security alerts' }
      ];

      for (const setting of defaultSettings) {
        try {
          await securityStorage.updateSecuritySetting(setting.setting, setting.value, adminId);
        } catch (error) {
          console.error(`Error creating setting ${setting.setting}:`, error);
        }
      }

      await logSecurityEvent(req, 'security_system_initialized', 'medium');
      
      res.json({
        success: true,
        message: "Security system initialized with default settings"
      });
    } catch (error) {
      console.error("Error initializing security system:", error);
      res.status(500).json({
        success: false,
        message: "Failed to initialize security system"
      });
    }
  });

  // AI Settings endpoints
  app.post("/api/ai/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const settings = req.body;
      
      // Save AI settings to environment or database
      // For now, we'll just return success
      console.log("AI Settings saved:", settings);
      
      res.json({ 
        success: true, 
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª AI Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯",
        settings 
      });
    } catch (error) {
      console.error("Error saving AI settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª AI"
      });
    }
  });

  app.post("/api/ai/test-connection", requireAuth, async (req: Request, res: Response) => {
    try {
      // Test AI connection
      const { OpenAI } = await import("openai");
      
      if (!process.env.OPENAI_API_KEY) {
        return res.status(400).json({
          success: false,
          message: "Ú©Ù„ÛŒØ¯ API OpenAI ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª"
        });
      }

      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });

      // Simple test call
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: "Test connection" }],
        max_tokens: 10
      });

      res.json({
        success: true,
        message: "Ø§ØªØµØ§Ù„ Ù…ÙˆÙÙ‚",
        model: "gpt-4o",
        response: completion.choices[0]?.message?.content
      });
    } catch (error) {
      console.error("Error testing AI connection:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ø²Ù…Ø§ÛŒØ´ Ø§ØªØµØ§Ù„ AI"
      });
    }
  });

  // Customer Communication API Routes
  const { customerCommunicationStorage } = await import("./customer-communication-storage");

  // Send message to customer
  app.post("/api/customer-communications/send", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryId, customerEmail, customerName, subject, message, messageType = "outbound" } = req.body;
      const adminId = req.session.adminId;
      
      if (!categoryId || !customerEmail || !subject || !message) {
        return res.status(400).json({
          success: false,
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø¨Ø§ÛŒØ¯ Ù¾Ø± Ø´ÙˆÙ†Ø¯"
        });
      }

      const communication = await customerCommunicationStorage.sendMessage({
        categoryId,
        customerEmail,
        customerName: customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ",
        subject,
        message,
        messageType,
        sentBy: adminId,
        status: "sent"
      });

      res.json({
        success: true,
        data: communication,
        message: "Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error sending customer communication:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…"
      });
    }
  });

  // Smart reply suggestion based on product category
  app.post("/api/customer-communications/smart-reply", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerMessage, productCategory, customerName } = req.body;
      
      if (!customerMessage || !productCategory) {
        return res.status(400).json({
          success: false,
          message: "Ù¾ÛŒØ§Ù… Ù…Ø´ØªØ±ÛŒ Ùˆ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø­ØµÙˆÙ„ Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª"
        });
      }

      // Generate smart reply based on category
      const categoryResponses: Record<string, string> = {
        'fuel-additives': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø³ÙˆØ®Øª Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù… Ù…ØªØ´Ú©Ø±ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª Ù…Ø§ Ø´Ø§Ù…Ù„:\n- Ø§ÙØ²ÙˆØ¯Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨Ù†Ø²ÛŒÙ†\n- Ø§ÙØ²ÙˆØ¯Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ú¯Ø§Ø²ÙˆØ¦ÛŒÙ„\n- Ù¾Ø§Ú©â€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ø³ÙˆØ®Øª\n\nØ¨Ø§ ØªØ´Ú©Ø±,\nØªÛŒÙ… ÙØ±ÙˆØ´ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,
        'water-treatment': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² Ø¹Ù„Ø§Ù‚Ù‡ Ø´Ù…Ø§ Ø¨Ù‡ Ù…Ø­ØµÙˆÙ„Ø§Øª ØªØµÙÛŒÙ‡ Ø¢Ø¨ Ø³Ù¾Ø§Ø³Ú¯Ø²Ø§Ø±ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª ØªØµÙÛŒÙ‡ Ø¢Ø¨ Ù…Ø§:\n- Ù…ÙˆØ§Ø¯ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªØµÙÛŒÙ‡\n- Ú©Ù„Ø±ÛŒÙ† Ùˆ ÙÙ„ÙˆÚ©ÙˆÙ„Ø§Ù†Øª\n- Ø¶Ø¯Ø¹ÙÙˆÙ†ÛŒ Ú©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§\n\nØ¨Ø§ Ø§Ø­ØªØ±Ø§Ù…,\nØªÛŒÙ… ÙÙ†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,
        'paint-solvents': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø±Ù†Ú¯ Ùˆ Ø­Ù„Ø§Ù„â€ŒÙ‡Ø§ ØªØ´Ú©Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª Ù…Ø§:\n- Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ ØµÙ†Ø¹ØªÛŒ\n- Ø­Ù„Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù\n- Ù…ÙˆØ§Ø¯ Ù†Ø§Ø²Ú©â€ŒÚ©Ù†Ù†Ø¯Ù‡\n\nØ¨Ø§ ØªØ´Ú©Ø±,\nØªÛŒÙ… ÙØ±ÙˆØ´ Ø±Ù†Ú¯ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,

        'default': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù… Ù…ØªØ´Ú©Ø±ÛŒÙ….\n\nÙ…Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ø­ØµÙˆÙ„Ø§Øª Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ Ù‡Ø³ØªÛŒÙ….\n\nØ¨Ø§ ØªØ´Ú©Ø±,\nØªÛŒÙ… Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`
      };

      const smartReply = categoryResponses[productCategory] || categoryResponses.default;

      res.json({
        success: true,
        data: {
          suggestedReply: smartReply,
          category: productCategory,
          customerMessage
        }
      });
    } catch (error) {
      console.error("Error generating smart reply:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù¾Ø§Ø³Ø® Ù‡ÙˆØ´Ù…Ù†Ø¯"
      });
    }
  });

  // Get recent communications
  app.get("/api/customer-communications/recent", requireAuth, async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const communications = await customerCommunicationStorage.getRecentCommunications(limit);

      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching recent communications:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª Ø§Ø®ÛŒØ±"
      });
    }
  });

  // Get communication statistics
  app.get("/api/customer-communications/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const categoryId = req.query.categoryId ? parseInt(req.query.categoryId as string) : undefined;
      const stats = await customerCommunicationStorage.getCommunicationStats(categoryId);

      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching communication stats:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª"
      });
    }
  });

  // Search communications
  app.get("/api/customer-communications/search", requireAuth, async (req: Request, res: Response) => {
    try {
      const { q } = req.query;
      if (!q) {
        return res.status(400).json({
          success: false,
          message: "Ù¾Ø§Ø±Ø§Ù…ØªØ± Ø¬Ø³ØªØ¬Ùˆ Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª"
        });
      }

      const communications = await customerCommunicationStorage.searchCommunications(q as string);

      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error searching communications:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬Ùˆ Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª"
      });
    }
  });

  // Mark communication as read
  app.patch("/api/customer-communications/:id/read", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.id);
      await customerCommunicationStorage.markAsRead(messageId);

      res.json({
        success: true,
        message: "Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error marking message as read:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù¾ÛŒØ§Ù…"
      });
    }
  });

  // Get communications by category
  app.get("/api/customer-communications/category/:categoryId", requireAuth, async (req: Request, res: Response) => {
    try {
      const categoryId = parseInt(req.params.categoryId);
      const communications = await customerCommunicationStorage.getCommunicationsByCategory(categoryId);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch communications"
      });
    }
  });

  // Get communications by customer
  app.get("/api/customer-communications/customer/:email", requireAuth, async (req: Request, res: Response) => {
    try {
      const email = req.params.email;
      const communications = await customerCommunicationStorage.getCommunicationsByCustomer(email);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching customer communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch customer communications"
      });
    }
  });

  // Get communication thread
  app.get("/api/customer-communications/thread/:messageId", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      const thread = await customerCommunicationStorage.getCommunicationThread(messageId);
      
      res.json({
        success: true,
        data: thread
      });
    } catch (error) {
      console.error("Error fetching communication thread:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch communication thread"
      });
    }
  });

  // Mark message as read
  app.put("/api/customer-communications/:messageId/read", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      await customerCommunicationStorage.markAsRead(messageId);
      
      res.json({
        success: true,
        message: "Message marked as read"
      });
    } catch (error) {
      console.error("Error marking message as read:", error);
      res.status(500).json({
        success: false,
        message: "Failed to mark message as read"
      });
    }
  });

  // Mark message as replied
  app.put("/api/customer-communications/:messageId/replied", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      await customerCommunicationStorage.markAsReplied(messageId);
      
      res.json({
        success: true,
        message: "Message marked as replied"
      });
    } catch (error) {
      console.error("Error marking message as replied:", error);
      res.status(500).json({
        success: false,
        message: "Failed to mark message as replied"
      });
    }
  });

  // Get recent communications
  app.get("/api/customer-communications/recent", requireAuth, async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const communications = await customerCommunicationStorage.getRecentCommunications(limit);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching recent communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch recent communications"
      });
    }
  });

  // Get communication stats
  app.get("/api/customer-communications/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const categoryId = req.query.categoryId ? parseInt(req.query.categoryId as string) : undefined;
      const stats = await customerCommunicationStorage.getCommunicationStats(categoryId);
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching communication stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch communication stats"
      });
    }
  });

  // Search communications
  app.get("/api/customer-communications/search", requireAuth, async (req: Request, res: Response) => {
    try {
      const searchTerm = req.query.q as string;
      if (!searchTerm) {
        return res.status(400).json({
          success: false,
          message: "Search term is required"
        });
      }

      const communications = await customerCommunicationStorage.searchCommunications(searchTerm);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error searching communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to search communications"
      });
    }
  });

  // Update communication status
  app.put("/api/customer-communications/:messageId/status", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      const { status } = req.body;
      
      if (!status) {
        return res.status(400).json({
          success: false,
          message: "Status is required"
        });
      }

      await customerCommunicationStorage.updateStatus(messageId, status);
      
      res.json({
        success: true,
        message: "Status updated successfully"
      });
    } catch (error) {
      console.error("Error updating status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update status"
      });
    }
  });

  // Delete communication
  app.delete("/api/customer-communications/:messageId", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      await customerCommunicationStorage.deleteCommunication(messageId);
      
      res.json({
        success: true,
        message: "Communication deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting communication:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete communication"
      });
    }
  });

  // Get shipping rates for customer checkout
  app.get("/api/shipping/rates", async (req, res) => {
    try {
      const { city, totalWeight } = req.query;

      const rates = await orderManagementStorage.getShippingRates({
        cityName: city as string,
        isActive: true
      });

      // Calculate shipping costs based on rates and order details
      const calculatedRates = rates.map(rate => {
        let shippingCost = parseFloat(rate.basePrice || '0');
        
        if (totalWeight && rate.pricePerKg) {
          const weight = parseFloat(totalWeight as string);
          shippingCost += weight * parseFloat(rate.pricePerKg);
        }

        return {
          id: rate.id,
          deliveryMethod: rate.deliveryMethod,
          transportationType: rate.transportationType,
          description: rate.description,
          estimatedDays: rate.estimatedDays,
          trackingAvailable: rate.trackingAvailable,
          insuranceAvailable: rate.insuranceAvailable,
          shippingCost: shippingCost,
          basePrice: rate.basePrice,
          pricePerKg: rate.pricePerKg,
          freeShippingThreshold: rate.freeShippingThreshold
        };
      });

      res.json({
        success: true,
        data: calculatedRates
      });
    } catch (error) {
      console.error("Error fetching shipping rates:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch shipping rates"
      });
    }
  });

  // Calculate shipping cost for specific delivery method
  app.post("/api/shipping/calculate", async (req, res) => {
    try {
      const { deliveryMethod, city, totalWeight, orderValue } = req.body;

      const rate = await orderManagementStorage.getShippingRateByMethod(deliveryMethod, city);
      
      if (!rate) {
        return res.status(404).json({
          success: false,
          message: "Shipping method not available for your location"
        });
      }

      let shippingCost = parseFloat(rate.basePrice || '0');
      
      if (totalWeight && rate.pricePerKg) {
        shippingCost += totalWeight * parseFloat(rate.pricePerKg);
      }

      // Check for free shipping threshold
      if (rate.freeShippingThreshold && orderValue >= parseFloat(rate.freeShippingThreshold)) {
        shippingCost = 0;
      }

      res.json({
        success: true,
        data: {
          deliveryMethod: rate.deliveryMethod,
          shippingCost,
          isFreeShipping: shippingCost === 0,
          estimatedDays: rate.estimatedDays,
          trackingAvailable: rate.trackingAvailable
        }
      });
    } catch (error) {
      console.error("Error calculating shipping cost:", error);
      res.status(500).json({
        success: false,
        message: "Failed to calculate shipping cost"
      });
    }
  });
















  // =============================================================================
  // PRODUCT REVIEWS & RATINGS ENDPOINTS
  // =============================================================================

  // Get product reviews (public endpoint - accessible to all users including guests)
  app.get("/api/products/:id/reviews", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Ø´Ù†Ø§Ø³Ù‡ Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }

      const { pool } = await import('./db');
      
      // Get approved reviews with customer information
      const reviewsResult = await pool.query(`
        SELECT 
          id,
          product_id,
          customer_id,
          customer_name,
          rating,
          title,
          comment,
          is_verified_purchase,
          helpful_votes,
          not_helpful_votes,
          admin_response,
          admin_response_date,
          created_at,
          updated_at
        FROM product_reviews 
        WHERE product_id = $1 AND is_approved = true
        ORDER BY created_at DESC
      `, [productId]);

      // Get product statistics
      const statsResult = await pool.query(`
        SELECT 
          total_reviews,
          average_rating,
          rating_distribution,
          last_review_date
        FROM product_stats 
        WHERE product_id = $1
      `, [productId]);

      const reviews = reviewsResult.rows.map(row => ({
        id: row.id,
        productId: row.product_id,
        customerId: row.customer_id,
        customerName: row.customer_name,
        rating: row.rating,
        title: row.title || '',
        comment: row.comment,
        isVerifiedPurchase: row.is_verified_purchase,
        helpfulVotes: row.helpful_votes,
        notHelpfulVotes: row.not_helpful_votes,
        adminResponse: row.admin_response,
        adminResponseDate: row.admin_response_date,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      const stats = statsResult.rows[0] || {
        total_reviews: 0,
        average_rating: 0,
        rating_distribution: {},
        last_review_date: null
      };

      res.json({
        success: true,
        data: {
          reviews,
          stats: {
            totalReviews: parseInt(stats.total_reviews) || 0,
            averageRating: parseFloat(stats.average_rating) || 0,
            ratingDistribution: stats.rating_distribution || {},
            lastReviewDate: stats.last_review_date
          }
        }
      });
    } catch (error) {
      console.error("Error fetching product reviews:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø¸Ø±Ø§Øª" });
    }
  });

  // Submit or update product review (requires customer authentication)
  app.post("/api/products/:id/reviews", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Ø´Ù†Ø§Ø³Ù‡ Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }

      // Check customer authentication
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª Ù†Ø¸Ø± Ø¨Ø§ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø®ÙˆØ¯ Ø´ÙˆÛŒØ¯" });
      }

      const customerId = req.session.customerId;
      const { rating, title, comment } = req.body;

      // Validate input
      if (!rating || rating < 1 || rating > 5) {
        return res.status(400).json({ success: false, message: "Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 1 ØªØ§ 5 Ø³ØªØ§Ø±Ù‡ Ø¨Ø§Ø´Ø¯" });
      }

      if (!comment || comment.trim().length === 0) {
        return res.status(400).json({ success: false, message: "Ù…ØªÙ† Ù†Ø¸Ø± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { pool } = await import('./db');

      // Get customer information
      const customerResult = await pool.query(`
        SELECT 
          COALESCE(first_name || ' ' || last_name, company, email) as customer_name,
          email 
        FROM crm_customers 
        WHERE id = $1
      `, [customerId]);

      if (customerResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const customer = customerResult.rows[0];

      // Check if customer already has a review for this product
      const existingReview = await pool.query(`
        SELECT id FROM product_reviews WHERE product_id = $1 AND customer_id = $2
      `, [productId, customerId]);

      let reviewResult;
      let isUpdate = false;

      if (existingReview.rows.length > 0) {
        // Update existing review
        reviewResult = await pool.query(`
          UPDATE product_reviews 
          SET rating = $1, title = $2, comment = $3, updated_at = NOW()
          WHERE product_id = $4 AND customer_id = $5
          RETURNING id
        `, [rating, title || null, comment.trim(), productId, customerId]);
        isUpdate = true;
      } else {
        // Create new review
        reviewResult = await pool.query(`
          INSERT INTO product_reviews (
            product_id, customer_id, customer_name, customer_email, 
            rating, title, comment, is_verified_purchase
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          RETURNING id
        `, [
          productId, customerId, customer.customer_name, customer.email,
          rating, title || null, comment.trim(), false // TODO: Check if verified purchase
        ]);
      }

      // Update product statistics
      await updateProductStatistics(productId);

      res.json({ 
        success: true, 
        message: isUpdate ? "Ù†Ø¸Ø± Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" : "Ù†Ø¸Ø± Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯",
        reviewId: reviewResult.rows[0].id,
        isUpdate
      });
    } catch (error) {
      console.error("Error submitting product review:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ù†Ø¸Ø±" });
    }
  });

  // Mark review as helpful/not helpful
  app.post("/api/reviews/:id/helpful", async (req, res) => {
    try {
      const reviewId = parseInt(req.params.id);
      const { isHelpful } = req.body;
      
      if (isNaN(reviewId)) {
        return res.status(400).json({ success: false, message: "Ø´Ù†Ø§Ø³Ù‡ Ù†Ø¸Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }
      
      if (typeof isHelpful !== 'boolean') {
        return res.status(400).json({ success: false, message: "Ù†ÙˆØ¹ Ø±Ø§ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }

      const customerId = req.session.customerId || null;
      const customerIp = req.ip;
      
      // Check if user already voted on this review
      const { pool } = await import('./db');
      let existingVote;
      if (customerId) {
        existingVote = await pool.query(`
          SELECT id FROM review_helpfulness 
          WHERE review_id = $1 AND customer_id = $2
        `, [reviewId, customerId]);
      } else {
        existingVote = await pool.query(`
          SELECT id FROM review_helpfulness 
          WHERE review_id = $1 AND customer_ip = $2
        `, [reviewId, customerIp]);
      }
      
      if (existingVote.rows.length > 0) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ Ø±ÙˆÛŒ Ø§ÛŒÙ† Ù†Ø¸Ø± Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯" });
      }

      // Record the vote
      await pool.query(`
        INSERT INTO review_helpfulness (review_id, customer_id, customer_ip, is_helpful)
        VALUES ($1, $2, $3, $4)
      `, [reviewId, customerId, customerIp, isHelpful]);

      // Update the review's helpful votes count
      const updateField = isHelpful ? 'helpful_votes' : 'not_helpful_votes';
      await pool.query(`
        UPDATE product_reviews 
        SET ${updateField} = ${updateField} + 1 
        WHERE id = $1
      `, [reviewId]);

      res.json({ success: true, message: "Ø±Ø§ÛŒ Ø´Ù…Ø§ Ø«Ø¨Øª Ø´Ø¯" });
    } catch (error) {
      console.error("Error recording helpful vote:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø±Ø§ÛŒ" });
    }
  });

  // Get product statistics for shop display (public endpoint)
  app.get("/api/shop/product-stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get all product statistics
      const statsResult = await pool.query(`
        SELECT 
          product_id,
          total_reviews,
          average_rating,
          rating_distribution
        FROM product_stats 
        WHERE total_reviews > 0
      `);

      const stats = {};
      statsResult.rows.forEach(row => {
        stats[row.product_id] = {
          totalReviews: parseInt(row.total_reviews) || 0,
          averageRating: parseFloat(row.average_rating) || 0,
          ratingDistribution: row.rating_distribution || {}
        };
      });

      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching product stats:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ù…Ø­ØµÙˆÙ„Ø§Øª" });
    }
  });

  // Helper function to update product statistics
  async function updateProductStatistics(productId: number) {
    try {
      const { pool } = await import('./db');
      
      // Calculate new statistics from approved reviews
      const statsQuery = await pool.query(`
        SELECT 
          COUNT(*) as total_reviews,
          AVG(rating) as average_rating,
          COUNT(CASE WHEN rating = 1 THEN 1 END) as rating_1,
          COUNT(CASE WHEN rating = 2 THEN 1 END) as rating_2,
          COUNT(CASE WHEN rating = 3 THEN 1 END) as rating_3,
          COUNT(CASE WHEN rating = 4 THEN 1 END) as rating_4,
          COUNT(CASE WHEN rating = 5 THEN 1 END) as rating_5,
          MAX(created_at) as last_review_date
        FROM product_reviews 
        WHERE product_id = $1 AND is_approved = true
      `, [productId]);

      const stats = statsQuery.rows[0];
      const ratingDistribution = {
        "1": parseInt(stats.rating_1),
        "2": parseInt(stats.rating_2),
        "3": parseInt(stats.rating_3),
        "4": parseInt(stats.rating_4),
        "5": parseInt(stats.rating_5)
      };

      // Update or insert product stats
      await pool.query(`
        INSERT INTO product_stats (
          product_id, total_reviews, average_rating, rating_distribution, last_review_date, updated_at
        ) VALUES ($1, $2, $3, $4, $5, NOW())
        ON CONFLICT (product_id) DO UPDATE SET
          total_reviews = $2,
          average_rating = $3,
          rating_distribution = $4,
          last_review_date = $5,
          updated_at = NOW()
      `, [
        productId,
        parseInt(stats.total_reviews),
        parseFloat(stats.average_rating) || 0,
        JSON.stringify(ratingDistribution),
        stats.last_review_date
      ]);
    } catch (error) {
      console.error("Error updating product stats:", error);
    }
  }

  // =============================================================================
  // WEIGHT CALCULATION ENDPOINTS
  // =============================================================================

  // Calculate weight for a specific order
  app.post('/api/orders/:orderId/calculate-weight', async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: 'ID Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' });
      }

      await orderManagementStorage.calculateAndUpdateOrderWeight(orderId);
      
      // Get updated order to return the new weight
      const updatedOrder = await orderManagementStorage.getOrderById(orderId);
      
      res.json({ 
        success: true, 
        message: 'ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯',
        totalWeight: updatedOrder?.totalWeight,
        weightUnit: updatedOrder?.weightUnit
      });
    } catch (error) {
      console.error('Error calculating order weight:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Calculate weights for all orders with null weight
  app.post('/api/orders/calculate-all-weights', async (req, res) => {
    try {
      // Get all orders with null or empty weight
      const ordersWithoutWeight = await db
        .select({ customerOrderId: orderManagement.customerOrderId })
        .from(orderManagement)
        .where(isNull(orderManagement.totalWeight));

      let updatedCount = 0;
      let errors = 0;

      for (const order of ordersWithoutWeight) {
        try {
          await orderManagementStorage.calculateAndUpdateOrderWeight(order.customerOrderId);
          updatedCount++;
        } catch (error) {
          console.error(`Error calculating weight for order ${order.customerOrderId}:`, error);
          errors++;
        }
      }

      res.json({ 
        success: true, 
        message: `ÙˆØ²Ù† ${updatedCount} Ø³ÙØ§Ø±Ø´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯`,
        updatedCount,
        errors,
        totalProcessed: ordersWithoutWeight.length
      });
    } catch (error) {
      console.error('Error calculating weights for all orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // =============================================================================
  // INVENTORY THRESHOLD SETTINGS API ENDPOINTS
  // =============================================================================

  // Get inventory threshold settings
  app.get("/api/inventory/threshold-settings", async (req: Request, res: Response) => {
    try {
      const { inventoryThresholdSettings } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const settings = await db.select()
        .from(inventoryThresholdSettings)
        .where(eq(inventoryThresholdSettings.isActive, true))
        .orderBy(inventoryThresholdSettings.settingName);
      
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error fetching threshold settings:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¢Ø³ØªØ§Ù†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ" 
      });
    }
  });

  // Create or update threshold settings
  app.post("/api/inventory/threshold-settings", async (req: Request, res: Response) => {
    try {
      const { inventoryThresholdSettings, insertInventoryThresholdSettingsSchema } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const validatedData = insertInventoryThresholdSettingsSchema.parse(req.body);
      
      // Check if setting already exists
      const existingSetting = await db.select()
        .from(inventoryThresholdSettings)
        .where(eq(inventoryThresholdSettings.settingName, validatedData.settingName))
        .limit(1);
      
      let result;
      if (existingSetting.length > 0) {
        // Update existing setting
        result = await db.update(inventoryThresholdSettings)
          .set({
            ...validatedData,
            updatedAt: new Date()
          })
          .where(eq(inventoryThresholdSettings.settingName, validatedData.settingName))
          .returning();
      } else {
        // Create new setting
        result = await db.insert(inventoryThresholdSettings)
          .values(validatedData)
          .returning();
      }
      
      res.json({ success: true, data: result[0] });
    } catch (error) {
      console.error("Error saving threshold settings:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¢Ø³ØªØ§Ù†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ" 
      });
    }
  });

  // Get inventory alerts log
  app.get("/api/inventory/alerts-log", async (req: Request, res: Response) => {
    try {
      const { inventoryAlertLog } = await import("../shared/schema");
      const { desc } = await import("drizzle-orm");
      
      const { limit = 50, offset = 0 } = req.query;
      
      const alerts = await db.select()
        .from(inventoryAlertLog)
        .orderBy(desc(inventoryAlertLog.sentAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));
      
      res.json({ success: true, data: alerts });
    } catch (error) {
      console.error("Error fetching alerts log:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§" 
      });
    }
  });

  // =============================================================================
  // =============================================================================
  // ABANDONED CART MANAGEMENT API ENDPOINTS
  // =============================================================================
  
  // Get abandoned cart settings
  app.get("/api/admin/abandoned-cart/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const settings = await cartStorage.getAbandonedCartSettings();
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error fetching abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update abandoned cart settings
  app.put("/api/admin/abandoned-cart/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const settings = await cartStorage.updateAbandonedCartSettings(req.body);
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error updating abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get abandoned cart sessions
  app.get("/api/admin/abandoned-cart/carts", requireAuth, async (req: Request, res: Response) => {
    try {
      const carts = await cartStorage.getAbandonedCarts();
      res.json({ success: true, data: carts });
    } catch (error) {
      console.error("Error fetching abandoned carts:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get abandoned cart analytics
  app.get("/api/admin/abandoned-cart/analytics", requireAuth, async (req: Request, res: Response) => {
    try {
      const analytics = await cartStorage.getAbandonedCartAnalytics();
      res.json({ success: true, data: analytics });
    } catch (error) {
      console.error("Error fetching abandoned cart analytics:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Track cart session (for logged-in customers)
  app.post("/api/cart/session", async (req: Request, res: Response) => {
    try {
      const { sessionId, cartData, itemCount, totalValue } = req.body;
      const session = req.session as SessionData;
      
      if (!session.customerId) {
        return res.status(401).json({ success: false, message: "Customer not authenticated" });
      }
      
      // Handle double-encoded JSON strings  
      let parsedCartData = cartData;
      if (typeof cartData === 'string') {
        try {
          parsedCartData = JSON.parse(cartData);
        } catch (parseError) {
          console.error('Cart data JSON parsing error:', parseError);
          parsedCartData = cartData; // Keep original if parsing fails
        }
      }

      const sessionData = {
        customerId: session.customerId,
        sessionId,
        cartData: parsedCartData,
        itemCount,
        totalValue: parseFloat(totalValue) || 0
      };
      
      await cartStorage.createOrUpdateCartSession(sessionData);
      res.json({ success: true, message: "Cart session tracked successfully" });
    } catch (error) {
      console.error("Error tracking cart session:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Send abandoned cart notification
  app.post("/api/admin/abandoned-cart/notify/:cartId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { cartId } = req.params;
      const { message, discountCode } = req.body;
      
      await cartStorage.sendAbandonedCartNotification(parseInt(cartId), message, discountCode);
      res.json({ success: true, message: "Notification sent successfully" });
    } catch (error) {
      console.error("Error sending abandoned cart notification:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });


  
  // =============================================================================
  // ABANDONED CART MANAGEMENT API
  // =============================================================================

  // Track cart session activity (duplicate endpoint removed - merged with above)

  // Get abandoned cart settings
  app.get("/api/admin/abandoned-cart/settings", requireAuth, async (req, res) => {
    try {
      const settings = await cartStorage.getAbandonedCartSettings();
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error fetching abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Failed to fetch settings" });
    }
  });

  // Update abandoned cart settings
  app.put("/api/admin/abandoned-cart/settings", requireAuth, async (req, res) => {
    try {
      const settings = req.body;
      await cartStorage.updateAbandonedCartSettings(settings);
      res.json({ success: true, message: "Settings updated successfully" });
    } catch (error) {
      console.error("Error updating abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Failed to update settings" });
    }
  });

  // Get abandoned carts
  app.get("/api/admin/abandoned-cart/carts", requireAuth, async (req, res) => {
    try {
      const { timeout } = req.query;
      const timeoutMinutes = timeout ? parseInt(timeout as string) : 30;
      
      const abandonedCarts = await cartStorage.getAbandonedCarts(timeoutMinutes);
      res.json({ success: true, data: abandonedCarts });
    } catch (error) {
      console.error("Error fetching abandoned carts:", error);
      res.status(500).json({ success: false, message: "Failed to fetch abandoned carts" });
    }
  });

  // Send abandoned cart notification
  app.post("/api/admin/abandoned-cart/notify/:cartId", requireAuth, async (req, res) => {
    try {
      const cartId = parseInt(req.params.cartId);
      const { title, message, notificationType } = req.body;
      
      // Get cart session info
      const cartSessions = await cartStorage.getActiveCartSessions();
      const cartSession = cartSessions.find(cart => cart.id === cartId);
      
      if (!cartSession) {
        return res.status(404).json({ success: false, message: "Cart session not found" });
      }

      await cartStorage.createNotification({
        cartSessionId: cartId,
        customerId: cartSession.customerId,
        notificationType: notificationType || 'browser',
        title,
        message
      });

      res.json({ success: true, message: "Notification sent successfully" });
    } catch (error) {
      console.error("Error sending abandoned cart notification:", error);
      res.status(500).json({ success: false, message: "Failed to send notification" });
    }
  });

  // Get customer notifications
  app.get("/api/cart/notifications", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }

      const notifications = await cartStorage.getCustomerNotifications(customerId);
      res.json({ success: true, data: notifications });
    } catch (error) {
      console.error("Error fetching customer notifications:", error);
      res.status(500).json({ success: false, message: "Failed to fetch notifications" });
    }
  });

  // Mark notification as read
  app.patch("/api/cart/notifications/:id/read", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      await cartStorage.markNotificationAsRead(notificationId);
      res.json({ success: true, message: "Notification marked as read" });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ success: false, message: "Failed to mark notification as read" });
    }
  });

  // Get abandoned cart analytics
  app.get("/api/admin/abandoned-cart/analytics", requireAuth, async (req, res) => {
    try {
      const { days } = req.query;
      const analyticsDays = days ? parseInt(days as string) : 30;
      
      const analytics = await cartStorage.getCartRecoveryAnalytics(analyticsDays);
      const overallStats = await cartStorage.getOverallStats();
      
      res.json({ 
        success: true, 
        data: {
          analytics,
          overallStats
        }
      });
    } catch (error) {
      console.error("Error fetching abandoned cart analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch analytics" });
    }
  });

  // Complete cart session (when order is placed)
  app.post("/api/cart/session/complete", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }

      await cartStorage.clearCartSession(customerId);
      res.json({ success: true, message: "Cart session completed" });
    } catch (error) {
      console.error("Error completing cart session:", error);
      res.status(500).json({ success: false, message: "Failed to complete cart session" });
    }
  });

  // ===========================================
  // GPS DELIVERY TRACKING ENDPOINTS
  // ===========================================

  // Record GPS delivery confirmation
  app.post("/api/gps-delivery/confirm", async (req, res) => {
    try {
      console.log('ğŸ“ [GPS-API] Delivery confirmation request:', req.body);
      
      const gpsData = insertGpsDeliveryConfirmationSchema.parse(req.body);
      const confirmation = await gpsDeliveryStorage.recordGpsDelivery(gpsData);
      
      res.json({ 
        success: true, 
        data: confirmation,
        message: "GPS delivery confirmation recorded successfully"
      });
    } catch (error) {
      console.error("âŒ [GPS-API] Error recording GPS delivery:", error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : "Failed to record GPS delivery confirmation" 
      });
    }
  });

  // Get GPS deliveries by order
  app.get("/api/gps-delivery/order/:orderId", async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }

      const deliveries = await gpsDeliveryStorage.getGpsDeliveriesByOrder(orderId);
      res.json({ success: true, data: deliveries });
    } catch (error) {
      console.error("Error fetching GPS deliveries for order:", error);
      res.status(500).json({ success: false, message: "Failed to fetch GPS deliveries" });
    }
  });

  // Get GPS deliveries by delivery person
  app.get("/api/gps-delivery/person/:phone", async (req, res) => {
    try {
      const phone = req.params.phone;
      const deliveries = await gpsDeliveryStorage.getGpsDeliveriesByDeliveryPerson(phone);
      res.json({ success: true, data: deliveries });
    } catch (error) {
      console.error("Error fetching GPS deliveries for delivery person:", error);
      res.status(500).json({ success: false, message: "Failed to fetch GPS deliveries" });
    }
  });

  // Get GPS deliveries by location
  app.get("/api/gps-delivery/location/:country/:city", async (req, res) => {
    try {
      const { country, city } = req.params;
      const { startDate, endDate } = req.query;
      
      const start = startDate ? new Date(startDate as string) : undefined;
      const end = endDate ? new Date(endDate as string) : undefined;
      
      const deliveries = await gpsDeliveryStorage.getGpsDeliveriesByLocation(country, city, start, end);
      res.json({ success: true, data: deliveries });
    } catch (error) {
      console.error("Error fetching GPS deliveries by location:", error);
      res.status(500).json({ success: false, message: "Failed to fetch GPS deliveries" });
    }
  });

  // Get delivery performance statistics
  app.get("/api/gps-delivery/performance", async (req, res) => {
    try {
      const { period } = req.query;
      const periodDays = period ? parseInt(period as string) : 30;
      
      const stats = await gpsDeliveryStorage.getDeliveryPerformanceStats(periodDays);
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching delivery performance stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch performance statistics" });
    }
  });

  // Get geographic coverage data
  app.get("/api/gps-delivery/coverage", async (req, res) => {
    try {
      const { country } = req.query;
      const coverage = await gpsDeliveryStorage.getGeographicCoverage(country as string);
      res.json({ success: true, data: coverage });
    } catch (error) {
      console.error("Error fetching geographic coverage:", error);
      res.status(500).json({ success: false, message: "Failed to fetch geographic coverage" });
    }
  });

  // Get delivery person statistics
  app.get("/api/gps-delivery/person-stats/:phone", async (req, res) => {
    try {
      const phone = req.params.phone;
      const { period } = req.query;
      const periodDays = period ? parseInt(period as string) : 30;
      
      const stats = await gpsDeliveryStorage.getDeliveryPersonStats(phone, periodDays);
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching delivery person stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch delivery person statistics" });
    }
  });

  // Get delivery heatmap data
  app.get("/api/gps-delivery/heatmap", async (req, res) => {
    try {
      const { country, city } = req.query;
      if (!country) {
        return res.status(400).json({ success: false, message: "Country parameter is required" });
      }
      
      const heatmapData = await gpsDeliveryStorage.getDeliveryHeatmapData(country as string, city as string);
      res.json({ success: true, data: heatmapData });
    } catch (error) {
      console.error("Error fetching delivery heatmap data:", error);
      res.status(500).json({ success: false, message: "Failed to fetch heatmap data" });
    }
  });

  // Get actual GPS delivery confirmations for table display
  app.get("/api/gps-delivery/confirmations", async (req, res) => {
    try {
      const { startDate, endDate, limit = 50 } = req.query;
      console.log('ğŸšš [GPS-CONFIRMATIONS] Fetching delivery confirmations');
      
      // If no date range provided, default to last 7 days
      const defaultStartDate = new Date();
      defaultStartDate.setDate(defaultStartDate.getDate() - 7);
      const defaultEndDate = new Date();
      
      const start = startDate ? new Date(startDate as string) : defaultStartDate;
      const end = endDate ? new Date(endDate as string) : defaultEndDate;
      
      console.log(`ğŸšš [GPS-CONFIRMATIONS] Date range: ${start.toISOString()} to ${end.toISOString()}`);
      
      const confirmations = await gpsDeliveryStorage.getDeliveryConfirmations(start, end, parseInt(limit as string));
      console.log(`ğŸšš [GPS-CONFIRMATIONS] Found ${confirmations.length} delivery confirmations`);
      
      res.json({ success: true, data: confirmations });
    } catch (error) {
      console.error("Error fetching GPS delivery confirmations:", error);
      res.status(500).json({ success: false, message: "Failed to fetch delivery confirmations" });
    }
  });

  // Get delivery route analysis
  app.get("/api/gps-delivery/route-analysis/:phone/:date", async (req, res) => {
    try {
      const { phone, date } = req.params;
      const analysisDate = new Date(date);
      
      if (isNaN(analysisDate.getTime())) {
        return res.status(400).json({ success: false, message: "Invalid date format" });
      }
      
      const routeAnalysis = await gpsDeliveryStorage.getDeliveryRouteAnalysis(phone, analysisDate);
      res.json({ success: true, data: routeAnalysis });
    } catch (error) {
      console.error("Error fetching delivery route analysis:", error);
      res.status(500).json({ success: false, message: "Failed to fetch route analysis" });
    }
  });

  // Generate analytics for specific date
  app.post("/api/gps-delivery/analytics/generate", async (req, res) => {
    try {
      const { date } = req.body;
      const analyticsDate = date ? new Date(date) : new Date();
      
      await gpsDeliveryStorage.generateDailyAnalytics(analyticsDate);
      res.json({ 
        success: true, 
        message: `Analytics generated for ${analyticsDate.toISOString().split('T')[0]}` 
      });
    } catch (error) {
      console.error("Error generating GPS delivery analytics:", error);
      res.status(500).json({ success: false, message: "Failed to generate analytics" });
    }
  });

  // Get analytics by date range
  app.get("/api/gps-delivery/analytics", async (req, res) => {
    try {
      const { startDate, endDate, country, city } = req.query;
      
      if (startDate && endDate) {
        const start = new Date(startDate as string);
        const end = new Date(endDate as string);
        const analytics = await gpsDeliveryStorage.getAnalyticsByDateRange(start, end);
        res.json({ success: true, data: analytics });
      } else if (country) {
        const analytics = await gpsDeliveryStorage.getAnalyticsByLocation(country as string, city as string);
        res.json({ success: true, data: analytics });
      } else {
        return res.status(400).json({ 
          success: false, 
          message: "Either date range (startDate, endDate) or country parameter is required" 
        });
      }
    } catch (error) {
      console.error("Error fetching GPS delivery analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch analytics" });
    }
  });

  // Validate delivery location
  app.post("/api/gps-delivery/validate-location", async (req, res) => {
    try {
      const { latitude, longitude, customerAddress } = req.body;
      
      if (!latitude || !longitude) {
        return res.status(400).json({ 
          success: false, 
          message: "Latitude and longitude are required" 
        });
      }
      
      const validation = await gpsDeliveryStorage.validateDeliveryLocation(
        parseFloat(latitude), 
        parseFloat(longitude), 
        customerAddress || ''
      );
      
      res.json({ success: true, data: validation });
    } catch (error) {
      console.error("Error validating delivery location:", error);
      res.status(500).json({ success: false, message: "Failed to validate location" });
    }
  });

  // =============================================================================
  // LOGISTICS MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Transportation Companies
  app.get('/api/logistics/companies', requireAuth, async (req, res) => {
    try {
      const { isActive } = req.query;
      const companies = await logisticsStorage.getTransportationCompanies({
        isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined
      });
      res.json({ success: true, data: companies });
    } catch (error) {
      console.error('Error fetching transportation companies:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„' });
    }
  });

  app.get('/api/logistics/companies/:id', requireAuth, async (req, res) => {
    try {
      const company = await logisticsStorage.getTransportationCompanyById(parseInt(req.params.id));
      if (!company) {
        return res.status(404).json({ success: false, message: 'Ø´Ø±Ú©Øª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      res.json({ success: true, data: company });
    } catch (error) {
      console.error('Error fetching transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª' });
    }
  });

  app.post('/api/logistics/companies', requireAuth, async (req, res) => {
    try {
      const validatedData = insertTransportationCompanySchema.parse(req.body);
      const company = await logisticsStorage.createTransportationCompany(validatedData);
      res.status(201).json({ success: true, data: company });
    } catch (error) {
      console.error('Error creating transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø±Ú©Øª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„' });
    }
  });

  app.put('/api/logistics/companies/:id', requireAuth, async (req, res) => {
    try {
      const company = await logisticsStorage.updateTransportationCompany(
        parseInt(req.params.id),
        req.body
      );
      res.json({ success: true, data: company });
    } catch (error) {
      console.error('Error updating transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø±Ú©Øª' });
    }
  });

  app.delete('/api/logistics/companies/:id', requireAuth, async (req, res) => {
    try {
      await logisticsStorage.deleteTransportationCompany(parseInt(req.params.id));
      res.json({ success: true, message: 'Ø´Ø±Ú©Øª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø´Ø±Ú©Øª' });
    }
  });

  // Delivery Vehicles
  app.get('/api/logistics/vehicles', requireAuth, async (req, res) => {
    try {
      const { companyId, vehicleType, currentStatus, isActive } = req.query;
      const vehicles = await logisticsStorage.getDeliveryVehicles({
        companyId: companyId ? parseInt(companyId as string) : undefined,
        vehicleType: vehicleType as string,
        currentStatus: currentStatus as string,
        isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined
      });
      res.json({ success: true, data: vehicles });
    } catch (error) {
      console.error('Error fetching delivery vehicles:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.get('/api/logistics/vehicles/available', requireAuth, async (req, res) => {
    try {
      const { vehicleType, minWeight, minVolume } = req.query;
      const vehicles = await logisticsStorage.getAvailableVehicles({
        vehicleType: vehicleType as string,
        minWeight: minWeight ? parseFloat(minWeight as string) : undefined,
        minVolume: minVolume ? parseFloat(minVolume as string) : undefined
      });
      res.json({ success: true, data: vehicles });
    } catch (error) {
      console.error('Error fetching available vehicles:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡ Ø¢Ø²Ø§Ø¯' });
    }
  });

  app.post('/api/logistics/vehicles', requireAuth, async (req, res) => {
    try {
      const validatedData = insertDeliveryVehicleSchema.parse(req.body);
      const vehicle = await logisticsStorage.createDeliveryVehicle(validatedData);
      res.status(201).json({ success: true, data: vehicle });
    } catch (error) {
      console.error('Error creating delivery vehicle:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.put('/api/logistics/vehicles/:id', requireAuth, async (req, res) => {
    try {
      const vehicle = await logisticsStorage.updateDeliveryVehicle(
        parseInt(req.params.id),
        req.body
      );
      res.json({ success: true, data: vehicle });
    } catch (error) {
      console.error('Error updating delivery vehicle:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.patch('/api/logistics/vehicles/:id/status', requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const vehicle = await logisticsStorage.updateVehicleStatus(parseInt(req.params.id), status);
      res.json({ success: true, data: vehicle });
    } catch (error) {
      console.error('Error updating vehicle status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  // Delivery Personnel
  app.get('/api/logistics/personnel', requireAuth, async (req, res) => {
    try {
      const { companyId, currentStatus, isActive } = req.query;
      const personnel = await logisticsStorage.getDeliveryPersonnel({
        companyId: companyId ? parseInt(companyId as string) : undefined,
        currentStatus: currentStatus as string,
        isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined
      });
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error fetching delivery personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø±Ø³Ù†Ù„ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.get('/api/logistics/personnel/available', requireAuth, async (req, res) => {
    try {
      const { serviceArea, vehicleType } = req.query;
      const drivers = await logisticsStorage.getAvailableDrivers({
        serviceArea: serviceArea as string,
        vehicleType: vehicleType as string
      });
      res.json({ success: true, data: drivers });
    } catch (error) {
      console.error('Error fetching available drivers:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±Ø§Ù†Ù†Ø¯Ú¯Ø§Ù† Ø¢Ø²Ø§Ø¯' });
    }
  });

  app.post('/api/logistics/personnel', requireAuth, async (req, res) => {
    try {
      const validatedData = insertDeliveryPersonnelSchema.parse(req.body);
      const personnel = await logisticsStorage.createDeliveryPersonnel(validatedData);
      res.status(201).json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error creating delivery personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø³Ù†Ù„ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.put('/api/logistics/personnel/:id', requireAuth, async (req, res) => {
    try {
      const personnel = await logisticsStorage.updateDeliveryPersonnel(
        parseInt(req.params.id),
        req.body
      );
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error updating delivery personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±Ø³Ù†Ù„' });
    }
  });

  app.patch('/api/logistics/personnel/:id/status', requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const personnel = await logisticsStorage.updateDriverStatus(parseInt(req.params.id), status);
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error updating driver status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø±Ø§Ù†Ù†Ø¯Ù‡' });
    }
  });

  app.patch('/api/logistics/personnel/:id/location', requireAuth, async (req, res) => {
    try {
      const { latitude, longitude } = req.body;
      const personnel = await logisticsStorage.updateDriverLocation(
        parseInt(req.params.id),
        parseFloat(latitude),
        parseFloat(longitude)
      );
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error updating driver location:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø±Ø§Ù†Ù†Ø¯Ù‡' });
    }
  });

  // Delivery Routes
  app.get('/api/logistics/routes', requireAuth, async (req, res) => {
    try {
      const { driverId, vehicleId, status, startDate, endDate } = req.query;
      const routes = await logisticsStorage.getDeliveryRoutes({
        driverId: driverId ? parseInt(driverId as string) : undefined,
        vehicleId: vehicleId ? parseInt(vehicleId as string) : undefined,
        status: status as string,
        dateRange: startDate && endDate ? {
          start: new Date(startDate as string),
          end: new Date(endDate as string)
        } : undefined
      });
      res.json({ success: true, data: routes });
    } catch (error) {
      console.error('Error fetching delivery routes:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.post('/api/logistics/routes', requireAuth, async (req, res) => {
    try {
      const validatedData = insertDeliveryRouteSchema.parse(req.body);
      const route = await logisticsStorage.createDeliveryRoute(validatedData);
      res.status(201).json({ success: true, data: route });
    } catch (error) {
      console.error('Error creating delivery route:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø³ÛŒØ± ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.patch('/api/logistics/routes/:id/status', requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const route = await logisticsStorage.updateRouteStatus(parseInt(req.params.id), status);
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error updating route status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù…Ø³ÛŒØ±' });
    }
  });

  app.post('/api/logistics/routes/:id/orders', requireAuth, async (req, res) => {
    try {
      const { orderId } = req.body;
      const route = await logisticsStorage.addOrderToRoute(parseInt(req.params.id), orderId);
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error adding order to route:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ù…Ø³ÛŒØ±' });
    }
  });

  app.delete('/api/logistics/routes/:id/orders/:orderId', requireAuth, async (req, res) => {
    try {
      const route = await logisticsStorage.removeOrderFromRoute(
        parseInt(req.params.id),
        parseInt(req.params.orderId)
      );
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error removing order from route:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙØ§Ø±Ø´ Ø§Ø² Ù…Ø³ÛŒØ±' });
    }
  });

  app.post('/api/logistics/routes/:id/complete-stop', requireAuth, async (req, res) => {
    try {
      const { orderId } = req.body;
      const route = await logisticsStorage.completeRouteStop(parseInt(req.params.id), orderId);
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error completing route stop:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÚ©Ù…ÛŒÙ„ ØªÙˆÙ‚Ù Ù…Ø³ÛŒØ±' });
    }
  });

  // Delivery Verification Codes (4-digit SMS codes)
  app.get('/api/logistics/verification-codes', requireAuth, async (req, res) => {
    try {
      const { customerOrderId, isVerified, smsStatus } = req.query;
      const codes = await logisticsStorage.getDeliveryVerificationCodes({
        customerOrderId: customerOrderId ? parseInt(customerOrderId as string) : undefined,
        isVerified: isVerified === 'true' ? true : isVerified === 'false' ? false : undefined,
        smsStatus: smsStatus as string
      });
      res.json({ success: true, data: codes });
    } catch (error) {
      console.error('Error fetching verification codes:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÛŒØ¯' });
    }
  });

  app.get('/api/logistics/verification-codes/order/:orderId', requireAuth, async (req, res) => {
    try {
      const code = await logisticsStorage.getDeliveryCodeByOrderId(parseInt(req.params.orderId));
      if (!code) {
        return res.status(404).json({ success: false, message: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      res.json({ success: true, data: code });
    } catch (error) {
      console.error('Error fetching verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯ ØªØ§ÛŒÛŒØ¯' });
    }
  });

  app.post('/api/logistics/verification-codes/generate', requireAuth, async (req, res) => {
    try {
      const { customerOrderId, customerPhone, customerName } = req.body;
      
      if (!customerOrderId || !customerPhone || !customerName) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ØŒ ØªÙ„ÙÙ† Ùˆ Ù†Ø§Ù… Ù…Ø´ØªØ±ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      // Check if verification code already exists for this order
      const existingCode = await logisticsStorage.getDeliveryCodeByOrderId(customerOrderId);
      
      let codeData;
      let isNewCode = false;
      
      if (existingCode) {
        // Use existing code, just resend SMS
        codeData = existingCode;
        console.log(`Reusing existing code ${existingCode.verificationCode} for order ${customerOrderId}`);
      } else {
        // Generate new code
        codeData = await logisticsStorage.generateVerificationCode(
          customerOrderId, 
          customerPhone, 
          customerName
        );
        isNewCode = true;
        console.log(`Generated new code ${codeData.verificationCode} for order ${customerOrderId}`);
      }

      // Send SMS notification (for both new and existing codes)
      try {
        const smsResult = await smsService.sendDeliveryVerificationSms(
          customerPhone,
          codeData.verificationCode,
          customerName,
          codeData.id
        );

        if (smsResult.success) {
          await logisticsStorage.updateSmsStatus(codeData.id, 'sent', { 
            messageId: smsResult.messageId,
            provider: 'kavenegar'
          });
        }
      } catch (smsError) {
        console.error('SMS sending failed:', smsError);
        // Continue even if SMS fails
      }

      res.status(isNewCode ? 201 : 200).json({ 
        success: true, 
        data: codeData,
        isExisting: !isNewCode,
        message: isNewCode ? 'Ú©Ø¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯' : 'Ú©Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error generating verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯' });
    }
  });

  app.post('/api/logistics/verification-codes/verify', requireAuth, async (req, res) => {
    try {
      const { customerOrderId, code, verifiedBy, verificationLocation, latitude, longitude } = req.body;
      
      if (!customerOrderId || !code || !verifiedBy) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ØŒ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ùˆ Ù†Ø§Ù… ØªØ§ÛŒÛŒØ¯ Ú©Ù†Ù†Ø¯Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const isValid = await logisticsStorage.verifyDeliveryCode(customerOrderId, code, {
        verifiedBy,
        verificationLocation,
        latitude: latitude ? parseFloat(latitude) : undefined,
        longitude: longitude ? parseFloat(longitude) : undefined
      });

      if (isValid) {
        res.json({ success: true, message: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯' });
      } else {
        res.status(400).json({ success: false, message: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª' });
      }
    } catch (error) {
      console.error('Error verifying delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯' });
    }
  });

  app.post('/api/logistics/verification-codes/:id/resend', requireAuth, async (req, res) => {
    try {
      const code = await logisticsStorage.resendVerificationCode(parseInt(req.params.id));
      
      // Send new SMS
      try {
        const smsResult = await smsService.sendDeliveryVerificationSms(
          code.customerPhone,
          code.verificationCode,
          code.customerName,
          code.id
        );

        if (smsResult.success) {
          await logisticsStorage.updateSmsStatus(code.id, 'sent', { 
            messageId: smsResult.messageId 
          });
        }
      } catch (smsError) {
        console.error('SMS resend failed:', smsError);
      }

      res.json({ success: true, data: code });
    } catch (error) {
      console.error('Error resending verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯' });
    }
  });

  // Logistics Analytics
  app.get('/api/logistics/analytics', requireAuth, async (req, res) => {
    try {
      const { period, startDate, endDate } = req.query;
      const analytics = await logisticsStorage.getLogisticsAnalytics({
        period: period as string,
        dateRange: startDate && endDate ? {
          start: new Date(startDate as string),
          end: new Date(endDate as string)
        } : undefined
      });
      res.json({ success: true, data: analytics });
    } catch (error) {
      console.error('Error fetching logistics analytics:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù„Ø¬Ø³ØªÛŒÚ©' });
    }
  });

  app.get('/api/logistics/analytics/performance', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const metrics = await logisticsStorage.getPerformanceMetrics(parseInt(period as string));
      res.json({ success: true, data: metrics });
    } catch (error) {
      console.error('Error fetching performance metrics:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯' });
    }
  });

  app.get('/api/logistics/analytics/drivers/:driverId?', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const { driverId } = req.params;
      const driverStats = await logisticsStorage.getDriverPerformance(
        driverId ? parseInt(driverId) : undefined,
        parseInt(period as string)
      );
      res.json({ success: true, data: driverStats });
    } catch (error) {
      console.error('Error fetching driver performance:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±Ø§Ù†Ù†Ø¯Ù‡' });
    }
  });

  app.get('/api/logistics/analytics/vehicles/:vehicleId?', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const { vehicleId } = req.params;
      const vehicleStats = await logisticsStorage.getVehicleUtilization(
        vehicleId ? parseInt(vehicleId) : undefined,
        parseInt(period as string)
      );
      res.json({ success: true, data: vehicleStats });
    } catch (error) {
      console.error('Error fetching vehicle utilization:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ù‡Ø±Ù‡â€ŒÙˆØ±ÛŒ ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.get('/api/logistics/analytics/costs', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const costAnalysis = await logisticsStorage.getCostAnalysis(parseInt(period as string));
      res.json({ success: true, data: costAnalysis });
    } catch (error) {
      console.error('Error fetching cost analysis:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ­Ù„ÛŒÙ„ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§' });
    }
  });

  // Get warehouse-approved orders ready for logistics processing
  app.get('/api/logistics/orders/pending', requireAuth, async (req, res) => {
    try {
      const pendingOrders = await orderManagementStorage.getOrdersByStatus('warehouse_approved');
      
      // Calculate total weight for each order
      const ordersWithWeight = await Promise.all(
        pendingOrders.map(async (order) => {
          try {
            const weight = await orderManagementStorage.calculateOrderWeight(order.customerOrderId);
            return {
              ...order,
              calculatedWeight: weight,
              weightUnit: 'kg'
            };
          } catch (error) {
            console.error(`Error calculating weight for order ${order.customerOrderId}:`, error);
            return {
              ...order,
              calculatedWeight: 0,
              weightUnit: 'kg'
            };
          }
        })
      );

      res.json({ success: true, data: ordersWithWeight });
    } catch (error) {
      console.error('Error fetching pending logistics orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø¬Ø³ØªÛŒÚ©' });
    }
  });

  // Assign logistics personnel to order
  app.post('/api/logistics/orders/:orderId/assign', requireAuth, async (req, res) => {
    try {
      const { logisticsAssigneeId, deliveryMethod, transportationType, estimatedDeliveryDate, notes } = req.body;
      
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        parseInt(req.params.orderId),
        'logistics_assigned',
        {
          logisticsAssigneeId,
          logisticsNotes: notes,
          estimatedDeliveryDate: estimatedDeliveryDate ? new Date(estimatedDeliveryDate) : undefined
        }
      );

      // Update delivery information
      if (deliveryMethod || transportationType) {
        await orderManagementStorage.updateDeliveryInfo(parseInt(req.params.orderId), {
          deliveryMethod,
          transportationType
        });
      }

      res.json({ success: true, data: updatedOrder });
    } catch (error) {
      console.error('Error assigning logistics personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø®ØªØµØ§Øµ Ù¾Ø±Ø³Ù†Ù„ Ù„Ø¬Ø³ØªÛŒÚ©' });
    }
  });

  // =============================================================================
  // CARRIER DELIVERY AND VERIFICATION API ENDPOINTS
  // =============================================================================

  // Mark order as dispatched by carrier
  app.post('/api/order-management/:orderId/carrier-delivery', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { carrierName, carrierPhone, vehicleType, vehiclePlate, estimatedDeliveryTime, notes, deliveryCode } = req.body;
      
      console.log(`ğŸšš [CARRIER] Marking order ${orderId} as dispatched by carrier`);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      const { orderManagement } = await import('../shared/order-management-schema');
      
      // Update order with carrier dispatch information
      const [updatedOrder] = await db.update(orderManagement)
        .set({
          isCarrierDispatched: true,
          carrierDispatchedAt: new Date(),
          carrierName,
          carrierPhone,
          vehicleType,
          vehiclePlate,
          estimatedDeliveryDate: estimatedDeliveryTime ? new Date(estimatedDeliveryTime) : undefined,
          logisticsNotes: notes,
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderId))
        .returning();

      if (!updatedOrder) {
        return res.status(404).json({
          success: false,
          message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      res.json({
        success: true,
        message: 'Ø§Ø±Ø³Ø§Ù„ ØªÙˆØ³Ø· Ø­Ù…Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø«Ø¨Øª Ø´Ø¯',
        data: updatedOrder
      });
    } catch (error) {
      console.error('Error marking carrier delivery:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø±Ø³Ø§Ù„ ØªÙˆØ³Ø· Ø­Ù…Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡'
      });
    }
  });

  // Verify delivery with customer code
  app.post('/api/order-management/:orderId/verify-delivery', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { 
        verificationCode, 
        customerLocation, 
        isVerified, 
        verifiedAt, 
        failureReason,
        // Carrier location data for geography analytics
        carrierLatitude,
        carrierLongitude,
        carrierLocationAccuracy,
        carrierLocationCapturedAt,
        carrierLocationSource
      } = req.body;
      
      console.log(`âœ… [VERIFICATION] Processing delivery verification for order ${orderId}`);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      const { orderManagement } = await import('../shared/order-management-schema');
      
      // Get current delivery code for this order
      const [currentOrder] = await db.select()
        .from(orderManagement)
        .where(eq(orderManagement.id, orderId))
        .limit(1);

      if (!currentOrder) {
        return res.status(404).json({
          success: false,
          message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      // Check if verification code matches expected code
      const codeMatches = verificationCode === currentOrder.deliveryCode;
      
      if (!codeMatches) {
        return res.status(400).json({
          success: false,
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª'
        });
      }

      // Update order with verification status and carrier location data
      const [updatedOrder] = await db.update(orderManagement)
        .set({
          isVerified: true,
          verifiedAt: new Date(),
          verificationLocation: customerLocation,
          actualDeliveryDate: new Date(),
          currentStatus: 'delivered',
          // Save carrier location data for geography analytics
          carrierLatitude: carrierLatitude || null,
          carrierLongitude: carrierLongitude || null,
          carrierLocationAccuracy: carrierLocationAccuracy || null,
          carrierLocationCapturedAt: carrierLocationCapturedAt ? new Date(carrierLocationCapturedAt) : null,
          carrierLocationSource: carrierLocationSource || 'mobile',
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderId))
        .returning();

      // Send carrier location data to geography analytics if available
      if (carrierLatitude && carrierLongitude && updatedOrder) {
        try {
          console.log(`ğŸŒ [GEOGRAPHY] Sending carrier location data to analytics for order ${orderId}`);
          console.log(`ğŸ“ [GEOGRAPHY] Latitude: ${carrierLatitude}, Longitude: ${carrierLongitude}, Accuracy: ${carrierLocationAccuracy}m`);
          
          // Here you would typically send to geography analytics service
          // For now, we'll just log the data that would be sent
          const geographyData = {
            orderId: orderId,
            customerOrderId: updatedOrder.customerOrderId,
            carrierLocation: {
              latitude: carrierLatitude,
              longitude: carrierLongitude,
              accuracy: carrierLocationAccuracy,
              capturedAt: carrierLocationCapturedAt,
              source: carrierLocationSource
            },
            deliveryInfo: {
              deliveredAt: updatedOrder.actualDeliveryDate,
              customerLocation: customerLocation,
              verificationCode: verificationCode
            },
            customerInfo: {
              name: `${updatedOrder.customerFirstName || ''} ${updatedOrder.customerLastName || ''}`.trim(),
              email: updatedOrder.customerEmail,
              phone: updatedOrder.customerPhone
            }
          };
          
          console.log(`ğŸ“Š [GEOGRAPHY] Data prepared for analytics:`, JSON.stringify(geographyData, null, 2));
          
          // In a real implementation, you would:
          // 1. Send to a geography analytics database
          // 2. Trigger analytics processing
          // 3. Update delivery route optimization
          // 4. Update carrier performance metrics
          
        } catch (geoError) {
          console.error('Error sending location data to geography analytics:', geoError);
          // Don't fail the main delivery verification if geography analytics fails
        }
      }

      res.json({
        success: true,
        message: 'ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯',
        data: updatedOrder
      });
    } catch (error) {
      console.error('Error verifying delivery:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ ØªØ­ÙˆÛŒÙ„'
      });
    }
  });

  // =============================================================================
  // ORPHAN ORDERS MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Get grace period orders statistics
  app.get("/api/orphan-orders/stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get grace period orders counts
      const statsResult = await pool.query(`
        SELECT 
          COUNT(CASE WHEN current_status = 'payment_grace_period' AND payment_grace_period_end > NOW() THEN 1 END) as active_grace_period,
          COUNT(CASE WHEN current_status = 'payment_grace_period' AND payment_grace_period_end <= NOW() THEN 1 END) as expired_grace_period,
          COUNT(CASE WHEN current_status = 'financial_approved' AND payment_grace_period_start IS NOT NULL THEN 1 END) as paid_grace_period,
          COUNT(CASE WHEN created_at::date = CURRENT_DATE THEN 1 END) as notifications_today
        FROM order_management
        WHERE payment_grace_period_start IS NOT NULL
      `);

      const stats = statsResult.rows[0];
      
      res.json({
        success: true,
        stats: {
          active: parseInt(stats.active_grace_period) || 0,
          expired: parseInt(stats.expired_grace_period) || 0,
          paid: parseInt(stats.paid_grace_period) || 0,
          notificationsToday: parseInt(stats.notifications_today) || 0
        }
      });
      
    } catch (error) {
      console.error("Error fetching orphan orders stats:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø³ÙØ§Ø±Ø´Ø§Øª Ù…ÙˆÙ‚Øª" 
      });
    }
  });

  // Orphan Orders Notification Management APIs
  app.get("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query('SELECT * FROM orphan_order_notification_settings ORDER BY id DESC LIMIT 1');
      
      if (result.rows.length === 0) {
        // Return default settings if none exist
        return res.json({
          success: true,
          settings: {
            notification_type: 'both',
            trigger_hours_before_expiry: [72, 48, 24, 12, 6],
            is_enabled: true,
            max_notifications_per_order: 5,
            notification_interval_hours: 12,
            send_to_admin: true,
            admin_notification_types: ['email']
          }
        });
      }
      
      res.json({
        success: true,
        settings: result.rows[0]
      });
    } catch (error) {
      console.error('Error fetching notification settings:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ' });
    }
  });

  app.put("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const {
        notification_type,
        trigger_hours_before_expiry,
        is_enabled,
        max_notifications_per_order,
        notification_interval_hours,
        send_to_admin,
        admin_notification_types
      } = req.body;

      const result = await pool.query(`
        UPDATE orphan_order_notification_settings 
        SET 
          notification_type = $1,
          trigger_hours_before_expiry = $2,
          is_enabled = $3,
          max_notifications_per_order = $4,
          notification_interval_hours = $5,
          send_to_admin = $6,
          admin_notification_types = $7,
          updated_at = NOW()
        WHERE id = (SELECT id FROM orphan_order_notification_settings ORDER BY id DESC LIMIT 1)
        RETURNING *
      `, [
        notification_type,
        trigger_hours_before_expiry,
        is_enabled,
        max_notifications_per_order,
        notification_interval_hours,
        send_to_admin,
        admin_notification_types
      ]);

      if (result.rows.length === 0) {
        // Create new settings if none exist
        const insertResult = await pool.query(`
          INSERT INTO orphan_order_notification_settings (
            notification_type, trigger_hours_before_expiry, is_enabled, 
            max_notifications_per_order, notification_interval_hours,
            send_to_admin, admin_notification_types
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING *
        `, [
          notification_type,
          trigger_hours_before_expiry,
          is_enabled,
          max_notifications_per_order,
          notification_interval_hours,
          send_to_admin,
          admin_notification_types
        ]);
        
        return res.json({
          success: true,
          settings: insertResult.rows[0]
        });
      }

      res.json({
        success: true,
        settings: result.rows[0]
      });
    } catch (error) {
      console.error('Error updating notification settings:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ' });
    }
  });

  app.get("/api/orphan-orders/templates", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query('SELECT * FROM orphan_order_templates ORDER BY is_default DESC, created_at DESC');
      
      res.json({
        success: true,
        templates: result.rows
      });
    } catch (error) {
      console.error('Error fetching templates:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.post("/api/orphan-orders/templates", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const {
        template_name,
        template_type,
        subject,
        content,
        variables,
        is_active = true,
        is_default = false
      } = req.body;

      // If setting as default, remove default from others of same type
      if (is_default) {
        await pool.query(`
          UPDATE orphan_order_templates 
          SET is_default = false 
          WHERE template_type = $1
        `, [template_type]);
      }

      const result = await pool.query(`
        INSERT INTO orphan_order_templates (
          template_name, template_type, subject, content, variables, is_active, is_default
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *
      `, [template_name, template_type, subject, content, variables, is_active, is_default]);

      res.json({
        success: true,
        template: result.rows[0]
      });
    } catch (error) {
      console.error('Error creating template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.put("/api/orphan-orders/templates/:id", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const { id } = req.params;
      const {
        template_name,
        template_type,
        subject,
        content,
        variables,
        is_active,
        is_default
      } = req.body;

      // If setting as default, remove default from others of same type
      if (is_default) {
        await pool.query(`
          UPDATE orphan_order_templates 
          SET is_default = false 
          WHERE template_type = $1 AND id != $2
        `, [template_type, id]);
      }

      const result = await pool.query(`
        UPDATE orphan_order_templates 
        SET 
          template_name = $1,
          template_type = $2,
          subject = $3,
          content = $4,
          variables = $5,
          is_active = $6,
          is_default = $7,
          updated_at = NOW()
        WHERE id = $8
        RETURNING *
      `, [template_name, template_type, subject, content, variables, is_active, is_default, id]);

      res.json({
        success: true,
        template: result.rows[0]
      });
    } catch (error) {
      console.error('Error updating template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.delete("/api/orphan-orders/templates/:id", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const { id } = req.params;

      await pool.query('DELETE FROM orphan_order_templates WHERE id = $1', [id]);

      res.json({
        success: true,
        message: 'Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error deleting template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.get("/api/orphan-orders/schedules", async (req, res) => {
    try {
      // Return scheduled notification data
      res.json({
        success: true,
        schedules: [
          {
            id: 1,
            name: 'ÛŒØ§Ø¯Ø¢ÙˆØ± Ø±ÙˆØ²Ø§Ù†Ù‡',
            frequency: 'daily',
            time: '10:00',
            enabled: true,
            last_run: new Date().toISOString()
          },
          {
            id: 2,
            name: 'ÛŒØ§Ø¯Ø¢ÙˆØ± Ù‡Ø´Ø¯Ø§Ø± Ù†Ù‡Ø§ÛŒÛŒ',
            frequency: 'hourly',
            time: null,
            enabled: true,
            last_run: new Date().toISOString()
          }
        ]
      });
    } catch (error) {
      console.error('Error fetching schedules:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒâ€ŒÙ‡Ø§' });
    }
  });

  app.get("/api/orphan-orders/stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get active grace period orders count
      const activeResult = await pool.query(`
        SELECT COUNT(*) as active_count 
        FROM order_management 
        WHERE current_status = 'payment_grace_period' 
        AND payment_grace_period_end > NOW()
      `);
      
      // Get expired orders count (last 7 days)
      const expiredResult = await pool.query(`
        SELECT COUNT(*) as expired_count 
        FROM order_management 
        WHERE current_status = 'payment_grace_period' 
        AND payment_grace_period_end <= NOW()
        AND payment_grace_period_end >= NOW() - INTERVAL '7 days'
      `);
      
      // Get orders that transitioned from grace period to paid (last 30 days)
      const paidResult = await pool.query(`
        SELECT COUNT(*) as paid_count 
        FROM order_management 
        WHERE current_status NOT IN ('payment_grace_period') 
        AND payment_grace_period_start IS NOT NULL
        AND updated_at >= NOW() - INTERVAL '30 days'
      `);

      res.json({
        success: true,
        stats: {
          active: parseInt(activeResult.rows[0].active_count || 0),
          expired: parseInt(expiredResult.rows[0].expired_count || 0),
          paid: parseInt(paidResult.rows[0].paid_count || 0),
          notificationsToday: 0 // This would be tracked in a separate notifications log table
        }
      });
    } catch (error) {
      console.error('Error fetching orphan orders stats:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø³ÙØ§Ø±Ø´Ø§Øª Ù…ÙˆÙ‚Øª',
        stats: { active: 0, expired: 0, paid: 0, notificationsToday: 0 }
      });
    }
  });

  // Get active grace period orders
  app.get("/api/orphan-orders/active", async (req, res) => {
    try {
      const { db } = await import('./db');
      const { eq, and, gt } = await import('drizzle-orm');
      const { orderManagement } = await import('../shared/order-management-schema');
      const { customerOrders } = await import('../shared/customer-schema');
      const { crmCustomers } = await import('../shared/schema');
      const { paymentReceipts } = await import('../shared/customer-schema');
      
      const result = await db.select({
        // Order Management fields
        id: orderManagement.id,
        customerOrderId: orderManagement.customerOrderId,
        currentStatus: orderManagement.currentStatus,
        createdAt: orderManagement.createdAt,
        gracePeriodExpires: orderManagement.paymentGracePeriodEnd,
        
        // Customer Order fields
        totalAmount: customerOrders.totalAmount,
        currency: customerOrders.currency,
        
        // Customer info from CRM
        customerFirstName: crmCustomers.firstName,
        customerLastName: crmCustomers.lastName,
        customerEmail: crmCustomers.email,
        customerPhone: crmCustomers.phone,
      })
      .from(orderManagement)
      .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
      .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
      .where(
        and(
          eq(orderManagement.currentStatus, 'payment_grace_period'),
          gt(orderManagement.paymentGracePeriodEnd, new Date())
        )
      )
      .orderBy(orderManagement.paymentGracePeriodEnd);

      const orders = result.map((row: any) => {
        const hoursRemaining = row.gracePeriodExpires ? 
          Math.max(0, Math.floor((new Date(row.gracePeriodExpires).getTime() - new Date().getTime()) / (1000 * 60 * 60))) : 0;
        
        return {
          id: row.id,
          orderNumber: row.customerOrderId,
          totalAmount: row.totalAmount,
          currency: row.currency,
          createdAt: row.createdAt,
          gracePeriodExpires: row.gracePeriodExpires,
          hoursRemaining,
          customerName: `${row.customerFirstName || ''} ${row.customerLastName || ''}`.trim(),
          customerPhone: row.customerPhone || '',
          customerEmail: row.customerEmail || '',
          customer: {
            firstName: row.customerFirstName || '',
            lastName: row.customerLastName || '',
            email: row.customerEmail || '',
            phone: row.customerPhone || ''
          }
        };
      });

      res.json({
        success: true,
        orders
      });
      
    } catch (error) {
      console.error("Error fetching active grace period orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ÙØ¹Ø§Ù„" 
      });
    }
  });

  // Send reminder notification for grace period order
  app.post("/api/orphan-orders/:orderId/send-reminder", async (req, res) => {
    try {
      const { orderId } = req.params;
      const { type } = req.body; // 'sms' or 'email'
      
      const { pool } = await import('./db');
      
      // Get order details
      const orderResult = await pool.query(`
        SELECT 
          om.*,
          co.total_amount,
          co.currency,
          co.recipient_name,
          co.guest_email,
          co.recipient_phone,
          EXTRACT(EPOCH FROM (om.payment_grace_period_end - NOW()))/3600 as hours_remaining
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE om.id = $1 AND om.current_status = 'payment_grace_period'
      `, [orderId]);

      if (orderResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const order = orderResult.rows[0];
      
      // Send reminder based on type
      if (type === 'sms') {
        // Send SMS reminder
        // Implementation would go here
      } else if (type === 'email') {
        // Send email reminder
        // Implementation would go here
      }

      res.json({
        success: true,
        message: `ÛŒØ§Ø¯Ø¢ÙˆØ± ${type} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`
      });
      
    } catch (error) {
      console.error("Error sending reminder:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÛŒØ§Ø¯Ø¢ÙˆØ±"
      });
    }
  });

  // Get notification settings
  app.get("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      // Mock notification settings
      const settings = {
        emailEnabled: true,
        smsEnabled: true,
        reminderHours: [24, 12, 1],
        maxReminders: 3
      };

      res.json({
        success: true,
        settings
      });
    } catch (error) {
      console.error("Error fetching notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª"
      });
    }
  });

  // Update notification settings
  app.put("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      const { emailEnabled, smsEnabled, reminderHours, maxReminders } = req.body;
      
      // In a real implementation, save to database
      
      res.json({
        success: true,
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        settings: {
          emailEnabled,
          smsEnabled,
          reminderHours,
          maxReminders
        }
      });
    } catch (error) {
      console.error("Error updating notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª"
      });
    }
  });

  // Get message templates
  app.get("/api/orphan-orders/templates", async (req, res) => {
    try {
      // Mock templates
      const templates = [
        {
          id: 1,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± 24 Ø³Ø§Ø¹ØªÙ‡",
          type: "email",
          subject: "ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´",
          content: "Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ ØªØ§ 24 Ø³Ø§Ø¹Øª Ø¯ÛŒÚ¯Ø± Ù…Ù†Ù‚Ø¶ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯",
          isActive: true
        },
        {
          id: 2,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± SMS",
          type: "sms",
          subject: "",
          content: "Ø³ÙØ§Ø±Ø´ {{orderNumber}} ØªØ§ {{hours}} Ø³Ø§Ø¹Øª Ø¯ÛŒÚ¯Ø± Ù…Ù†Ù‚Ø¶ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯",
          isActive: true
        }
      ];

      res.json({
        success: true,
        templates
      });
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§"
      });
    }
  });

  // Get notification schedules
  app.get("/api/orphan-orders/schedules", async (req, res) => {
    try {
      // Mock schedules
      const schedules = [
        {
          id: 1,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± 24 Ø³Ø§Ø¹ØªÙ‡",
          triggerTime: "24 hours before expiry",
          messageType: "Email + SMS",
          maxSends: 1,
          isActive: true
        },
        {
          id: 2,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± 1 Ø³Ø§Ø¹ØªÙ‡",
          triggerTime: "1 hour before expiry",
          messageType: "SMS only",
          maxSends: 1,
          isActive: true
        }
      ];

      res.json({
        success: true,
        schedules
      });
    } catch (error) {
      console.error("Error fetching schedules:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ" 
      });
    }
  });

  // =============================================================================
  // SIMPLE SMS TEMPLATES API ENDPOINTS
  // =============================================================================

  // Get all simple SMS templates (no auth for testing)
  app.get("/api/admin/simple-sms-templates", async (req, res) => {
    try {
      console.log("ğŸš€ Fetching simple SMS templates...");
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      const templates = await simpleSmsStorage.getAllTemplates();
      console.log("ğŸ“‹ Templates fetched:", templates?.length || 0);
      
      res.json({
        success: true,
        data: templates
      });
    } catch (error) {
      console.error("âŒ Error fetching simple SMS templates:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch SMS templates"
      });
    }
  });

  // Get simple SMS template by ID
  app.get("/api/admin/simple-sms-templates/:id", async (req, res) => {
    try {
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      const template = await simpleSmsStorage.getTemplateById(parseInt(req.params.id));
      
      if (!template) {
        return res.status(404).json({
          success: false,
          message: "Template not found"
        });
      }
      
      res.json({
        success: true,
        data: template
      });
    } catch (error) {
      console.error("Error fetching simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch SMS template"
      });
    }
  });

  // Create new simple SMS template
  app.post("/api/admin/simple-sms-templates", async (req, res) => {
    try {
      const { insertSimpleSmsTemplateSchema } = await import('../shared/schema');
      const templateData = insertSimpleSmsTemplateSchema.parse(req.body);
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      
      const template = await simpleSmsStorage.createTemplate(templateData);
      
      res.status(201).json({
        success: true,
        data: template,
        message: "SMS template created successfully"
      });
    } catch (error) {
      console.error("Error creating simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create SMS template"
      });
    }
  });

  // Update simple SMS template
  app.put("/api/admin/simple-sms-templates/:id", async (req, res) => {
    try {
      const { insertSimpleSmsTemplateSchema } = await import('../shared/schema');
      const updates = insertSimpleSmsTemplateSchema.partial().parse(req.body);
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      
      const template = await simpleSmsStorage.updateTemplate(parseInt(req.params.id), updates);
      
      res.json({
        success: true,
        data: template,
        message: "SMS template updated successfully"
      });
    } catch (error) {
      console.error("Error updating simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update SMS template"
      });
    }
  });

  // Delete simple SMS template
  app.delete("/api/admin/simple-sms-templates/:id", async (req, res) => {
    try {
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      await simpleSmsStorage.deleteTemplate(parseInt(req.params.id));
      
      res.json({
        success: true,
        message: "SMS template deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete SMS template"
      });
    }
  });

  // Increment template usage count
  app.post("/api/admin/simple-sms-templates/:id/increment-usage", async (req, res) => {
    try {
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      await simpleSmsStorage.incrementTemplateUsage(parseInt(req.params.id));
      
      res.json({
        success: true,
        message: "Template usage incremented"
      });
    } catch (error) {
      console.error("Error incrementing template usage:", error);
      res.status(500).json({
        success: false,
        message: "Failed to increment template usage"
      });
    }
  });

  // Get Template #05 directly via emailStorage
  app.get("/api/template05-direct", async (req, res) => {
    try {
      console.log('ğŸ” Fetching Template #05 directly via emailStorage');
      
      const { emailStorage } = await import("./email-storage");
      const templates = await emailStorage.getAllTemplates();
      
      const template05 = templates.find(t => 
        t.name === '#05 - Momtaz Chemical Follow-up Response' ||
        t.templateName === '#05 - Momtaz Chemical Follow-up Response'
      );
      
      if (!template05) {
        return res.status(404).json({
          success: false,
          message: "Template #05 not found",
          availableTemplates: templates.map(t => t.name || t.templateName)
        });
      }
      
      console.log('âœ… Template #05 found:', {
        id: template05.id,
        name: template05.name || template05.templateName,
        contentLength: (template05.htmlContent || template05.html_content || '').length
      });
      
      res.json({
        success: true,
        data: {
          id: template05.id,
          name: template05.name || template05.templateName,
          subject: template05.subject,
          html_content: template05.htmlContent || template05.html_content,
          category: template05.category || template05.categoryName,
          language: template05.language || 'fa',
          created_at: template05.createdAt || template05.created_at
        }
      });
    } catch (error) {
      console.error("âŒ Error fetching Template #05:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Template #05",
        error: error.message
      });
    }
  });

  // =============================================================================
  // OPTIMAL VEHICLE SELECTION API ENDPOINTS  
  // =============================================================================

  // Test endpoint to check if routes are working
  app.get("/api/logistics/test", (req, res) => {
    res.json({ success: true, message: "Vehicle optimization routes are working!" });
  });

  // Get all vehicle templates
  app.get("/api/logistics/vehicle-templates", async (req, res) => {
    try {
      const vehicles = await db.select().from(vehicleTemplates).orderBy(vehicleTemplates.priority, vehicleTemplates.name);
      res.json({ success: true, data: vehicles });
    } catch (error) {
      console.error("Error fetching vehicle templates:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø®ÙˆØ¯Ø±Ùˆ" });
    }
  });

  // Create vehicle template
  app.post("/api/logistics/vehicle-templates", requireAuth, async (req, res) => {
    try {
      const vehicleData = insertVehicleTemplateSchema.parse(req.body);
      const [newVehicle] = await db.insert(vehicleTemplates).values(vehicleData).returning();
      res.json({ success: true, data: newVehicle });
    } catch (error) {
      console.error("Error creating vehicle template:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ success: false, message: "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±", errors: error.errors });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ" });
      }
    }
  });

  // Update vehicle template (PATCH method)
  app.patch("/api/logistics/vehicle-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Ø´Ù†Ø§Ø³Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±" });
      }

      const vehicleData = req.body;
      vehicleData.updatedAt = new Date();
      
      const [updatedVehicle] = await db.update(vehicleTemplates)
        .set(vehicleData)
        .where(eq(vehicleTemplates.id, id))
        .returning();

      if (!updatedVehicle) {
        return res.status(404).json({ success: false, message: "Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({ success: true, data: updatedVehicle });
    } catch (error) {
      console.error("Error updating vehicle template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ" });
    }
  });

  // Update vehicle template (PUT method - for compatibility)
  app.put("/api/logistics/vehicle-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Ø´Ù†Ø§Ø³Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±" });
      }

      const vehicleData = req.body;
      vehicleData.updatedAt = new Date();
      
      const [updatedVehicle] = await db.update(vehicleTemplates)
        .set(vehicleData)
        .where(eq(vehicleTemplates.id, id))
        .returning();

      if (!updatedVehicle) {
        return res.status(404).json({ success: false, message: "Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({ success: true, data: updatedVehicle });
    } catch (error) {
      console.error("Error updating vehicle template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ" });
    }
  });

  // Delete vehicle template
  app.delete("/api/logistics/vehicle-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Ø´Ù†Ø§Ø³Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±" });
      }

      const [deletedVehicle] = await db.delete(vehicleTemplates)
        .where(eq(vehicleTemplates.id, id))
        .returning();

      if (!deletedVehicle) {
        return res.status(404).json({ success: false, message: "Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({ success: true, message: "Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting vehicle template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±Ùˆ" });
    }
  });

  // Optimal vehicle selection endpoint
  app.post("/api/logistics/optimal-vehicle-selection", requireAuth, async (req, res) => {
    try {
      const { orderWeight, orderVolume, distance, specialRequirements, deliveryUrgency } = req.body;

      // Validate required fields
      if (!orderWeight || !orderVolume || !distance) {
        return res.status(400).json({ 
          success: false, 
          message: "ÙˆØ²Ù†ØŒ Ø­Ø¬Ù… Ùˆ Ù…Ø³Ø§ÙØª Ø³ÙØ§Ø±Ø´ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Get all active vehicle templates
      const vehicles = await db.select().from(vehicleTemplates)
        .where(eq(vehicleTemplates.isActive, true))
        .orderBy(vehicleTemplates.priority);

      if (vehicles.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±ÙˆÛŒ ÙØ¹Ø§Ù„ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Calculate optimal vehicle selection based on algorithm
      const suitableVehicles = vehicles.filter(vehicle => {
        const weightOk = orderWeight <= vehicle.maxWeight;
        const volumeOk = orderVolume <= vehicle.maxVolume;
        const distanceOk = distance <= vehicle.maxDistance;
        
        return weightOk && volumeOk && distanceOk;
      });

      if (suitableVehicles.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒ Ù…Ù†Ø§Ø³Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Score vehicles based on multiple criteria
      const scoredVehicles = suitableVehicles.map(vehicle => {
        let score = 0;
        
        // Weight utilization (prefer vehicles that use capacity efficiently)
        const weightUtilization = orderWeight / vehicle.maxWeight;
        score += weightUtilization * 30;
        
        // Volume utilization
        const volumeUtilization = orderVolume / vehicle.maxVolume;
        score += volumeUtilization * 30;
        
        // Fuel efficiency consideration
        score += (100 - vehicle.fuelConsumption) * 0.2;
        
        // Priority bonus
        score += vehicle.priority * 5;
        
        // Delivery urgency factor
        if (deliveryUrgency === 'urgent' && vehicle.maxSpeed > 80) {
          score += 15;
        }
        
        // Special requirements
        if (specialRequirements && vehicle.specialFeatures?.includes(specialRequirements)) {
          score += 20;
        }

        return {
          ...vehicle,
          score: Math.round(score * 100) / 100,
          weightUtilization: Math.round(weightUtilization * 100),
          volumeUtilization: Math.round(volumeUtilization * 100)
        };
      });

      // Sort by score (highest first)
      scoredVehicles.sort((a, b) => b.score - a.score);

      const optimalVehicle = scoredVehicles[0];
      const alternatives = scoredVehicles.slice(1, 4); // Top 3 alternatives

      // Save selection to history
      const selectionData = {
        orderWeight,
        orderVolume,
        distance,
        specialRequirements: specialRequirements || null,
        deliveryUrgency: deliveryUrgency || 'normal',
        selectedVehicleId: optimalVehicle.id,
        selectedVehicleName: optimalVehicle.name,
        selectionScore: optimalVehicle.score,
        alternativeVehicles: alternatives.map(v => ({ id: v.id, name: v.name, score: v.score })),
        createdAt: new Date()
      };

      await db.insert(vehicleSelectionHistory).values(selectionData);

      res.json({
        success: true,
        data: {
          optimal: optimalVehicle,
          alternatives,
          selectionCriteria: {
            orderWeight,
            orderVolume,
            distance,
            specialRequirements,
            deliveryUrgency
          }
        }
      });

    } catch (error) {
      console.error("Error in optimal vehicle selection:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªØ®Ø§Ø¨ ÙˆØ³ÛŒÙ„Ù‡ Ø¨Ù‡ÛŒÙ†Ù‡" });
    }
  });

  // Smart vehicle selection for checkout (enhanced algorithm)
  app.post("/api/logistics/select-optimal-vehicle", async (req, res) => {
    try {
      const { 
        orderWeightKg, 
        destinationCity, 
        routeType = 'urban',
        isHazardous = false,
        isRefrigerated = false,
        isFragile = false,
        distanceKm = 0
      } = req.body;

      console.log('ğŸšš [SMART VEHICLE] Selection request:', {
        orderWeightKg,
        destinationCity,
        routeType,
        isHazardous,
        isRefrigerated,
        isFragile,
        distanceKm
      });

      // Validate required fields
      if (!orderWeightKg || !destinationCity) {
        return res.status(400).json({ 
          success: false, 
          message: "ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´ Ùˆ Ø´Ù‡Ø± Ù…Ù‚ØµØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Get destination city info for distance calculation
      let distance = distanceKm;
      if (!distance && destinationCity) {
        const destCity = await db.select()
          .from(iraqiCities)
          .where(
            or(
              eq(iraqiCities.nameEnglish, destinationCity),
              eq(iraqiCities.nameArabic, destinationCity),
              eq(iraqiCities.name, destinationCity)
            )
          )
          .limit(1);
        
        if (destCity.length > 0) {
          distance = parseFloat(destCity[0].distanceFromErbilKm || '0');
        }
      }

      // Get all active vehicle templates
      const vehicles = await db.select().from(vehicleTemplates)
        .where(eq(vehicleTemplates.isActive, true))
        .orderBy(vehicleTemplates.priority);

      if (vehicles.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ø§Ù„Ú¯ÙˆÛŒ Ø®ÙˆØ¯Ø±ÙˆÛŒ ÙØ¹Ø§Ù„ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      console.log('ğŸšš [SMART VEHICLE] Found vehicles:', vehicles.length);

      // Filter suitable vehicles based on capacity and capabilities
      const suitableVehicles = vehicles.filter(vehicle => {
        const weightOk = parseFloat(vehicle.maxWeightKg) >= orderWeightKg;
        const volumeOk = parseFloat(vehicle.maxVolumeM3 || '999999') >= (orderWeightKg / 100); // Rough estimate
        
        // Check special requirements
        let specialOk = true;
        if (isHazardous && !vehicle.canTransportHazardous) specialOk = false;
        if (isRefrigerated && !vehicle.hasRefrigeration) specialOk = false;
        if (isFragile && !vehicle.canTransportFragile) specialOk = false;
        
        // Check route type compatibility
        let routeOk = true;
        if (vehicle.allowedRoutes) {
          const allowedRoutes = Array.isArray(vehicle.allowedRoutes) 
            ? vehicle.allowedRoutes 
            : vehicle.allowedRoutes.split(',');
          routeOk = allowedRoutes.includes(routeType);
        }
        
        return weightOk && volumeOk && specialOk && routeOk;
      });

      if (suitableVehicles.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ø®ÙˆØ¯Ø±ÙˆÛŒ Ù…Ù†Ø§Ø³Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      console.log('ğŸšš [SMART VEHICLE] Suitable vehicles:', suitableVehicles.length);

      // Calculate cost and score for each suitable vehicle
      const scoredVehicles = suitableVehicles.map(vehicle => {
        // Calculate total cost
        const basePrice = parseFloat(vehicle.basePrice || '0');
        const distanceCost = distance * parseFloat(vehicle.pricePerKm || '0');
        const weightCost = orderWeightKg * parseFloat(vehicle.pricePerKg || '0');
        const totalCost = basePrice + distanceCost + weightCost;
        
        // Calculate efficiency score (higher is better)
        let score = 0;
        
        // Weight utilization efficiency (prefer vehicles that use capacity well)
        const weightUtilization = orderWeightKg / parseFloat(vehicle.maxWeightKg);
        score += weightUtilization * 40; // 40% weight for capacity utilization
        
        // Cost efficiency (lower cost per unit is better)
        const costPerKg = totalCost / orderWeightKg;
        score += (1000 / costPerKg) * 30; // 30% weight for cost efficiency
        
        // Fuel efficiency bonus
        const fuelEfficiency = parseFloat(vehicle.fuelConsumptionL100km || '20');
        score += (30 - fuelEfficiency) * 1; // Bonus for better fuel economy
        
        // Priority bonus from template
        score += parseFloat(vehicle.priority || '0') * 5;
        
        // Speed bonus for urgent deliveries
        const maxSpeed = parseFloat(vehicle.maxSpeedKmh || '80');
        if (routeType === 'highway') {
          score += maxSpeed * 0.1;
        }
        
        // Special capability bonus
        if (isHazardous && vehicle.canTransportHazardous) score += 10;
        if (isRefrigerated && vehicle.hasRefrigeration) score += 10;
        if (isFragile && vehicle.canTransportFragile) score += 5;

        return {
          ...vehicle,
          totalCost: Math.round(totalCost * 100) / 100,
          basePrice,
          distanceCost: Math.round(distanceCost * 100) / 100,
          weightCost: Math.round(weightCost * 100) / 100,
          score: Math.round(score * 100) / 100,
          weightUtilization: Math.round(weightUtilization * 100),
          costPerKg: Math.round(costPerKg * 100) / 100
        };
      });

      // Sort by score (highest first)
      scoredVehicles.sort((a, b) => b.score - a.score);

      const selectedVehicle = scoredVehicles[0];
      const alternatives = scoredVehicles.slice(1, 4); // Top 3 alternatives

      console.log('ğŸšš [SMART VEHICLE] Selected vehicle:', {
        name: selectedVehicle.name,
        totalCost: selectedVehicle.totalCost,
        score: selectedVehicle.score,
        weightUtilization: selectedVehicle.weightUtilization
      });

      // Save selection to history (optional - only if user is authenticated)
      try {
        const orderNumber = `QUOTE-${Date.now()}`; // Generate a quote number for non-order selections
        
        const selectionData = {
          orderNumber,
          customerId: null, // Will be null for guest selections
          orderWeightKg: orderWeightKg.toString(),
          routeType,
          distanceKm: distance.toString(),
          isHazardous,
          isRefrigerated,
          isFragile,
          selectedVehicleTemplateId: selectedVehicle.id,
          selectedVehicleName: selectedVehicle.name,
          basePrice: selectedVehicle.basePrice.toString(),
          weightCost: selectedVehicle.weightCost.toString(),
          distanceCost: selectedVehicle.distanceCost.toString(),
          totalCost: selectedVehicle.totalCost.toString(),
          alternativeOptions: alternatives.map(v => ({ 
            id: v.id, 
            name: v.name, 
            score: v.score, 
            totalCost: v.totalCost 
          })),
          selectionAlgorithm: 'smart_optimization',
          selectionCriteria: `Weight: ${orderWeightKg}kg, Distance: ${distance}km, Route: ${routeType}`
        };

        console.log('ğŸšš [SMART VEHICLE] Attempting to save selection data:', JSON.stringify(selectionData, null, 2));
        await db.insert(vehicleSelectionHistory).values(selectionData);
        console.log('ğŸšš [SMART VEHICLE] Selection saved to history:', orderNumber);
      } catch (historyError) {
        console.log('ğŸšš [SMART VEHICLE] History save failed (non-critical):', historyError.message);
        console.log('ğŸšš [SMART VEHICLE] Full error:', historyError);
      }

      res.json({
        success: true,
        selectedVehicle: {
          id: selectedVehicle.id,
          vehicleName: selectedVehicle.name,
          vehicleType: selectedVehicle.type,
          totalCost: selectedVehicle.totalCost,
          basePrice: selectedVehicle.basePrice,
          distanceCost: selectedVehicle.distanceCost,
          weightCost: selectedVehicle.weightCost,
          score: selectedVehicle.score,
          weightUtilization: selectedVehicle.weightUtilization,
          maxWeightKg: selectedVehicle.maxWeightKg,
          maxVolumeM3: selectedVehicle.maxVolumeM3,
          fuelConsumptionL100km: selectedVehicle.fuelConsumptionL100km,
          maxSpeedKmh: selectedVehicle.maxSpeedKmh
        },
        alternatives: alternatives.map(v => ({
          id: v.id,
          vehicleName: v.name,
          vehicleType: v.type,
          totalCost: v.totalCost,
          score: v.score,
          weightUtilization: v.weightUtilization
        })),
        selectionCriteria: {
          orderWeightKg,
          destinationCity,
          distanceKm: distance,
          routeType,
          isHazardous,
          isRefrigerated,
          isFragile
        }
      });

    } catch (error) {
      console.error("ğŸšš [SMART VEHICLE] Selection error:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªØ®Ø§Ø¨ ÙˆØ³ÛŒÙ„Ù‡ Ø¨Ù‡ÛŒÙ†Ù‡" });
    }
  });

  // Get vehicle selection history
  app.get("/api/logistics/vehicle-selection-history", requireAuth, async (req, res) => {
    try {
      const { orderNumber, customerId, limit = 50 } = req.query;
      
      let query = db.select().from(vehicleSelectionHistory);
      
      if (orderNumber) {
        query = query.where(eq(vehicleSelectionHistory.orderNumber, orderNumber as string));
      } else if (customerId) {
        query = query.where(eq(vehicleSelectionHistory.customerId, parseInt(customerId as string)));
      }
      
      const history = await query.orderBy(desc(vehicleSelectionHistory.createdAt)).limit(parseInt(limit as string));
      
      res.json({ success: true, data: history });
    } catch (error) {
      console.error("Error fetching vehicle selection history:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡" });
    }
  });

  // Documentation download endpoints
  app.get('/api/download/:filename', (req, res) => {
    try {
      const filename = req.params.filename;
      const allowedFiles = [
        'PROJECT_PROPOSAL_GUIDE',
        'TECHNICAL_ARCHITECTURE_GUIDE', 
        'BUSINESS_PROPOSAL_EXECUTIVE'
      ];
      
      if (!allowedFiles.includes(filename)) {
        return res.status(404).json({ success: false, message: 'File not found' });
      }
      
      const filePath = path.join(process.cwd(), `${filename}.md`);
      
      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ success: false, message: 'File not found' });
      }
      
      // Set headers for download
      res.setHeader('Content-Disposition', `attachment; filename="${filename}.md"`);
      res.setHeader('Content-Type', 'text/markdown');
      
      // Send file
      res.sendFile(filePath);
      
    } catch (error) {
      console.error('Download error:', error);
      res.status(500).json({ success: false, message: 'Server error' });
    }
  });

  // Documentation view endpoints
  app.get('/api/view/:filename', (req, res) => {
    try {
      const filename = req.params.filename;
      const allowedFiles = [
        'PROJECT_PROPOSAL_GUIDE',
        'TECHNICAL_ARCHITECTURE_GUIDE', 
        'BUSINESS_PROPOSAL_EXECUTIVE'
      ];
      
      if (!allowedFiles.includes(filename)) {
        return res.status(404).send('<h1>File not found</h1>');
      }
      
      const filePath = path.join(process.cwd(), `${filename}.md`);
      
      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return res.status(404).send('<h1>File not found</h1>');
      }
      
      // Read file content
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Convert markdown to HTML with proper Persian support
      const html = `
<!DOCTYPE html>
<html dir="rtl" lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${filename}</title>
    <style>
        body {
            font-family: 'Vazir', 'Tahoma', Arial, sans-serif;
            line-height: 1.8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f9f9f9;
            color: #333;
            direction: rtl;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #2563eb; border-bottom: 3px solid #2563eb; padding-bottom: 10px; }
        h2 { color: #059669; border-bottom: 2px solid #059669; padding-bottom: 8px; }
        h3 { color: #dc2626; }
        h4 { color: #7c3aed; }
        .persian { text-align: right; }
        .english { text-align: left; direction: ltr; }
        pre { background: #f3f4f6; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { background: #e5e7eb; padding: 2px 5px; border-radius: 3px; }
        blockquote { border-right: 4px solid #3b82f6; padding-right: 15px; margin: 20px 0; background: #eff6ff; }
        ul, ol { padding-right: 20px; }
        li { margin: 8px 0; }
        .highlight { background: #fef3c7; padding: 15px; border-radius: 5px; border-right: 4px solid #f59e0b; }
        @media print {
            body { background: white; }
            .container { box-shadow: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <pre>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
    </div>
</body>
</html>`;
      
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(html);
      
    } catch (error) {
      console.error('View error:', error);
      res.status(500).send('<h1>Server error</h1>');
    }
  });

  // ============================================================================
  // ORDER TRACKING API ENDPOINTS - View Only System (MOVED BEFORE CATCH-ALL)
  // ============================================================================
  console.log('ğŸš€ [ROUTE DEBUG] Registering order tracking endpoints BEFORE catch-all...');

  // DEBUG TEST ENDPOINT - Simple response to check route registration  
  app.get('/api/test/simple', (req, res) => {
    console.log('ğŸ” [TEST] Simple endpoint called');
    res.json({ success: true, message: 'Test endpoint working', timestamp: new Date().toISOString() });
  });
  console.log('âœ… [ROUTE DEBUG] Test endpoint registered BEFORE catch-all');

  // UNIFIED API: Get ALL orders for comprehensive order management
  app.get('/api/orders/tracking/all', requireAuth, async (req, res) => {
    try {
      const startTime = Date.now();
      
      // ğŸ“„ PAGINATION PARAMETERS
      const limit = parseInt(req.query.limit as string) || 100; // Default 100 orders
      const offset = parseInt(req.query.offset as string) || 0;
      
      console.log(`ğŸ” [PAGINATED ORDER API] Starting request with limit=${limit}, offset=${offset}...`);

      // Get total count first for pagination metadata
      const countResult = await customerPool.query(`
        SELECT COUNT(*) as total_count
        FROM customer_orders co
        LEFT JOIN crm_customers cc ON co.customer_id = cc.id
        LEFT JOIN order_management om ON co.id = om.customer_order_id
      `);
      
      const totalCount = parseInt(countResult.rows[0].total_count);

      // PAGINATED QUERY: Join all relevant tables with LIMIT and OFFSET
      const result = await customerPool.query(`
        SELECT 
          co.id as customer_order_id,
          co.order_number,
          co.total_amount,
          co.currency,
          co.status as customer_status,
          co.payment_method,
          co.created_at,
          co.updated_at,
          cc.first_name,
          cc.last_name,
          cc.company,
          cc.phone,
          cc.email,
          om.id as management_id,
          om.current_status,
          om.delivery_code,
          om.tracking_number,
          om.estimated_delivery_date,
          om.actual_delivery_date,
          om.delivery_person_name,
          om.delivery_person_phone,
          om.financial_notes,
          om.warehouse_notes,
          om.logistics_notes,
          om.financial_reviewed_at,
          om.warehouse_processed_at,
          om.logistics_processed_at
        FROM customer_orders co
        LEFT JOIN crm_customers cc ON co.customer_id = cc.id
        LEFT JOIN order_management om ON co.id = om.customer_order_id
        -- SHOW ALL ORDERS: No filtering by status - admin needs to see everything for complete management
        ORDER BY co.created_at DESC
        LIMIT $1 OFFSET $2
      `, [limit, offset]);
      
      const queryTime = Date.now() - startTime;
      console.log(`âœ… [PAGINATED ORDER API] Query completed: ${queryTime}ms, found ${result.rows.length} orders (${totalCount} total)`);
      
      // Comprehensive mapping with all order information
      const orders = result.rows.map((row: any) => {
        const customerName = `${row.first_name || ''} ${row.last_name || ''}`.trim() || row.company || 'Ù…Ø´ØªØ±ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ';
        
        return {
          id: row.customer_order_id,
          customerOrderId: row.customer_order_id,
          orderNumber: row.order_number,
          managementId: row.management_id,
          
          // Status information (prefer management status over customer status)
          status: row.current_status || row.customer_status || 'pending',
          customerStatus: row.customer_status,
          currentStatus: row.current_status,
          
          // Financial information
          totalAmount: parseFloat(row.total_amount) || 0,
          currency: row.currency || 'IQD',
          paymentMethod: row.payment_method,
          
          // Customer information
          customerName,
          customerEmail: row.email || '',
          customerPhone: row.phone || '',
          
          // Delivery information
          deliveryCode: row.delivery_code,
          trackingNumber: row.tracking_number,
          estimatedDeliveryDate: row.estimated_delivery_date,
          actualDeliveryDate: row.actual_delivery_date,
          deliveryPersonName: row.delivery_person_name,
          deliveryPersonPhone: row.delivery_person_phone,
          
          // Department notes
          financialNotes: row.financial_notes,
          warehouseNotes: row.warehouse_notes,
          logisticsNotes: row.logistics_notes,
          
          // Processing timestamps
          financialReviewedAt: row.financial_reviewed_at,
          warehouseProcessedAt: row.warehouse_processed_at,
          logisticsProcessedAt: row.logistics_processed_at,
          
          // Order timestamps
          createdAt: row.created_at,
          updatedAt: row.updated_at
        };
      });

      const totalTime = Date.now() - startTime;
      console.log(`âœ… [PAGINATED ORDER API] Total processing: ${totalTime}ms, returning ${orders.length} orders of ${totalCount}`);
      
      // Calculate pagination metadata
      const hasNextPage = (offset + limit) < totalCount;
      const currentPage = Math.floor(offset / limit) + 1;
      const totalPages = Math.ceil(totalCount / limit);
      
      res.json({
        success: true,
        message: `Successfully retrieved ${orders.length} orders (page ${currentPage} of ${totalPages})`,
        orders,
        pagination: {
          totalCount,
          currentPage,
          totalPages,
          limit,
          offset,
          hasNextPage,
          nextOffset: hasNextPage ? offset + limit : null
        },
        stats: {
          totalOrders: totalCount,
          currentPageOrders: orders.length,
          managedOrders: orders.filter(o => o.managementId).length,
          pendingOrders: orders.filter(o => o.status === 'pending').length,
          processingTime: totalTime
        }
      });
      
    } catch (error) {
      console.error('ğŸ” [FIXED] API ERROR:', error);
      res.status(500).json({ success: false, message: 'Database error in fixed tracking API' });
    }
  });

  // NEW FRESH API ENDPOINT FOR DEBUGGING - REMOVE CACHE ISSUES
  app.get('/api/orders/tracking/fresh', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ†• [FRESH API] Starting fresh orders query...');
      
      const result = await customerPool.query(`
        SELECT 
          co.id,
          co.order_number,
          co.total_amount, 
          co.status,
          cc.first_name,
          cc.last_name,
          cc.company,
          cc.phone,
          cc.email
        FROM customer_orders co
        LEFT JOIN crm_customers cc ON co.customer_id = cc.id
        ORDER BY co.created_at DESC
        LIMIT 10
      `);
      
      console.log('ğŸ†• [FRESH API] Found', result.rows.length, 'orders');
      
      const orders = result.rows.map((row: any) => ({
        id: row.id,
        orderNumber: row.order_number,
        customerName: `${row.first_name || ''} ${row.last_name || ''}`.trim() || row.company || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        totalAmount: parseFloat(row.total_amount) || 0,
        status: row.status || 'pending',
        customerEmail: row.email || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        customerPhone: row.phone || 'Ù†Ø§Ù…Ø´Ø®Øµ'
      }));
      
      console.log('ğŸ†• [FRESH API] Returning processed orders:', orders.slice(0, 2));
      
      res.json({
        success: true,
        message: 'Fresh API working!',
        orders
      });
      
    } catch (error) {
      console.error('ğŸ†• [FRESH API ERROR]:', error);
      res.status(500).json({ success: false, message: 'Fresh API error' });
    }
  });

  // REMOVED: First duplicate statistics endpoint - consolidated below for consistency

  console.log('âœ… [ROUTE DEBUG] All order tracking endpoints registered BEFORE catch-all');

  // EMERGENCY ORDER MANAGEMENT SYSTEM - Complete Redesign & Fix (MOVED BEFORE CATCH-ALL)
  app.post('/api/admin/emergency-order-fix', async (req, res) => {
    if (!req.isAuthenticated() || (!req.user?.roleId && !req.session?.adminId)) {
      return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
    }

    try {
      console.log('ğŸ†˜ [EMERGENCY FIX] Starting complete order management system redesign...');
      const fixedOrders: string[] = [];
      const auditLog: string[] = [];
      
      auditLog.push('=== EMERGENCY ORDER SYSTEM REDESIGN STARTED ===');
      auditLog.push(`Timestamp: ${new Date().toISOString()}`);
      auditLog.push(`Admin: ${req.user?.username || req.session?.adminId || 'Unknown'}`);
      
      // Fix M2511130 - CRITICAL: Status mismatch (customer: pending, management: logistics_dispatched)
      const order130 = await storage.getOrderByNumber('M2511130');
      if (order130 && order130.status === 'pending' && order130.paymentStatus === 'partial') {
        console.log(`ğŸ”„ [EMERGENCY] Fixing critical status mismatch for order ${order130.orderNumber}`);
        auditLog.push(`M2511130: Status mismatch detected - customer:pending vs management:logistics_dispatched`);
        
        // Since order_management shows logistics_dispatched, this order was already delivered
        // We need to sync customer_orders to match reality
        await storage.db.update(storage.schema.customerOrders)
          .set({ 
            status: 'delivered',
            paymentStatus: 'paid',
            updatedAt: new Date().toISOString()
          })
          .where(storage.eq(storage.schema.customerOrders.id, order130.id));

        console.log(`âœ… [EMERGENCY] Order ${order130.orderNumber} status synchronized - pendingâ†’delivered`);
        auditLog.push(`M2511130: FIXED - Status synchronized to delivered`);
        fixedOrders.push(order130.orderNumber);
      }

      // Fix M2511133 - CRITICAL: wallet_partial with no actual wallet transaction
      const order133 = await storage.getOrderByNumber('M2511133');
      if (order133 && order133.paymentMethod === 'wallet_partial' && order133.paymentStatus === 'partial') {
        console.log(`ğŸ’° [EMERGENCY] Processing orphaned wallet order ${order133.orderNumber}`);
        auditLog.push(`M2511133: Wallet payment marked partial but no transaction exists`);
        
        // Check customer wallet balance
        const customerWallet = await walletStorage.getWalletByCustomerId(order133.customerId);
        if (customerWallet) {
          const orderAmount = parseFloat(order133.totalAmount);
          const walletBalance = parseFloat(customerWallet.balance);
          
          auditLog.push(`M2511133: Customer wallet balance: ${walletBalance} IQD, Order amount: ${orderAmount} IQD`);
          
          if (walletBalance >= orderAmount) {
            // CREATE MISSING WALLET TRANSACTION
            const transaction = await walletStorage.createTransaction({
              walletId: customerWallet.id,
              customerId: order133.customerId,
              transactionType: 'debit',
              amount: orderAmount.toString(),
              currency: order133.currency || 'IQD',
              balanceBefore: walletBalance.toString(),
              balanceAfter: (walletBalance - orderAmount).toString(),
              description: `ØªØµØ­ÛŒØ­ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${order133.orderNumber} - ØªØ±Ø§Ù†Ø²Ú©Ø´Ù† Ú¯Ù…Ø´Ø¯Ù‡ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯`,
              referenceType: 'order',
              referenceId: order133.id,
              paymentMethod: 'wallet_full',
              status: 'completed',
              notes: 'Emergency fix - Missing transaction created'
            });

            // Update wallet balance
            await walletStorage.updateWalletBalance(customerWallet.id, (walletBalance - orderAmount).toString());

            // Fix order status
            await storage.db.update(storage.schema.customerOrders)
              .set({ 
                paymentMethod: 'wallet_full',
                paymentStatus: 'paid',
                status: 'warehouse_ready',
                updatedAt: new Date().toISOString()
              })
              .where(storage.eq(storage.schema.customerOrders.id, order133.id));

            // Create/update management record
            await orderManagementStorage.updateOrderManagement(order133.id, {
              currentStatus: 'warehouse_pending',
              financialReviewerId: req.user?.id || req.session?.adminId || 'emergency_fix',
              financialReviewedAt: new Date().toISOString(),
              financialNotes: `EMERGENCY FIX: Missing wallet transaction created - ${orderAmount} IQD deducted`
            });

            console.log(`âœ… [EMERGENCY] Order ${order133.orderNumber} completely fixed - wallet transaction created`);
            auditLog.push(`M2511133: FIXED - Wallet transaction created, balance updated, order moved to warehouse`);
            fixedOrders.push(order133.orderNumber);
          } else {
            auditLog.push(`M2511133: ERROR - Insufficient wallet balance for order amount`);
          }
        }
      }

      // Fix M2511135 - wallet_partial with no wallet transaction
      const order135 = await storage.getOrderByNumber('M2511135');
      if (order135 && order135.paymentMethod === 'wallet_partial' && order135.paymentStatus === 'partial') {
        console.log(`ğŸ’° [AUTO FIX] Processing incomplete wallet order ${order135.orderNumber}`);
        
        // Check customer wallet
        const customerWallet = await walletStorage.getWalletByCustomerId(order135.customerId);
        if (customerWallet) {
          const orderAmount = parseFloat(order135.totalAmount);
          const walletBalance = parseFloat(customerWallet.balance);
          
          if (walletBalance >= orderAmount) {
            // Full wallet payment
            await walletStorage.createTransaction({
              walletId: customerWallet.id,
              customerId: order135.customerId,
              transactionType: 'debit',
              amount: orderAmount.toString(),
              currency: order135.currency,
              balanceBefore: walletBalance.toString(),
              balanceAfter: (walletBalance - orderAmount).toString(),
              description: `Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§Ù…Ù„ Ø³ÙØ§Ø±Ø´ ${order135.orderNumber} - Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø®ÙˆØ¯Ú©Ø§Ø±`,
              referenceType: 'order',
              referenceId: order135.id,
              paymentMethod: 'wallet_full',
              status: 'completed'
            });

            // Update order to paid
            await storage.db.update(storage.schema.customerOrders)
              .set({ 
                paymentMethod: 'wallet_full',
                paymentStatus: 'paid',
                status: 'delivered'  // Since order_management shows warehouse_processing, move to delivered
              })
              .where(storage.eq(storage.schema.customerOrders.id, order135.id));

            // Update management status
            await orderManagementStorage.updateOrderManagement(order135.id, {
              currentStatus: 'delivered',
              financialReviewerId: req.user?.id || req.session?.adminId,
              financialReviewedAt: new Date().toISOString(),
              financialNotes: `Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§Ù…Ù„ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ - ${orderAmount} ${order135.currency} - Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø®ÙˆØ¯Ú©Ø§Ø±`
            });

            console.log(`âœ… [AUTO FIX] Order ${order135.orderNumber} fixed with full wallet payment and delivered`);
            fixedOrders.push(order135.orderNumber);
          }
        }
      }

      // Fix M2511138 - bank_transfer_grace with receipt_uploaded
      const order138 = await storage.getOrderByNumber('M2511138');
      if (order138 && order138.paymentMethod === 'bank_transfer_grace' && order138.paymentStatus === 'receipt_uploaded') {
        console.log(`ğŸ¦ [AUTO FIX] Processing bank receipt order ${order138.orderNumber}`);
        
        // Auto-approve bank payment
        await storage.db.update(storage.schema.customerOrders)
          .set({ 
            paymentStatus: 'paid',
            status: 'warehouse_ready'
          })
          .where(storage.eq(storage.schema.customerOrders.id, order138.id));

        // Move to warehouse
        await orderManagementStorage.updateOrderManagement(order138.id, {
          currentStatus: 'warehouse_pending',
          financialReviewerId: req.user?.id || req.session?.adminId,
          financialReviewedAt: new Date().toISOString(),
          financialNotes: `ØªØ§ÛŒÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ - Ø±Ø³ÛŒØ¯ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡ - Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§ØªÙˆÙ…Ø§ØªÛŒÚ©`
        });

        console.log(`âœ… [AUTO FIX] Order ${order138.orderNumber} automatically approved and moved to warehouse`);
        fixedOrders.push(order138.orderNumber);
      }

      res.json({ 
        success: true, 
        message: 'Payment workflow automation completed successfully',
        ordersFixed: fixedOrders
      });

    } catch (error) {
      console.error('âŒ [PAYMENT AUTOMATION] Error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ØªÙˆÙ…Ø§Ø³ÛŒÙˆÙ† workflow Ù¾Ø±Ø¯Ø§Ø®Øª' 
      });
    }
  });

  // ORDER SYNCHRONIZATION ENDPOINTS - Added before catch-all for proper routing
  app.post('/api/admin/manual-sync-orders', async (req, res) => {
    try {
      console.log('ğŸ”§ [MANUAL SYNC] Admin triggered manual order synchronization');
      await synchronizeOrderTables();
      
      res.json({
        success: true,
        message: 'Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯',
        fixed: 0, // Will be updated by sync function if needed
        created: 0
      });
    } catch (error: any) {
      console.error('âŒ [MANUAL SYNC] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ÙØ±Ø¢ÛŒÙ†Ø¯ Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ',
        error: error.message
      });
    }
  });

  app.get('/api/admin/sync-status', async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const totalOrdersResult = await pool.query('SELECT COUNT(*) as count FROM customer_orders');
      const totalManagementResult = await pool.query('SELECT COUNT(*) as count FROM order_management');
      
      const totalOrders = parseInt(totalOrdersResult.rows[0].count);
      const totalManagement = parseInt(totalManagementResult.rows[0].count);
      
      res.json({
        success: true,
        totalOrders,
        synced: totalManagement,
        issues: Math.max(0, totalOrders - totalManagement),
        lastSync: new Date().toISOString()
      });
    } catch (error: any) {
      console.error('âŒ [SYNC STATUS] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ'
      });
    }
  });

  // API endpoint for converting proforma invoice to official invoice for wallet-paid orders reaching warehouse
  app.post("/api/orders/:orderNumber/convert-to-invoice", async (req: any, res: any) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ 
        success: false, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª" 
      });
    }

    try {
      const { orderNumber } = req.params;
      const customerId = req.user?.customerId || req.user?.id;
      
      console.log(`ğŸ“„ [INVOICE CONVERT] Converting proforma to invoice for order ${orderNumber} by customer ${customerId}`);
      
      // Get order details
      const order = await storage.getCustomerOrderByNumber(orderNumber);
      if (!order) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      // Verify order belongs to current customer
      if (order.customerId !== customerId) {
        return res.status(403).json({
          success: false,
          message: "Ø¯Ø³ØªØ±Ø³ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø²"
        });
      }
      
      // Check if order is wallet-paid
      const isWalletPaid = order.paymentMethod && (
        order.paymentMethod.includes('wallet') || 
        order.paymentMethod.includes('Ú©ÛŒÙ Ù¾ÙˆÙ„') ||
        order.paymentMethod === 'wallet_full' ||
        order.paymentMethod === 'wallet_partial'
      );
      
      // BUSINESS RULE CHANGE: All orders can be converted to final invoice when they leave warehouse
      // No longer restricted to wallet payments only
      console.log(`ğŸ“„ [MANUAL CONVERT] Manual conversion requested for order ${orderNumber} with payment method: ${order.paymentMethod}`);
      
      // Check if order has reached warehouse status
      const isWarehouseReady = ['warehouse_ready', 'warehouse_pending', 'warehouse_processing', 
                                'logistics_ready', 'logistics_processing', 'delivered', 'completed'].includes(order.status);
      
      if (!isWarehouseReady) {
        return res.status(400).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ù‡Ù†ÙˆØ² Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ù†Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª"
        });
      }
      
      // Update order to mark as official invoice
      await storage.updateCustomerOrder(order.id, {
        invoiceType: 'official_invoice',
        invoiceConvertedAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
      
      console.log(`âœ… [INVOICE CONVERT] Order ${orderNumber} converted from proforma to official invoice`);
      
      res.json({
        success: true,
        message: "Ù¾ÛŒØ´â€ŒÙØ§Ú©ØªÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ ÙØ§Ú©ØªÙˆØ± Ø±Ø³Ù…ÛŒ ØªØ¨Ø¯ÛŒÙ„ Ø´Ø¯",
        orderNumber,
        invoiceType: 'official_invoice'
      });
      
    } catch (error: any) {
      console.error(`âŒ [INVOICE CONVERT] Error converting proforma to invoice:`, error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ Ù¾ÛŒØ´â€ŒÙØ§Ú©ØªÙˆØ± Ø¨Ù‡ ÙØ§Ú©ØªÙˆØ±"
      });
    }
  });

  // =============================================================================
  // SUPER ADMIN ORDER DELETION SYSTEM - MUST BE BEFORE CATCH-ALL
  // Ø³ÛŒØ³ØªÙ… Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ø³ÙØ§Ø±Ø´Ø§Øª ØªÙˆØ³Ø· Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†
  // =============================================================================

  // Delete order completely from all systems - SUPER ADMIN ONLY
  app.delete('/api/super-admin/orders/:orderNumber', requireSuperAdmin, async (req: Request, res: Response) => {
    const { orderNumber } = req.params;
    const adminId = req.session?.adminId;

    try {
      console.log(`ğŸ—‘ï¸ [SUPER ADMIN] Starting complete order deletion for: ${orderNumber} by admin ${adminId}`);

      // Use direct SQL to bypass Drizzle schema issues
      const orderQueryResult = await customerPool.query(
        'SELECT id FROM customer_orders WHERE order_number = $1',
        [orderNumber]
      );

      if (orderQueryResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: `Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ ${orderNumber} ÛŒØ§ÙØª Ù†Ø´Ø¯`
        });
      }

      const customerOrderId = orderQueryResult.rows[0].id;
      console.log(`ğŸ“‹ [DELETE] Found customer order ID: ${customerOrderId}`);

      // Start SQL transaction
      await customerPool.query('BEGIN');

      try {
        // Delete from related tables first
        const orderItemsResult = await customerPool.query(
          'DELETE FROM order_items WHERE order_id = $1',
          [customerOrderId]
        );
        console.log(`ğŸ§¾ [DELETE] Removed ${orderItemsResult.rowCount} order items`);

        const orderMgmtResult = await customerPool.query(
          'DELETE FROM order_management WHERE customer_order_id = $1',
          [customerOrderId]
        );
        console.log(`ğŸ“Š [DELETE] Removed ${orderMgmtResult.rowCount} order management records`);

        const paymentReceiptsResult = await customerPool.query(
          'DELETE FROM payment_receipts WHERE customer_order_id = $1',
          [customerOrderId]
        );
        console.log(`ğŸ’³ [DELETE] Removed ${paymentReceiptsResult.rowCount} payment receipts`);

        // Delete from wallet_transactions table
        const walletTransactionsResult = await customerPool.query(
          'DELETE FROM wallet_transactions WHERE reference_id = $1',
          [customerOrderId]
        );
        console.log(`ğŸ’° [DELETE] Removed ${walletTransactionsResult.rowCount} wallet transactions`);

        // Delete from gps_delivery_confirmations table
        const gpsConfirmationsResult = await customerPool.query(
          'DELETE FROM gps_delivery_confirmations WHERE customer_order_id = $1',
          [customerOrderId]
        );
        console.log(`ğŸ“ [DELETE] Removed ${gpsConfirmationsResult.rowCount} GPS delivery confirmations`);

        // Delete the main customer order
        const customerOrderResult = await customerPool.query(
          'DELETE FROM customer_orders WHERE id = $1',
          [customerOrderId]
        );
        console.log(`ğŸ“¦ [DELETE] Removed customer order: ${orderNumber}`);

        // Commit transaction
        await customerPool.query('COMMIT');

      } catch (error) {
        await customerPool.query('ROLLBACK');
        throw error;
      }

      console.log(`âœ… [SUPER ADMIN] Successfully deleted order ${orderNumber} from all systems`);

      res.json({
        success: true,
        message: `Ø³ÙØ§Ø±Ø´ ${orderNumber} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² ØªÙ…Ø§Ù… Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ø­Ø°Ù Ø´Ø¯`,
        orderNumber,
        deletedBy: adminId,
        deletedAt: new Date().toISOString()
      });

    } catch (error: any) {
      console.error(`âŒ [SUPER ADMIN] Failed to delete order ${orderNumber}:`, error);
      res.status(500).json({
        success: false,
        message: error.message || 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ø³ÙØ§Ø±Ø´'
      });
    }
  });

  // REMOVED: Duplicate endpoint - see improved version below

  // Production Reset - SUPER ADMIN ONLY
  app.post('/api/super-admin/reset-for-production', requireAuth, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ—‘ï¸ [PRODUCTION RESET] Starting production reset process');
      
      const adminId = req.session?.adminId;
      const { preserveCustomers = false } = req.body; // Ú¯Ø²ÛŒÙ†Ù‡ Ø­ÙØ¸ Ù…Ø´ØªØ±ÛŒØ§Ù†
      
      // Require admin authentication (super admin only)
      if (!adminId || adminId !== 15) {
        console.log('âŒ [PRODUCTION RESET] Access denied - super admin required');
        return res.status(403).json({ 
          success: false, 
          message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ Ø¨Ù‡ Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†" 
        });
      }

      console.log(`ğŸ” [PRODUCTION RESET] Super admin ${adminId} authorized`);
      console.log(`ğŸ“‹ [PRODUCTION RESET] Customer preservation option: ${preserveCustomers ? 'ENABLED (customers will be preserved)' : 'DISABLED (customers will be deleted)'}`);

      // Tables to clear (always cleared)
      const alwaysClearTables = [
        'customer_orders',
        'order_items', 
        'order_management',
        'wallet_transactions',
        'wallet_recharge_requests',
        'payment_receipts',
        'delivery_verification_codes',
        'gps_delivery_confirmations',
        'vehicle_selection_history',
        'email_logs',
        'sms_logs',
        'abandoned_orders'
      ];

      // Tables to clear only if preserveCustomers is false
      const customerTables = [
        'customers',
        'customer_addresses'
      ];

      const tablesToClear = preserveCustomers ? alwaysClearTables : [...alwaysClearTables, ...customerTables];

      let totalRecordsDeleted = 0;
      let tablesCleared = 0;

      // Begin transaction
      await customerPool.query('BEGIN');

      try {
        // Clear each table
        for (const table of tablesToClear) {
          try {
            const result = await customerPool.query(`DELETE FROM ${table}`);
            const deletedCount = result.rowCount || 0;
            totalRecordsDeleted += deletedCount;
            tablesCleared++;
            console.log(`ğŸ—‘ï¸ [PRODUCTION RESET] Cleared ${table}: ${deletedCount} records`);
          } catch (error) {
            console.warn(`âš ï¸ [PRODUCTION RESET] Could not clear ${table}:`, error);
            // Continue with other tables even if one fails
          }
        }

        // Reset counters
        try {
          await customerPool.query('DELETE FROM counters');
          console.log('ğŸ”„ [PRODUCTION RESET] Reset all counters');
          tablesCleared++;
        } catch (error) {
          console.warn('âš ï¸ [PRODUCTION RESET] Could not reset counters:', error);
        }

        // Commit transaction
        await customerPool.query('COMMIT');

        console.log(`âœ… [PRODUCTION RESET] Successfully cleared ${tablesCleared} tables and ${totalRecordsDeleted} records`);

        const resultMessage = preserveCustomers 
          ? 'Ø³ÛŒØ³ØªÙ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯ (Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒØ§Ù† Ø­ÙØ¸ Ø´Ø¯)'
          : 'Ø³ÛŒØ³ØªÙ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø§ÛŒ Ù…Ø­ÛŒØ· ØªÙˆÙ„ÛŒØ¯ÛŒ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯';
        
        res.json({
          success: true,
          message: resultMessage,
          tablesCleared,
          recordsDeleted: totalRecordsDeleted,
          preserveCustomers,
          resetBy: adminId,
          resetAt: new Date().toISOString()
        });

      } catch (error) {
        await customerPool.query('ROLLBACK');
        throw error;
      }

    } catch (error: any) {
      console.error('âŒ [PRODUCTION RESET] Reset failed:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ ØªÙˆÙ„ÛŒØ¯ÛŒ'
      });
    }
  });

  // Get content settings - Public endpoint for category toggles (must be before catch-all)
  app.get('/api/public/content-settings', async (req, res) => {
    try {
      console.log('ğŸ“Š [PUBLIC CONTENT] Fetching public content settings:', req.query);
      const { language = 'en', section } = req.query;
      
      let query = db.select().from(contentItems);
      
      if (language && language !== 'all') {
        query = query.where(eq(contentItems.language, language as string));
      }
      
      if (section && section !== 'all') {
        query = query.where(eq(contentItems.section, section as string));
      }
      
      const items = await query;
      console.log(`âœ… [PUBLIC CONTENT] Found ${items.length} content items`);
      res.json({ success: true, data: items });
    } catch (error) {
      console.error('âŒ [PUBLIC CONTENT] Error fetching content settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­ØªÙˆØ§" });
    }
  });

  // Test sequential delivery code generation
  app.post("/api/test/sequential-code", async (req, res) => {
    try {
      const { customerOrderId, customerPhone, customerName } = req.body;
      
      if (!customerOrderId || !customerPhone || !customerName) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: customerOrderId, customerPhone, customerName"
        });
      }

      const result = await logisticsStorage.generateVerificationCode(
        customerOrderId,
        customerPhone,
        customerName
      );

      res.json({
        success: true,
        data: result,
        message: "Sequential delivery code generated successfully"
      });
    } catch (error) {
      console.error("Error generating sequential code:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate sequential code",
        error: error.message
      });
    }
  });

  // Email Templates API endpoints - REMOVED DUPLICATE (already defined above)

  app.post('/api/email-templates', requireAuth, async (req: Request, res: Response) => {
    try {
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      
      // Generate unique template number
      const templateCount = await db.select({ count: sql<number>`count(*)` }).from(emailTemplates);
      const templateNumber = `TPL-${String(templateCount[0].count + 1).padStart(4, '0')}`;
      
      const [newTemplate] = await db.insert(emailTemplates).values({
        ...validatedData,
        templateNumber,
        updatedAt: new Date()
      }).returning();

      res.status(201).json({ success: true, data: newTemplate });
    } catch (error) {
      console.error('Error creating email template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„' });
    }
  });

  app.put('/api/email-templates/:id', requireAuth, async (req: Request, res: Response) => {
    try {
      const templateId = parseInt(req.params.id);
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      
      const [updatedTemplate] = await db.update(emailTemplates)
        .set({
          ...validatedData,
          updatedAt: new Date()
        })
        .where(eq(emailTemplates.id, templateId))
        .returning();

      if (!updatedTemplate) {
        return res.status(404).json({ success: false, message: 'Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: updatedTemplate });
    } catch (error) {
      console.error('Error updating email template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„' });
    }
  });

  app.delete('/api/email-templates/:id', requireAuth, async (req: Request, res: Response) => {
    try {
      const templateId = parseInt(req.params.id);
      
      const deletedTemplate = await db.delete(emailTemplates)
        .where(eq(emailTemplates.id, templateId))
        .returning();

      if (!deletedTemplate.length) {
        return res.status(404).json({ success: false, message: 'Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting email template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„' });
    }
  });

  // =============================================================================
  // EXPIRED ORDERS CLEANUP ENDPOINTS
  // =============================================================================

  // Manual cleanup of expired orders
  app.post("/api/admin/cleanup/expired-orders", requireAuth, async (req, res) => {
    try {
      const { expiredOrdersCleanup } = await import('./expired-orders-cleanup');
      
      await expiredOrdersCleanup.manualCleanup();
      
      res.json({
        success: true,
        message: "ØªÙ…ÛŒØ²Ú©Ø§Ø±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error performing manual cleanup:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†Ø¬Ø§Ù… ØªÙ…ÛŒØ²Ú©Ø§Ø±ÛŒ"
      });
    }
  });

  // Get cleanup service status
  app.get("/api/admin/cleanup/status", requireAuth, async (req, res) => {
    try {
      const { expiredOrdersCleanup } = await import('./expired-orders-cleanup');
      
      const status = expiredOrdersCleanup.getStatus();
      
      res.json({
        success: true,
        data: status
      });
    } catch (error) {
      console.error("Error getting cleanup status:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª ØªÙ…ÛŒØ²Ú©Ø§Ø±ÛŒ"
      });
    }
  });

  // NOTE: Duplicate ABANDONED CART endpoints removed - using endpoints from Customer Section above

  // =============================================================================
  // DEBUG ENDPOINTS (FOR TESTING)
  // =============================================================================

  // Manual trigger for expired orders cleanup
  app.post("/api/debug/trigger-expired-cleanup", async (req, res) => {
    try {
      const { ExpiredOrdersCleanupService } = await import('./expired-orders-cleanup');
      const service = ExpiredOrdersCleanupService.getInstance();
      await service.performCleanup();
      res.json({ success: true, message: "Expired cleanup triggered manually" });
    } catch (error) {
      console.error("Error triggering expired cleanup:", error);
      res.status(500).json({ success: false, message: "Failed to trigger cleanup" });
    }
  });

  // =====================================
  // COMPANY INFORMATION MANAGEMENT
  // =====================================

  // Get company information
  app.get("/api/company-info", requireAuth, async (req, res) => {
    try {
      const companyData = await db.select().from(companyInformation).limit(1);
      
      res.json({
        success: true,
        data: companyData.length > 0 ? companyData[0] : null
      });
    } catch (error) {
      console.error('Error fetching company info:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch company information'
      });
    }
  });

  // Update company information
  app.put("/api/company-info", requireAuth, async (req, res) => {
    try {
      const validatedData = insertCompanyInformationSchema.parse(req.body);
      
      // Check if company info exists
      const existing = await db.select().from(companyInformation).limit(1);
      
      let result;
      if (existing.length > 0) {
        // Update existing record
        result = await db
          .update(companyInformation)
          .set({ ...validatedData, updatedAt: new Date() })
          .where(eq(companyInformation.id, existing[0].id))
          .returning();
      } else {
        // Insert new record
        result = await db
          .insert(companyInformation)
          .values(validatedData)
          .returning();
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Company information updated successfully'
      });
    } catch (error) {
      console.error('Error updating company info:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update company information'
      });
    }
  });

  // Get incoming correspondence
  app.get("/api/correspondence/incoming", requireAuth, async (req, res) => {
    try {
      const { limit = 50, offset = 0, status, priority } = req.query;
      
      let query = db.select().from(incomingCorrespondence);
      
      if (status) {
        query = query.where(eq(incomingCorrespondence.status, status as string));
      }
      
      if (priority) {
        query = query.where(eq(incomingCorrespondence.priority, priority as string));
      }
      
      const data = await query
        .orderBy(desc(incomingCorrespondence.dateReceived))
        .limit(Number(limit))
        .offset(Number(offset));

      res.json({
        success: true,
        data: data,
        total: data.length
      });
    } catch (error) {
      console.error('Error fetching incoming correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch incoming correspondence'
      });
    }
  });

  // Add incoming correspondence
  app.post("/api/correspondence/incoming", requireAuth, async (req, res) => {
    try {
      const validatedData = insertIncomingCorrespondenceSchema.parse(req.body);
      
      const result = await db
        .insert(incomingCorrespondence)
        .values(validatedData)
        .returning();

      res.json({
        success: true,
        data: result[0],
        message: 'Incoming correspondence added successfully'
      });
    } catch (error) {
      console.error('Error adding incoming correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to add incoming correspondence'
      });
    }
  });

  // Update incoming correspondence
  app.put("/api/correspondence/incoming/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertIncomingCorrespondenceSchema.parse(req.body);
      
      const result = await db
        .update(incomingCorrespondence)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(incomingCorrespondence.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Correspondence not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Incoming correspondence updated successfully'
      });
    } catch (error) {
      console.error('Error updating incoming correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update incoming correspondence'
      });
    }
  });

  // Get outgoing correspondence
  app.get("/api/correspondence/outgoing", requireAuth, async (req, res) => {
    try {
      const { limit = 50, offset = 0, status, priority } = req.query;
      
      let query = db.select().from(outgoingCorrespondence);
      
      if (status) {
        query = query.where(eq(outgoingCorrespondence.status, status as string));
      }
      
      if (priority) {
        query = query.where(eq(outgoingCorrespondence.priority, priority as string));
      }
      
      const data = await query
        .orderBy(desc(outgoingCorrespondence.dateSent))
        .limit(Number(limit))
        .offset(Number(offset));

      res.json({
        success: true,
        data: data,
        total: data.length
      });
    } catch (error) {
      console.error('Error fetching outgoing correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch outgoing correspondence'
      });
    }
  });

  // Add outgoing correspondence
  app.post("/api/correspondence/outgoing", requireAuth, async (req, res) => {
    try {
      const validatedData = insertOutgoingCorrespondenceSchema.parse(req.body);
      
      const result = await db
        .insert(outgoingCorrespondence)
        .values(validatedData)
        .returning();

      res.json({
        success: true,
        data: result[0],
        message: 'Outgoing correspondence added successfully'
      });
    } catch (error) {
      console.error('Error adding outgoing correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to add outgoing correspondence'
      });
    }
  });

  // Update outgoing correspondence
  app.put("/api/correspondence/outgoing/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertOutgoingCorrespondenceSchema.parse(req.body);
      
      const result = await db
        .update(outgoingCorrespondence)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(outgoingCorrespondence.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Correspondence not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Outgoing correspondence updated successfully'
      });
    } catch (error) {
      console.error('Error updating outgoing correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update outgoing correspondence'
      });
    }
  });

  // Get company documents
  app.get("/api/company-documents", requireAuth, async (req, res) => {
    try {
      const { limit = 50, offset = 0, status, documentType } = req.query;
      
      let query = db.select().from(companyDocuments);
      
      if (status) {
        query = query.where(eq(companyDocuments.status, status as string));
      }
      
      if (documentType) {
        query = query.where(eq(companyDocuments.documentType, documentType as string));
      }
      
      const data = await query
        .orderBy(desc(companyDocuments.issueDate))
        .limit(Number(limit))
        .offset(Number(offset));

      res.json({
        success: true,
        data: data,
        total: data.length
      });
    } catch (error) {
      console.error('Error fetching company documents:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch company documents'
      });
    }
  });

  // Add company document
  app.post("/api/company-documents", requireAuth, async (req, res) => {
    try {
      const validatedData = insertCompanyDocumentSchema.parse(req.body);
      
      const result = await db
        .insert(companyDocuments)
        .values({
          ...validatedData,
          uploadedBy: req.session.adminId
        })
        .returning();

      res.json({
        success: true,
        data: result[0],
        message: 'Company document added successfully'
      });
    } catch (error) {
      console.error('Error adding company document:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to add company document'
      });
    }
  });

  // Update company document
  app.put("/api/company-documents/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertCompanyDocumentSchema.parse(req.body);
      
      const result = await db
        .update(companyDocuments)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(companyDocuments.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Document not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Company document updated successfully'
      });
    } catch (error) {
      console.error('Error updating company document:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update company document'
      });
    }
  });

  // Delete company document
  app.delete("/api/company-documents/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const result = await db
        .delete(companyDocuments)
        .where(eq(companyDocuments.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Document not found'
        });
      }

      res.json({
        success: true,
        message: 'Company document deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting company document:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete company document'
      });
    }
  });

  // =====================================
  // BUSINESS CARDS MANAGEMENT
  // =====================================

  // Get business cards
  app.get("/api/business-cards", requireAuth, async (req, res) => {
    try {
      const { limit = 50, offset = 0, status, department, isActive } = req.query;
      
      let query = db.select().from(businessCards);
      
      if (status) {
        query = query.where(eq(businessCards.cardStatus, status as string));
      }
      
      if (department) {
        query = query.where(eq(businessCards.department, department as string));
      }
      
      if (isActive !== undefined) {
        query = query.where(eq(businessCards.isActive, isActive === 'true'));
      }
      
      const data = await query
        .orderBy(desc(businessCards.createdAt))
        .limit(Number(limit))
        .offset(Number(offset));

      res.json({
        success: true,
        data: data,
        total: data.length
      });
    } catch (error) {
      console.error('Error fetching business cards:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch business cards'
      });
    }
  });

  // Add business card
  app.post("/api/business-cards", requireAuth, async (req, res) => {
    try {
      const validatedData = insertBusinessCardSchema.parse(req.body);
      
      const result = await db
        .insert(businessCards)
        .values({
          ...validatedData,
          createdBy: req.session.adminId
        })
        .returning();

      res.json({
        success: true,
        data: result[0],
        message: 'Business card added successfully'
      });
    } catch (error) {
      console.error('Error adding business card:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to add business card'
      });
    }
  });

  // Update business card
  app.put("/api/business-cards/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const validatedData = insertBusinessCardSchema.parse(req.body);
      
      const result = await db
        .update(businessCards)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(businessCards.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Business card not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Business card updated successfully'
      });
    } catch (error) {
      console.error('Error updating business card:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update business card'
      });
    }
  });

  // Delete business card
  app.delete("/api/business-cards/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const result = await db
        .delete(businessCards)
        .where(eq(businessCards.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Business card not found'
        });
      }

      res.json({
        success: true,
        message: 'Business card deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting business card:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete business card'
      });
    }
  });

  // Approve business card
  app.put("/api/business-cards/:id/approve", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const result = await db
        .update(businessCards)
        .set({ 
          cardStatus: 'approved',
          approvedBy: req.session.adminId,
          approvedAt: new Date(),
          updatedAt: new Date()
        })
        .where(eq(businessCards.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Business card not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Business card approved successfully'
      });
    } catch (error) {
      console.error('Error approving business card:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to approve business card'
      });
    }
  });

  // Update print info
  app.put("/api/business-cards/:id/print", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { printQuantity } = req.body;
      
      const result = await db
        .update(businessCards)
        .set({ 
          cardStatus: 'printed',
          printQuantity: printQuantity || 500,
          lastPrintDate: new Date(),
          updatedAt: new Date()
        })
        .where(eq(businessCards.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Business card not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Business card print info updated successfully'
      });
    } catch (error) {
      console.error('Error updating print info:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update print info'
      });
    }
  });

  // Company Images CRUD endpoints
  
  // Get all company images
  app.get("/api/company-images", requireAuth, async (req, res) => {
    try {
      const result = await db
        .select()
        .from(companyImages)
        .orderBy(desc(companyImages.createdAt));

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error fetching company images:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch company images'
      });
    }
  });

  // Create new company image
  app.post("/api/company-images", requireAuth, async (req, res) => {
    try {
      const imageData = insertCompanyImageSchema.parse(req.body);

      const result = await db
        .insert(companyImages)
        .values({
          ...imageData,
          uploadedBy: req.session.adminId
        })
        .returning();

      res.status(201).json({
        success: true,
        data: result[0],
        message: 'Company image created successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error creating company image:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create company image'
      });
    }
  });

  // Update company image
  app.put("/api/company-images/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const imageData = insertCompanyImageSchema.parse(req.body);

      const result = await db
        .update(companyImages)
        .set({
          ...imageData,
          updatedAt: new Date()
        })
        .where(eq(companyImages.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Company image not found'
        });
      }

      res.json({
        success: true,
        data: result[0],
        message: 'Company image updated successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error updating company image:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update company image'
      });
    }
  });

  // Delete company image
  app.delete("/api/company-images/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;

      const result = await db
        .delete(companyImages)
        .where(eq(companyImages.id, Number(id)))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Company image not found'
        });
      }

      res.json({
        success: true,
        message: 'Company image deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting company image:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to delete company image'
      });
    }
  });

  // Company Information CRUD endpoints
  
  // Get company information
  app.get("/api/company-info", requireAuth, async (req, res) => {
    try {
      const result = await db
        .select()
        .from(companyInformation)
        .limit(1);

      res.json({
        success: true,
        data: result.length > 0 ? result[0] : null
      });
    } catch (error) {
      console.error('Error fetching company information:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch company information'
      });
    }
  });

  // Update company information
  app.put("/api/company-info", requireAuth, async (req, res) => {
    try {
      const companyData = insertCompanyInformationSchema.parse(req.body);

      // Check if record exists
      const existing = await db
        .select()
        .from(companyInformation)
        .limit(1);

      let result;
      if (existing.length > 0) {
        // Update existing record
        result = await db
          .update(companyInformation)
          .set({
            ...companyData,
            updatedAt: new Date()
          })
          .where(eq(companyInformation.id, existing[0].id))
          .returning();
      } else {
        // Create new record
        result = await db
          .insert(companyInformation)
          .values(companyData)
          .returning();
      }

      res.json({
        success: true,
        data: result[0],
        message: existing.length > 0 ? 'Company information updated successfully' : 'Company information created successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error updating company information:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update company information'
      });
    }
  });

  // Correspondence endpoints
  
  // Get incoming correspondence
  app.get("/api/correspondence/incoming", requireAuth, async (req, res) => {
    try {
      const result = await db
        .select()
        .from(incomingCorrespondence)
        .orderBy(desc(incomingCorrespondence.receivedDate));

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error fetching incoming correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch incoming correspondence'
      });
    }
  });

  // Create incoming correspondence
  app.post("/api/correspondence/incoming", requireAuth, async (req, res) => {
    try {
      const correspondenceData = insertIncomingCorrespondenceSchema.parse(req.body);

      const result = await db
        .insert(incomingCorrespondence)
        .values(correspondenceData)
        .returning();

      res.status(201).json({
        success: true,
        data: result[0],
        message: 'Incoming correspondence created successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error creating incoming correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create incoming correspondence'
      });
    }
  });

  // Get outgoing correspondence
  app.get("/api/correspondence/outgoing", requireAuth, async (req, res) => {
    try {
      const result = await db
        .select()
        .from(outgoingCorrespondence)
        .orderBy(desc(outgoingCorrespondence.sentDate));

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error fetching outgoing correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch outgoing correspondence'
      });
    }
  });

  // Create outgoing correspondence
  app.post("/api/correspondence/outgoing", requireAuth, async (req, res) => {
    try {
      const correspondenceData = insertOutgoingCorrespondenceSchema.parse(req.body);

      const result = await db
        .insert(outgoingCorrespondence)
        .values(correspondenceData)
        .returning();

      res.status(201).json({
        success: true,
        data: result[0],
        message: 'Outgoing correspondence created successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error creating outgoing correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create outgoing correspondence'
      });
    }
  });

  // Company Documents endpoints
  
  // Get all company documents
  app.get("/api/company-documents", requireAuth, async (req, res) => {
    try {
      const result = await db
        .select()
        .from(companyDocuments)
        .orderBy(desc(companyDocuments.createdAt));

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error fetching company documents:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch company documents'
      });
    }
  });

  // Create company document
  app.post("/api/company-documents", requireAuth, async (req, res) => {
    try {
      const documentData = insertCompanyDocumentSchema.parse(req.body);

      const result = await db
        .insert(companyDocuments)
        .values(documentData)
        .returning();

      res.status(201).json({
        success: true,
        data: result[0],
        message: 'Company document created successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error creating company document:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create company document'
      });
    }
  });

  // Business Cards endpoints
  
  // Get all business cards
  app.get("/api/business-cards", requireAuth, async (req, res) => {
    try {
      const result = await db
        .select()
        .from(businessCards)
        .orderBy(desc(businessCards.createdAt));

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error fetching business cards:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch business cards'
      });
    }
  });

  // Create business card
  app.post("/api/business-cards", requireAuth, async (req, res) => {
    try {
      const cardData = insertBusinessCardSchema.parse(req.body);

      const result = await db
        .insert(businessCards)
        .values(cardData)
        .returning();

      res.status(201).json({
        success: true,
        data: result[0],
        message: 'Business card created successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: error.errors
        });
      }

      console.error('Error creating business card:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to create business card'
      });
    }
  });

  // =============================================================================
  // COMPANY INFORMATION API ENDPOINTS
  // =============================================================================

  // Get company information
  app.get("/api/admin/company-information", requireAuth, async (req, res) => {
    try {
      const companyInfo = await companyStorage.getCompanyInformation();
      
      res.json({
        success: true,
        data: companyInfo
      });
    } catch (error) {
      console.error('Error fetching company information:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch company information'
      });
    }
  });

  // Missing endpoints for company information management
  
  // Get correspondence incoming
  app.get("/api/correspondence/incoming", requireAuth, async (req, res) => {
    try {
      // Placeholder for correspondence functionality
      res.json({
        success: true,
        data: []
      });
    } catch (error) {
      console.error('Error fetching incoming correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ú©Ø§ØªØ¨Ø§Øª ÙˆØ±ÙˆØ¯ÛŒ'
      });
    }
  });

  // Get correspondence outgoing
  app.get("/api/correspondence/outgoing", requireAuth, async (req, res) => {
    try {
      // Placeholder for correspondence functionality
      res.json({
        success: true,
        data: []
      });
    } catch (error) {
      console.error('Error fetching outgoing correspondence:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ú©Ø§ØªØ¨Ø§Øª Ø®Ø±ÙˆØ¬ÛŒ'
      });
    }
  });

  // Get company images
  app.get("/api/company-images", requireAuth, async (req, res) => {
    try {
      // Placeholder for company images functionality
      res.json({
        success: true,
        data: []
      });
    } catch (error) {
      console.error('Error fetching company images:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØµØ§ÙˆÛŒØ± Ø´Ø±Ú©Øª'
      });
    }
  });

  // Get company documents
  app.get("/api/company-documents", requireAuth, async (req, res) => {
    try {
      // Placeholder for company documents functionality
      res.json({
        success: true,
        data: []
      });
    } catch (error) {
      console.error('Error fetching company documents:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø³Ù†Ø§Ø¯ Ø´Ø±Ú©Øª'
      });
    }
  });

  // Get business cards
  app.get("/api/business-cards", requireAuth, async (req, res) => {
    try {
      // Placeholder for business cards functionality
      res.json({
        success: true,
        data: []
      });
    } catch (error) {
      console.error('Error fetching business cards:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±'
      });
    }
  });

  // Get management dashboard data with proper structure
  app.get("/api/management/dashboard", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ“Š [DASHBOARD] Fetching management dashboard data');
      
      const dashboardData = {
        summary: {
          dailySales: Math.floor(Math.random() * 100000000), // Random sales for demo
          activeOrders: Math.floor(Math.random() * 50) + 10,
          onlineCustomers: Math.floor(Math.random() * 25) + 5,
          systemAlerts: Math.floor(Math.random() * 5)
        },
        quickStats: {
          orderStatuses: {
            pending: Math.floor(Math.random() * 20) + 5,
            processing: Math.floor(Math.random() * 15) + 3,
            readyToShip: Math.floor(Math.random() * 10) + 2,
            delivered: Math.floor(Math.random() * 50) + 20
          },
          departmentPerformance: {
            finance: Math.floor(Math.random() * 30) + 70,
            warehouse: Math.floor(Math.random() * 25) + 75,
            logistics: Math.floor(Math.random() * 20) + 80
          },
          criticalInventory: [
            { name: 'Solvent 402', stock: 15, status: 'low' },
            { name: 'NPK Fertilizer', stock: 5, status: 'critical' },
            { name: 'Paint Thinner', stock: 8, status: 'low' }
          ]
        }
      };

      console.log('ğŸ“Š [DASHBOARD] Dashboard data prepared');
      
      res.json({
        success: true,
        data: dashboardData
      });
    } catch (error) {
      console.error('ğŸ“Š [DASHBOARD] Error fetching dashboard data:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯'
      });
    }
  });

  // Get system health data
  app.get("/api/management/system-health", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ”§ [SYSTEM] Fetching system health data');
      
      const systemHealth = {
        server: {
          cpu: Math.floor(Math.random() * 40) + 20, // 20-60%
          memory: Math.floor(Math.random() * 30) + 40, // 40-70%
          disk: Math.floor(Math.random() * 25) + 30 // 30-55%
        },
        services: {
          database: 'online',
          email: 'online',
          sms: 'limited'
        },
        backup: {
          lastBackup: new Date(Date.now() - 24 * 60 * 60 * 1000).toLocaleDateString('fa-IR'),
          status: 'success',
          nextScheduled: new Date(Date.now() + 24 * 60 * 60 * 1000).toLocaleDateString('fa-IR')
        }
      };

      console.log('ğŸ”§ [SYSTEM] System health data prepared');
      
      res.json({
        success: true,
        data: systemHealth
      });
    } catch (error) {
      console.error('ğŸ”§ [SYSTEM] Error fetching system health:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…'
      });
    }
  });

  // Get customer activities data  
  app.get("/api/management/customer-activities", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ‘¥ [CUSTOMER ACTIVITIES] Fetching real customer activities from database');
      
      const activities = await crmStorage.getRecentCustomerActivities(10);
      
      // Get customer data for each activity
      const formattedActivities = await Promise.all(
        activities
          .filter(activity => activity.activityType === 'login' || activity.activityType === 'logout')
          .map(async (activity) => {
            let activityData = {};
            try {
              // Parse JSON string from database
              activityData = typeof activity.activityData === 'string' 
                ? JSON.parse(activity.activityData) 
                : activity.activityData || {};
            } catch (error) {
              console.error('Error parsing activity data:', error);
              activityData = {};
            }

            // Get customer info from CRM
            let customerInfo = null;
            try {
              customerInfo = await crmStorage.getCrmCustomerById(activity.customerId);
            } catch (error) {
              console.error('Error fetching customer info:', error);
            }

            return {
              type: activity.activityType,
              customerName: activity.customerName || 'Ù†Ø§Ù… Ù†Ø§Ù…Ø´Ø®Øµ',
              phone: customerInfo?.phone || activityData.phone || '',
              email: customerInfo?.email || activityData.email || '',
              timestamp: activity.createdAt.toISOString()
            };
          })
      );

      console.log(`ğŸ‘¥ [CUSTOMER ACTIVITIES] Found ${formattedActivities.length} login/logout activities`);
      
      res.json({
        success: true,
        data: formattedActivities
      });
    } catch (error) {
      console.error('ğŸ‘¥ [CUSTOMER ACTIVITIES] Error fetching customer activities:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†'
      });
    }
  });

  // Update company information
  app.put("/api/admin/company-information", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ“ [COMPANY INFO] PUT request received');
      console.log('ğŸ“ [COMPANY INFO] Raw body:', typeof req.body, req.body);
      console.log('ğŸ“ [COMPANY INFO] Content-Type:', req.get('Content-Type'));
      
      // Handle potential JSON parsing issues
      let requestBody = req.body;
      
      // If body is a string, try to parse it
      if (typeof requestBody === 'string') {
        try {
          requestBody = JSON.parse(requestBody);
        } catch (parseError) {
          console.error('ğŸ“ [COMPANY INFO] JSON parsing error:', parseError);
          return res.status(400).json({
            success: false,
            message: 'Invalid JSON format in request body'
          });
        }
      }
      
      console.log('ğŸ“ [COMPANY INFO] Processed body:', requestBody);
      
      const companyData = insertCompanyInformationSchema.parse(requestBody);
      console.log('ğŸ“ [COMPANY INFO] Validated data:', companyData);
      
      const result = await companyStorage.upsertCompanyInfo(companyData);
      console.log('ğŸ“ [COMPANY INFO] Update result:', result);

      res.json({
        success: true,
        data: result,
        message: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error('ğŸ“ [COMPANY INFO] Validation error:', error.errors);
        return res.status(400).json({
          success: false,
          message: 'Ø®Ø·Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§',
          errors: error.errors
        });
      }

      console.error('ğŸ“ [COMPANY INFO] Update error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª'
      });
    }
  });

  // Data Integrity Management Endpoints
  app.get("/api/admin/data-integrity/corrupted-orders", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ” [DATA INTEGRITY] Getting corrupted orders');
      const corruptedOrders = await findCorruptedOrders();
      console.log(`âœ… [DATA INTEGRITY] Found ${corruptedOrders.length} corrupted orders`);
      
      res.json({
        success: true,
        corruptedOrders
      });
    } catch (error) {
      console.error("Error getting corrupted orders:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  app.get("/api/admin/data-integrity/stats", requireAuth, async (req, res) => {
    try {
      console.log('ğŸ“Š [DATA INTEGRITY] Getting data integrity stats');
      const stats = await getDataIntegrityStats();
      console.log(`âœ… [DATA INTEGRITY] Stats: ${stats.totalCorrupted} corrupted orders, total value: ${stats.totalCorruptedValue}`);
      
      res.json({
        success: true,
        stats
      });
    } catch (error) {
      console.error("Error getting data integrity stats:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  app.get("/api/admin/data-integrity/validate/:orderId", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid order ID"
        });
      }

      console.log(`ğŸ” [DATA INTEGRITY] Validating order ${orderId}`);
      const validation = await validateOrderIntegrity(orderId);
      console.log(`âœ… [DATA INTEGRITY] Order ${orderId} validation: ${validation.valid ? 'VALID' : 'INVALID'}`);
      
      res.json({
        success: true,
        validation
      });
    } catch (error) {
      console.error("Error validating order integrity:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  app.post("/api/admin/data-integrity/mark-deleted/:orderId", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { reason } = req.body;
      
      if (isNaN(orderId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid order ID"
        });
      }

      if (!reason) {
        return res.status(400).json({
          success: false,
          message: "Reason is required"
        });
      }

      console.log(`ğŸ—‘ï¸ [DATA INTEGRITY] Marking order ${orderId} as deleted: ${reason}`);
      const result = await markCorruptedOrderAsDeleted(orderId, reason);
      console.log(`âœ… [DATA INTEGRITY] Order ${orderId} marked as deleted`);
      
      res.json({
        success: true,
        message: "Order marked as deleted",
        result
      });
    } catch (error) {
      console.error("Error marking order as deleted:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // =============================================================================
  // IRAQI GEOGRAPHIC DATA API ENDPOINTS
  // =============================================================================

  // Get all Iraqi provinces with trilingual support
  app.get('/api/iraqi-provinces', async (req, res) => {
    try {
      console.log('[DEBUG] Iraqi provinces endpoint called');
      const provinces = await db
        .select()
        .from(iraqiProvinces)
        .orderBy(iraqiProvinces.nameArabic);

      console.log('[DEBUG] Provinces found:', provinces.length);
      res.json({
        success: true,
        data: provinces,
        count: provinces.length
      });
    } catch (error) {
      console.error('[ERROR] Iraqi provinces fetch error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø³ØªØ§Ù†â€ŒÙ‡Ø§ÛŒ Ø¹Ø±Ø§Ù‚',
        error: error.message
      });
    }
  });

  // Get all Iraqi cities with province information
  app.get('/api/iraqi-cities', async (req, res) => {
    try {
      const { provinceId } = req.query;
      
      let query = db
        .select()
        .from(iraqiCities)
        .where(eq(iraqiCities.isActive, true));

      if (provinceId) {
        query = query.where(eq(iraqiCities.provinceId, parseInt(provinceId as string)));
      }

      const cities = await query.orderBy(iraqiCities.nameArabic);

      res.json({
        success: true,
        data: cities,
        count: cities.length
      });
    } catch (error) {
      console.error('Error fetching Iraqi cities:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ù‡Ø±Ù‡Ø§ÛŒ Ø¹Ø±Ø§Ù‚'
      });
    }
  });

  // Get comprehensive Iraqi geographical statistics
  app.get('/api/iraqi-geography-stats', async (req, res) => {
    try {
      const [provinceCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(iraqiProvinces)
        .where(eq(iraqiProvinces.isActive, true));

      const [cityCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(iraqiCities)
        .where(eq(iraqiCities.isActive, true));

      const [capitalCityCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(iraqiCities)
        .where(and(
          eq(iraqiCities.isActive, true),
          eq(iraqiCities.isProvinceCapital, true)
        ));

      // Cities by region
      const regionStats = await db
        .select({
          region: iraqiCities.region,
          count: sql<number>`count(*)`,
        })
        .from(iraqiCities)
        .where(eq(iraqiCities.isActive, true))
        .groupBy(iraqiCities.region);

      res.json({
        success: true,
        data: {
          totalProvinces: provinceCount.count,
          totalCities: cityCount.count,
          capitalCities: capitalCityCount.count,
          regionDistribution: regionStats,
          lastUpdated: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Error fetching Iraqi geography stats:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒ Ø¹Ø±Ø§Ù‚'
      });
    }
  });

  // Update Iraqi province information
  app.put('/api/admin/iraqi-provinces/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const [updatedProvince] = await db
        .update(iraqiProvinces)
        .set({
          ...updateData,
          updatedAt: new Date()
        })
        .where(eq(iraqiProvinces.id, parseInt(id)))
        .returning();

      if (!updatedProvince) {
        return res.status(404).json({
          success: false,
          message: 'Ø§Ø³ØªØ§Ù† ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      res.json({
        success: true,
        data: updatedProvince,
        message: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø³ØªØ§Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error updating Iraqi province:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø³ØªØ§Ù†'
      });
    }
  });

  // Update Iraqi city information
  app.put('/api/admin/iraqi-cities/:id', requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const [updatedCity] = await db
        .update(iraqiCities)
        .set({
          ...updateData,
          updatedAt: new Date()
        })
        .where(eq(iraqiCities.id, parseInt(id)))
        .returning();

      if (!updatedCity) {
        return res.status(404).json({
          success: false,
          message: 'Ø´Ù‡Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      res.json({
        success: true,
        data: updatedCity,
        message: 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ù‡Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error updating Iraqi city:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ù‡Ø±'
      });
    }
  });

  // Export completed orders as CSV with date range filter - Updated for dual session support
  app.get("/api/customers/export-orders-csv", async (req, res) => {
    try {
      console.log('ğŸ“Š [CSV EXPORT] Session details:', {
        customerId: req.session?.customerId,
        adminId: req.session?.adminId,
        isAuthenticated: req.session?.isAuthenticated,
        sessionId: req.sessionID
      });
      
      // Get customer ID - support for dual session mode where customer may be logged in 
      const customerId = req.session?.customerId;
      
      // Check authentication
      if (!customerId) {
        console.log('âŒ [CSV EXPORT] No customer ID in session');
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ÙˆØ§Ø±Ø¯ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø®ÙˆØ¯ Ø´ÙˆÛŒØ¯." 
        });
      }
      
      console.log('âœ… [CSV EXPORT] Processing CSV export for customer:', customerId);
      const { startDate, endDate } = req.query;
      
      const customer = await customerStorage.getCustomer(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Get CRM customer data for detailed address information
      const crmCustomer = await crmStorage.getCrmCustomerById(customerId);
      
      // Get all orders for customer
      const allOrders = await customerStorage.getOrdersForProfile(customerId);
      
      // Filter for completed orders only (confirmed, delivered, or paid status)
      const completedOrders = allOrders.filter(order => 
        order.status === 'confirmed' || 
        order.status === 'delivered' || 
        order.paymentStatus === 'paid'
      );
      
      // Apply date range filter if provided
      let filteredOrders = completedOrders;
      if (startDate || endDate) {
        filteredOrders = completedOrders.filter(order => {
          const orderDate = new Date(order.createdAt);
          const start = startDate ? new Date(startDate as string) : null;
          const end = endDate ? new Date(endDate as string) : null;
          
          // Set end date to end of day for inclusive filtering
          if (end) {
            end.setHours(23, 59, 59, 999);
          }
          
          if (start && end) {
            return orderDate >= start && orderDate <= end;
          } else if (start) {
            return orderDate >= start;
          } else if (end) {
            return orderDate <= end;
          }
          return true;
        });
      }
      
      if (filteredOrders.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ø³ÙØ§Ø±Ø´ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø± Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }
      
      // Generate CSV content with Persian headers
      const csvHeaders = [
        'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´',
        'ØªØ§Ø±ÛŒØ® Ø³ÙØ§Ø±Ø´',
        'Ù…Ø¨Ù„Øº Ú©Ù„ (Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ)',
        'ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´',
        'ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª',
        'Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª',
        'ØªØ¹Ø¯Ø§Ø¯ Ø§Ù‚Ù„Ø§Ù…',
        'Ø¢Ø¯Ø±Ø³ ØªØ­ÙˆÛŒÙ„',
        'ÛŒØ§Ø¯Ø¯Ø§Ø´Øª Ù…Ø´ØªØ±ÛŒ'
      ];
      
      // Build comprehensive delivery address from customer information
      const buildDeliveryAddress = () => {
        const addressParts = [];
        
        if (crmCustomer) {
          // Use CRM customer data if available (most detailed)
          if (crmCustomer.address) {
            addressParts.push(crmCustomer.address);
          }
          if (crmCustomer.cityRegion || crmCustomer.city) {
            addressParts.push(crmCustomer.cityRegion || crmCustomer.city);
          }
          if (crmCustomer.province) {
            addressParts.push(crmCustomer.province);
          }
          if (crmCustomer.country) {
            addressParts.push(crmCustomer.country);
          }
          if (crmCustomer.postalCode) {
            addressParts.push(`Ú©Ø¯ Ù¾Ø³ØªÛŒ: ${crmCustomer.postalCode}`);
          }
        } else if (customer) {
          // Fallback to basic customer data
          if (customer.address) {
            addressParts.push(customer.address);
          }
          if (customer.city) {
            addressParts.push(customer.city);
          }
          if (customer.country) {
            addressParts.push(customer.country);
          }
        }
        
        return addressParts.length > 0 ? addressParts.join(' - ') : 'Ø¢Ø¯Ø±Ø³ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡';
      };

      const deliveryAddress = buildDeliveryAddress();

      const csvRows = filteredOrders.map(order => [
        order.orderNumber || `M${order.id}`,
        new Date(order.createdAt).toLocaleDateString('fa-IR'),
        order.totalAmount?.toLocaleString('fa-IR') || '0',
        order.status === 'confirmed' ? 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡' :
        order.status === 'delivered' ? 'ØªØ­ÙˆÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡' :
        order.status === 'processing' ? 'Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´' :
        order.status === 'shipped' ? 'Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡' : order.status || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        order.paymentStatus === 'paid' ? 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯Ù‡' :
        order.paymentStatus === 'pending' ? 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù¾Ø±Ø¯Ø§Ø®Øª' :
        order.paymentStatus === 'failed' ? 'Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚' : order.paymentStatus || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        order.paymentMethod === 'online_payment' ? 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø¢Ù†Ù„Ø§ÛŒÙ†' :
        order.paymentMethod === 'wallet_payment' ? 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„' :
        order.paymentMethod === 'bank_transfer_grace' ? 'Ø­ÙˆØ§Ù„Ù‡ Ø¨Ø§Ù†Ú©ÛŒ' :
        order.paymentMethod === 'cash_on_delivery' ? 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø¯Ø± Ù…Ø­Ù„' : order.paymentMethod || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        order.items?.length || 0,
        order.deliveryAddress || deliveryAddress, // Use order's delivery address if available, otherwise use customer address
        order.customerNotes || 'Ø¨Ø¯ÙˆÙ† ÛŒØ§Ø¯Ø¯Ø§Ø´Øª'
      ]);
      
      // Convert to CSV format
      const csvContent = [
        csvHeaders.join(','),
        ...csvRows.map(row => row.map(cell => `"${cell}"`).join(','))
      ].join('\n');
      
      // Generate filename with date range
      const dateRange = startDate && endDate 
        ? `${startDate}_to_${endDate}`
        : startDate 
        ? `from_${startDate}`
        : endDate 
        ? `until_${endDate}`
        : 'all_time';
      
      const fileName = `completed-orders-${customer.id}-${dateRange}-${new Date().toISOString().split('T')[0]}.csv`;
      
      // Set response headers for CSV download
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Add BOM for UTF-8 support in Excel
      res.write('\uFEFF');
      res.write(csvContent);
      res.end();
      
    } catch (error) {
      console.error('Error exporting orders CSV:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ CSV" });
    }
  });

  // Admin endpoint for exporting customer CSV orders
  app.get("/api/admin/customers/:customerId/export-orders-csv", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      const { startDate, endDate } = req.query;
      
      console.log('ğŸ“Š [ADMIN CSV EXPORT] Processing request for customer:', customerId);
      
      const customer = await customerStorage.getCustomer(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Get CRM customer data for detailed address information
      let crmCustomer;
      try {
        crmCustomer = await crmStorage.getCrmCustomerById(customerId);
        console.log('âœ… [ADMIN CSV] CRM data loaded for customer:', customerId);
      } catch (error) {
        console.log('âš ï¸ [ADMIN CSV] CRM data not available, using fallback');
        crmCustomer = null;
      }
      
      // Get all orders for customer
      const allOrders = await customerStorage.getOrdersForProfile(customerId);
      
      // Filter for completed orders only (confirmed, delivered, or paid status)
      const completedOrders = allOrders.filter(order => 
        order.status === 'confirmed' || 
        order.status === 'delivered' || 
        order.paymentStatus === 'paid'
      );
      
      // Apply date range filter if provided
      let filteredOrders = completedOrders;
      if (startDate || endDate) {
        filteredOrders = completedOrders.filter(order => {
          const orderDate = new Date(order.createdAt);
          const start = startDate ? new Date(startDate as string) : null;
          const end = endDate ? new Date(endDate as string) : null;
          
          if (end) {
            end.setHours(23, 59, 59, 999);
          }
          
          if (start && end) {
            return orderDate >= start && orderDate <= end;
          } else if (start) {
            return orderDate >= start;
          } else if (end) {
            return orderDate <= end;
          }
          return true;
        });
      }
      
      if (filteredOrders.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ø³ÙØ§Ø±Ø´ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø± Ø¨Ø§Ø²Ù‡ Ø²Ù…Ø§Ù†ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }
      
      // Build delivery address from CRM customer data if available
      const buildDeliveryAddress = (customer, crmCustomer) => {
        if (crmCustomer && (crmCustomer.address || crmCustomer.cityRegion || crmCustomer.province)) {
          const addressParts = [];
          
          if (crmCustomer.address && crmCustomer.address.trim()) {
            addressParts.push(crmCustomer.address.trim());
          }
          
          if (crmCustomer.cityRegion && crmCustomer.cityRegion.trim()) {
            addressParts.push(crmCustomer.cityRegion.trim());
          }
          
          if (crmCustomer.province && crmCustomer.province.trim() && 
              crmCustomer.province !== crmCustomer.cityRegion) {
            addressParts.push(crmCustomer.province.trim());
          }
          
          if (crmCustomer.country && crmCustomer.country.trim()) {
            addressParts.push(crmCustomer.country.trim());
          }
          
          if (crmCustomer.postalCode && crmCustomer.postalCode.toString().trim()) {
            addressParts.push(`Ú©Ø¯ Ù¾Ø³ØªÛŒ: ${crmCustomer.postalCode}`);
          }
          
          const fullAddress = addressParts.length > 0 ? addressParts.join(', ') : 'Ø¢Ø¯Ø±Ø³ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡';
          console.log('âœ… [ADMIN CSV ADDRESS] Built from CRM:', fullAddress);
          return fullAddress;
        } else if (customer && (customer.address || customer.city)) {
          const addressParts = [];
          if (customer.address && customer.address.trim()) addressParts.push(customer.address.trim());
          if (customer.city && customer.city.trim()) addressParts.push(customer.city.trim());
          if (customer.country && customer.country.trim()) addressParts.push(customer.country.trim());
          
          const basicAddress = addressParts.length > 0 ? addressParts.join(', ') : 'Ø¢Ø¯Ø±Ø³ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡';
          console.log('âš ï¸ [ADMIN CSV ADDRESS] Fallback from customer:', basicAddress);
          return basicAddress;
        }
        
        console.log('âŒ [ADMIN CSV ADDRESS] No address data available');
        return 'Ø¢Ø¯Ø±Ø³ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡';
      };
      
      const deliveryAddress = buildDeliveryAddress(customer, crmCustomer);
      console.log('ğŸ  [ADMIN CSV] Final delivery address:', deliveryAddress);
      
      // CSV Headers
      const csvHeaders = [
        'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´',
        'ØªØ§Ø±ÛŒØ® Ø³ÙØ§Ø±Ø´', 
        'Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„',
        'ØªØ¹Ø¯Ø§Ø¯',
        'Ù‚ÛŒÙ…Øª ÙˆØ§Ø­Ø¯',
        'Ù…Ø¬Ù…ÙˆØ¹',
        'ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´',
        'ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª',
        'Ø¢Ø¯Ø±Ø³ ØªØ­ÙˆÛŒÙ„',
        'ØªØ§Ø±ÛŒØ® ØªØ­ÙˆÛŒÙ„'
      ];
      
      // Build CSV rows
      const csvRows = [];
      
      for (const order of filteredOrders) {
        const orderDate = new Date(order.createdAt).toLocaleDateString('fa-IR');
        const deliveryDate = order.deliveredAt 
          ? new Date(order.deliveredAt).toLocaleDateString('fa-IR') 
          : 'ØªØ­ÙˆÛŒÙ„ Ù†Ø´Ø¯Ù‡';
        
        if (order.items && order.items.length > 0) {
          for (const item of order.items) {
            csvRows.push([
              order.orderNumber || order.id,
              orderDate,
              item.productName || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              item.quantity || 0,
              item.unitPrice || 0,
              item.totalPrice || (item.quantity * item.unitPrice) || 0,
              order.status || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              order.paymentStatus || 'Ù†Ø§Ù…Ø´Ø®Øµ',
              deliveryAddress,
              deliveryDate
            ]);
          }
        } else {
          csvRows.push([
            order.orderNumber || order.id,
            orderDate,
            'Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø´Ø®Øµ',
            1,
            order.totalAmount || 0,
            order.totalAmount || 0,
            order.status || 'Ù†Ø§Ù…Ø´Ø®Øµ',
            order.paymentStatus || 'Ù†Ø§Ù…Ø´Ø®Øµ',
            deliveryAddress,
            deliveryDate
          ]);
        }
      }
      
      // Convert to CSV format
      const csvContent = [
        csvHeaders.join(','),
        ...csvRows.map(row => row.map(cell => `"${cell}"`).join(','))
      ].join('\n');
      
      // Generate filename
      const dateRange = startDate && endDate 
        ? `${startDate}_to_${endDate}`
        : startDate 
        ? `from_${startDate}`
        : endDate 
        ? `until_${endDate}`
        : 'all_time';
      
      const fileName = `admin-export-customer-${customerId}-orders-${dateRange}-${new Date().toISOString().split('T')[0]}.csv`;
      
      // Set response headers for CSV download
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Add BOM for UTF-8 support in Excel
      res.write('\uFEFF');
      res.write(csvContent);
      res.end();
      
      console.log('âœ… [ADMIN CSV] Export completed for customer:', customerId);
      
    } catch (error) {
      console.error('Error in admin CSV export:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ CSV" });
    }
  });

  // Register FIFO batch routes
  const fifoBatchRouter = await import('./routes/fifo-batch');
  app.use(fifoBatchRouter.default);

  // =============================================================================
  // INTERNATIONAL GEOGRAPHY API ENDPOINTS
  // =============================================================================

  // International Countries
  app.get('/api/logistics/international-countries', requireAuth, async (req, res) => {
    try {
      const { isActive, region } = req.query;
      let query = db.select().from(internationalCountries);
      
      if (isActive !== undefined) {
        query = query.where(eq(internationalCountries.isActive, isActive === 'true'));
      }
      
      if (region) {
        query = query.where(eq(internationalCountries.region, region as string));
      }
      
      const countries = await query.orderBy(internationalCountries.name);
      res.json({ success: true, data: countries });
    } catch (error) {
      console.error('Error fetching international countries:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø´ÙˆØ±Ù‡Ø§ÛŒ Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  app.get('/api/logistics/international-countries/:id', requireAuth, async (req, res) => {
    try {
      const country = await db.select()
        .from(internationalCountries)
        .where(eq(internationalCountries.id, parseInt(req.params.id)))
        .limit(1);
      
      if (country.length === 0) {
        return res.status(404).json({ success: false, message: 'Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      res.json({ success: true, data: country[0] });
    } catch (error) {
      console.error('Error fetching international country:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´ÙˆØ±' });
    }
  });

  app.post('/api/logistics/international-countries', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalCountrySchema.parse(req.body);
      const country = await db.insert(internationalCountries)
        .values(validatedData)
        .returning();
      
      res.status(201).json({ success: true, data: country[0] });
    } catch (error) {
      console.error('Error creating international country:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø´ÙˆØ± Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  app.put('/api/logistics/international-countries/:id', requireAuth, async (req, res) => {
    try {
      const country = await db.update(internationalCountries)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(internationalCountries.id, parseInt(req.params.id)))
        .returning();
      
      if (country.length === 0) {
        return res.status(404).json({ success: false, message: 'Ú©Ø´ÙˆØ± ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      res.json({ success: true, data: country[0] });
    } catch (error) {
      console.error('Error updating international country:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø´ÙˆØ±' });
    }
  });

  // International Cities
  app.get('/api/logistics/international-cities', requireAuth, async (req, res) => {
    try {
      const { countryId, cityType, isActive } = req.query;
      let query = db.select({
        id: internationalCities.id,
        name: internationalCities.name,
        nameEn: internationalCities.nameEn,
        nameLocal: internationalCities.nameLocal,
        countryId: internationalCities.countryId,
        provinceState: internationalCities.provinceState,
        cityType: internationalCities.cityType,
        distanceFromErbilKm: internationalCities.distanceFromErbilKm,
        isActive: internationalCities.isActive,
        hasShippingRoutes: internationalCities.hasShippingRoutes,
        isPriorityDestination: internationalCities.isPriorityDestination,
        customsInformation: internationalCities.customsInformation,
        notes: internationalCities.notes,
        countryName: internationalCountries.name,
        countryCode: internationalCountries.countryCode
      })
      .from(internationalCities)
      .leftJoin(internationalCountries, eq(internationalCities.countryId, internationalCountries.id));
      
      if (countryId) {
        query = query.where(eq(internationalCities.countryId, parseInt(countryId as string)));
      }
      
      if (cityType) {
        query = query.where(eq(internationalCities.cityType, cityType as string));
      }
      
      if (isActive !== undefined) {
        query = query.where(eq(internationalCities.isActive, isActive === 'true'));
      }
      
      const cities = await query.orderBy(internationalCities.name);
      res.json({ success: true, data: cities });
    } catch (error) {
      console.error('Error fetching international cities:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ù‡Ø±Ù‡Ø§ÛŒ Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  app.post('/api/logistics/international-cities', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalCitySchema.parse(req.body);
      const city = await db.insert(internationalCities)
        .values(validatedData)
        .returning();
      
      res.status(201).json({ success: true, data: city[0] });
    } catch (error) {
      console.error('Error creating international city:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ù‡Ø± Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  app.put('/api/logistics/international-cities/:id', requireAuth, async (req, res) => {
    try {
      const city = await db.update(internationalCities)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(internationalCities.id, parseInt(req.params.id)))
        .returning();
      
      if (city.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø´Ù‡Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      res.json({ success: true, data: city[0] });
    } catch (error) {
      console.error('Error updating international city:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ù‡Ø±' });
    }
  });

  // International Shipping Rates
  app.get('/api/logistics/international-shipping-rates', requireAuth, async (req, res) => {
    try {
      const { countryId, cityId, shippingMethod, isActive } = req.query;
      let query = db.select({
        id: internationalShippingRates.id,
        countryId: internationalShippingRates.countryId,
        cityId: internationalShippingRates.cityId,
        shippingMethod: internationalShippingRates.shippingMethod,
        transportProvider: internationalShippingRates.transportProvider,
        basePrice: internationalShippingRates.basePrice,
        pricePerKg: internationalShippingRates.pricePerKg,
        pricePerKm: internationalShippingRates.pricePerKm,
        minimumCharge: internationalShippingRates.minimumCharge,
        maximumWeight: internationalShippingRates.maximumWeight,
        estimatedDaysMin: internationalShippingRates.estimatedDaysMin,
        estimatedDaysMax: internationalShippingRates.estimatedDaysMax,
        currency: internationalShippingRates.currency,
        supportsHazardous: internationalShippingRates.supportsHazardous,
        supportsFlammable: internationalShippingRates.supportsFlammable,
        supportsRefrigerated: internationalShippingRates.supportsRefrigerated,
        requiresCustomsClearance: internationalShippingRates.requiresCustomsClearance,
        isActive: internationalShippingRates.isActive,
        notes: internationalShippingRates.notes,
        countryName: internationalCountries.name,
        cityName: internationalCities.name
      })
      .from(internationalShippingRates)
      .leftJoin(internationalCountries, eq(internationalShippingRates.countryId, internationalCountries.id))
      .leftJoin(internationalCities, eq(internationalShippingRates.cityId, internationalCities.id));
      
      if (countryId) {
        query = query.where(eq(internationalShippingRates.countryId, parseInt(countryId as string)));
      }
      
      if (cityId) {
        query = query.where(eq(internationalShippingRates.cityId, parseInt(cityId as string)));
      }
      
      if (shippingMethod) {
        query = query.where(eq(internationalShippingRates.shippingMethod, shippingMethod as string));
      }
      
      if (isActive !== undefined) {
        query = query.where(eq(internationalShippingRates.isActive, isActive === 'true'));
      }
      
      const rates = await query.orderBy(internationalShippingRates.basePrice);
      res.json({ success: true, data: rates });
    } catch (error) {
      console.error('Error fetching international shipping rates:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø®â€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„ Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  app.post('/api/logistics/international-shipping-rates', requireAuth, async (req, res) => {
    try {
      const validatedData = insertInternationalShippingRateSchema.parse(req.body);
      const rate = await db.insert(internationalShippingRates)
        .values(validatedData)
        .returning();
      
      res.status(201).json({ success: true, data: rate[0] });
    } catch (error) {
      console.error('Error creating international shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø±Ø® Ø­Ù…Ù„ Ø¨ÛŒÙ†â€ŒØ§Ù„Ù…Ù„Ù„ÛŒ' });
    }
  });

  app.put('/api/logistics/international-shipping-rates/:id', requireAuth, async (req, res) => {
    try {
      const rate = await db.update(internationalShippingRates)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(internationalShippingRates.id, parseInt(req.params.id)))
        .returning();
      
      if (rate.length === 0) {
        return res.status(404).json({ success: false, message: 'Ù†Ø±Ø® Ø­Ù…Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      res.json({ success: true, data: rate[0] });
    } catch (error) {
      console.error('Error updating international shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ø±Ø® Ø­Ù…Ù„' });
    }
  });

  // Vehicle assignment API endpoints for logistics management
  
  // Get customer's selected vehicle details from their order
  app.get("/api/orders/:orderId/vehicle-details", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid order ID" 
        });
      }

      // First, get the vehicle selection history for this order
      const selectionHistory = await db
        .select()
        .from(vehicleSelectionHistory)
        .where(eq(vehicleSelectionHistory.customerOrderId, orderId))
        .orderBy(desc(vehicleSelectionHistory.selectedAt))
        .limit(1);

      if (selectionHistory.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No vehicle selection found for this order"
        });
      }

      const vehicleSelection = selectionHistory[0];
      
      // Get the vehicle template details
      const vehicleTemplate = await db
        .select()
        .from(vehicleTemplates)
        .where(eq(vehicleTemplates.id, vehicleSelection.vehicleTemplateId))
        .limit(1);

      if (vehicleTemplate.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Vehicle template not found"
        });
      }

      const template = vehicleTemplate[0];

      res.json({
        success: true,
        vehicleType: template.vehicleType,
        vehicleName: template.name,
        maxWeight: template.maxWeightKg,
        totalCost: vehicleSelection.totalCost,
        distanceKm: vehicleSelection.distanceKm,
        selectedAt: vehicleSelection.selectedAt
      });

    } catch (error) {
      console.error("Error fetching vehicle details:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get available fleet vehicles of specific type
  app.get("/api/logistics/available-vehicles", requireAuth, async (req, res) => {
    try {
      const { vehicleType, weight } = req.query;
      
      if (!vehicleType) {
        return res.status(400).json({
          success: false,
          message: "Vehicle type is required"
        });
      }

      // Mock fleet vehicles data for now - in real implementation this would come from fleet management database
      const mockFleetVehicles = [
        {
          id: 1,
          vehicleName: "Ú©Ø§Ù…ÛŒÙˆÙ† Ø³Ø¨Ú© 1",
          plateNumber: "Û±Û²Û³ Ø¹ Û´Ûµ",
          driverName: "Ø§Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯ÛŒ",
          driverPhone: "07501234567",
          vehicleType: vehicleType,
          maxWeight: 1000,
          status: "available"
        },
        {
          id: 2,
          vehicleName: "Ú©Ø§Ù…ÛŒÙˆÙ† Ø³Ø¨Ú© 2",
          plateNumber: "Û¶Û·Û¸ Ø¨ Û¹Û°",
          driverName: "Ø¹Ù„ÛŒ Ø­Ø³ÛŒÙ†ÛŒ",
          driverPhone: "07509876543",
          vehicleType: vehicleType,
          maxWeight: 1200,
          status: "available"
        },
        {
          id: 3,
          vehicleName: "Ú©Ø§Ù…ÛŒÙˆÙ† Ø³Ù†Ú¯ÛŒÙ† 1",
          plateNumber: "Û±Û±Û± Ø¯ Û²Û²",
          driverName: "Ø­Ø³Ù† Ø¹Ù„ÙˆÛŒ",
          driverPhone: "07501122334",
          vehicleType: "heavy_truck",
          maxWeight: 5000,
          status: "available"
        }
      ];

      // Filter vehicles by type and weight capacity
      const weightNum = weight ? parseFloat(weight as string) : 0;
      const availableVehicles = mockFleetVehicles.filter(vehicle => 
        vehicle.vehicleType === vehicleType && 
        vehicle.maxWeight >= weightNum &&
        vehicle.status === "available"
      );

      res.json({
        success: true,
        vehicles: availableVehicles
      });

    } catch (error) {
      console.error("Error fetching available vehicles:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Assign vehicle to order
  app.post("/api/logistics/assign-vehicle", requireAuth, async (req, res) => {
    try {
      const { orderId, orderManagementId, vehicleId, truckNumber, driverName, driverPhone } = req.body;
      
      if (!orderId || !orderManagementId || !vehicleId || !truckNumber || !driverName || !driverPhone) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields"
        });
      }

      // Update the order management record with vehicle assignment details
      const updateResult = await db
        .update(orderManagement)
        .set({
          vehiclePlate: truckNumber,
          driverName: driverName,
          driverPhone: driverPhone,
          currentStatus: 'logistics_assigned',
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderManagementId));

      res.json({
        success: true,
        message: "Vehicle assigned successfully",
        assignedVehicle: {
          vehicleId,
          truckNumber,
          driverName,
          driverPhone
        }
      });

    } catch (error) {
      console.error("Error assigning vehicle:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // ============= READY VEHICLES DIRECTORY ENDPOINTS (DUPLICATE REMOVED) =============
  // NOTE: Main ready-vehicles endpoints are defined earlier in this file around line 29500

  // Get vehicle details from checkout for order
  app.get("/api/orders/:orderId/vehicle-details", requireAuth, async (req, res) => {
    try {
      const { orderId } = req.params;
      console.log('ğŸšš [VEHICLE DETAILS] Fetching checkout vehicle details for order:', orderId);

      // Try to get vehicle selection from vehicle_selection_history first
      let vehicleSelectionResult = await db.execute(sql`
        SELECT 
          vsh.selected_vehicle_name,
          vsh.total_cost,
          vsh.order_weight_kg,
          vsh.selected_vehicle_template_id,
          vt.vehicle_type,
          vt.max_weight
        FROM vehicle_selection_history vsh
        LEFT JOIN vehicle_templates vt ON vsh.selected_vehicle_template_id = vt.id
        WHERE vsh.order_number = (SELECT order_number FROM customer_orders WHERE id = ${orderId})
        ORDER BY vsh.created_at DESC
        LIMIT 1
      `);

      // If no vehicle selection history, try to get from order management
      if (vehicleSelectionResult.length === 0) {
        vehicleSelectionResult = await db.execute(sql`
          SELECT 
            om.delivery_method as selected_vehicle_name,
            om.transportation_type as vehicle_type,
            om.total_amount as total_cost,
            om.total_weight as order_weight_kg
          FROM order_management om
          WHERE om.customer_order_id = ${orderId}
          LIMIT 1
        `);
      }

      // If still no data, check customer_orders delivery_method
      if (vehicleSelectionResult.length === 0) {
        vehicleSelectionResult = await db.execute(sql`
          SELECT 
            co.delivery_method as selected_vehicle_name,
            'unknown' as vehicle_type,
            0 as total_cost,
            oi.weight_kg as order_weight_kg
          FROM customer_orders co
          LEFT JOIN (
            SELECT order_id, SUM(weight_kg * quantity) as weight_kg
            FROM order_items
            GROUP BY order_id
          ) oi ON co.id = oi.order_id
          WHERE co.id = ${orderId}
          LIMIT 1
        `);
      }

      if (vehicleSelectionResult.length === 0) {
        console.log('âŒ [VEHICLE DETAILS] No vehicle details found for order:', orderId);
        return res.json({
          success: true,
          vehicleDetails: null,
          message: "No vehicle selection history found - will suggest vehicles based on order weight"
        });
      }

      const vehicleData = vehicleSelectionResult[0];
      console.log('âœ… [CHECKOUT VEHICLE] Found vehicle details:', vehicleData);

      const vehicleDetails = {
        vehicleType: vehicleData.vehicle_type || 'unknown',
        vehicleName: vehicleData.selected_vehicle_name || 'Unknown Vehicle',
        totalCost: vehicleData.total_cost || 0,
        maxWeight: vehicleData.max_weight || vehicleData.order_weight_kg || 50,
        orderWeight: vehicleData.order_weight_kg || 0
      };

      res.json({
        success: true,
        vehicleDetails
      });
    } catch (error) {
      console.error('âŒ [VEHICLE DETAILS] Error fetching vehicle details:', error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch vehicle details"
      });
    }
  });

  // Assign vehicle to order
  app.post("/api/logistics/assign-vehicle", requireAuth, async (req, res) => {
    try {
      const { orderId, orderManagementId, vehicleId, truckNumber, driverName, driverPhone } = req.body;
      console.log('ğŸš› [ASSIGN VEHICLE] Assigning vehicle to order:', { orderId, vehicleId, truckNumber });

      // Update order management record with vehicle assignment
      await db.execute(sql`
        UPDATE order_management 
        SET 
          vehicle_type = (SELECT vehicle_type FROM ready_vehicles WHERE id = ${vehicleId}),
          vehicle_plate = ${truckNumber},
          driver_name = ${driverName},
          driver_phone = ${driverPhone},
          current_status = 'logistics_assigned',
          updated_at = NOW()
        WHERE id = ${orderManagementId}
      `);

      // Mark ready vehicle as assigned (not available)
      await db.execute(sql`
        UPDATE ready_vehicles 
        SET 
          is_available = false,
          updated_at = NOW()
        WHERE id = ${vehicleId}
      `);

      console.log('âœ… [ASSIGN VEHICLE] Vehicle successfully assigned to order');

      res.json({
        success: true,
        message: "Vehicle assigned successfully"
      });
    } catch (error) {
      console.error('âŒ [ASSIGN VEHICLE] Error assigning vehicle:', error);
      res.status(500).json({
        success: false,
        message: "Failed to assign vehicle"
      });
    }
  });

  // ============= LOYALTY SYSTEM ENDPOINTS =============
  
  // Get loyalty system statistics
  app.get("/api/loyalty/stats", requireAuth, async (req, res) => {
    try {
      // Mock data for now - replace with actual database queries
      const stats = {
        totalActiveCustomers: 1247,
        totalPointsAwarded: 45820,
        totalDiscountsUsed: 156,
        tierDistribution: {
          bronze: 847,
          silver: 312,
          gold: 88
        },
        monthlyGrowth: {
          customers: 12.5,
          points: 18.3,
          discounts: 25.7
        }
      };
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching loyalty stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch loyalty statistics" });
    }
  });

  // Get loyalty customers with their data
  app.get("/api/loyalty/customers", requireAuth, async (req, res) => {
    try {
      // Mock data for now - replace with actual database queries
      const customers = [
        {
          id: 1,
          name: "Ø§Ø­Ù…Ø¯ Ø¹Ù„ÛŒ Ù…Ø­Ù…Ø¯ÛŒ",
          email: "ahmad@example.com",
          totalPoints: 2450,
          usedPoints: 200,
          availablePoints: 2250,
          tierLevel: "gold",
          totalSpent: 12500000,
          joinDate: "2024-01-15",
          lastActivity: "2025-01-25"
        },
        {
          id: 2,
          name: "ÙØ§Ø·Ù…Ù‡ Ø§Ø­Ù…Ø¯ÛŒ",
          email: "fateme@example.com",
          totalPoints: 1230,
          usedPoints: 100,
          availablePoints: 1130,
          tierLevel: "silver",
          totalSpent: 3500000,
          joinDate: "2024-03-20",
          lastActivity: "2025-01-20"
        },
        {
          id: 3,
          name: "Ù…Ø­Ù…Ø¯ Ø±Ø¶Ø§ÛŒÛŒ",
          email: "mohammad@example.com",
          totalPoints: 890,
          usedPoints: 0,
          availablePoints: 890,
          tierLevel: "bronze",
          totalSpent: 890000,
          joinDate: "2024-06-10",
          lastActivity: "2025-01-18"
        }
      ];
      
      res.json({
        success: true,
        data: customers
      });
    } catch (error) {
      console.error("Error fetching loyalty customers:", error);
      res.status(500).json({ success: false, message: "Failed to fetch loyalty customers" });
    }
  });

  // Get loyalty rules configuration
  app.get("/api/loyalty/rules", requireAuth, async (req, res) => {
    try {
      // Mock data for now - replace with actual database queries
      const rules = [
        {
          id: 1,
          ruleName: "Points per IQD",
          ruleType: "points_per_purchase",
          ruleValue: 0.001,
          currency: "IQD",
          isActive: true
        },
        {
          id: 2,
          ruleName: "Discount conversion rate",
          ruleType: "discount_rate",
          ruleValue: 20, // 20 points = 1% discount
          currency: "IQD",
          isActive: true
        },
        {
          id: 3,
          ruleName: "Bronze tier threshold",
          ruleType: "tier_threshold",
          ruleValue: 0,
          currency: "IQD",
          isActive: true
        },
        {
          id: 4,
          ruleName: "Silver tier threshold",
          ruleType: "tier_threshold",
          ruleValue: 1000000,
          currency: "IQD",
          isActive: true
        },
        {
          id: 5,
          ruleName: "Gold tier threshold",
          ruleType: "tier_threshold",
          ruleValue: 5000000,
          currency: "IQD",
          isActive: true
        }
      ];
      
      res.json({
        success: true,
        data: rules
      });
    } catch (error) {
      console.error("Error fetching loyalty rules:", error);
      res.status(500).json({ success: false, message: "Failed to fetch loyalty rules" });
    }
  });

  // Get recent loyalty transactions
  app.get("/api/loyalty/transactions/recent", requireAuth, async (req, res) => {
    try {
      // Mock data for now - replace with actual database queries
      const transactions = [
        {
          id: 1,
          customerId: 1,
          customerName: "Ø§Ø­Ù…Ø¯ Ø¹Ù„ÛŒ Ù…Ø­Ù…Ø¯ÛŒ",
          transactionType: "earned",
          pointsAmount: 50,
          description: "Ø§Ù…ØªÛŒØ§Ø² Ø®Ø±ÛŒØ¯ Ø³ÙØ§Ø±Ø´ #M2511249",
          createdAt: "2025-01-29T10:30:00Z"
        },
        {
          id: 2,
          customerId: 2,
          customerName: "ÙØ§Ø·Ù…Ù‡ Ø§Ø­Ù…Ø¯ÛŒ",
          transactionType: "redeemed",
          pointsAmount: -200,
          description: "Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ø¯ ØªØ®ÙÛŒÙ LOYALTY-2024-ABC123",
          createdAt: "2025-01-28T15:20:00Z"
        },
        {
          id: 3,
          customerId: 3,
          customerName: "Ù…Ø­Ù…Ø¯ Ø±Ø¶Ø§ÛŒÛŒ",
          transactionType: "earned",
          pointsAmount: 25,
          description: "Ø§Ù…ØªÛŒØ§Ø² Ø®Ø±ÛŒØ¯ Ù…Ø­ØµÙˆÙ„ NPK Fertilizer",
          createdAt: "2025-01-27T09:45:00Z"
        }
      ];
      
      res.json({
        success: true,
        data: transactions
      });
    } catch (error) {
      console.error("Error fetching recent transactions:", error);
      res.status(500).json({ success: false, message: "Failed to fetch recent transactions" });
    }
  });

  // Activate loyalty system
  app.post("/api/loyalty/activate", requireAuth, async (req, res) => {
    try {
      // Mock activation logic - replace with actual system activation
      console.log("ğŸ¯ [LOYALTY] System activation requested by admin:", req.session.adminId);
      
      // Here you would:
      // 1. Create necessary database tables if they don't exist
      // 2. Initialize default loyalty rules
      // 3. Set system as active in configuration
      // 4. Send activation notification emails
      
      res.json({
        success: true,
        message: "Ø³ÛŒØ³ØªÙ… ÙˆÙØ§Ø¯Ø§Ø±ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙØ¹Ø§Ù„ Ø´Ø¯",
        data: {
          activatedAt: new Date().toISOString(),
          status: "active",
          initialRules: {
            pointsPerIQD: 0.001,
            discountRate: 20,
            tierThresholds: {
              bronze: 0,
              silver: 1000000,
              gold: 5000000
            }
          }
        }
      });
    } catch (error) {
      console.error("Error activating loyalty system:", error);
      res.status(500).json({ success: false, message: "Failed to activate loyalty system" });
    }
  });

  // Update loyalty rules
  app.post("/api/loyalty/rules", requireAuth, async (req, res) => {
    try {
      console.log("ğŸ¯ [LOYALTY] Loyalty rules update requested:", req.body);
      
      // Mock rule update logic - replace with actual database updates
      const updatedRules = {
        pointsPerIQD: req.body.pointsPerIQD || 0.001,
        discountRate: req.body.discountRate || 20,
        maxDiscountPercent: req.body.maxDiscountPercent || 25,
        pointsExpiryDays: req.body.pointsExpiryDays || 365,
        minPointsForConversion: req.body.minPointsForConversion || 50
      };
      
      res.json({
        success: true,
        message: "Ù‚ÙˆØ§Ù†ÛŒÙ† ÙˆÙØ§Ø¯Ø§Ø±ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        data: updatedRules
      });
    } catch (error) {
      console.error("Error updating loyalty rules:", error);
      res.status(500).json({ success: false, message: "Failed to update loyalty rules" });
    }
  });

  // Generate discount code from points
  app.post("/api/loyalty/generate-discount", requireAuth, async (req, res) => {
    try {
      const { customerId, points } = req.body;
      
      if (!customerId || !points || points < 50) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid request: customerId and points (minimum 50) are required" 
        });
      }
      
      console.log("ğŸ¯ [LOYALTY] Discount generation requested for customer:", customerId, "points:", points);
      
      // Calculate discount percentage (20 points = 1%)
      const discountPercentage = Math.min(points / 20, 25); // Max 25%
      
      // Generate unique discount code
      const discountCode = `LOYALTY-${new Date().getFullYear()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
      
      // Mock discount generation - replace with actual database insertion
      const discount = {
        id: Date.now(),
        customerId,
        discountCode,
        pointsUsed: points,
        discountPercentage,
        isUsed: false,
        createdAt: new Date().toISOString(),
        expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
      };
      
      res.json({
        success: true,
        message: "Ú©Ø¯ ØªØ®ÙÛŒÙ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯",
        data: discount
      });
    } catch (error) {
      console.error("Error generating discount:", error);
      res.status(500).json({ success: false, message: "Failed to generate discount code" });
    }
  });

  // ============================================================================
  // ORDER TRACKING API ENDPOINTS - View Only System  
  // ============================================================================
  console.log('ğŸš€ [ROUTE DEBUG] Registering order tracking endpoints...');

  // DEBUG TEST ENDPOINT - Simple response to check route registration  
  app.get('/api/test/simple', (req, res) => {
    console.log('ğŸ” [TEST] Simple endpoint called');
    res.json({ success: true, message: 'Test endpoint working', timestamp: new Date().toISOString() });
  });
  console.log('âœ… [ROUTE DEBUG] Test endpoint registered');

  
  // NEW FRESH API ENDPOINT FOR DEBUGGING - REMOVE CACHE ISSUES
  app.get('/api/orders/tracking/fresh', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ†• [FRESH API] Starting fresh orders query...');
      
      const result = await customerPool.query(`
        SELECT 
          co.id,
          co.order_number,
          co.total_amount, 
          co.status,
          cc.first_name,
          cc.last_name,
          cc.company,
          cc.phone,
          cc.email
        FROM customer_orders co
        LEFT JOIN crm_customers cc ON co.customer_id = cc.id
        ORDER BY co.created_at DESC
        LIMIT 10
      `);
      
      console.log('ğŸ†• [FRESH API] Found', result.rows.length, 'orders');
      
      const orders = result.rows.map((row: any) => ({
        id: row.id,
        orderNumber: row.order_number,
        customerName: `${row.first_name || ''} ${row.last_name || ''}`.trim() || row.company || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        totalAmount: parseFloat(row.total_amount) || 0,
        status: row.status || 'pending',
        customerEmail: row.email || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        customerPhone: row.phone || 'Ù†Ø§Ù…Ø´Ø®Øµ'
      }));
      
      console.log('ğŸ†• [FRESH API] Returning processed orders:', orders.slice(0, 2));
      
      res.json({
        success: true,
        message: 'Fresh API working!',
        orders
      });
      
    } catch (error) {
      console.error('ğŸ†• [FRESH API ERROR]:', error);
      res.status(500).json({ success: false, message: 'Fresh API error' });
    }
  });


  // Get order details by ID (view-only)
  app.get('/api/orders/tracking/:orderId/details', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (!orderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get comprehensive order details
      const orderResult = await customerPool.query(`
        SELECT 
          om.*,
          cc.first_name,
          cc.last_name,
          cc.company_name,
          cc.phone,
          cc.email,
          cc.city,
          cc.address,
          cc.postal_code
        FROM order_management om
        LEFT JOIN crm_customers cc ON om.customer_id = cc.id
        WHERE om.id = $1
      `, [orderId]);

      if (orderResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const order = orderResult.rows[0];

      // Get order items
      const itemsResult = await customerPool.query(`
        SELECT 
          oi.id,
          oi.product_name,
          oi.quantity,
          oi.unit_price,
          oi.total_price
        FROM order_items oi
        WHERE oi.customer_order_id = $1
      `, [order.customer_order_id]);

      const orderDetails = {
        id: order.id,
        customerOrderId: order.customer_order_id,
        orderNumber: order.order_number,
        status: order.status,
        totalAmount: parseFloat(order.total_amount) || 0,
        createdAt: order.created_at,
        updatedAt: order.updated_at,
        shippingMethod: order.shipping_method,
        paymentMethod: order.payment_method,
        trackingNumber: order.tracking_number,
        estimatedDeliveryDate: order.estimated_delivery_date,
        deliveryPersonName: order.delivery_person_name,
        deliveryPersonPhone: order.delivery_person_phone,
        notes: order.notes,
        customerInfo: {
          firstName: order.first_name,
          lastName: order.last_name,
          companyName: order.company_name,
          phone: order.phone,
          email: order.email,
          city: order.city,
          address: order.address,
          postalCode: order.postal_code
        },
        items: itemsResult.rows.map((item: any) => ({
          id: item.id,
          productName: item.product_name,
          quantity: item.quantity,
          unitPrice: parseFloat(item.unit_price) || 0,
          totalPrice: parseFloat(item.total_price) || 0
        }))
      };

      res.json({
        success: true,
        order: orderDetails
      });

    } catch (error) {
      console.error('Error fetching order details:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª Ø³ÙØ§Ø±Ø´" 
      });
    }
  });

  // Get financial orders (view-only)
  app.get('/api/order-management/financial', requireAuth, async (req, res) => {
    try {
      const financialOrdersResult = await customerPool.query(`
        SELECT 
          om.id as order_id,
          om.customer_order_id,
          om.order_number,
          om.current_status,
          om.total_amount,
          om.created_at,
          om.payment_method,
          om.notes,
          cc.first_name,
          cc.last_name,
          cc.company_name,
          cc.phone,
          cc.email
        FROM order_management om
        LEFT JOIN crm_customers cc ON om.customer_id = cc.id
        WHERE om.current_status IN ('pending', 'financial_rejected') 
        AND om.current_status NOT IN ('warehouse_pending', 'warehouse_processing', 'warehouse_ready', 'logistics_processing', 'in_transit', 'delivered')
        ORDER BY om.created_at DESC
        LIMIT 50
      `);

      const financialOrders = financialOrdersResult.rows.map((row: any) => ({
        id: row.order_id,
        customerOrderId: row.customer_order_id,
        orderNumber: row.order_number,
        status: row.current_status,
        totalAmount: parseFloat(row.total_amount) || 0,
        createdAt: row.created_at,
        paymentMethod: row.payment_method,
        notes: row.notes,
        customerInfo: {
          firstName: row.first_name,
          lastName: row.last_name,
          companyName: row.company_name,
          phone: row.phone,
          email: row.email
        }
      }));

      res.json({
        success: true,
        orders: financialOrders
      });

    } catch (error) {
      console.error('Error fetching financial orders:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø§Ù„ÛŒ" 
      });
    }
  });

  // ORDER SYNCHRONIZATION ENDPOINTS - Added before error handlers for proper routing
  // New manual synchronization endpoint for admin panel
  app.post('/api/admin/manual-sync-orders', async (req, res) => {
    try {
      console.log('ğŸ”§ [MANUAL SYNC] Admin triggered manual order synchronization');
      await synchronizeOrderTables();
      
      res.json({
        success: true,
        message: 'Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯',
        fixed: 0, // Will be updated by sync function if needed
        created: 0
      });
    } catch (error: any) {
      console.error('âŒ [MANUAL SYNC] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ÙØ±Ø¢ÛŒÙ†Ø¯ Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ',
        error: error.message
      });
    }
  });

  // Sync status endpoint
  app.get('/api/admin/sync-status', async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      const totalOrdersResult = await pool.query('SELECT COUNT(*) as count FROM customer_orders');
      const totalManagementResult = await pool.query('SELECT COUNT(*) as count FROM order_management');
      
      const totalOrders = parseInt(totalOrdersResult.rows[0].count);
      const totalManagement = parseInt(totalManagementResult.rows[0].count);
      
      res.json({
        success: true,
        totalOrders,
        synced: totalManagement,
        issues: Math.max(0, totalOrders - totalManagement),
        lastSync: new Date().toISOString()
      });
    } catch (error: any) {
      console.error('âŒ [SYNC STATUS] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ'
      });
    }
  });

  // Global error handler for all API routes
  app.use('/api/*', (err: any, req: Request, res: Response, next: NextFunction) => {
    console.error('API Error:', err);
    
    // Ensure JSON response even for errors
    if (!res.headersSent) {
      res.status(err.status || 500).json({
        success: false,
        message: err.message || 'Internal server error',
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
      });
    }
  });

  // Abandoned Orders API Routes
  app.post('/api/abandoned-orders/hybrid-payment', async (req, res) => {
    try {
      const { orderNumber, walletAmount, bankAmount, customerInfo, cartData } = req.body;
      
      console.log('ğŸ“§ [ABANDONED ORDER] Tracking abandoned hybrid payment:', { orderNumber, walletAmount, bankAmount });
      
      const abandonedOrder = await storage.createAbandonedOrder({
        customerId: customerInfo.id,
        customerEmail: customerInfo.email,
        customerName: `${customerInfo.firstName} ${customerInfo.lastName}`.trim(),
        customerPhone: customerInfo.phone,
        cartData: cartData,
        totalAmount: (walletAmount + bankAmount).toString(),
        currency: 'IQD',
        checkoutStep: 'bank_payment',
        walletAmountUsed: walletAmount.toString(),
        bankAmountPending: bankAmount.toString(),
        hybridOrderNumber: orderNumber,
        remindersSent: 0,
        isRecovered: false,
        isHybridPayment: true
      });
      
      console.log(`ğŸš« [HYBRID PAYMENT ABANDONED] Customer ${customerInfo.email} abandoned order ${orderNumber} - Wallet: ${walletAmount} IQD, Bank: ${bankAmount} IQD`);
      
      res.json({ success: true, abandonedOrderId: abandonedOrder.id });
    } catch (error) {
      console.error('âŒ [ABANDONED ORDER] Failed to track abandonment:', error);
      res.status(500).json({ error: 'Failed to track abandonment' });
    }
  });

  app.get('/api/abandoned-orders', async (req, res) => {
    try {
      const abandonedOrders = await storage.getAbandonedOrders();
      
      // Transform data for frontend with proper mapping
      const transformedOrders = abandonedOrders.map(order => ({
        id: order.id,
        customerId: order.customerId,
        customerEmail: order.customerEmail,
        customerName: order.customerName,
        customerPhone: order.customerPhone,
        cartData: order.cartData,
        totalAmount: order.totalAmount,
        currency: order.currency,
        checkoutStep: order.checkoutStep,
        walletAmountUsed: order.walletAmountUsed,
        bankAmountPending: order.bankAmountPending,
        hybridOrderNumber: order.hybridOrderNumber,
        remindersSent: order.remindersSent,
        lastReminderAt: order.lastReminderAt,
        createdAt: order.createdAt,
        isRecovered: order.isRecovered,
        isHybridPayment: order.isHybridPayment,
        totalValue: parseFloat(order.totalAmount || '0'),
        walletUsed: parseFloat(order.walletAmountUsed || '0'),
        bankPending: parseFloat(order.bankAmountPending || '0')
      }));
      
      res.json({ data: transformedOrders });
    } catch (error) {
      console.error('âŒ [ABANDONED ORDERS] Failed to fetch:', error);
      res.status(500).json({ error: 'Failed to fetch abandoned orders' });
    }
  });

  app.post('/api/abandoned-orders/send-reminders', async (req, res) => {
    try {
      await sendAbandonedOrderReminders();
      res.json({ success: true, message: 'Reminders sent successfully' });
    } catch (error) {
      console.error('âŒ [SEND REMINDERS] Failed:', error);
      res.status(500).json({ error: 'Failed to send reminders' });
    }
  });

  app.post('/api/abandoned-orders/:id/recover', async (req, res) => {
    try {
      const { id } = req.params;
      const { orderId } = req.body;
      
      await storage.markAbandonedOrderRecovered(parseInt(id), orderId);
      
      res.json({ success: true, message: 'Order marked as recovered' });
    } catch (error) {
      console.error('âŒ [RECOVER ORDER] Failed:', error);
      res.status(500).json({ error: 'Failed to mark order as recovered' });
    }
  });

  const httpServer = createServer(app);
  // =============================================================================
  // CRITICAL ORDER TABLE SYNCHRONIZATION SYSTEM
  // =============================================================================

  // Automatic synchronization function to prevent stuck orders
  async function synchronizeOrderTables(): Promise<void> {
    try {
      console.log('ğŸ”„ [TABLE SYNC] Starting automatic order table synchronization...');
      
      const { pool } = await import('./db');
      
      // Direct SQL approach for better reliability

      // 1. HANDLE MISSING ORDER MANAGEMENT RECORDS
      const ordersWithoutManagement = await pool.query(`
        SELECT co.id, co.order_number, co.status, co.payment_status
        FROM customer_orders co
        LEFT JOIN order_management om ON co.id = om.customer_order_id
        WHERE om.customer_order_id IS NULL
      `);

      console.log(`ğŸ” [TABLE SYNC] Found ${ordersWithoutManagement.rows.length} orders without management records`);

      // Create missing order management records
      for (const order of ordersWithoutManagement.rows) {
        const currentStatus = determineOrderManagementStatus(order.status, order.payment_status);
        
        await pool.query(`
          INSERT INTO order_management (customer_order_id, current_status, created_at, updated_at)
          VALUES ($1, $2, NOW(), NOW())
        `, [order.id, currentStatus]);
        
        console.log(`âœ… [TABLE SYNC] Created management record for order ${order.order_number} with status: ${currentStatus}`);
      }

      // 2. HANDLE STATUS MISMATCHES
      const statusMismatches = await pool.query(`
        SELECT 
          co.id as customer_order_id,
          co.order_number,
          co.status as customer_status,
          co.payment_status as customer_payment_status,
          om.current_status as management_status,
          om.id as management_id
        FROM customer_orders co
        INNER JOIN order_management om ON co.id = om.customer_order_id
        WHERE 
          (co.status = 'deleted' AND om.current_status IN ('pending', 'confirmed', 'financial_review', 'warehouse_ready', 'warehouse_pending'))
          OR 
          (co.status = 'pending' AND om.current_status = 'warehouse_ready')
          OR
          (co.status = 'warehouse_ready' AND co.payment_status = 'receipt_uploaded' AND om.current_status = 'payment_uploaded')
          OR
          (co.payment_status = 'receipt_uploaded' AND om.current_status NOT IN ('financial_review', 'financial_approved', 'warehouse_ready', 'warehouse_pending', 'warehouse_processing'))
      `);

      console.log(`ğŸ” [TABLE SYNC] Found ${statusMismatches.rows.length} status mismatches to fix`);

      // Fix status mismatches
      for (const mismatch of statusMismatches.rows) {
        let correctManagementStatus: string;
        let correctCustomerStatus: string | null = null;
        
        if (mismatch.customer_status === 'deleted') {
          correctManagementStatus = 'cancelled';
        } else {
          correctManagementStatus = determineOrderManagementStatus(mismatch.customer_status, mismatch.customer_payment_status);
        }
        
        // Special fix for warehouse_ready + receipt_uploaded mismatch
        if (mismatch.customer_status === 'warehouse_ready' && mismatch.customer_payment_status === 'receipt_uploaded') {
          correctCustomerStatus = 'pending';
          correctManagementStatus = 'financial_review';
        }
        
        // Update order_management status
        await pool.query(`
          UPDATE order_management 
          SET current_status = $1, updated_at = NOW()
          WHERE id = $2
        `, [correctManagementStatus, mismatch.management_id]);
        
        // Update customer_orders status if needed
        if (correctCustomerStatus) {
          await pool.query(`
            UPDATE customer_orders 
            SET status = $1, updated_at = NOW()
            WHERE id = $2
          `, [correctCustomerStatus, mismatch.customer_order_id]);
        }
        
        console.log(`âœ… [TABLE SYNC] Fixed status mismatch for order ${mismatch.order_number}: ${mismatch.management_status} â†’ ${correctManagementStatus}${correctCustomerStatus ? ` (customer: ${mismatch.customer_status} â†’ ${correctCustomerStatus})` : ''}`);
      }

      // 3. CLEAN UP ORPHANED MANAGEMENT RECORDS
      const orphanedManagement = await pool.query(`
        SELECT om.id, om.customer_order_id
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE co.id IS NULL
      `);

      console.log(`ğŸ” [TABLE SYNC] Found ${orphanedManagement.rows.length} orphaned management records`);

      // Remove orphaned records
      for (const orphaned of orphanedManagement.rows) {
        await pool.query(`
          DELETE FROM order_management WHERE id = $1
        `, [orphaned.id]);
        
        console.log(`ğŸ—‘ï¸ [TABLE SYNC] Removed orphaned management record for missing customer order ${orphaned.customer_order_id}`);
      }

      console.log('âœ… [TABLE SYNC] Order table synchronization completed successfully');
      
    } catch (error) {
      console.error('âŒ [TABLE SYNC] Error during order table synchronization:', error);
    }
  }

  // Helper function to determine correct order management status
  function determineOrderManagementStatus(customerStatus: string, paymentStatus: string): string {
    if (customerStatus === 'deleted') return 'cancelled';
    if (customerStatus === 'delivered') return 'delivered';
    
    // Status determination logic based on payment and order status
    if (paymentStatus === 'paid') {
      if (customerStatus === 'pending') return 'warehouse_ready';
      if (customerStatus === 'confirmed') return 'warehouse_ready';
      if (customerStatus === 'warehouse_ready') return 'warehouse_ready';
      return 'warehouse_ready';
    }
    
    // CRITICAL FIX: receipt_uploaded should go to financial_review, not warehouse_ready
    if (paymentStatus === 'receipt_uploaded') {
      return 'financial_review';
    }
    
    if (paymentStatus === 'pending') {
      return 'payment_uploaded';
    }
    
    if (paymentStatus === 'grace_period') {
      return 'payment_grace_period';
    }
    
    return 'pending';
  }

  // Manual synchronization endpoint (admin only)
  app.post('/api/admin/system/sync-orders', requireAuth, async (req: Request, res: Response) => {
    try {
      await synchronizeOrderTables();
      res.json({ 
        success: true, 
        message: 'Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¬Ø¯Ø§ÙˆÙ„ Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error in manual order synchronization:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¬Ø¯Ø§ÙˆÙ„ Ø³ÙØ§Ø±Ø´'
      });
    }
  });

  // ==========================================================================
  // SYNC SERVICE API ENDPOINTS - Automatic Table Synchronization System
  // ==========================================================================

  // Auto sync status endpoint - GET current sync service status
  app.get('/api/admin/sync/status', requireAuth, async (req: Request, res: Response) => {
    try {
      const stats = await globalSyncService.getSyncStats();
      res.json({ 
        success: true,
        data: {
          isEnabled: globalSyncService.isEnabled(),
          lastRunTime: globalSyncService.getLastRunTime(),
          syncStats: stats,
          message: 'Sync service status retrieved successfully'
        }
      });
    } catch (error) {
      console.error('[SYNC API] Error getting sync status:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø³Ø±ÙˆÛŒØ³ Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ'
      });
    }
  });

  // Manual sync trigger endpoint - POST trigger immediate sync
  app.post('/api/admin/sync/trigger', requireAuth, async (req: Request, res: Response) => {
    try {
      const result = await globalSyncService.performManualSync();
      res.json({ 
        success: true,
        data: result,
        message: 'Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯'
      });
    } catch (error) {
      console.error('[SYNC API] Error in manual sync:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ'
      });
    }
  });

  // Sync service configuration endpoint - POST update sync settings
  app.post('/api/admin/sync/config', requireAuth, async (req: Request, res: Response) => {
    try {
      const { enabled, intervalMinutes } = req.body;
      
      if (typeof enabled === 'boolean') {
        if (enabled) {
          globalSyncService.enable();
        } else {
          globalSyncService.disable();
        }
      }
      
      if (typeof intervalMinutes === 'number' && intervalMinutes > 0) {
        globalSyncService.setInterval(intervalMinutes);
      }
      
      res.json({ 
        success: true,
        data: {
          enabled: globalSyncService.isEnabled(),
          intervalMinutes: globalSyncService.getIntervalMinutes()
        },
        message: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆÛŒØ³ Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });
    } catch (error) {
      console.error('[SYNC API] Error updating sync config:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ'
      });
    }
  });

  // Sync conflicts endpoint - GET current conflicts that need resolution
  app.get('/api/admin/sync/conflicts', requireAuth, async (req: Request, res: Response) => {
    try {
      const conflicts = await globalSyncService.getConflicts();
      res.json({ 
        success: true,
        data: conflicts,
        message: 'Sync conflicts retrieved successfully'
      });
    } catch (error) {
      console.error('[SYNC API] Error getting sync conflicts:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ¹Ø§Ø±Ø¶Ø§Øª Ù‡Ù…Ø³Ø§Ù†Ø³Ø§Ø²ÛŒ'
      });
    }
  });

  // Resolve conflict endpoint - POST resolve specific conflict
  app.post('/api/admin/sync/resolve-conflict', requireAuth, async (req: Request, res: Response) => {
    try {
      const { orderNumber, resolution } = req.body;
      
      if (!orderNumber || !resolution) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ùˆ Ù†ÙˆØ¹ Ø­Ù„ ØªØ¹Ø§Ø±Ø¶ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª'
        });
      }
      
      const result = await globalSyncService.resolveConflict(orderNumber, resolution);
      res.json({ 
        success: true,
        data: result,
        message: 'ØªØ¹Ø§Ø±Ø¶ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ù„ Ø´Ø¯'
      });
    } catch (error) {
      console.error('[SYNC API] Error resolving conflict:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ù„ ØªØ¹Ø§Ø±Ø¶'
      });
    }
  });

  // Manual sync service API endpoints
  app.post('/api/sync/manual-sync', requireAuth, async (req, res) => {
    try {
      console.log('ğŸ”„ [MANUAL SYNC] Starting manual synchronization...');
      const result = await globalSyncService.performFullSync();
      res.json({ 
        success: true, 
        message: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯',
        result 
      });
    } catch (error) {
      console.error('âŒ [MANUAL SYNC] Manual sync failed:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ'
      });
    }
  });

  app.get('/api/sync/status', requireAuth, async (req, res) => {
    try {
      const stats = await globalSyncService.getSyncStats();
      res.json({ 
        success: true, 
        stats,
        isRunning: globalSyncService.isRunning()
      });
    } catch (error) {
      console.error('âŒ [SYNC STATUS] Failed to get sync status:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ'
      });
    }
  });

  // Super admin routes moved before catch-all above

  // Payment Workflow Automation - Fix Incomplete Payments  
  app.post('/api/admin/fix-incomplete-payments', async (req, res) => {
    if (!req.isAuthenticated() || (!req.user?.roleId && !req.session?.adminId)) {
      return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
    }

    try {
      console.log(`ğŸ—‘ï¸ [SUPER ADMIN] Starting complete order deletion for: ${orderNumber} by admin ${adminId}`);

      // Start transaction for atomic operations
      await db.transaction(async (tx) => {
        // 1. Find the order in customer_orders table
        const customerOrderResult = await tx
          .select()
          .from(customerOrders)
          .where(eq(customerOrders.orderNumber, orderNumber))
          .limit(1);

        if (customerOrderResult.length === 0) {
          throw new Error(`Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ ${orderNumber} ÛŒØ§ÙØª Ù†Ø´Ø¯`);
        }

        const customerOrder = customerOrderResult[0];
        const customerOrderId = customerOrder.id;
        console.log(`ğŸ“‹ [DELETE] Found customer order ID: ${customerOrderId}`);

        // 2. Delete from order_items table
        const deletedOrderItems = await tx
          .delete(orderItems)
          .where(eq(orderItems.orderId, customerOrderId))
          .returning();
        console.log(`ğŸ§¾ [DELETE] Removed ${deletedOrderItems.length} order items`);

        // 3. Delete from order_management table
        const deletedOrderManagement = await tx
          .delete(orderManagement)
          .where(eq(orderManagement.customerOrderId, customerOrderId))
          .returning();
        console.log(`ğŸ“Š [DELETE] Removed ${deletedOrderManagement.length} order management records`);

        // 4. Delete from payment_receipts table
        const deletedPaymentReceipts = await tx
          .delete(paymentReceipts)
          .where(eq(paymentReceipts.customerOrderId, customerOrderId))
          .returning();
        console.log(`ğŸ’³ [DELETE] Removed ${deletedPaymentReceipts.length} payment receipts`);

        // 5. Delete from wallet transactions related to this order
        try {
          const { walletTransactions } = await import('@shared/customer-schema');
          const deletedWalletTransactions = await tx
            .delete(walletTransactions)
            .where(sql`description LIKE '%${orderNumber}%'`)
            .returning();
          console.log(`ğŸ’° [DELETE] Removed ${deletedWalletTransactions.length} wallet transactions`);
        } catch (walletError) {
          console.log(`âš ï¸ [DELETE] Wallet transactions table not accessible, skipping`);
        }

        // 6. Delete from gps_delivery_confirmations table
        try {
          const { gpsDeliveryConfirmations } = await import('@shared/logistics-schema');
          const deletedGpsDeliveries = await tx
            .delete(gpsDeliveryConfirmations)
            .where(eq(gpsDeliveryConfirmations.orderNumber, orderNumber))
            .returning();
          console.log(`ğŸ“ [DELETE] Removed ${deletedGpsDeliveries.length} GPS delivery confirmations`);
        } catch (gpsError) {
          console.log(`âš ï¸ [DELETE] GPS delivery confirmations table not accessible, skipping`);
        }

        // 7. Delete from vehicle_selection_history table
        try {
          const { vehicleSelectionHistory } = await import('@shared/logistics-schema');
          const deletedVehicleHistory = await tx
            .delete(vehicleSelectionHistory)
            .where(eq(vehicleSelectionHistory.orderNumber, orderNumber))
            .returning();
          console.log(`ğŸš› [DELETE] Removed ${deletedVehicleHistory.length} vehicle selection records`);
        } catch (vehicleError) {
          console.log(`âš ï¸ [DELETE] Vehicle selection history table not accessible, skipping`);
        }

        // 8. Delete from delivery_verification_codes table
        try {
          const { deliveryVerificationCodes } = await import('@shared/logistics-schema');
          const deletedDeliveryVerifications = await tx
            .delete(deliveryVerificationCodes)
            .where(eq(deliveryVerificationCodes.orderNumber, orderNumber))
            .returning();
          console.log(`ğŸ” [DELETE] Removed ${deletedDeliveryVerifications.length} delivery verification codes`);
        } catch (deliveryError) {
          console.log(`âš ï¸ [DELETE] Delivery verification codes table not accessible, skipping`);
        }

        // 9. Delete from abandoned_orders table (if exists)
        try {
          const { abandonedOrders } = await import('@shared/schema');
          const deletedAbandonedOrders = await tx
            .delete(abandonedOrders)
            .where(eq(abandonedOrders.hybridOrderNumber, orderNumber))
            .returning();
          console.log(`ğŸ›’ [DELETE] Removed ${deletedAbandonedOrders.length} abandoned order records`);
        } catch (abandonedError) {
          console.log(`âš ï¸ [DELETE] Abandoned orders table not accessible, skipping`);
        }

        // 10. Delete from shop orders table (if order exists there)
        try {
          const { orders: shopOrders } = await import('@shared/shop-schema');
          const deletedShopOrders = await tx
            .delete(shopOrders)
            .where(eq(shopOrders.orderNumber, orderNumber))
            .returning();
          console.log(`ğŸ›ï¸ [DELETE] Removed ${deletedShopOrders.length} shop order records`);
        } catch (shopError) {
          console.log(`âš ï¸ [DELETE] Shop orders table not accessible, skipping`);
        }

        // 11. Delete any email logs related to this order
        try {
          const { emailLogs } = await import('@shared/email-schema');
          const deletedEmailLogs = await tx
            .delete(emailLogs)
            .where(sql`subject LIKE '%${orderNumber}%' OR content LIKE '%${orderNumber}%'`)
            .returning();
          console.log(`ğŸ“§ [DELETE] Removed ${deletedEmailLogs.length} email log records`);
        } catch (emailError) {
          console.log(`âš ï¸ [DELETE] Email logs table not accessible, skipping`);
        }

        // 12. Delete any SMS logs related to this order
        try {
          const { smsLogs } = await import('@shared/schema');
          const deletedSmsLogs = await tx
            .delete(smsLogs)
            .where(sql`message LIKE '%${orderNumber}%'`)
            .returning();
          console.log(`ğŸ“± [DELETE] Removed ${deletedSmsLogs.length} SMS log records`);
        } catch (smsError) {
          console.log(`âš ï¸ [DELETE] SMS logs table not accessible, skipping`);
        }

        // 13. Finally, delete the main customer order
        const deletedCustomerOrder = await tx
          .delete(customerOrders)
          .where(eq(customerOrders.id, customerOrderId))
          .returning();
        console.log(`ğŸ¯ [DELETE] Removed main customer order: ${orderNumber}`);

        return {
          deletedOrderItems: deletedOrderItems.length,
          deletedOrderManagement: deletedOrderManagement.length,
          deletedPaymentReceipts: deletedPaymentReceipts.length,
          customerOrder: deletedCustomerOrder[0]
        };
      });

      console.log(`âœ… [SUPER ADMIN] Order ${orderNumber} completely deleted from all systems`);

      res.json({
        success: true,
        message: `Ø³ÙØ§Ø±Ø´ ${orderNumber} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² ØªÙ…Ø§Ù… Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ø­Ø°Ù Ø´Ø¯`,
        data: {
          orderNumber,
          deletedBy: adminId,
          deletedAt: new Date().toISOString(),
          action: 'complete_deletion'
        }
      });

    } catch (error) {
      console.error(`âŒ [SUPER ADMIN] Failed to delete order ${orderNumber}:`, error);
      res.status(500).json({
        success: false,
        message: `Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙØ§Ø±Ø´ ${orderNumber}: ${error.message}`,
        error: error.message
      });
    }
  });

  // Get customer orders by email for super admin deletion
  app.get('/api/super-admin/customer-orders-by-email/:email', requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      const { email } = req.params;
      const decodedEmail = decodeURIComponent(email);
      console.log(`ğŸ” [SUPER ADMIN] Fetching customer orders for email: ${decodedEmail}`);
      
      const result = await customerPool.query(`
        SELECT 
          co.id, 
          co.order_number as "orderNumber", 
          co.guest_name as "customerName", 
          co.guest_email as "customerEmail", 
          co.total_amount as "totalAmount", 
          co.currency, 
          co.status, 
          co.payment_status as "paymentStatus",
          co.payment_method as "paymentMethod", 
          co.created_at as "createdAt", 
          co.updated_at as "updatedAt",
          co.customer_id as "customerId",
          -- Get customer details
          COALESCE(co.guest_name, c.first_name || ' ' || c.last_name, crm.first_name || ' ' || crm.last_name) as "fullCustomerName",
          COALESCE(co.guest_email, c.email, crm.email) as "fullCustomerEmail",
          c.phone as "customerPhone",
          crm.phone as "crmCustomerPhone"
        FROM customer_orders co
        LEFT JOIN customers c ON co.customer_id = c.id
        LEFT JOIN crm_customers crm ON co.customer_id = crm.id
        WHERE (
          co.guest_email = $1 
          OR c.email = $1 
          OR crm.email = $1
        )
        ORDER BY co.created_at DESC
      `, [decodedEmail]);
      
      console.log(`âœ… [SUPER ADMIN] Found ${result.rows.length} orders for email ${decodedEmail}`);

      res.json({
        success: true,
        data: result.rows,
        searchEmail: decodedEmail
      });

    } catch (error) {
      console.error(`âŒ [SUPER ADMIN] Failed to fetch customer orders for ${req.params.email}:`, error);
      res.status(500).json({
        success: false,
        message: `Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ù…Ø´ØªØ±ÛŒ: ${error.message}`,
        error: error.message
      });
    }
  });

  // Get orders that can be deleted (for super admin interface) - ENHANCED
  app.get('/api/super-admin/deletable-orders', requireSuperAdmin, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ” [SUPER ADMIN] Starting enhanced deletable orders request');
      
      // Get orders with complete details only - filter out incomplete temporary orders
      const result = await customerPool.query(`
        SELECT 
          co.id, 
          co.order_number as "orderNumber", 
          co.guest_name as "customerName", 
          co.guest_email as "customerEmail", 
          co.total_amount as "totalAmount", 
          co.currency, 
          co.status, 
          co.payment_status as "paymentStatus",
          co.payment_method as "paymentMethod", 
          co.created_at as "createdAt", 
          co.updated_at as "updatedAt",
          co.customer_id as "customerId",
          -- Get customer details if available
          COALESCE(co.guest_name, c.first_name || ' ' || c.last_name, crm.first_name || ' ' || crm.last_name) as "fullCustomerName",
          COALESCE(co.guest_email, c.email, crm.email) as "fullCustomerEmail"
        FROM customer_orders co
        LEFT JOIN customers c ON co.customer_id = c.id
        LEFT JOIN crm_customers crm ON co.customer_id = crm.id
        WHERE (
          -- Include orders with order numbers (completed/confirmed orders)
          co.order_number IS NOT NULL 
          OR 
          -- Include failed/incomplete orders that should be cleaned up
          (co.order_number IS NULL AND (
            co.status IN ('cancelled', 'failed', 'pending') 
            OR co.payment_status IN ('failed', 'cancelled', 'pending')
            OR co.created_at < NOW() - INTERVAL '1 hour'
          ))
        )
        ORDER BY co.created_at DESC 
        LIMIT 100
      `);
      
      const allOrders = result.rows;
      
      // Separate orders by type for better presentation
      const ordersWithNumbers = allOrders.filter(order => order.orderNumber);
      const temporaryOrders = allOrders.filter(order => !order.orderNumber);
      
      console.log(`âœ… [SUPER ADMIN] Found ${allOrders.length} total orders:`, {
        withOrderNumbers: ordersWithNumbers.length,
        temporaryOrders: temporaryOrders.length
      });

      res.json({
        success: true,
        data: allOrders,
        summary: {
          total: allOrders.length,
          withOrderNumbers: ordersWithNumbers.length,
          temporaryOrders: temporaryOrders.length
        },
        message: `${allOrders.length} Ø³ÙØ§Ø±Ø´ (${ordersWithNumbers.length} Ú©Ø§Ù…Ù„ØŒ ${temporaryOrders.length} Ù…ÙˆÙ‚Øª) Ù‚Ø§Ø¨Ù„ Ø­Ø°Ù ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error('âŒ [SUPER ADMIN] Failed to fetch deletable orders:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ø³ÙØ§Ø±Ø´Ø§Øª Ù‚Ø§Ø¨Ù„ Ø­Ø°Ù'
      });
    }
  });

  // Payment Workflow Automation - Fix Incomplete Payments  
  app.post('/api/admin/fix-incomplete-payments', async (req, res) => {
    if (!req.isAuthenticated() || (!req.user?.roleId && !req.session?.adminId)) {
      return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
    }

    try {
      console.log('ğŸš€ [PAYMENT AUTOMATION] Starting complete payment workflow automation...');
      const fixedOrders: string[] = [];
      
      // Fix M2511133 - wallet_partial with no wallet transaction
      const order133 = await storage.getOrderByNumber('M2511133');
      if (order133 && order133.paymentMethod === 'wallet_partial') {
        console.log(`ğŸ’° [AUTO FIX] Processing incomplete wallet order ${order133.orderNumber}`);
        
        // Check customer wallet
        const customerWallet = await walletStorage.getWalletByCustomerId(order133.customerId);
        if (customerWallet) {
          const orderAmount = parseFloat(order133.totalAmount);
          const walletBalance = parseFloat(customerWallet.balance);
          
          if (walletBalance >= orderAmount) {
            // Full wallet payment
            await walletStorage.createTransaction({
              walletId: customerWallet.id,
              customerId: order133.customerId,
              transactionType: 'debit',
              amount: orderAmount.toString(),
              currency: order133.currency,
              balanceBefore: walletBalance.toString(),
              balanceAfter: (walletBalance - orderAmount).toString(),
              description: `Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§Ù…Ù„ Ø³ÙØ§Ø±Ø´ ${order133.orderNumber} - Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø®ÙˆØ¯Ú©Ø§Ø±`,
              referenceType: 'order',
              referenceId: order133.id,
              paymentMethod: 'wallet_full',
              status: 'completed'
            });

            // Update order to paid
            await storage.db.update(storage.schema.customerOrders)
              .set({ 
                paymentMethod: 'wallet_full',
                paymentStatus: 'paid'
              })
              .where(storage.eq(storage.schema.customerOrders.id, order133.id));

            // Move to warehouse
            await orderManagementStorage.updateOrderManagement(order133.id, {
              currentStatus: 'warehouse_pending',
              financialReviewerId: req.user?.id || req.session?.adminId,
              financialReviewedAt: new Date().toISOString(),
              financialNotes: `Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§Ù…Ù„ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ - ${orderAmount} ${order133.currency} - Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø®ÙˆØ¯Ú©Ø§Ø±`
            });

            console.log(`âœ… [AUTO FIX] Order ${order133.orderNumber} fixed with full wallet payment`);
            fixedOrders.push(order133.orderNumber);
          }
        }
      }

      // Fix M2511138 - bank_transfer_grace with receipt_uploaded
      const order138 = await storage.getOrderByNumber('M2511138');
      if (order138 && order138.paymentMethod === 'bank_transfer_grace' && order138.paymentStatus === 'receipt_uploaded') {
        console.log(`ğŸ¦ [AUTO FIX] Processing bank receipt order ${order138.orderNumber}`);
        
        // Auto-approve bank payment
        await storage.db.update(storage.schema.customerOrders)
          .set({ paymentStatus: 'paid' })
          .where(storage.eq(storage.schema.customerOrders.id, order138.id));

        // Move to warehouse
        await orderManagementStorage.updateOrderManagement(order138.id, {
          currentStatus: 'warehouse_pending',
          financialReviewerId: req.user?.id || req.session?.adminId,
          financialReviewedAt: new Date().toISOString(),
          financialNotes: `ØªØ§ÛŒÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§Ù†Ú©ÛŒ - Ø±Ø³ÛŒØ¯ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡ - Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§ØªÙˆÙ…Ø§ØªÛŒÚ©`
        });

        console.log(`âœ… [AUTO FIX] Order ${order138.orderNumber} automatically approved and moved to warehouse`);
        fixedOrders.push(order138.orderNumber);
      }

      res.json({ 
        success: true, 
        message: 'Payment workflow automation completed successfully',
        ordersFixed: fixedOrders
      });

    } catch (error) {
      console.error('âŒ [PAYMENT AUTOMATION] Error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ØªÙˆÙ…Ø§Ø³ÛŒÙˆÙ† workflow Ù¾Ø±Ø¯Ø§Ø®Øª' 
      });
    }
  });

  // Manual sync endpoint for troubleshooting
  app.post("/api/admin/manual-sync", requireAuth, async (req, res) => {
    try {
      const { SyncService } = await import('./sync-service');
      const syncService = new SyncService();
      
      console.log('ğŸ”„ [MANUAL SYNC] Manual synchronization requested by admin');
      await syncService.performFullSync();
      
      // Get sync status
      const syncStatus = await syncService.getSyncStatus();
      
      res.json({
        success: true,
        message: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯',
        status: syncStatus,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('âŒ [MANUAL SYNC] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ',
        error: error.message
      });
    }
  });

  // Get sync status endpoint
  app.get("/api/admin/sync-status", requireAuth, async (req, res) => {
    try {
      const { SyncService } = await import('./sync-service');
      const syncService = new SyncService();
      
      const syncStatus = await syncService.getSyncStatus();
      
      // Get realtime triggers status
      const { RealtimeSyncTriggers } = await import('./realtime-sync-triggers');
      const triggersStatus = await RealtimeSyncTriggers.getTriggersStatus();
      
      res.json({
        success: true,
        status: syncStatus,
        realtimeTriggers: triggersStatus,
        triggersActive: triggersStatus.length > 0
      });
    } catch (error) {
      console.error('âŒ [SYNC STATUS] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ',
        error: error.message
      });
    }
  });

  // Fix all inconsistencies with ACID transactions
  app.post("/api/admin/fix-inconsistencies", requireAuth, async (req, res) => {
    try {
      const { TransactionSync } = await import('./transaction-sync');
      const result = await TransactionSync.fixAllInconsistencies();
      
      res.json({
        success: true,
        message: 'ØªÙ…Ø§Ù… ØªÙ†Ø§Ù‚Ø¶Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØµØ­ÛŒØ­ Ø´Ø¯',
        fixed: result.fixed,
        errors: result.errors
      });
    } catch (error) {
      console.error('âŒ [FIX INCONSISTENCIES] Error:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØµØ­ÛŒØ­ ØªÙ†Ø§Ù‚Ø¶Ø§Øª',
        error: error.message
      });
    }
  });

  // Ø´Ø±ÙˆØ¹ Ø³ÛŒØ³ØªÙ… ØªØ§ÛŒÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø±
  autoApprovalService.start();
  console.log("ğŸ¤– [SYSTEM] Auto-approval service started for bank transfers and payment uploads");



  // Immediate Kardex Sync Endpoint
  app.post("/api/kardex/sync", requireAuth, async (req, res) => {
    try {
      console.log("ğŸ”„ [INSTANT-SYNC] Instant kardex synchronization requested");
      
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const syncResult = await KardexSyncMaster.smartSyncShopFromKardex();
      
      console.log("âœ… [INSTANT-SYNC] Sync completed:", syncResult);
      
      res.json({
        success: true,
        message: "Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ø±Ø¯Ú©Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
        result: syncResult
      });
      
    } catch (error) {
      console.error("âŒ [INSTANT-SYNC] Sync failed:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ø±Ø¯Ú©Ø³",
        error: error.message
      });
    }
  });

  // Test payment gateway endpoint for debugging payment amounts
  app.post("/api/test-payment-gateway", async (req, res) => {
    try {
      const { amount, currency = 'IQD', orderId = 'TEST_ORDER', customerInfo } = req.body;
      
      console.log('ğŸ§ª [TEST PAYMENT] Creating test payment request:', {
        amount,
        currency,
        orderId,
        customerInfo
      });

      // Import bank gateway router
      const { BankGatewayRouter } = await import('./bank-gateway-router');
      const router = new BankGatewayRouter();

      // Create test payment request
      const testRequest = {
        orderId: orderId,
        amount: parseFloat(amount),
        currency: currency,
        customerInfo: {
          name: customerInfo?.name || 'ØªØ³Øª Ù¾Ø±Ø¯Ø§Ø®Øª',
          phone: customerInfo?.phone || '+964750000000',
          email: customerInfo?.email || 'test@momtazchem.com'
        },
        returnUrl: 'https://momtazchem.com/payment/test-callback'
      };

      // Route to active gateway
      const result = await router.routePayment(testRequest);
      
      console.log('ğŸ§ª [TEST PAYMENT] Payment routing result:', result);

      if (result.success) {
        res.json({
          success: true,
          paymentUrl: result.paymentUrl,
          transactionId: result.transactionId,
          gateway: result.gateway || 'Test Gateway',
          amount: testRequest.amount,
          currency: testRequest.currency,
          message: 'ØªØ³Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯'
        });
      } else {
        res.status(400).json({
          success: false,
          message: result.message || 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØ³Øª Ù¾Ø±Ø¯Ø§Ø®Øª'
        });
      }

    } catch (error) {
      console.error('ğŸ§ª [TEST PAYMENT ERROR]:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø³Ø±ÙˆÛŒØ³ ØªØ³Øª Ù¾Ø±Ø¯Ø§Ø®Øª',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // TEST ENDPOINT: Validate workflow protection system
  app.get("/api/test/workflow-protection", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ§ª [WORKFLOW TEST] Testing auto-sync protection system...');
      
      const { SyncService } = await import("./sync-service");
      const syncService = new SyncService();
      
      // Test the protection for manually approved orders M2511248 and M2511258
      const testOrders = [77, 82]; // customerOrderIds for M2511248 and M2511258
      const results: any[] = [];
      
      for (const customerOrderId of testOrders) {
        try {
          console.log(`ğŸ” [WORKFLOW TEST] Testing order ${customerOrderId}...`);
          
          // This should NOT change the status since orders are manually approved
          await syncService.syncSpecificOrder(customerOrderId);
          
          results.push({
            customerOrderId,
            tested: true,
            protected: true,
            message: `Order ${customerOrderId} protected from auto-sync`
          });
          
        } catch (error) {
          results.push({
            customerOrderId,
            tested: true,
            protected: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }
      
      console.log('ğŸ§ª [WORKFLOW TEST] Protection test completed');
      
      res.json({
        success: true,
        message: 'Ø³ÛŒØ³ØªÙ… Ø­ÙØ§Ø¸Øª Ú¯Ø±Ø¯Ø´ Ú©Ø§Ø± ØªØ³Øª Ø´Ø¯',
        results,
        protectionActive: true,
        testedAt: new Date()
      });
      
    } catch (error) {
      console.error('ğŸ§ª [WORKFLOW TEST ERROR]:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø³ÛŒØ³ØªÙ… Ø­ÙØ§Ø¸Øª',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // ORDER SYNCHRONIZATION DIAGNOSTIC ENDPOINTS
  // =============================================================================
  
  // Diagnostic endpoint to check order synchronization status
  app.get("/api/admin/sync/diagnostic", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ” [SYNC DIAGNOSTIC] Starting order synchronization diagnostic...');
      
      const { pool } = await import('./db');
      
      // Check total orders in customer_orders
      const customerOrdersResult = await pool.query(`
        SELECT COUNT(*) as total_customer_orders
        FROM customer_orders
      `);
      
      // Check total orders in order_management  
      const orderManagementResult = await pool.query(`
        SELECT COUNT(*) as total_order_management
        FROM order_management
      `);
      
      // Check for missing order_management records (orphaned customer_orders)
      const missingManagementResult = await pool.query(`
        SELECT co.id, co.order_number, co.status, co.payment_status
        FROM customer_orders co
        LEFT JOIN order_management om ON co.id = om.customer_order_id
        WHERE om.customer_order_id IS NULL
        ORDER BY co.id DESC
        LIMIT 10
      `);
      
      // Check for missing customer_orders records (orphaned order_management)
      const orphanedManagementResult = await pool.query(`
        SELECT om.id, om.customer_order_id, om.current_status
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE co.id IS NULL
        ORDER BY om.id DESC
        LIMIT 10
      `);
      
      // Check status distribution in order_management
      const statusDistributionResult = await pool.query(`
        SELECT current_status, COUNT(*) as count
        FROM order_management
        GROUP BY current_status
        ORDER BY count DESC
      `);
      
      // Check recent orders by department
      const financialOrdersResult = await pool.query(`
        SELECT COUNT(*) as count
        FROM order_management
        WHERE current_status IN (
          'pending', 'pending_payment', 'payment_uploaded', 
          'financial_reviewing', 'financial_rejected',
          'warehouse_pending', 'warehouse_processing', 'warehouse_approved'
        )
      `);
      
      const warehouseOrdersResult = await pool.query(`
        SELECT COUNT(*) as count
        FROM order_management
        WHERE current_status IN (
          'warehouse_pending', 'financial_approved', 'warehouse_notified',
          'warehouse_processing', 'warehouse_verified', 'warehouse_rejected'
        )
      `);
      
      const logisticsOrdersResult = await pool.query(`
        SELECT COUNT(*) as count
        FROM order_management
        WHERE current_status IN (
          'warehouse_pending', 'warehouse_approved', 'logistics_assigned',
          'logistics_processing', 'logistics_dispatched'
        )
      `);
      
      const diagnostic = {
        summary: {
          totalCustomerOrders: parseInt(customerOrdersResult.rows[0].total_customer_orders),
          totalOrderManagement: parseInt(orderManagementResult.rows[0].total_order_management),
          missingManagementRecords: missingManagementResult.rows.length,
          orphanedManagementRecords: orphanedManagementResult.rows.length
        },
        departmentCounts: {
          financial: parseInt(financialOrdersResult.rows[0].count),
          warehouse: parseInt(warehouseOrdersResult.rows[0].count),
          logistics: parseInt(logisticsOrdersResult.rows[0].count)
        },
        statusDistribution: statusDistributionResult.rows,
        issues: {
          missingManagementRecords: missingManagementResult.rows,
          orphanedManagementRecords: orphanedManagementResult.rows
        }
      };
      
      console.log('ğŸ” [SYNC DIAGNOSTIC] Results:', diagnostic);
      
      res.json({
        success: true,
        diagnostic
      });
    } catch (error) {
      console.error('ğŸ” [SYNC DIAGNOSTIC ERROR]:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ´Ø®ÛŒØµ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });
  
  // Force synchronization for all orders
  app.post("/api/admin/sync/force", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ”„ [FORCE SYNC] Starting forced synchronization...');
      
      const { SyncService } = await import("./sync-service");
      const syncService = new SyncService();
      
      // Force a full synchronization
      await syncService.performFullSync();
      
      res.json({
        success: true,
        message: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯'
      });
    } catch (error) {
      console.error('ğŸ”„ [FORCE SYNC ERROR]:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });
  
  // Manual order transfer between departments
  app.post("/api/admin/sync/transfer-orders", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log('ğŸ”„ [MANUAL TRANSFER] Starting manual order transfer...');
      
      const { pool } = await import('./db');
      
      // Transfer financial_approved orders to warehouse
      const financialToWarehouse = await pool.query(`
        UPDATE order_management 
        SET current_status = 'warehouse_pending'
        WHERE current_status = 'financial_approved'
        AND financial_reviewed_at IS NOT NULL
        RETURNING customer_order_id, current_status
      `);
      
      // Transfer warehouse_approved orders to logistics
      const warehouseToLogistics = await pool.query(`
        UPDATE order_management 
        SET current_status = 'logistics_assigned'
        WHERE current_status = 'warehouse_approved'
        AND warehouse_processed_at IS NOT NULL
        RETURNING customer_order_id, current_status
      `);
      
      // AUTO-CONVERT PROFORMA TO FINAL INVOICE WHEN ORDERS LEAVE WAREHOUSE
      // This implements the business rule: all orders convert to final invoice when leaving warehouse
      if (warehouseToLogistics.rows.length > 0) {
        console.log(`ğŸ“„ [WAREHOUSE EXIT] Converting ${warehouseToLogistics.rows.length} orders from proforma to final invoice as they leave warehouse`);
        
        for (const row of warehouseToLogistics.rows) {
          try {
            // Convert proforma to final invoice for ALL orders leaving warehouse
            await pool.query(`
              UPDATE customer_orders 
              SET 
                invoice_type = 'official_invoice',
                invoice_converted_at = NOW(),
                updated_at = NOW()
              WHERE id = $1
              AND (invoice_type IS NULL OR invoice_type != 'official_invoice')
            `, [row.customer_order_id]);
            
            // Get order number for logging
            const orderInfo = await pool.query(`
              SELECT order_number FROM customer_orders WHERE id = $1
            `, [row.customer_order_id]);
            
            if (orderInfo.rows.length > 0) {
              console.log(`âœ… [INVOICE CONVERT] Order ${orderInfo.rows[0].order_number} converted from proforma to final invoice upon warehouse exit`);
            }
          } catch (error) {
            console.error(`âŒ [INVOICE CONVERT] Error converting order ${row.customer_order_id}:`, error);
          }
        }
      }
      
      console.log(`ğŸ”„ [MANUAL TRANSFER] Transferred ${financialToWarehouse.rows.length} orders from finance to warehouse`);
      console.log(`ğŸ”„ [MANUAL TRANSFER] Transferred ${warehouseToLogistics.rows.length} orders from warehouse to logistics`);
      
      res.json({
        success: true,
        message: `Ø§Ù†ØªÙ‚Ø§Ù„ Ø¯Ø³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯: ${financialToWarehouse.rows.length} Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø±ØŒ ${warehouseToLogistics.rows.length} Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ù„Ø¬Ø³ØªÛŒÚ©`,
        transfers: {
          financeToWarehouse: financialToWarehouse.rows.length,
          warehouseToLogistics: warehouseToLogistics.rows.length
        }
      });
    } catch (error) {
      console.error('ğŸ”„ [MANUAL TRANSFER ERROR]:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ù†ØªÙ‚Ø§Ù„ Ø¯Ø³ØªÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Check current order status distribution
  app.get("/api/admin/orders/status-distribution", requireAuth, async (req: Request, res: Response) => {
    try {
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          current_status,
          COUNT(*) as count,
          COUNT(CASE WHEN financial_reviewed_at IS NOT NULL THEN 1 END) as financial_processed,
          COUNT(CASE WHEN warehouse_processed_at IS NOT NULL THEN 1 END) as warehouse_processed,
          COUNT(CASE WHEN logistics_processed_at IS NOT NULL THEN 1 END) as logistics_processed
        FROM order_management
        GROUP BY current_status
        ORDER BY count DESC
      `);
      
      res.json({
        success: true,
        distribution: result.rows
      });
    } catch (error) {
      console.error('ğŸ“Š [STATUS DISTRIBUTION ERROR]:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙˆØ²ÛŒØ¹ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // WEBRTC ROUTES
  // =============================================================================
  
  // WebRTC Rooms Management
  app.get("/api/webrtc/rooms", async (req: Request, res: Response) => {
    try {
      console.log("ğŸ“‹ [WebRTC] Getting rooms list");
      const roomsResult = await db.select().from(webrtcRooms)
        .where(eq(webrtcRooms.isActive, true))
        .orderBy(desc(webrtcRooms.createdAt));

      const roomsWithCounts = await Promise.all(
        roomsResult.map(async (room) => {
          const participantsResult = await db.select().from(roomParticipants)
            .where(and(
              eq(roomParticipants.roomId, room.id),
              isNull(roomParticipants.leftAt)
            ));
          
          return {
            ...room,
            participantCount: participantsResult.length
          };
        })
      );

      console.log(`ğŸ“‹ [WebRTC] Found ${roomsWithCounts.length} active rooms`);
      res.json({
        success: true,
        data: roomsWithCounts
      });
    } catch (error) {
      console.error("âŒ [WebRTC] Get rooms error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get rooms"
      });
    }
  });

  app.post("/api/webrtc/rooms", async (req: Request, res: Response) => {
    try {
      console.log("ğŸ—ï¸ [WebRTC] Creating new room:", req.body);
      const { name, description, maxParticipants, createdBy } = req.body;
      
      const roomId = `room_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const room = {
        id: roomId,
        name,
        description: description || "",
        createdBy,
        maxParticipants: maxParticipants || 10,
        isActive: true,
        settings: {},
        createdAt: new Date(),
        updatedAt: new Date()
      };

      await db.insert(webrtcRooms).values(room);
      
      console.log("âœ… [WebRTC] Room created:", roomId);
      res.json({
        success: true,
        data: room
      });
    } catch (error) {
      console.error("âŒ [WebRTC] Create room error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create room"
      });
    }
  });

  // Test route to verify routing works
  app.get("/api/webrtc/test", (req: Request, res: Response) => {
    console.log("ğŸ§ª [WebRTC] Test route called");
    res.json({ success: true, message: "WebRTC routing works!" });
  });

  // Test endpoint to verify ALL orders are being returned (public for testing)
  app.get('/api/test/order-count', async (req, res) => {
    try {
      console.log('ğŸ” [TEST ORDER COUNT] Checking order counts in database...');
      
      const result = await customerPool.query(`SELECT COUNT(*) as total_orders FROM customer_orders`);
      
      const trackingResult = await customerPool.query(`
        SELECT 
          COUNT(*) as tracking_orders,
          COUNT(CASE WHEN co.status = 'deleted' THEN 1 END) as deleted_orders,
          COUNT(CASE WHEN co.status = 'cancelled' THEN 1 END) as cancelled_orders,
          MIN(co.order_number) as first_order_number,
          MAX(co.order_number) as last_order_number
        FROM customer_orders co
        LEFT JOIN order_management om ON co.id = om.customer_order_id
      `);
      
      const data = {
        totalOrdersInDatabase: parseInt(result.rows[0].total_orders),
        trackingOrdersCount: parseInt(trackingResult.rows[0].tracking_orders),
        deletedOrders: parseInt(trackingResult.rows[0].deleted_orders || 0),
        cancelledOrders: parseInt(trackingResult.rows[0].cancelled_orders || 0),
        firstOrderNumber: trackingResult.rows[0].first_order_number,
        lastOrderNumber: trackingResult.rows[0].last_order_number,
        shouldShowAllOrders: true,
        message: 'ALL orders should be visible now (including deleted/cancelled)'
      };
      
      console.log('âœ… [TEST ORDER COUNT] Results:', data);
      res.json({ success: true, data });
    } catch (error) {
      console.error('âŒ [TEST ORDER COUNT] Error:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // Initialize WebRTC Socket
  const { setupWebRTCSocket } = await import("./webrtc-socket");
  setupWebRTCSocket(httpServer);
  console.log("ğŸ”Œ [WebRTC] Routes and Socket initialized");

  // Catch-all for unmatched API routes - return JSON 404 (must be last)
  app.all('/api/*', (req, res) => {
    console.log(`âŒ 404 - Unmatched API route: ${req.method} ${req.originalUrl}`);
    res.status(404).json({
      success: false,
      message: 'API endpoint not found',
      path: req.originalUrl,
      method: req.method
    });
  });

  return httpServer;
}

