import express, { type Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import bcrypt from "bcryptjs";
import multer from "multer";
import path from "path";
import fs from "fs";
import puppeteer from "puppeteer";
import nodemailer from "nodemailer";
import crypto from "crypto";
import { emailService } from "./email-service";
import { storage } from "./storage";
import { insertLeadSchema, insertLeadActivitySchema } from "@shared/schema";
import { insertContactSchema, insertShowcaseProductSchema, showcaseProducts } from "@shared/showcase-schema";
import { simpleCustomerStorage } from "./simple-customer-storage";
import { shopStorage } from "./shop-storage";
import { customerStorage } from "./customer-storage";
import { customerAddressStorage } from "./customer-address-storage";
import { emailStorage } from "./email-storage";
import { crmStorage } from "./crm-storage";
import { customerCommunicationStorage } from "./customer-communication-storage";
import { crmDb } from "./crm-db";
import { smsStorage } from "./sms-storage";
import { SimpleSmsStorage, simpleSmsStorage, simpleSmsDb } from "./simple-sms-storage";
import { widgetRecommendationStorage } from "./widget-recommendation-storage";
import { orderManagementStorage } from "./order-management-storage";
import { walletStorage } from "./wallet-storage";
import { requireDepartment, attachUserDepartments } from "./department-auth";
import { insertCustomerInquirySchema, insertEmailTemplateSchema, insertCustomerSchema, insertCustomerAddressSchema, walletRechargeRequests, customerOrders, orderItems } from "@shared/customer-schema";
import { customerDb, customerPool } from "./customer-db";
import { insertEmailCategorySchema, insertSmtpSettingSchema, insertEmailRecipientSchema, smtpConfigSchema, emailLogs, emailCategories, smtpSettings, emailRecipients, categoryEmailAssignments, insertCategoryEmailAssignmentSchema } from "@shared/email-schema";
import { insertShopProductSchema, insertShopCategorySchema, paymentGateways, orders, shopProducts } from "@shared/shop-schema";
import { sendContactEmail } from "./email";
import TemplateProcessor from "./template-processor";
import InventoryAlertService from "./inventory-alerts";
import { db } from "./db";
import { sql, eq, and, or, isNull, isNotNull, desc, gte } from "drizzle-orm";
import { z } from "zod";
import * as schema from "@shared/schema";
const { crmCustomers } = schema;
import { orderManagement, shippingRates, vatSettings, deliveryMethods } from "@shared/order-management-schema";
import { generateEAN13Barcode, validateEAN13, parseEAN13Barcode, isMomtazchemBarcode } from "@shared/barcode-utils";
import { generateSmartSKU, validateSKUUniqueness } from "./ai-sku-generator";
import { deliveryVerificationStorage } from "./delivery-verification-storage";
import { gpsDeliveryStorage } from "./gps-delivery-storage";
import { insertGpsDeliveryConfirmationSchema } from "@shared/gps-delivery-schema";
// SMS service will be imported dynamically when needed
import { ticketingStorage } from "./ticketing-storage";
import { getLocalizedMessage, getLocalizedEmailSubject, generateSMSMessage } from "./multilingual-messages";
import { supportTickets } from "../shared/ticketing-schema";
import { 
  insertSupportTicketSchema, 
  insertTicketResponseSchema,
  type SupportTicket,
  type TicketResponse,
  TICKET_PRIORITIES,
  TICKET_STATUSES,
  TICKET_CATEGORIES
} from "@shared/ticketing-schema";
import { cartStorage } from "./cart-storage";
import { 
  cartSessions, 
  abandonedCartSettings, 
  abandonedCartNotifications,
  type CartSession,
  type AbandonedCartSettings,
  type AbandonedCartNotification
} from "@shared/cart-schema";
import { gpsDeliveryStorage } from "./gps-delivery-storage";
import { logisticsStorage } from "./logistics-storage";
import { 
  transportationCompanies,
  deliveryVehicles,
  deliveryPersonnel,
  deliveryRoutes,
  deliveryVerificationCodes,
  logisticsAnalytics,
  insertTransportationCompanySchema,
  insertDeliveryVehicleSchema,
  insertDeliveryPersonnelSchema,
  insertDeliveryRouteSchema,
  insertDeliveryVerificationCodeSchema,
  type TransportationCompany,
  type DeliveryVehicle,
  type DeliveryPersonnel,
  type DeliveryRoute,
  type DeliveryVerificationCode,
  VEHICLE_TYPES,
  DELIVERY_STATUS,
  ROUTE_STATUS,
  SMS_STATUS
} from "@shared/logistics-schema";
import { 
  gpsDeliveryConfirmations,
  gpsDeliveryAnalytics,
  insertGpsDeliveryConfirmationSchema,
  insertGpsDeliveryAnalyticsSchema,
  type GpsDeliveryConfirmation,
  type GpsDeliveryAnalytics
} from "@shared/gps-delivery-schema";

// Extend session type to include admin user and customer user
declare module "express-session" {
  interface SessionData {
    adminId?: number;
    customerId?: number;
    isAuthenticated?: boolean;
    departmentUser?: {
      id: number;
      username: string;
      department: string;
    };
  }
}

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(process.cwd(), 'uploads');
const imagesDir = path.join(uploadsDir, 'images');
const catalogsDir = path.join(uploadsDir, 'catalogs');
const documentsDir = path.join(uploadsDir, 'documents');
const receiptsDir = path.join(uploadsDir, 'receipts');

[uploadsDir, imagesDir, catalogsDir, documentsDir, receiptsDir].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Multer configuration for image uploads
const imageStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, imagesDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `product-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

// Multer configuration for catalog uploads
const catalogStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, catalogsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `catalog-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadImage = multer({
  storage: imageStorage,
  limits: {
    fileSize: 2 * 1024 * 1024, // 2MB limit - optimized for web display
  },
  fileFilter: (req, file, cb) => {
    // Allow only optimal image formats for web display
    const allowedMimeTypes = [
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/webp'
    ];
    
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only JPEG, PNG, and WebP images are allowed for optimal customer display'));
    }
  }
});

const uploadCatalog = multer({
  storage: catalogStorage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Only PDF files are allowed'));
    }
  }
});

// MSDS upload configuration
const msdsDir = path.join(process.cwd(), 'uploads', 'msds');
if (!fs.existsSync(msdsDir)) {
  fs.mkdirSync(msdsDir, { recursive: true });
}

const msdsStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, msdsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `msds-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadMsds = multer({
  storage: msdsStorage,
  limits: {
    fileSize: 15 * 1024 * 1024, // 15MB limit for MSDS files
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Only PDF files are allowed for MSDS uploads'));
    }
  }
});

// Multer configuration for document uploads
const documentStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, documentsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// Receipt upload configuration
const receiptStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, receiptsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `receipt-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const uploadReceipt = multer({
  storage: receiptStorage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit for receipts
  },
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'application/pdf'
    ];
    
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only JPEG, PNG, and PDF files are allowed for receipt uploads'));
    }
  }
});

const upload = multer({
  storage: documentStorage,
  limits: {
    fileSize: 20 * 1024 * 1024, // 20MB limit
  },
  fileFilter: (req, file, cb) => {
    // Allow common document types
    const allowedTypes = [
      'application/pdf',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
      'application/vnd.openxmlformats-officedocument.presentationml.presentation', // .pptx
      'text/plain',
      'image/png',
      'image/jpeg',
      'image/jpg'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('File type not allowed'));
    }
  }
});

// Admin authentication middleware
const requireAuth = async (req: Request, res: Response, next: NextFunction) => {
  console.log(`ðŸ” [AUTH DEBUG] ${req.method} ${req.path}`);
  console.log(`ðŸ” [AUTH DEBUG] Session:`, {
    exists: !!req.session,
    isAuthenticated: req.session?.isAuthenticated,
    adminId: req.session?.adminId,
    customUserId: req.session?.customUserId,
    sessionID: req.sessionID
  });

  // Check for valid authentication - either admin or custom user
  if (req.session && req.session.isAuthenticated === true) {
    if (req.session.adminId) {
      console.log(`âœ… Admin authentication successful for admin ${req.session.adminId}`);
      console.log(`ðŸ”„ Dual session mode: Admin=${req.session.adminId}, Customer=${req.session.customerId || 'none'}`);
      next();
    } else if (req.session.customUserId) {
      console.log(`âœ… Custom user authentication successful for user ${req.session.customUserId}`);
      next();
    } else {
      console.log('âŒ Authentication failed - no valid user ID in session');
      res.status(401).json({ 
        success: false, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" 
      });
    }
  } else {
    console.log('âŒ Admin authentication failed for:', req.path);
    console.log('âŒ Session details:', {
      isAuthenticated: req.session?.isAuthenticated,
      adminId: req.session?.adminId,
      customUserId: req.session?.customUserId,
      customerId: req.session?.customerId
    });
    
    // If only customer session exists, show specific error
    if (req.session?.customerId && !req.session?.adminId && !req.session?.customUserId) {
      return res.status(403).json({ 
        success: false, 
        message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¨Ø®Ø´ Ù…Ø¯ÛŒØ±ÛŒØª Ù†ÛŒØ§Ø² Ø¨Ù‡ ÙˆØ±ÙˆØ¯ Ù…Ø¯ÛŒØ± Ø¯Ø§Ø±Ø¯" 
      });
    }
    
    res.status(401).json({ 
      success: false, 
      message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" 
    });
  }
};

// Customer authentication middleware with improved error handling  
const requireCustomerAuth = (req: Request, res: Response, next: NextFunction) => {
  try {
    if (req.session && req.session.customerId) {
      next();
    } else {
      console.log('Customer authentication failed for:', req.originalUrl);
      res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
    }
  } catch (error) {
    console.error('Customer authentication middleware error:', error);
    res.status(500).json({
      success: false,
      message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒ"
    });
  }
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Import department auth functions
  const { attachUserDepartments, requireDepartment } = await import("./department-auth");
  
  // Create requireAdmin alias for better semantics
  const requireAdmin = requireAuth;
  
  // Add department middleware to all authenticated routes (excluding ticket creation for guest access)
  app.use('/api', (req, res, next) => {
    // Skip auth middleware for ticket creation to allow guest access
    if (req.path === '/tickets' && req.method === 'POST') {
      return next();
    }
    // Skip middleware for test endpoints
    if (req.path.startsWith('/test/') || req.path.startsWith('/analytics/')) {
      return next();
    }
    // Skip middleware for warehouse order management endpoints
    if (req.path.startsWith('/order-management/warehouse/')) {
      return next();
    }
    attachUserDepartments(req, res, next);
  });
  
  // Serve static files from attached_assets directory
  app.use('/attached_assets', express.static(path.join(process.cwd(), 'attached_assets')));
  
  // Serve static files from uploads directory
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

  // ============================================
  // START: Documentation PDF Generation Routes
  // ============================================

  // Generate User Documentation PDF
  app.get("/api/documentation/user/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating User Documentation with PDFMake');
      const { generateDocumentationPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateDocumentationPDFWithPDFMake('User Guide', language);
      
      const filename = language === 'fa' ? 
        'Momtazchem-User-Guide-Persian.pdf' : 
        'Momtazchem-User-Guide-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating user documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate user documentation PDF' });
    }
  });

  // Generate Admin Documentation PDF
  app.get("/api/documentation/admin/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Admin Documentation with PDFMake');
      const { generateDocumentationPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateDocumentationPDFWithPDFMake('Admin Guide', language);
      
      const filename = language === 'fa' ? 
        'Momtazchem-Admin-Guide-Persian.pdf' : 
        'Momtazchem-Admin-Guide-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating admin documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate admin documentation PDF' });
    }
  });

  // Generate Technical Documentation PDF
  app.get("/api/documentation/technical/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Technical Documentation with PDFMake');
      const { generateDocumentationPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateDocumentationPDFWithPDFMake('Technical Documentation', language);
      
      const filename = language === 'fa' ? 
        'Momtazchem-Technical-Guide-Persian.pdf' : 
        'Momtazchem-Technical-Guide-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating technical documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate technical documentation PDF' });
    }
  });

  // Generate Complete Documentation PDF
  app.get("/api/documentation/complete/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Complete Documentation with PDFMake');
      const { generateDocumentationPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateDocumentationPDFWithPDFMake('Complete Documentation', language);
      
      const filename = language === 'fa' ? 
        'Momtazchem-Complete-Documentation-Persian.pdf' : 
        'Momtazchem-Complete-Documentation-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating complete documentation PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate complete documentation PDF' });
    }
  });

  // Generate Project Proposal PDF
  app.get("/api/documentation/proposal/:language", async (req: Request, res: Response) => {
    try {
      const { language } = req.params;
      if (!['en', 'fa'].includes(language)) {
        return res.status(400).json({ success: false, message: 'Invalid language. Use "en" or "fa".' });
      }
      
      console.log('Generating Project Proposal with PDFMake');
      const { generateDocumentationPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateDocumentationPDFWithPDFMake('Project Proposal', language);
      
      const filename = language === 'fa' ? 
        'Momtazchem-Project-Proposal-Persian.pdf' : 
        'Momtazchem-Project-Proposal-English.pdf';
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error('Error generating project proposal PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate project proposal PDF' });
    }
  });

  // =============================================================================
  // API MIDDLEWARE - ENSURE ALL /api ROUTES RETURN JSON
  // =============================================================================
  
  // Middleware to ensure all API routes return JSON (not HTML)
  app.use('/api/*', (req, res, next) => {
    // Set Content-Type header to application/json for all API routes
    res.setHeader('Content-Type', 'application/json');
    
    // Override the default error handling to always return JSON
    const originalSend = res.send;
    res.send = function(data) {
      // If data is a string that looks like HTML, convert to JSON error
      if (typeof data === 'string' && data.includes('<!DOCTYPE html>')) {
        return originalSend.call(this, JSON.stringify({
          success: false,
          message: 'API endpoint not found',
          error: 'This endpoint should return JSON, not HTML'
        }));
      }
      return originalSend.call(this, data);
    };
    
    next();
  });

  // =============================================================================
  // HEALTH CHECK API
  // =============================================================================
  
  // Health check endpoint - must return JSON
  app.get("/api/health", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Test database connection
      const dbResult = await pool.query('SELECT 1 as healthy');
      const dbHealthy = dbResult.rows[0]?.healthy === 1;
      
      const status = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        services: {
          database: dbHealthy ? 'healthy' : 'unhealthy',
          server: 'healthy'
        }
      };
      
      res.json(status);
    } catch (error) {
      console.error('Health check failed:', error);
      res.status(500).json({
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        error: error.message,
        services: {
          database: 'unhealthy',
          server: 'healthy'
        }
      });
    }
  });

  // =============================================================================
  // AI SETTINGS API
  // =============================================================================
  
  // Save AI Settings
  app.post("/api/ai/settings", requireAuth, async (req, res) => {
    try {
      const { apiKey, secretKey, model, maxTokens, temperature, aiEnabled, skuGeneration, smartRecommendations } = req.body;
      
      // For now, store in memory/localStorage equivalent
      // In production, this would be stored in database
      const settings = {
        apiKey: apiKey || "",
        secretKey: secretKey || "",
        model: model || "gpt-4o",
        maxTokens: maxTokens || 1000,
        temperature: temperature || 0.7,
        aiEnabled: aiEnabled !== false,
        skuGeneration: skuGeneration !== false,
        smartRecommendations: smartRecommendations !== false,
        updatedAt: new Date()
      };
      
      res.json({ success: true, settings });
    } catch (error) {
      console.error("Error saving AI settings:", error);
      res.status(500).json({ message: "Failed to save AI settings" });
    }
  });

  // Test AI Connection
  app.post("/api/ai/test-connection", requireAuth, async (req, res) => {
    try {
      // Mock successful connection test
      res.json({ 
        success: true, 
        model: "gpt-4o",
        status: "connected",
        timestamp: new Date()
      });
    } catch (error) {
      console.error("Error testing AI connection:", error);
      res.status(500).json({ message: "Failed to test AI connection" });
    }
  });

  // =============================================================================
  // AI SEO GENERATOR API
  // =============================================================================
  
  // Generate AI-powered SEO content
  app.post("/api/ai/seo/generate", requireAuth, async (req, res) => {
    try {
      const { generateAISeoContent } = await import('./ai-seo-generator.ts');
      const seoRequest = req.body;
      
      // Validate required fields
      if (!seoRequest.pageType || !seoRequest.language) {
        return res.status(400).json({
          success: false,
          message: 'Page type and language are required'
        });
      }
      
      const seoContent = await generateAISeoContent(seoRequest);
      
      res.json({
        success: true,
        data: seoContent,
        message: 'AI SEO content generated successfully'
      });
    } catch (error) {
      console.error('Error generating AI SEO content:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate AI SEO content: ' + error.message
      });
    }
  });

  // Analyze SEO performance
  app.post("/api/ai/seo/analyze", requireAuth, async (req, res) => {
    try {
      const { analyzeSeoPerformance } = await import('./ai-seo-generator.ts');
      const { url, targetKeywords } = req.body;
      
      if (!url || !targetKeywords) {
        return res.status(400).json({
          success: false,
          message: 'URL and target keywords are required'
        });
      }
      
      const analysis = await analyzeSeoPerformance(url, targetKeywords);
      
      res.json({
        success: true,
        data: analysis,
        message: 'SEO analysis completed successfully'
      });
    } catch (error) {
      console.error('Error analyzing SEO performance:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to analyze SEO performance: ' + error.message
      });
    }
  });

  // Generate keyword suggestions
  app.post("/api/ai/seo/keywords", requireAuth, async (req, res) => {
    try {
      const { generateKeywordSuggestions } = await import('./ai-seo-generator.ts');
      const { seedKeywords, language, industry } = req.body;
      
      if (!seedKeywords || !Array.isArray(seedKeywords)) {
        return res.status(400).json({
          success: false,
          message: 'Seed keywords array is required'
        });
      }
      
      const suggestions = await generateKeywordSuggestions(seedKeywords, language, industry);
      
      res.json({
        success: true,
        data: suggestions,
        message: 'Keyword suggestions generated successfully'
      });
    } catch (error) {
      console.error('Error generating keyword suggestions:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate keyword suggestions: ' + error.message
      });
    }
  });

  // Optimize content for SEO
  app.post("/api/ai/seo/optimize", requireAuth, async (req, res) => {
    try {
      const { optimizeContentForSeo } = await import('./ai-seo-generator.ts');
      const { content, targetKeywords, language } = req.body;
      
      if (!content || !targetKeywords) {
        return res.status(400).json({
          success: false,
          message: 'Content and target keywords are required'
        });
      }
      
      const optimization = await optimizeContentForSeo(content, targetKeywords, language);
      
      res.json({
        success: true,
        data: optimization,
        message: 'Content optimized successfully'
      });
    } catch (error) {
      console.error('Error optimizing content:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to optimize content: ' + error.message
      });
    }
  });

  // Generate bulk SEO content
  app.post("/api/ai/seo/bulk-generate", requireAuth, async (req, res) => {
    try {
      const { generateBulkSeoContent } = await import('./ai-seo-generator.ts');
      const { pages } = req.body;
      
      if (!pages || !Array.isArray(pages)) {
        return res.status(400).json({
          success: false,
          message: 'Pages array is required'
        });
      }
      
      const results = await generateBulkSeoContent(pages);
      
      res.json({
        success: true,
        data: results,
        message: `Bulk SEO content generated for ${results.length} pages`
      });
    } catch (error) {
      console.error('Error generating bulk SEO content:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate bulk SEO content: ' + error.message
      });
    }
  });

  // =============================================================================
  // AI PRODUCT RECOMMENDATIONS API
  // =============================================================================
  
  // Generate AI-powered product recommendations
  app.post('/api/recommendations/analyze', async (req, res) => {
    try {
      const { getAIProductRecommendations } = await import('./ai-recommendations.ts');
      
      const recommendationRequest = req.body;
      
      // Validate required fields
      if (!recommendationRequest.industry || !recommendationRequest.application || !recommendationRequest.requirements) {
        return res.status(400).json({
          success: false,
          message: 'Industry, application, and requirements are required fields'
        });
      }

      const recommendations = await getAIProductRecommendations(recommendationRequest);
      
      res.json({
        success: true,
        data: recommendations
      });
    } catch (error) {
      console.error('Recommendation API Error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to generate recommendations'
      });
    }
  });

  // Generate follow-up recommendations based on additional information
  app.post('/api/recommendations/follow-up', async (req, res) => {
    try {
      const { generateFollowUpRecommendations } = await import('./ai-recommendations.ts');
      
      const { originalRequest, previousRecommendations, newInformation } = req.body;
      
      if (!originalRequest || !previousRecommendations || !newInformation) {
        return res.status(400).json({
          success: false,
          message: 'Original request, previous recommendations, and new information are required'
        });
      }

      const updatedRecommendations = await generateFollowUpRecommendations(
        originalRequest,
        previousRecommendations,
        newInformation
      );
      
      res.json({
        success: true,
        data: updatedRecommendations
      });
    } catch (error) {
      console.error('Follow-up Recommendation API Error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to generate follow-up recommendations'
      });
    }
  });

  // API endpoint to get active users count
  app.get("/api/active-users", requireAuth, async (req: Request, res: Response) => {
    try {
      // Simple active users tracking - show current admin session
      const activeUsersData = {
        totalActiveSessions: 1,
        activeUsersCount: 1,
        activeUsers: [
          {
            id: req.session.adminId,
            username: 'Admin',
            lastActivity: new Date().toISOString(),
            sessionId: req.sessionID
          }
        ],
        lastUpdated: new Date().toISOString()
      };
      
      res.json({
        success: true,
        data: activeUsersData
      });
    } catch (error) {
      console.error("Error fetching active users:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch active users",
        data: {
          totalActiveSessions: 0,
          activeUsersCount: 0,
          activeUsers: [],
          lastUpdated: new Date().toISOString()
        }
      });
    }
  });

  // Admin authentication routes
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Username and password are required" 
        });
      }

      let user = null;
      let isCustomUser = false;

      // First check standard users table
      user = await storage.getUserByUsername(username);
      
      if (!user) {
        // Check custom_users table
        const { pool } = await import('./db');
        const result = await pool.query(`
          SELECT id, full_name, email, password_hash, role_id, is_active
          FROM custom_users 
          WHERE email = $1 AND is_active = true
        `, [username]);
        
        if (result.rows.length > 0) {
          const customUser = result.rows[0];
          user = {
            id: customUser.id,
            username: customUser.email,
            email: customUser.email,
            passwordHash: customUser.password_hash,
            roleId: customUser.role_id,
            isActive: customUser.is_active
          };
          isCustomUser = true;
          console.log(`ðŸ” Found custom user:`, { id: user.id, email: user.email, roleId: user.roleId });
        }
      }
      
      if (!user) {
        console.log(`âŒ No user found for username: ${username}`);
        return res.status(401).json({ 
          success: false, 
          message: "Invalid credentials" 
        });
      }

      console.log(`ðŸ” Found ${isCustomUser ? 'custom' : 'standard'} user:`, { 
        id: user.id, 
        email: user.email, 
        hasPasswordHash: !!user.passwordHash,
        roleId: user.roleId
      });

      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      console.log(`ðŸ” Password validation result: ${isValidPassword}`);
      
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid credentials" 
        });
      }

      // Clear any existing customer session first (single session mode)
      req.session.customerId = undefined;
      req.session.customerEmail = undefined;
      req.session.crmCustomerId = undefined;
      
      // Set up session with appropriate user type
      if (isCustomUser) {
        req.session.customUserId = user.id;
        req.session.isAuthenticated = true;
        console.log(`âœ… [LOGIN] Session configured for custom user ${user.id} (customer session cleared):`, {
          customUserId: req.session.customUserId,
          isAuthenticated: req.session.isAuthenticated,
          sessionId: req.sessionID
        });
      } else {
        req.session.adminId = user.id;
        req.session.isAuthenticated = true;
        console.log(`âœ… [LOGIN] Session configured for admin ${user.id} (customer session cleared):`, {
          adminId: req.session.adminId,
          isAuthenticated: req.session.isAuthenticated,
          sessionId: req.sessionID
        });
      }
      
      // Send response immediately without waiting for session save
      res.json({ 
        success: true, 
        message: "Login successful",
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email, 
          roleId: user.roleId,
          userType: isCustomUser ? 'custom' : 'admin'
        }
      });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });


  app.post("/api/admin/logout", (req, res) => {
    // Clear all session data (single session mode)
    req.session.adminId = undefined;
    req.session.customUserId = undefined;
    req.session.customerId = undefined;
    req.session.customerEmail = undefined;
    req.session.crmCustomerId = undefined;
    req.session.isAuthenticated = undefined;
    
    // Always destroy entire session for clean logout
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ 
          success: false, 
          message: "Could not log out" 
        });
      }
      console.log('ðŸ”„ Complete admin logout - all sessions cleared');
      res.json({ success: true, message: "Logged out successfully" });
    });
  });

  app.post("/api/admin/register", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Username and password are required" 
        });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ 
          success: false, 
          message: "User already exists" 
        });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);

      // Create user
      const newUser = await storage.createUser({
        username,
        email: username,
        passwordHash,
        roleId: 1, // Default admin role ID
        isActive: true,
      });

      res.json({ 
        success: true, 
        message: "Admin account created successfully",
        user: { id: newUser.id, username: newUser.username, email: newUser.email, roleId: newUser.roleId }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/admin/me", requireAuth, async (req, res) => {
    try {
      let user = null;
      let userType = 'admin';
      
      if (req.session.adminId) {
        // Standard admin user
        user = await storage.getUserById(req.session.adminId);
        userType = 'admin';
      } else if (req.session.customUserId) {
        // Custom user from custom_users table
        const { pool } = await import('./db');
        const result = await pool.query(`
          SELECT cu.id, cu.full_name, cu.email, cu.role_id, cu.is_active,
                 cr.name as role_name, cr.display_name as role_display_name
          FROM custom_users cu
          LEFT JOIN custom_roles cr ON cu.role_id = cr.id
          WHERE cu.id = $1 AND cu.is_active = true
        `, [req.session.customUserId]);
        
        if (result.rows.length > 0) {
          const customUser = result.rows[0];
          user = {
            id: customUser.id,
            username: customUser.email,
            email: customUser.email,
            roleId: customUser.role_id,
            roleName: customUser.role_name,
            roleDisplayName: customUser.role_display_name,
            isActive: customUser.is_active
          };
          userType = 'custom';
        }
      }
      
      if (!user) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }
      
      res.json({ 
        success: true, 
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email, 
          roleId: user.roleId,
          roleName: user.roleName || 'admin',
          roleDisplayName: user.roleDisplayName || 'Administrator',
          userType
        }
      });
    } catch (error) {
      console.error("Error in /api/admin/me:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Authentication check endpoint - STRICT admin validation
  app.get("/api/admin/check-auth", async (req, res) => {
    try {
      // Strict admin validation - require valid admin session
      if (!req.session.adminId || !req.session.isAuthenticated) {
        return res.status(401).json({ 
          success: false, 
          message: "Not authenticated as admin" 
        });
      }
      
      // Verify user still exists and is active
      const user = await storage.getUserById(req.session.adminId);
      if (!user || !user.isActive) {
        return res.status(401).json({ 
          success: false, 
          message: "User not found or inactive" 
        });
      }
      
      res.json({ 
        success: true, 
        authenticated: true,
        user: { id: user.id, username: user.username, email: user.email, roleId: user.roleId }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Password reset functionality
  app.post("/api/admin/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ 
          success: false, 
          message: "Email is required" 
        });
      }

      // Check if user exists
      const user = await storage.getUserByUsername(email);
      if (!user) {
        // Don't reveal if user exists or not for security
        return res.json({ 
          success: true, 
          message: "If an account with this email exists, a password reset link has been sent" 
        });
      }

      // Generate reset token
      const resetToken = Math.random().toString(36).substring(2) + Date.now().toString(36);
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now

      // Save reset token
      await storage.createPasswordReset({
        email: user.email,
        token: resetToken,
        expiresAt,
        used: false,
      });

      // Send password reset email using Universal Email Service
      const { CONFIG } = await import('./config');
      
      const { UniversalEmailService } = await import('./universal-email-service');
      await UniversalEmailService.sendPasswordResetEmail(
        user.email,
        resetToken,
        user.username,
        req
      );

      res.json({ 
        success: true, 
        message: "If an account with this email exists, a password reset link has been sent"
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });



  // Admin management endpoints
  app.get("/api/admin/users", requireAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const safeUsers = users.map(user => ({
        id: user.id,
        username: user.username,
        email: user.email,
        roleId: user.roleId,
        isActive: user.isActive,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      }));
      
      res.json({ 
        success: true, 
        users: safeUsers 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.put("/api/admin/users/:id", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { username, email, role, isActive } = req.body;
      
      if (isNaN(userId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      // Prevent self-deactivation
      if (req.session.adminId === userId && isActive === false) {
        return res.status(400).json({ 
          success: false, 
          message: "Cannot deactivate your own account" 
        });
      }

      const updatedUser = await storage.updateUser(userId, {
        username,
        email,
        roleId: role ? parseInt(role) : undefined,
        isActive,
      });

      res.json({ 
        success: true, 
        message: "User updated successfully",
        user: {
          id: updatedUser.id,
          username: updatedUser.username,
          email: updatedUser.email,
          roleId: updatedUser.roleId,
          isActive: updatedUser.isActive,
        }
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.put("/api/admin/change-password", requireAuth, async (req, res) => {
    try {
      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "Current and new passwords are required" 
        });
      }

      // Get current user
      const user = await storage.getUserById(req.session.adminId!);
      if (!user) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }

      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!isValidPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "Current password is incorrect" 
        });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password
      await storage.updateUserPassword(user.id, newPasswordHash);

      res.json({ 
        success: true, 
        message: "Password changed successfully" 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Admin endpoint to change any user's password
  app.put("/api/admin/users/:id/password", requireAuth, async (req, res) => {
    try {
      const userId = req.params.id;
      const { newPassword } = req.body;
      
      if (!userId) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      if (!newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "New password is required" 
        });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password in custom_users table
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE custom_users 
        SET password_hash = $1
        WHERE id = $2
        RETURNING id, full_name
      `, [newPasswordHash, userId]);

      if (result.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }

      res.json({ 
        success: true, 
        message: "User password updated successfully" 
      });
    } catch (error) {
      console.error("Error updating user password:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Admin endpoint to send password reset link to a user
  app.post("/api/admin/users/:id/send-reset-link", requireAuth, async (req, res) => {
    try {
      const userId = req.params.id;
      
      if (!userId) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      // Get user from custom_users table
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, full_name, email 
        FROM custom_users 
        WHERE id = $1
      `, [userId]);

      if (result.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "User not found" 
        });
      }

      const user = result.rows[0];

      // Generate reset token
      const resetToken = Math.random().toString(36).substring(2) + Date.now().toString(36);
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now

      // Save reset token in password_resets table
      await pool.query(`
        INSERT INTO password_resets (email, token, expires_at, used)
        VALUES ($1, $2, $3, $4)
      `, [user.email, resetToken, expiresAt, false]);

      // Generate reset link
      const resetLink = `${req.protocol}://${req.get('host')}/reset-password?token=${resetToken}`;

      // TODO: Send email with reset link
      // For now, we'll log it and return in response
      console.log(`Password reset link for ${user.email}: ${resetLink}`);

      res.json({ 
        success: true, 
        message: `Password reset link sent to ${user.email}`,
        resetLink, // In production, this would be sent via email
        resetToken // For testing purposes
      });
    } catch (error) {
      console.error("Error sending password reset link:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.delete("/api/admin/users/:id", requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      
      if (isNaN(userId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid user ID" 
        });
      }

      // Prevent self-deletion
      if (req.session.adminId === userId) {
        return res.status(400).json({ 
          success: false, 
          message: "Cannot delete your own account" 
        });
      }

      await storage.deleteUser(userId);

      res.json({ 
        success: true, 
        message: "User deleted successfully" 
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Serve uploaded files
  app.get('/uploads/images/:filename', (req, res) => {
    const filename = req.params.filename;
    const filepath = path.join(process.cwd(), 'uploads', 'images', filename);
    
    if (fs.existsSync(filepath)) {
      // Set proper content type based on file extension
      const ext = path.extname(filename).toLowerCase();
      let contentType = 'image/png'; // default
      
      switch (ext) {
        case '.jpg':
        case '.jpeg':
          contentType = 'image/jpeg';
          break;
        case '.png':
          contentType = 'image/png';
          break;
        case '.webp':
          contentType = 'image/webp';
          break;
        case '.gif':
          contentType = 'image/gif';
          break;
      }
      
      res.setHeader('Content-Type', contentType);
      res.setHeader('Cache-Control', 'public, max-age=86400');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.sendFile(filepath);
    } else {
      res.status(404).json({ message: 'Image not found' });
    }
  });

  app.get('/uploads/catalogs/:filename', (req, res) => {
    const filename = req.params.filename;
    const filepath = path.join(process.cwd(), 'uploads', 'catalogs', filename);
    
    if (fs.existsSync(filepath)) {
      res.sendFile(filepath);
    } else {
      res.status(404).json({ message: 'Catalog not found' });
    }
  });

  // File upload endpoints
  // Generic upload route (for images) - accepts both 'file' and 'image' field names
  const uploadFlexible = multer({
    storage: imageStorage,
    limits: {
      fileSize: 2 * 1024 * 1024, // 2MB limit - optimized for web display
    },
    fileFilter: (req, file, cb) => {
      // Allow only optimal image formats for web display
      const allowedMimeTypes = [
        'image/jpeg',
        'image/jpg', 
        'image/png',
        'image/webp'
      ];
      
      if (allowedMimeTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Only JPEG, PNG, and WebP images are allowed for optimal customer display'));
      }
    }
  });

  app.post("/api/upload", requireAuth, (req, res) => {
    const upload = uploadFlexible.fields([
      { name: 'file', maxCount: 1 },
      { name: 'image', maxCount: 1 }
    ]);

    upload(req, res, (err) => {
      if (err) {
        console.error('Upload error:', err);
        return res.status(400).json({ 
          success: false, 
          message: err.message 
        });
      }

      try {
        const files = req.files as { [fieldname: string]: Express.Multer.File[] };
        const uploadedFile = files?.file?.[0] || files?.image?.[0];

        if (!uploadedFile) {
          return res.status(400).json({ 
            success: false, 
            message: "No file uploaded" 
          });
        }

        const imageUrl = `/uploads/images/${uploadedFile.filename}`;
        res.json({ 
          success: true, 
          url: imageUrl,
          filename: uploadedFile.filename,
          originalName: uploadedFile.originalname,
          size: uploadedFile.size
        });
      } catch (error) {
        console.error('Upload processing error:', error);
        res.status(500).json({ 
          success: false, 
          message: "Failed to process upload" 
        });
      }
    });
  });

  app.post("/api/upload/image", requireAuth, uploadImage.single('image'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No image file uploaded" 
        });
      }

      const imageUrl = `/uploads/images/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: imageUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload image" 
      });
    }
  });

  app.post("/api/upload/catalog", requireAuth, uploadCatalog.single('catalog'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No catalog file uploaded" 
        });
      }

      const catalogUrl = `/uploads/catalogs/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: catalogUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload catalog" 
      });
    }
  });

  // MSDS upload endpoint
  app.post("/api/upload/msds", requireAuth, uploadMsds.single('msds'), (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          message: "No MSDS file uploaded" 
        });
      }

      const msdsUrl = `/uploads/msds/${req.file.filename}`;
      res.json({ 
        success: true, 
        url: msdsUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      console.error('MSDS upload error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to upload MSDS file" 
      });
    }
  });

  // Update product MSDS information (for both shop and showcase products)
  app.put("/api/products/:id/msds", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { msdsUrl, showMsdsToCustomers, msdsFileName } = req.body;

      // Update shop product MSDS
      await storage.updateShopProduct(parseInt(id), {
        msdsUrl,
        showMsdsToCustomers,
        msdsFileName,
        msdsUploadDate: new Date()
      });

      // Also update showcase product if it exists
      try {
        await storage.updateShowcaseProduct(parseInt(id), {
          msdsUrl,
          showMsdsToCustomers,
          msdsFileName,
          msdsUploadDate: new Date()
        });
      } catch (error) {
        // Showcase product might not exist, continue with shop product only
        console.log('Showcase product not found, updated shop product only');
      }

      res.json({ 
        success: true, 
        message: "MSDS information updated successfully" 
      });
    } catch (error) {
      console.error('Error updating MSDS information:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update MSDS information" 
      });
    }
  });

  // Get MSDS file for customers (only if showMsdsToCustomers is true)
  app.get("/api/products/:id/msds", async (req, res) => {
    try {
      const { id } = req.params;

      // Get product MSDS information
      const product = await storage.getShopProduct(parseInt(id));
      
      if (!product || !product.msdsUrl || !product.showMsdsToCustomers) {
        return res.status(404).json({ 
          success: false, 
          message: "MSDS not available for this product" 
        });
      }

      res.json({
        success: true,
        data: {
          msdsUrl: product.msdsUrl,
          msdsFileName: product.msdsFileName || 'MSDS.pdf',
          msdsUploadDate: product.msdsUploadDate
        }
      });
    } catch (error) {
      console.error('Error fetching MSDS:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch MSDS" 
      });
    }
  });

  // Bank receipt upload endpoint (DISABLED - using newer version below)
  /*
  app.post("/api/payment/upload-receipt", requireCustomerAuth, (req, res) => {
    const uploadReceipt = multer({
      storage: receiptStorage,
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
      fileFilter: (req, file, cb) => {
        // Accept images and PDFs
        if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
          cb(null, true);
        } else {
          cb(new Error('Only image and PDF files are allowed for receipt uploads'));
        }
      }
    }).single('receipt');

    uploadReceipt(req, res, async (err) => {
      if (err) {
        console.error('Receipt upload error:', err);
        return res.status(400).json({ 
          success: false, 
          message: err.message 
        });
      }

      try {
        if (!req.file) {
          return res.status(400).json({ 
            success: false, 
            message: "ÙØ§ÛŒÙ„ ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª" 
          });
        }

        const { orderId, notes } = req.body;
        const customerId = (req.session as any)?.customerId;
        const receiptUrl = `/uploads/receipts/${req.file.filename}`;

        // Update order with receipt information
        if (orderId) {
          await shopStorage.updateOrder(parseInt(orderId), {
            paymentStatus: 'receipt_uploaded',
            receiptUrl: receiptUrl,
            receiptUploadDate: new Date(),
            receiptNotes: notes || null
          });

          // Also store in payment_receipts table for order management system
          await orderManagementStorage.uploadPaymentReceipt({
            customerOrderId: parseInt(orderId),
            customerId: customerId,
            receiptUrl: receiptUrl,
            originalFileName: req.file.originalname,
            fileSize: req.file.size,
            mimeType: req.file.mimetype,
            notes: notes || null
          });

          // Update order_management table if it exists
          const orderMgmt = await orderManagementStorage.getOrderManagementByCustomerOrderId(parseInt(orderId));
          if (orderMgmt) {
            await orderManagementStorage.updateOrderManagement(orderMgmt.id, {
              paymentReceiptUrl: receiptUrl,
              currentStatus: 'payment_uploaded',
              currentDepartment: 'finance',
              updatedAt: new Date()
            });
            console.log(`âœ… Order management updated for order ${orderId} - moved to finance department`);
          } else {
            console.log(`âš ï¸ Order management record not found for order ${orderId}`);
          }

          // Log the receipt upload
          console.log(`Receipt uploaded for order ${orderId} by customer ${customerId}`);
        }

        res.json({ 
          success: true, 
          message: "ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯",
          data: {
            receiptUrl: receiptUrl,
            filename: req.file.filename,
            originalName: req.file.originalname,
            size: req.file.size,
            uploadDate: new Date()
          }
        });
      } catch (error) {
        console.error('Error processing receipt upload:', error);
        res.status(500).json({ 
          success: false, 
          message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ" 
        });
      }
    });
  });
  */

  // Get receipt for order (customer can view their own receipt)
  app.get("/api/payment/receipt/:orderId", requireCustomerAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const customerId = (req.session as any)?.customerId;

      // Get order and verify it belongs to the customer
      const order = await shopStorage.getOrderById(orderId);
      
      if (!order) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Verify customer owns this order
      if (order.customerId !== customerId) {
        return res.status(403).json({ 
          success: false, 
          message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª" 
        });
      }

      if (!order.receiptUrl) {
        return res.status(404).json({ 
          success: false, 
          message: "ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      res.json({
        success: true,
        data: {
          receiptUrl: order.receiptUrl,
          receiptUploadDate: order.receiptUploadDate,
          receiptNotes: order.receiptNotes,
          paymentStatus: order.paymentStatus
        }
      });
    } catch (error) {
      console.error('Error fetching receipt:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ" 
      });
    }
  });



  // Helper function to get category email assignment
  async function getCategoryEmailAssignment(productInterest: string): Promise<string | null> {
    try {
      // Map product interests to category keys
      const categoryMapping: { [key: string]: string } = {
        'fuel-additives': 'fuel-additives',
        'water-treatment': 'water-treatment',
        'paint-solvents': 'paint-thinner',
        'agricultural-products': 'agricultural-fertilizers',
        'agricultural-fertilizers': 'agricultural-fertilizers',
        'industrial-chemicals': 'industrial-chemicals',
        'paint-thinner': 'paint-thinner',
        'technical-equipment': 'technical-equipment',
        'commercial-goods': 'commercial-goods',
        'other-products': 'orders'
      };

      const categoryKey = categoryMapping[productInterest] || 'orders';
      
      const assignment = await db
        .select()
        .from(categoryEmailAssignments)
        .where(eq(categoryEmailAssignments.categoryKey, categoryKey))
        .limit(1);

      return assignment.length > 0 ? assignment[0].assignedEmail : null;
    } catch (error) {
      console.error("Error getting category email assignment:", error);
      return null;
    }
  }

  // Contact form submission
  app.post("/api/contact", async (req, res) => {
    try {
      const contactData = insertContactSchema.parse(req.body);
      const contact = await storage.createContact(contactData);
      
      // Get category-specific email assignment
      const categoryEmail = await getCategoryEmailAssignment(contact.productInterest);
      
      // Send email notification with intelligent routing
      try {
        await sendContactEmail({
          firstName: contact.firstName,
          lastName: contact.lastName,
          email: contact.email,
          company: contact.company ?? '',
          productInterest: contact.productInterest,
          message: contact.message ?? '',
          categoryEmail: categoryEmail ?? undefined // Add category-specific email for routing
        });
        console.log(`Email sent successfully for contact: ${contact.id}, routed to category email: ${categoryEmail || 'default'}`);
      } catch (emailError) {
        console.error("Failed to send email:", emailError);
        // Continue processing even if email fails
      }
      
      console.log("New contact form submission:", contact);
      
      res.json({ success: true, message: "Contact form submitted successfully" });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Validation error", 
          errors: error.errors 
        });
      } else {
        console.error("Contact form error:", error);
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  // Get all contacts (for admin purposes)
  app.get("/api/contacts", async (req, res) => {
    try {
      const contacts = await storage.getContacts();
      res.json(contacts);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // API endpoint for getting all batches of a product by barcode
  app.get("/api/batches/:barcode", requireAuth, async (req, res) => {
    try {
      const { barcode } = req.params;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        SELECT 
          id, 
          name, 
          batch_number, 
          stock_quantity, 
          created_at,
          unit_price,
          net_weight,
          gross_weight
        FROM showcase_products 
        WHERE barcode = $1
        ORDER BY created_at DESC
      `, [barcode]);
      
      res.json({
        success: true,
        barcode,
        batches: result.rows,
        totalBatches: result.rows.length,
        totalStock: result.rows.reduce((sum, batch) => sum + (batch.stock_quantity || 0), 0)
      });
    } catch (error) {
      console.error("Error getting batches:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†â€ŒÙ‡Ø§" });
    }
  });

  // API endpoint for getting current selling batch (LIFO)
  app.get("/api/selling-batch/:barcode", requireAuth, async (req, res) => {
    try {
      const { barcode } = req.params;
      const { ShopStorage } = await import('./shop-storage');
      const shopStorage = new ShopStorage();
      
      const currentBatch = await shopStorage.getCurrentSellingBatch(barcode);
      
      if (!currentBatch) {
        return res.status(404).json({
          success: false,
          message: `Ù‡ÛŒÚ† Ø¨Ú† Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø±Ú©Ø¯ ${barcode} ÛŒØ§ÙØª Ù†Ø´Ø¯`
        });
      }
      
      res.json({
        success: true,
        barcode,
        currentBatch: {
          batchId: currentBatch.id,
          batchNumber: currentBatch.batch_number,
          productName: currentBatch.name,
          stockQuantity: currentBatch.stock_quantity,
          createdAt: currentBatch.created_at
        }
      });
    } catch (error) {
      console.error("Error getting current selling batch:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú† ÙØ¹Ø§Ù„" });
    }
  });

  // API endpoint for getting product unit from kardex (showcase_products)
  app.get("/api/products/kardex/:id/unit", async (req, res) => {
    try {
      const { id } = req.params;
      const { showcaseDb } = await import('./db');
      const { showcaseProducts } = await import('../shared/showcase-schema');
      const { eq } = await import('drizzle-orm');
      
      const [product] = await showcaseDb
        .select({
          stockUnit: showcaseProducts.stockUnit,
          name: showcaseProducts.name
        })
        .from(showcaseProducts)
        .where(eq(showcaseProducts.id, parseInt(id)))
        .limit(1);
      
      if (!product) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„ Ø¯Ø± Ú©Ø§Ø±Ø¯Ú©Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        unit: product.stockUnit || 'ÙˆØ§Ø­Ø¯',
        productName: product.name
      });
    } catch (error) {
      console.error("Error fetching product unit from kardex:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ§Ø­Ø¯ Ù…Ø­ØµÙˆÙ„ Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³" 
      });
    }
  });

  // Protected admin routes for product management (Ú©Ø§Ø±Ø¯Ú©Ø³)
  app.post("/api/products", requireAuth, async (req, res) => {
    try {
      const productData = req.body;
      
      // Generate barcode if not provided
      let barcode = productData.barcode;
      if (!barcode) {
        try {
          const { generateEAN13Barcode } = await import('../shared/barcode-utils');
          barcode = await generateEAN13Barcode(productData.name, productData.category);
          console.log(`ðŸ”¢ Generated barcode for new product: ${barcode}`);
        } catch (barcodeError) {
          console.error("Barcode generation failed:", barcodeError);
          throw new Error("Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø¨Ø§Ø±Ú©Ø¯ Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯");
        }
      }

      // Check for duplicate barcode + batch combination
      if (barcode && productData.batchNumber) {
        const { pool } = await import('./db');
        const duplicateCheck = await pool.query(`
          SELECT COUNT(*) as count FROM showcase_products 
          WHERE barcode = $1 AND batch_number = $2
        `, [barcode, productData.batchNumber]);
        
        if (duplicateCheck.rows[0].count > 0) {
          return res.status(400).json({
            success: false,
            message: `Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ø¨Ø§Ø±Ú©Ø¯ ${barcode} Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ø¨Ú† ${productData.batchNumber} Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ Ø¨Ú† Ù…ØªÙØ§ÙˆØª Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.`
          });
        }
      }

      console.log(`âœ… New batch registration: Barcode ${barcode} + Batch ${productData.batchNumber || 'No Batch'} + Stock ${productData.stockQuantity || 0}`);
      
      
      // Create product in showcase_products table (Ú©Ø§Ø±Ø¯Ú©Ø³)
      const showcaseProductData = {
        name: productData.name,
        category: productData.category,
        description: productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        shortDescription: productData.shortDescription || productData.description,
        unitPrice: productData.unitPrice || productData.price || 11,
        currency: productData.currency || 'IQD',
        stockQuantity: productData.stockQuantity || 11,
        minStockLevel: productData.minStockLevel || 5,
        maxStockLevel: productData.maxStockLevel || 100,
        sku: productData.sku || `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        barcode: barcode,
        weight: productData.weight || 11,
        imageUrl: productData.imageUrl || null,
        specifications: productData.specifications || productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        features: productData.features || productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        applications: productData.applications || productData.description || "Ø§ÛŒÙ† ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§Ø³Øª",
        tags: productData.tags || ["Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ"],
        isActive: productData.isActive !== false,
        syncWithShop: productData.syncWithShop || false,
        parentProductId: productData.parentProductId || null,
        isVariant: productData.isVariant || false,
        variantType: productData.variantType || null,
        variantValue: productData.variantValue || null
      };
      
      const product = await storage.createProduct(showcaseProductData);
      
      // Trigger automatic synchronization after creating product
      try {
        const { KardexSyncMaster } = await import('./kardex-sync-master');
        const result = await KardexSyncMaster.smartSyncShopFromKardex();
        console.log(`ðŸ”„ Auto-sync completed after creating product:`, result.message);
      } catch (syncError) {
        console.log("Auto-sync failed after creation:", syncError);
      }
      
      res.status(201).json(product);
    } catch (error) {
      console.error("Error creating showcase product:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid product data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  });

  app.get("/api/products", async (req, res) => {
    try {
      const { category } = req.query;
      let products;
      
      // Use showcase_products table for admin products interface
      if (category && typeof category === 'string') {
        products = await storage.getProductsByCategory(category);
      } else {
        products = await storage.getProducts();
      }
      
      // Products from showcase_products are already in the correct format
      const mappedProducts = products;
      
      res.json(mappedProducts);
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  app.get("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      const product = await storage.getProductById(id);
      if (!product) {
        return res.status(404).json({ 
          success: false, 
          message: "Product not found" 
        });
      }

      res.json(product);
    } catch (error) {
      console.error(`Error fetching product ${id}:`, error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Update product (PATCH method)
  app.patch("/api/products/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      const productData = req.body;
      
      // Map frontend fields to backend fields for update
      const mappedData = {
        ...productData,
        price: productData.unitPrice || productData.price,
        priceUnit: productData.currency || productData.priceUnit || 'IQD',
        imageUrls: productData.imageUrl ? [productData.imageUrl] : (productData.imageUrls || [])
      };
      
      // Update showcase product instead of shop product for admin panel
      const product = await storage.updateProduct(id, mappedData);
      res.json(product);
    } catch (error) {
      console.error("Error updating product:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid product data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  });

  // Update product (PUT method - for compatibility)
  app.put("/api/products/:id", requireAuth, async (req, res) => {
    try {
      console.log(`ðŸ”§ [DEBUG] PUT /api/products/${req.params.id} - Body:`, JSON.stringify(req.body, null, 2));
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        console.log(`âŒ [DEBUG] Invalid product ID: ${req.params.id}`);
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      const productData = req.body;
      console.log(`ðŸ“‹ [DEBUG] Product data keys:`, Object.keys(productData));
      
      // Handle sync toggle requests (skip all validations)
      const isSyncToggle = Object.keys(productData).length === 1 && 'syncWithShop' in productData;
      
      if (isSyncToggle) {
        console.log(`ðŸ”„ [DEBUG] Quick sync toggle request for product ${id}:`, productData.syncWithShop);
        // Skip all validations for sync toggles - just update the field
      } else {
        // Full validation for regular updates
        if (!productData.name || productData.name.trim() === '') {
          return res.status(400).json({ 
            success: false, 
            message: "Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
          });
        }
        
        // Validate numerical fields
        if (productData.stockQuantity !== undefined && (isNaN(productData.stockQuantity) || productData.stockQuantity < 0)) {
          return res.status(400).json({ 
            success: false, 
            message: "Ù…Ù‚Ø¯Ø§Ø± Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ù…Ø«Ø¨Øª Ø¨Ø§Ø´Ø¯" 
          });
        }
        
        if (productData.unitPrice !== undefined && (isNaN(parseFloat(productData.unitPrice)) || parseFloat(productData.unitPrice) < 0)) {
          return res.status(400).json({ 
            success: false, 
            message: "Ù‚ÛŒÙ…Øª Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ù…Ø«Ø¨Øª Ø¨Ø§Ø´Ø¯" 
          });
        }
      }
      
      console.log(`ðŸ“ [DEBUG] Updating showcase product ${id} with validated data`);
      console.log(`ðŸ“ [DEBUG] Tags field:`, productData.tags, 'Type:', typeof productData.tags);
      
      // Check if stock quantity is being updated for warehouse sync
      const oldProduct = await storage.getProductById(id);
      
      // Handle inventory addition functionality
      if (productData.inventoryAddition && productData.inventoryAddition > 0) {
        console.log(`ðŸ“¦ [INVENTORY-ADDITION] Adding ${productData.inventoryAddition} units to product ${id}`);
        
        // Calculate new stock quantity by adding to existing stock
        const currentStock = oldProduct ? oldProduct.stockQuantity || 0 : 0;
        const newStock = currentStock + productData.inventoryAddition;
        
        console.log(`ðŸ“¦ [INVENTORY-ADDITION] Stock calculation: ${currentStock} + ${productData.inventoryAddition} = ${newStock}`);
        
        // Update product data with new stock quantity
        productData.stockQuantity = newStock;
        
        // If new batch number is provided, create a new batch entry in Ú©Ø§Ø±Ø¯Ú©Ø³ only
        if (productData.newBatchNumber && productData.newBatchNumber.trim()) {
          console.log(`ðŸ“¦ [BATCH-CREATION] Creating new batch in Ú©Ø§Ø±Ø¯Ú©Ø³: ${productData.newBatchNumber}`);
          
          // Add batch to Ú©Ø§Ø±Ø¯Ú©Ø³ (showcase_products) only - ÙØ±ÙˆØ´Ú¯Ø§Ù‡ doesn't need batch details
          try {
            const batchData = {
              barcode: oldProduct?.barcode || '',
              batchNumber: productData.newBatchNumber.trim(),
              stockQuantity: productData.inventoryAddition,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            };
            
            await shopStorage.addBatch(batchData);
            console.log(`âœ… [BATCH-CREATION] Successfully created batch in Ú©Ø§Ø±Ø¯Ú©Ø³: ${productData.newBatchNumber}`);
          } catch (batchError) {
            console.error(`âŒ [BATCH-CREATION] Failed to create batch:`, batchError);
            // Don't fail the main operation if batch creation fails
          }
        }
        
        // Clean up the addition fields from productData so they don't get saved
        delete productData.inventoryAddition;
        delete productData.newBatchNumber;
        
        console.log(`âœ… [INVENTORY-ADDITION] Final stock quantity: ${newStock}`);
      }
      
      const isStockUpdate = productData.stockQuantity !== undefined && 
                           oldProduct && 
                           oldProduct.stockQuantity !== productData.stockQuantity;
      
      // Update showcase product
      const product = await storage.updateProduct(id, productData);
      console.log(`âœ… [DEBUG] Updated product result:`, JSON.stringify({
        id: product.id,
        name: product.name,
        tags: product.tags,
        description: product.description,
        stockQuantity: product.stockQuantity
      }, null, 2));
      
      // If stock quantity was updated, sync to warehouse inventory
      if (isStockUpdate && !isSyncToggle) {
        try {
          console.log(`ðŸ“¦ [WAREHOUSE-SYNC] Stock quantity updated for ${product.name}: ${oldProduct.stockQuantity} â†’ ${product.stockQuantity}`);
          
          // Calculate stock difference for warehouse sync
          const stockDifference = (product.stockQuantity || 0) - (oldProduct.stockQuantity || 0);
          
          if (stockDifference !== 0) {
            console.log(`ðŸ“¦ [WAREHOUSE-SYNC] Creating inventory movement: ${stockDifference > 0 ? '+' : ''}${stockDifference} units`);
            
            // Prepare inventory movement data
            const movementData = {
              productId: product.id,
              productName: product.name,
              productSku: product.sku || '',
              productBarcode: product.barcode || '',
              movementType: stockDifference > 0 ? 'Ú©Ø§Ø±Ø¯Ú©Ø³_Ø§ÙØ²Ø§ÛŒØ´' : 'Ú©Ø§Ø±Ø¯Ú©Ø³_Ú©Ø§Ù‡Ø´',
              quantity: Math.abs(stockDifference),
              previousStock: oldProduct.stockQuantity || 0,
              newStock: product.stockQuantity || 0,
              movementDate: new Date().toISOString(),
              reason: 'ØªØºÛŒÛŒØ± Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³',
              source: 'Ú©Ø§Ø±Ø¯Ú©Ø³',
              notes: `Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø² ${oldProduct.stockQuantity || 0} Ø¨Ù‡ ${product.stockQuantity || 0} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`
            };
            
            // Call warehouse inventory sync API
            try {
              const warehouseResponse = await fetch('http://localhost:5000/api/warehouse/inventory-sync', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(movementData)
              });
              
              if (warehouseResponse.ok) {
                console.log(`âœ… [WAREHOUSE-SYNC] Successfully recorded inventory movement for ${product.name}`);
              } else {
                console.log(`âš ï¸ [WAREHOUSE-SYNC] Warehouse API not available, logging change locally`);
              }
            } catch (apiError) {
              console.log(`ðŸ“ [WAREHOUSE-SYNC] Warehouse API call failed, movement will be visible in next warehouse sync`);
            }
            
            console.log(`âœ… [WAREHOUSE-SYNC] Stock synchronized from Ú©Ø§Ø±Ø¯Ú©Ø³ to warehouse for product ${product.name}`);
          }
        } catch (warehouseError) {
          console.error(`âŒ [WAREHOUSE-SYNC] Failed to sync stock to warehouse:`, warehouseError);
          // Don't fail the main operation if warehouse sync fails
        }
      }
      
      // Shop visibility logic - actually sync to shop when enabled
      if (productData.syncWithShop === true) {
        console.log(`ðŸª Ù…Ø­ØµÙˆÙ„ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯: ${product.name}`);
        
        // Actually sync this product to shop
        try {
          const existingShopProducts = await shopStorage.getShopProducts();
          const existingShopProduct = existingShopProducts.find(sp => sp.name === product.name);
          
          if (!existingShopProduct) {
            // Calculate total stock from all batches in Ú©Ø§Ø±Ø¯Ú©Ø³ for this barcode
            let totalStock = product.stockQuantity || 0;
            if (product.barcode) {
              try {
                const { pool } = await import('./db');
                const totalStockResult = await pool.query(`
                  SELECT SUM(stock_quantity) as total_stock
                  FROM showcase_products 
                  WHERE barcode = $1
                `, [product.barcode]);
                
                totalStock = totalStockResult.rows[0]?.total_stock || 0;
                console.log(`ðŸ“¦ [SHOP-SYNC] Calculated total stock from all batches for new product: ${totalStock}`);
              } catch (error) {
                console.error('Error calculating total stock:', error);
              }
            }
            
            const shopProductData = {
              name: product.name,
              category: product.category,
              description: product.description,
              shortDescription: product.shortDescription || product.description,
              price: product.unitPrice || product.price || 0,
              priceUnit: product.currency || product.priceUnit || 'IQD',
              inStock: totalStock > 0 || (productData.showWhenOutOfStock || false),
              stockQuantity: totalStock, // Use total stock from all batches
              lowStockThreshold: 10,
              minStockLevel: product.minStockLevel || 5,
              maxStockLevel: product.maxStockLevel || 100,
              showWhenOutOfStock: productData.showWhenOutOfStock || false,
              sku: product.sku && !existingShopProducts.some(sp => sp.sku === product.sku) 
                ? product.sku 
                : `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
              barcode: product.barcode,
              imageUrls: product.imageUrl ? [product.imageUrl] : [],
              specifications: product.specifications || {},
              features: product.features || [],
              applications: product.applications || [],
              isActive: true,
              isFeatured: false,
              metaTitle: product.name,
              metaDescription: product.description
            };
            
            await shopStorage.createShopProduct(shopProductData);
            console.log(`âœ… Ù…Ø­ØµÙˆÙ„ Ø¨Ù‡ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯: ${product.name}`);
          } else {
            // Shop product already exists, update it
            // Calculate total stock from all batches in Ú©Ø§Ø±Ø¯Ú©Ø³ for this barcode
            let totalStock = product.stockQuantity || 0;
            if (product.barcode) {
              try {
                const { pool } = await import('./db');
                const totalStockResult = await pool.query(`
                  SELECT SUM(stock_quantity) as total_stock
                  FROM showcase_products 
                  WHERE barcode = $1
                `, [product.barcode]);
                
                totalStock = totalStockResult.rows[0]?.total_stock || 0;
                console.log(`ðŸ“¦ [SHOP-SYNC] Calculated total stock from all batches: ${totalStock}`);
              } catch (error) {
                console.error('Error calculating total stock:', error);
              }
            }
            
            const updateData = {
              stockQuantity: totalStock, // Use total stock from all batches
              inStock: totalStock > 0 || (productData.showWhenOutOfStock || false),
              price: product.unitPrice || product.price || 0,
              priceUnit: product.currency || product.priceUnit || 'IQD',
              description: product.description,
              shortDescription: product.shortDescription || product.description,
              imageUrls: product.imageUrl ? [product.imageUrl] : (existingShopProduct.imageUrls || []),
              specifications: product.specifications || {},
              features: product.features || [],
              applications: product.applications || [],
              barcode: product.barcode,
              sku: product.sku || existingShopProduct.sku,
              showWhenOutOfStock: productData.showWhenOutOfStock || false
            };
            
            await shopStorage.updateShopProduct(existingShopProduct.id, updateData);
            console.log(`âœ… Ù…Ø­ØµÙˆÙ„ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯: ${product.name}`);
          }
        } catch (syncError) {
          console.error(`âŒ Ø®Ø·Ø§ Ø¯Ø± sync Ú©Ø±Ø¯Ù† Ù…Ø­ØµÙˆÙ„ ${product.name}:`, syncError.message);
          // Continue with the product update even if shop sync fails
        }
      } else if (productData.syncWithShop === false) {
        console.log(`ðŸ”’ Ù…Ø­ØµÙˆÙ„ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ù…Ø®ÙÛŒ Ø´Ø¯: ${product.name}`);
        
        // Remove from shop if sync is disabled
        try {
          const existingShopProducts = await shopStorage.getShopProducts();
          const existingShopProduct = existingShopProducts.find(sp => sp.name === product.name);
          
          if (existingShopProduct) {
            await shopStorage.deleteShopProduct(existingShopProduct.id);
            console.log(`ðŸ—‘ï¸  Ù…Ø­ØµÙˆÙ„ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø­Ø°Ù Ø´Ø¯: ${product.name}`);
          }
        } catch (removeError: any) {
          console.error(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø­ØµÙˆÙ„ ${product.name} Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡:`, removeError.message);
          // Continue with the product update even if shop removal fails
        }
      }
      
      // Trigger automatic synchronization after any update
      try {
        const { KardexSyncMaster } = await import('./kardex-sync-master');
        const result = await KardexSyncMaster.smartSyncShopFromKardex();
        console.log(`ðŸ”„ Auto-sync completed after updating product ${id}:`, result.message);
      } catch (syncError) {
        console.log("Auto-sync failed after update:", syncError);
      }
      
      const responseProduct = product;
      console.log(`âœ… [DEBUG] Product update completed successfully for product ${id}`);
      
      res.json({ 
        success: true, 
        message: isSyncToggle ? "ÙˆØ¶Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" : "Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        product: responseProduct 
      });
    } catch (error: any) {
      console.error("Error updating showcase product:", error);
      
      // Handle specific database errors with Persian messages
      let errorMessage = "Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø³Ø±ÙˆØ±";
      let statusCode = 500;
      
      if (error instanceof z.ZodError) {
        statusCode = 400;
        errorMessage = "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡";
      } else if (error.code === '23505') { // Unique constraint violation
        statusCode = 400;
        if (error.constraint?.includes('sku')) {
          errorMessage = "Ú©Ø¯ SKU ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª";
        } else if (error.constraint?.includes('barcode')) {
          errorMessage = "Ø¨Ø§Ø±Ú©Ø¯ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª";
        } else {
          errorMessage = "Ù…Ù‚Ø¯Ø§Ø± ØªÚ©Ø±Ø§Ø±ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯";
        }
      } else if (error.code === '23503') { // Foreign key violation
        statusCode = 400;
        errorMessage = "Ù…Ø±Ø¬Ø¹ Ù†Ø§Ù…Ø¹ØªØ¨Ø±";
      } else if (error.code === '23514') { // Check constraint violation
        statusCode = 400;
        errorMessage = "Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡";
      } else if (error.message?.includes('authentication')) {
        statusCode = 401;
        errorMessage = "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª";
      }
      
      res.status(statusCode).json({ 
        success: false, 
        message: errorMessage
      });
    }
  });

  app.delete("/api/products/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid product ID" 
        });
      }

      // Get product name before deletion for shop cleanup
      const productToDelete = await storage.getProductById(id);
      
      // Delete from showcase products (admin interface)
      await storage.deleteProduct(id);
      
      // Also remove from shop if it exists there (by barcode matching for better accuracy)
      if (productToDelete) {
        try {
          const shopProducts = await shopStorage.getShopProducts();
          const matchingShopProduct = shopProducts.find(p => 
            p.barcode === productToDelete.barcode || 
            p.name === productToDelete.name ||
            p.sku === productToDelete.sku
          );
          if (matchingShopProduct) {
            await shopStorage.deleteShopProduct(matchingShopProduct.id);
            console.log(`âœ… [DELETE-SYNC] Removed matching shop product: ${matchingShopProduct.name} (barcode: ${matchingShopProduct.barcode})`);
          } else {
            console.log(`âš ï¸ [DELETE-SYNC] No matching shop product found for: ${productToDelete.name} (barcode: ${productToDelete.barcode})`);
          }
        } catch (error) {
          console.log("âŒ [DELETE-SYNC] Error removing from shop:", error);
        }
      }
      
      // Trigger automatic synchronization after deletion
      try {
        const { KardexSyncMaster } = await import('./kardex-sync-master');
        const result = await KardexSyncMaster.smartSyncShopFromKardex();
        console.log(`ðŸ”„ Auto-sync completed after deleting product ${id}:`, result.message);
      } catch (syncError) {
        console.log("Auto-sync failed after deletion:", syncError);
      }
      
      console.log(`Product ${id} deleted successfully from both showcase and shop with auto-sync`);
      res.json({ success: true, message: "Product deleted successfully" });
    } catch (error) {
      console.error("Delete product error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // KARDEX SYNC MASTER ENDPOINTS - Ø³ÛŒØ³ØªÙ… Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø§ÛŒÙ…Ù†
  // =============================================================================
  
  // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ
  app.get("/api/kardex-sync/status", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const status = await KardexSyncMaster.checkSyncStatus();
      
      res.json({
        success: true,
        data: status,
        message: "ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error checking sync status:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ"
      });
    }
  });
  
  // Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø§Ø² Ú©Ø§Ø±Ø¯Ú©Ø³ (Ø§ÛŒÙ…Ù†)
  app.post("/api/kardex-sync/full-rebuild", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.fullRebuildShopFromKardex();
      
      res.json({
        success: result.success,
        data: result.details,
        message: result.message
      });
    } catch (error) {
      console.error("Error in full rebuild:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ ÙØ±ÙˆØ´Ú¯Ø§Ù‡"
      });
    }
  });
  
  // Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ (ÙÙ‚Ø· ØªØºÛŒÛŒØ±Ø§Øª)
  app.post("/api/kardex-sync/smart-sync", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.smartSyncShopFromKardex();
      
      res.json({
        success: result.success,
        data: result.details,
        message: result.message
      });
    } catch (error) {
      console.error("Error in smart sync:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯"
      });
    }
  });

  // Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ù…Ø­ØµÙˆÙ„Ø§Øª Ø§Ø¶Ø§ÙÛŒ Ø§Ø² ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ú©Ù‡ Ø¯Ø± Ú©Ø§Ø±Ø¯Ú©Ø³ Ù†ÛŒØ³ØªÙ†Ø¯
  app.post("/api/kardex-sync/cleanup-extra", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.cleanupExtraShopProducts();
      
      if (result.success) {
        res.json({
          success: true,
          message: result.message,
          data: {
            deletedCount: result.deletedCount,
            deletedProducts: result.deletedProducts
          }
        });
      } else {
        res.status(500).json({
          success: false,
          message: result.message
        });
      }
    } catch (error) {
      console.error("âŒ [CLEANUP-EXTRA] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø­ØµÙˆÙ„Ø§Øª Ø§Ø¶Ø§ÙÛŒ"
      });
    }
  });

  // Ø­Ø°Ù SKU ØªÚ©Ø±Ø§Ø±ÛŒ
  app.post("/api/kardex-sync/cleanup-duplicates", async (req, res) => {
    try {
      const { KardexSyncMaster } = await import('./kardex-sync-master');
      const result = await KardexSyncMaster.cleanupDuplicateSKUs();
      
      if (result.success) {
        res.json({
          success: true,
          message: result.message,
          data: {
            deletedCount: result.deletedCount,
            duplicates: result.duplicates
          }
        });
      } else {
        res.status(500).json({
          success: false,
          message: result.message
        });
      }
    } catch (error) {
      console.error("âŒ [CLEANUP-SKU] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù SKU ØªÚ©Ø±Ø§Ø±ÛŒ"
      });
    }
  });

  // =============================================================================
  // BARCODE & INVENTORY MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get product by barcode - search in both regular products and shop products
  app.get("/api/products/barcode/:barcode", async (req, res) => {
    try {
      const { barcode } = req.params;
      const decodedBarcode = decodeURIComponent(barcode);
      
      // First search in shop products (inventory management)
      try {
        const shopProduct = await shopStorage.getShopProductBySku(decodedBarcode);
        if (shopProduct) {
          return res.json(shopProduct);
        }
      } catch (error) {
        console.log("Shop product not found by SKU, trying barcode field");
      }

      // Search shop products by barcode field directly
      try {
        const shopProducts = await shopStorage.getShopProducts();
        const foundShopProduct = shopProducts.find(p => 
          p.barcode === decodedBarcode || 
          p.sku === decodedBarcode
        );
        
        if (foundShopProduct) {
          return res.json(foundShopProduct);
        }
      } catch (error) {
        console.log("Error searching shop products:", error);
      }
      
      // Then search in regular products
      const products = await shopStorage.getShopProducts();
      const product = products.find(p => 
        p.barcode === decodedBarcode || 
        p.sku === decodedBarcode
      );
      
      if (!product) {
        return res.status(404).json({ 
          success: false, 
          message: "Product not found" 
        });
      }
      
      res.json(product);
    } catch (error) {
      console.error("Error fetching product by barcode:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Update product barcode information
  app.put("/api/products/:id/barcode", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { barcode, qrCode, sku } = req.body;
      
      const updateData: any = {};
      if (barcode) updateData.barcode = barcode;
      if (qrCode) updateData.qrCode = qrCode;
      if (sku) updateData.sku = sku;
      
      const updatedProduct = await shopStorage.updateShopProduct(parseInt(id), updateData);
      res.json(updatedProduct);
    } catch (error) {
      console.error("Error updating product barcode:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Log barcode scan
  app.post("/api/barcode/log", async (req, res) => {
    try {
      const { barcode, scanType, scanResult, location, additionalData } = req.body;
      
      // Simple logging to console for now - could be extended to database
      console.log('Barcode scan logged:', {
        barcode,
        scanType,
        scanResult,
        userId: req.session?.adminId,
        timestamp: new Date().toISOString()
      });
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error logging barcode scan:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // EAN-13 BARCODE MANAGEMENT API (GS1 Standard)
  // =============================================================================
  
  // Get EAN-13 records
  app.get("/api/ean13/records", requireAuth, async (req, res) => {
    try {
      // For now, return empty array - will be implemented when database schema is created
      res.json([]);
    } catch (error) {
      console.error("Error fetching EAN-13 records:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Bulk generate EAN-13 barcodes
  app.post("/api/ean13/bulk-generate", requireAuth, async (req, res) => {
    try {
      const { productIds } = req.body;
      
      if (!productIds || !Array.isArray(productIds)) {
        return res.status(400).json({
          success: false,
          message: "Product IDs array is required"
        });
      }

      let generated = 0;
      const companyPrefix = "12345"; // Should be obtained from GS1
      const countryCode = "864"; // Iraq
      
      for (const productId of productIds) {
        try {
          const products = await shopStorage.getShopProducts();
          const product = products.find(p => p.id === productId);
          if (!product || (product.barcode && product.barcode.length === 13)) {
            continue; // Skip if product not found or already has EAN-13
          }

          // Generate EAN-13 barcode
          const productCode = String(productId).padStart(3, '0');
          const barcode12 = countryCode + companyPrefix + productCode;
          
          // Calculate check digit
          let sum = 0;
          for (let i = 0; i < 12; i++) {
            const digit = parseInt(barcode12[i]);
            sum += i % 2 === 0 ? digit : digit * 3;
          }
          const checkDigit = (10 - (sum % 10)) % 10;
          const ean13 = barcode12 + checkDigit.toString();

          // Update product with EAN-13
          await shopStorage.updateShopProduct(productId, { barcode: ean13 });
          generated++;
        } catch (error) {
          console.error(`Error generating EAN-13 for product ${productId}:`, error);
        }
      }

      res.json({
        success: true,
        generated,
        message: `Generated ${generated} EAN-13 barcodes`
      });
    } catch (error) {
      console.error("Error in bulk EAN-13 generation:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Export EAN-13 data as CSV with multilingual support
  app.get("/api/ean13/export", requireAuth, async (req, res) => {
    try {
      const products = await shopStorage.getShopProducts();
      const ean13Products = products.filter(p => p.barcode && p.barcode.length === 13);
      
      // Create CSV with UTF-8 BOM for proper multilingual character display
      const BOM = '\uFEFF';
      
      // Multilingual headers (Persian/Arabic/Kurdish compatible)
      const csvHeader = "Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„,Ú©Ø¯ Ù…Ø­ØµÙˆÙ„,EAN-13,Ú©Ø¯ Ú©Ø´ÙˆØ±,Ù¾ÛŒØ´ÙˆÙ†Ø¯ Ø´Ø±Ú©Øª,Ú©Ø¯ Ù…Ø­ØµÙˆÙ„,Ø±Ù‚Ù… Ú†Ú©,Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ,Ù‚ÛŒÙ…Øª ÙˆØ§Ø­Ø¯,ÙˆØ§Ø­Ø¯ Ù‚ÛŒÙ…Øª,ÙˆØ¶Ø¹ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ,Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ\n";
      
      const csvRows = ean13Products.map(product => {
        const barcode = product.barcode!;
        const countryCode = barcode.substring(0, 3);
        const companyPrefix = barcode.substring(3, 8);
        const productCode = barcode.substring(8, 12);
        const checkDigit = barcode.substring(12, 13);
        
        // Format price with proper Persian/Arabic numerals support
        const price = product.unitPrice || product.priceRange || 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡';
        const currency = product.currency || 'Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ';
        const stockStatus = (product.stockQuantity && product.stockQuantity > 0) ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù†Ø§Ù…ÙˆØ¬ÙˆØ¯';
        const currentStock = product.stockQuantity || 0;
        
        // Escape quotes and handle special characters for CSV
        const escapeCsvField = (field: string | number) => {
          const str = String(field || '');
          // If field contains comma, newline, or quote, wrap in quotes and escape internal quotes
          if (str.includes(',') || str.includes('\n') || str.includes('"')) {
            return `"${str.replace(/"/g, '""')}"`;
          }
          return `"${str}"`;
        };
        
        return [
          escapeCsvField(product.name),
          escapeCsvField(product.sku || ''),
          escapeCsvField(barcode),
          escapeCsvField(countryCode),
          escapeCsvField(companyPrefix),
          escapeCsvField(productCode),
          escapeCsvField(checkDigit),
          escapeCsvField(product.category),
          escapeCsvField(price),
          escapeCsvField(currency),
          escapeCsvField(stockStatus),
          escapeCsvField(currentStock)
        ].join(',');
      }).join('\n');
      
      const csvContent = BOM + csvHeader + csvRows;
      
      // Set proper headers for UTF-8 CSV with BOM
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="Barcode_Export_${new Date().toISOString().split('T')[0]}.csv"`);
      res.send(csvContent);
      
      console.log(`âœ… [EXPORT] Generated CSV export with ${ean13Products.length} products with multilingual support`);
    } catch (error) {
      console.error("âŒ [EXPORT] Error exporting EAN-13 data:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬ÛŒ Ú¯ÛŒØ±ÛŒ ÙØ§ÛŒÙ„ CSV" 
      });
    }
  });

  // Export all barcode data (both showcase and shop) with pricing
  app.get("/api/barcode/export-all", requireAuth, async (req, res) => {
    try {
      const shopProducts = await shopStorage.getShopProducts();
      
      // Create CSV with UTF-8 BOM for proper multilingual character display
      const BOM = '\uFEFF';
      
      // Comprehensive multilingual headers with proper pricing information
      const csvHeader = "Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„,Ú©Ø¯ Ù…Ø­ØµÙˆÙ„,Ø¨Ø§Ø±Ú©Ø¯,Ù†ÙˆØ¹ Ø¨Ø§Ø±Ú©Ø¯,Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ,Ù‚ÛŒÙ…Øª ÙØ±ÙˆØ´Ú¯Ø§Ù‡,ÙˆØ§Ø­Ø¯ Ù‚ÛŒÙ…Øª,Ø§Ø±Ø²,Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡,ÙˆØ¶Ø¹ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ,Ø­Ø¯ Ú©Ù…ÛŒÙ†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ,Ø¢Ø³ØªØ§Ù†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ù…,ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯\n";
      
      // Process shop products only (single table system)
      const csvRows = shopProducts.map(product => {
        // Escape quotes and handle special characters for CSV
        const escapeCsvField = (field: string | number) => {
          const str = String(field || '');
          if (str.includes(',') || str.includes('\n') || str.includes('"')) {
            return `"${str.replace(/"/g, '""')}"`;
          }
          return `"${str}"`;
        };

        // Format price properly
        const formatPrice = (price: any) => {
          if (!price) return 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡';
          if (typeof price === 'string' && !isNaN(parseFloat(price))) {
            return parseFloat(price).toFixed(2);
          }
          if (typeof price === 'number') {
            return price.toFixed(2);
          }
          return String(price);
        };

        return [
          escapeCsvField(product.name),
          escapeCsvField(product.sku || ''),
          escapeCsvField(product.barcode || 'Ø¨Ø¯ÙˆÙ† Ø¨Ø§Ø±Ú©Ø¯'),
          escapeCsvField(product.barcode ? (product.barcode.length === 13 ? 'EAN-13' : 'Ø³ÙØ§Ø±Ø´ÛŒ') : 'Ù†Ø¯Ø§Ø±Ø¯'),
          escapeCsvField(product.category),
          escapeCsvField(formatPrice(product.price)), // Shop price
          escapeCsvField(product.priceUnit || 'ÙˆØ§Ø­Ø¯'),
          escapeCsvField(product.currency || 'Ø¯ÛŒÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÛŒ'),
          escapeCsvField(product.stockQuantity || 0),
          escapeCsvField((product.stockQuantity && product.stockQuantity > 0) ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù†Ø§Ù…ÙˆØ¬ÙˆØ¯'),
          escapeCsvField(product.minStockLevel || 0),
          escapeCsvField(product.lowStockThreshold || 10),
          escapeCsvField(product.createdAt ? new Date(product.createdAt).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          }) : '')
        ].join(',');
      }).join('\n');
      
      const csvContent = BOM + csvHeader + csvRows;
      
      // Set proper headers for UTF-8 CSV with BOM
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="Complete_Barcode_Export_${new Date().toISOString().split('T')[0]}.csv"`);
      res.send(csvContent);
      
      console.log(`âœ… [EXPORT] Generated complete barcode CSV with ${shopProducts.length} products including pricing`);
    } catch (error) {
      console.error("âŒ [EXPORT] Error exporting barcode data with pricing:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬ÛŒ Ú¯ÛŒØ±ÛŒ ÙØ§ÛŒÙ„ CSV Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù‚ÛŒÙ…Øª" 
      });
    }
  });

  // Helper function to generate label HTML with fixed grid layout
  function generateLabelHTML(products: any[], options: any) {
    const { showPrice, showWebsite, showSKU, labelSize, website } = options;
    
    // Fixed label dimensions matching frontend design
    const labelConfigs = {
      small: { 
        width: '40mm', height: '28mm', padding: '1mm',
        nameFont: '8px', skuFont: '6px', priceFont: '6px', websiteFont: '6px',
        barcodeFont: '10px', nameMaxLength: 15, skuMaxLength: 10
      },
      standard: { 
        width: '56mm', height: '36mm', padding: '2mm',
        nameFont: '10px', skuFont: '8px', priceFont: '8px', websiteFont: '8px',
        barcodeFont: '12px', nameMaxLength: 25, skuMaxLength: 15
      },
      large: { 
        width: '72mm', height: '44mm', padding: '3mm',
        nameFont: '14px', skuFont: '10px', priceFont: '10px', websiteFont: '10px',
        barcodeFont: '16px', nameMaxLength: 35, skuMaxLength: 18
      },
      roll: { 
        width: '48mm', height: '20mm', padding: '1mm',
        nameFont: '7px', skuFont: '6px', priceFont: '6px', websiteFont: '6px',
        barcodeFont: '8px', nameMaxLength: 18, skuMaxLength: 12
      }
    };
    
    const config = labelConfigs[labelSize] || labelConfigs.standard;
    
    const formatPrice = (product: any) => {
      if (!product.price) return '';
      const price = typeof product.price === 'string' ? parseFloat(product.price) : product.price;
      // Always use IQD as the currency for Iraqi market
      const unit = product.priceUnit || 'ÙˆØ§Ø­Ø¯';
      return `${Math.round(price).toLocaleString()} IQD / ${unit}`;
    };

    const truncateText = (text: string, maxLength: number) => {
      return text.length > maxLength ? text.substring(0, maxLength - 3) + '...' : text;
    };

    const generateBarcode = (value: string) => {
      return `<div class="barcode-text" style="font-family: 'Courier New', monospace; font-size: ${config.barcodeFont}; font-weight: bold; letter-spacing: 1px; text-align: center; line-height: 1.2; background: white; color: black;">${value}</div>`;
    };

    const labelsHTML = products.map(product => {
      const displayName = truncateText(product.name, config.nameMaxLength);
      const displaySku = product.sku ? truncateText(product.sku, config.skuMaxLength) : '';
      
      return `
      <div style="
        width: ${config.width}; 
        height: ${config.height}; 
        border: 3px solid #000; 
        padding: ${config.padding}; 
        margin: 2mm; 
        display: inline-block; 
        vertical-align: top;
        background: white;
        box-sizing: border-box;
        page-break-inside: avoid;
        font-family: Arial, sans-serif;
        overflow: hidden;
        position: relative;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      ">
        <!-- Fixed 4-row grid layout -->
        <div style="
          height: 100%; 
          display: grid; 
          grid-template-rows: 1fr 1fr 1fr 1fr; 
          gap: 1mm;
          text-align: center;
        ">
          <!-- Row 1: Product Name (always shown) -->
          <div style="
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-weight: bold; 
            font-size: ${config.nameFont}; 
            line-height: 1.1; 
            overflow: hidden;
            padding: 0 1mm;
          ">
            <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;">
              ${displayName}
            </span>
          </div>

          <!-- Row 2: SKU (if enabled) -->
          <div style="
            display: flex; 
            align-items: center; 
            justify-content: center;
            min-height: 0;
          ">
            ${showSKU && product.sku ? `
              <span class="sku-text" style="
                font-size: ${config.skuFont}; 
                color: #333; 
                font-family: 'Courier New', monospace;
                font-weight: 500;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 100%;
              ">
                SKU: ${displaySku}
              </span>
            ` : '<div style="height: 100%;"></div>'}
          </div>

          <!-- Row 3: Barcode (always shown) -->
          <div style="
            display: flex; 
            align-items: center; 
            justify-content: center;
            min-height: 0;
          ">
            ${generateBarcode(product.barcode)}
          </div>

          <!-- Row 4: Price and Website -->
          <div style="
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center;
            gap: 0.5mm;
            min-height: 0;
          ">
            ${showPrice && product.price ? `
              <span class="price-text" style="
                font-weight: bold; 
                color: #008000; 
                font-size: ${config.priceFont}; 
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 100%;
                text-shadow: 0 1px 1px rgba(0,0,0,0.1);
              ">
                ${formatPrice(product)}
              </span>
            ` : ''}
            
            ${showWebsite ? `
              <span class="website-text" style="
                color: #666; 
                font-size: ${config.websiteFont}; 
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 100%;
                font-weight: 500;
              ">
                momtazchem.com
              </span>
            ` : ''}
          </div>
        </div>
      </div>`;
    }).join('');

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Product Labels - Momtazchem</title>
        <style>
          @import url('https://fonts.googleapis.com/css2?family=Libre+Barcode+128&display=swap');
          
          * {
            box-sizing: border-box;
          }
          
          body { 
            margin: 0; 
            padding: 10mm; 
            font-family: Arial, sans-serif;
            background: white;
            color: black;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
          }
          
          .labels-container {
            display: flex; 
            flex-wrap: wrap; 
            gap: 3mm; 
            align-items: flex-start;
            justify-content: flex-start;
          }
          
          @page {
            size: A4;
            margin: 10mm;
          }
          
          @media print {
            body { 
              margin: 0; 
              padding: 10mm;
              -webkit-print-color-adjust: exact;
              print-color-adjust: exact;
            }
            
            .no-print { 
              display: none; 
            }
            
            .labels-container > div {
              border: 2px solid black !important;
              background: white !important;
              page-break-inside: avoid;
            }
            
            /* Enhanced print quality */
            .barcode-text {
              font-family: 'Courier New', monospace !important;
              font-weight: bold !important;
              letter-spacing: 1px !important;
            }
            
            /* Prevent text from breaking across pages */
            h1, h2, h3, h4, h5, h6 {
              page-break-after: avoid;
            }
            
            /* Better color contrast for printing */
            .price-text {
              color: #008000 !important;
              font-weight: bold !important;
            }
            
            .sku-text {
              color: #333333 !important;
            }
            
            .website-text {
              color: #666666 !important;
            }
          }
          
          /* Print preview styling */
          @media screen {
            body {
              background: #f5f5f5;
              padding: 20mm;
            }
            
            .labels-container {
              background: white;
              padding: 10mm;
              box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
          }
        </style>
      </head>
      <body>
        <div class="labels-container">
          ${labelsHTML}
        </div>
        
        <!-- Print Instructions (hidden in print) -->
        <div class="no-print" style="margin-top: 20mm; padding: 10mm; background: #f0f0f0; border-radius: 5mm;">
          <h3 style="margin: 0 0 5mm 0; color: #333;">Print Instructions:</h3>
          <ul style="margin: 0; padding-left: 15mm; color: #666;">
            <li>Use Ctrl+P (Cmd+P on Mac) to print</li>
            <li>Select "More settings" â†’ "Options" â†’ "Background graphics" for best quality</li>
            <li>Recommended: Use high-quality printer with black ink</li>
            <li>Print on A4 paper for standard labels</li>
          </ul>
        </div>
      </body>
      </html>
    `;
  }

  // Generate customized printable labels for products with user options
  app.post("/api/barcode/generate-custom-labels", requireAuth, async (req, res) => {
    try {
      console.log('ðŸ·ï¸  [CUSTOM LABELS] Request received:', { 
        productsCount: req.body.products?.length, 
        options: req.body.options,
        format: req.body.format 
      });
      
      const { products, options, format = 'html' } = req.body;
      
      if (!products || !Array.isArray(products) || products.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø¨Ø±Ú†Ø³Ø¨ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª"
        });
      }

      // Extract options with defaults
      const {
        includePrice = true,
        includeWebsite = true,
        includeSKU = true,
        websiteText = "www.momtazchem.com",
        labelSize = "standard"
      } = options || {};

      // Generate HTML for labels using the extracted options
      const labelHTML = generateLabelHTML(products, {
        showPrice: includePrice,
        showWebsite: includeWebsite,
        showSKU: includeSKU,
        labelSize,
        website: websiteText
      });

      // Return as image if requested
      if (format === 'image') {
        try {
          const browser = await puppeteer.launch({
            headless: 'new',
            args: [
              '--no-sandbox', 
              '--disable-setuid-sandbox',
              '--disable-dev-shm-usage',
              '--disable-accelerated-2d-canvas',
              '--no-first-run',
              '--no-zygote',
              '--single-process',
              '--disable-gpu'
            ],
            executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser'
          });
          
          const page = await browser.newPage();
          await page.setContent(labelHTML, { waitUntil: 'networkidle0' });
          
          // Set viewport for better image quality
          await page.setViewport({ width: 800, height: 600 });
          
          const screenshot = await page.screenshot({
            type: 'png',
            fullPage: true,
            omitBackground: false
          });
          
          await browser.close();

          res.setHeader('Content-Type', 'image/png');
          res.setHeader('Content-Disposition', `attachment; filename="Custom_Labels_${new Date().toISOString().split('T')[0]}.png"`);
          res.send(screenshot);
          
          console.log(`âœ… [CUSTOM LABELS] Generated custom labels image for ${products.length} products`);
          return;
        } catch (imageError) {
          console.log('Puppeteer image generation failed, trying alternative method:', imageError.message);
          
          // Alternative: Return as base64 encoded image using canvas
          try {
            // For now, we'll create a simple HTML response that can be converted to image on client side
            const imageHTML = `
              <!DOCTYPE html>
              <html>
              <head>
                <meta charset="UTF-8">
                <title>Product Labels</title>
                <style>
                  body { 
                    margin: 0; 
                    padding: 20px; 
                    font-family: Arial, sans-serif;
                    background: white;
                    width: 800px;
                    height: auto;
                  }
                  .convert-to-image { display: block; }
                </style>
                <script>
                  window.addEventListener('load', function() {
                    // This script will help convert HTML to canvas/image on client side
                    if (window.html2canvas) {
                      html2canvas(document.body).then(function(canvas) {
                        const link = document.createElement('a');
                        link.download = 'custom-labels.png';
                        link.href = canvas.toDataURL();
                        link.click();
                      });
                    }
                  });
                </script>
              </head>
              <body class="convert-to-image">
                ${labelHTML.replace('<!DOCTYPE html>', '').replace(/<html[^>]*>/, '').replace('</html>', '').replace(/<head[^>]*>[\s\S]*?<\/head>/, '').replace(/<body[^>]*>/, '').replace('</body>', '')}
              </body>
              </html>
            `;
            
            res.setHeader('Content-Type', 'text/html; charset=utf-8');
            res.setHeader('Content-Disposition', `attachment; filename="Custom_Labels_For_Image_${new Date().toISOString().split('T')[0]}.html"`);
            res.send(imageHTML);
            
            console.log(`âœ… [CUSTOM LABELS] Generated HTML for image conversion for ${products.length} products`);
            return;
          } catch (htmlError) {
            console.log('HTML image generation also failed, falling back to standard HTML:', htmlError.message);
          }
        }
      }

      // Return HTML directly for better compatibility and user control
      console.log('ðŸ·ï¸  [CUSTOM LABELS] Generating HTML for custom labels');
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.setHeader('Content-Disposition', 'attachment; filename="Custom_Product_Labels.html"');
      res.send(labelHTML);

      console.log(`âœ… [CUSTOM LABELS] Generated custom labels for ${products.length} products`);
    } catch (error) {
      console.error("âŒ [CUSTOM LABELS] Error generating custom labels:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø¨Ø±Ú†Ø³Ø¨â€ŒÙ‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´ÛŒ"
      });
    }
  });

  // Generate printable labels for products
  app.post("/api/barcode/generate-labels", requireAuth, async (req, res) => {
    try {
      console.log('ðŸ·ï¸  [LABELS] Request received:', { labelSize: req.body.labelSize, productsCount: req.body.products?.length });
      const { products, showPrice, showWebsite, showSKU, labelSize, website } = req.body;
      
      if (!products || !Array.isArray(products) || products.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒØ¨Ù„ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª"
        });
      }

      // Generate HTML for labels
      const labelHTML = generateLabelHTML(products, {
        showPrice,
        showWebsite,
        showSKU,
        labelSize,
        website: website || 'www.momtazchem.com'
      });

      // For roll printer, return HTML directly for better compatibility
      if (labelSize === 'roll') {
        console.log('ðŸ·ï¸  [LABELS] Generating HTML for roll printer');
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Disposition', 'inline; filename="Roll_Labels.html"');
        return res.send(labelHTML);
      }

      // For other sizes, generate PDF using Puppeteer
      try {
        const browser = await puppeteer.launch({
          headless: true,
          args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        
        const page = await browser.newPage();
        await page.setContent(labelHTML, { waitUntil: 'networkidle0' });
        
        const pdf = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: {
            top: '10mm',
            right: '10mm',
            bottom: '10mm',
            left: '10mm',
          }
        });
        
        await browser.close();

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="Product_Labels_${new Date().toISOString().split('T')[0]}.pdf"`);
        res.send(pdf);
      } catch (pdfError) {
        // Fallback to HTML if PDF generation fails
        console.log('PDF generation failed, falling back to HTML:', pdfError.message);
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Disposition', 'inline; filename="Product_Labels.html"');
        res.send(labelHTML);
      }

      console.log(`âœ… [LABELS] Generated labels PDF for ${products.length} products`);
    } catch (error) {
      console.error("âŒ [LABELS] Error generating labels:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒØ¨Ù„â€ŒÙ‡Ø§"
      });
    }
  });

  // Validate EAN-13 barcode
  app.post("/api/ean13/validate", requireAuth, async (req, res) => {
    try {
      const { barcode } = req.body;
      
      if (!barcode || typeof barcode !== 'string') {
        return res.status(400).json({
          success: false,
          message: "Barcode is required"
        });
      }

      // Validate EAN-13 format
      if (barcode.length !== 13 || !/^\d+$/.test(barcode)) {
        return res.json({
          success: true,
          valid: false,
          message: "Invalid EAN-13 format"
        });
      }

      // Validate check digit
      let sum = 0;
      for (let i = 0; i < 12; i++) {
        const digit = parseInt(barcode[i]);
        sum += i % 2 === 0 ? digit : digit * 3;
      }
      const calculatedCheckDigit = (10 - (sum % 10)) % 10;
      const providedCheckDigit = parseInt(barcode[12]);
      
      const isValid = calculatedCheckDigit === providedCheckDigit;
      
      res.json({
        success: true,
        valid: isValid,
        checkDigit: calculatedCheckDigit,
        message: isValid ? "Valid EAN-13 barcode" : "Invalid check digit"
      });
    } catch (error) {
      console.error("Error validating EAN-13:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // DATABASE BACKUP ENDPOINTS
  // =============================================================================

  // Create database backup
  app.post("/api/admin/backup/create", requireAuth, async (req, res) => {
    try {
      const { spawn } = await import('child_process');
      const fsModule = await import('fs');
      const pathModule = await import('path');
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
      const backupDir = './backups';
      const backupFile = `database_backup_${timestamp}.sql`;
      const backupPath = path.join(backupDir, backupFile);
      
      // Create backup directory if it doesn't exist
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }
      
      // Create backup using pg_dump
      const databaseUrl = process.env.DATABASE_URL;
      if (!databaseUrl) {
        return res.status(500).json({
          success: false,
          message: "Database URL not configured"
        });
      }

      const pgDump = spawn('pg_dump', [databaseUrl, '--no-owner', '--no-privileges']);
      
      const writeStream = fs.createWriteStream(backupPath);
      pgDump.stdout?.pipe(writeStream);
      
      let errorOutput = '';
      pgDump.stderr?.on('data', (data: Buffer) => {
        errorOutput += data.toString();
      });
      
      pgDump.on('close', (code: number | null) => {
        if (code === 0) {
          const stats = fs.statSync(backupPath);
          res.json({
            success: true,
            message: 'Backup created successfully',
            filename: backupFile,
            size: stats.size,
            timestamp: new Date().toISOString()
          });
        } else {
          console.error('pg_dump error:', errorOutput);
          res.status(500).json({
            success: false,
            message: 'Failed to create backup',
            error: errorOutput
          });
        }
      });
      
    } catch (error) {
      console.error("Error creating backup:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Download database backup
  app.get("/api/admin/backup/download/:filename", requireAuth, async (req, res) => {
    try {
      const { filename } = req.params;
      
      // Security check - only allow .sql and .sql.gz files and prevent directory traversal
      if ((!filename.endsWith('.sql') && !filename.endsWith('.sql.gz')) || filename.includes('..') || filename.includes('/')) {
        return res.status(400).json({
          success: false,
          message: 'Invalid filename'
        });
      }
      
      const backupPath = path.join('./backups', filename);
      
      if (!fs.existsSync(backupPath)) {
        return res.status(404).json({
          success: false,
          message: 'Backup file not found'
        });
      }
      
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Type', 'application/sql');
      
      const fileStream = fs.createReadStream(backupPath);
      fileStream.pipe(res);
      
    } catch (error) {
      console.error("Error downloading backup:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Delete database backup
  app.delete("/api/admin/backup/delete/:filename", requireAuth, async (req, res) => {
    try {
      const { filename } = req.params;
      
      // Security check - only allow .sql and .sql.gz files and prevent directory traversal
      if ((!filename.endsWith('.sql') && !filename.endsWith('.sql.gz')) || filename.includes('..') || filename.includes('/')) {
        return res.status(400).json({
          success: false,
          message: 'Invalid filename'
        });
      }
      
      const backupPath = path.join('./backups', filename);
      
      if (!fs.existsSync(backupPath)) {
        return res.status(404).json({
          success: false,
          message: 'Backup file not found'
        });
      }
      
      // Delete the backup file
      fs.unlinkSync(backupPath);
      
      res.json({
        success: true,
        message: 'Backup file deleted successfully'
      });
      
    } catch (error) {
      console.error("Error deleting backup:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // List available backups
  app.get("/api/admin/backup/list", requireAuth, async (req, res) => {
    try {
      
      const backupDir = './backups';
      
      if (!fs.existsSync(backupDir)) {
        return res.json({ backups: [] });
      }
      
      const files = fs.readdirSync(backupDir)
        .filter(file => file.endsWith('.sql') || file.endsWith('.sql.gz'))
        .map(file => {
          const filePath = path.join(backupDir, file);
          const stats = fs.statSync(filePath);
          return {
            filename: file,
            size: stats.size,
            created: stats.birthtime,
            modified: stats.mtime
          };
        })
        .sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime());
      
      res.json({ backups: files });
    } catch (error) {
      console.error("Error listing backups:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // ADMIN USER MANAGEMENT ENDPOINTS (SUPER ADMIN ONLY)
  // =============================================================================

  // Check if user has specific permission
  const hasPermission = async (userId: number, permissionName: string): Promise<boolean> => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 1 FROM users u
        JOIN admin_roles r ON u.role_id = r.id
        JOIN role_permissions rp ON r.id = rp.role_id
        JOIN admin_permissions p ON rp.permission_id = p.id
        WHERE u.id = $1 AND p.name = $2 AND u.is_active = true AND r.is_active = true
      `, [userId, permissionName]);
      return result.rows.length > 0;
    } catch (error) {
      console.error('Error checking permission:', error);
      return false;
    }
  };

  // Middleware to check super admin permission
  const requireSuperAdmin = async (req: Request, res: Response, next: NextFunction) => {
    const session = req.session as any;
    if (!session?.adminId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }

    const canManageUsers = await hasPermission(session.adminId, 'manage_users');
    if (!canManageUsers) {
      return res.status(403).json({ success: false, message: "Super admin access required" });
    }

    next();
  };

  // Get all admin users
  app.get("/api/admin/users", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT u.id, u.username, u.email, u.role_id, u.is_active, u.last_login_at, u.created_at,
               r.name as role_name, r.display_name as role_display_name
        FROM users u
        LEFT JOIN admin_roles r ON u.role_id = r.id
        ORDER BY u.created_at DESC
      `);
      
      const users = result.rows.map((row: any) => ({
        id: row.id,
        username: row.username,
        email: row.email,
        roleId: row.role_id,
        roleName: row.role_name,
        roleDisplayName: row.role_display_name,
        isActive: row.is_active,
        lastLoginAt: row.last_login_at,
        createdAt: row.created_at
      }));

      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get all admin roles
  app.get("/api/admin/roles", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT r.id, r.name, r.display_name, r.description, r.is_active,
               COUNT(rp.permission_id) as permission_count
        FROM admin_roles r
        LEFT JOIN role_permissions rp ON r.id = rp.role_id
        GROUP BY r.id, r.name, r.display_name, r.description, r.is_active
        ORDER BY r.id
      `);
      
      const roles = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        isActive: row.is_active,
        permissionCount: parseInt(row.permission_count)
      }));

      res.json(roles);
    } catch (error) {
      console.error("Error fetching roles:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Function to convert technical module IDs to Persian names
  function convertTechnicalToPersianModule(moduleId: string): string {
    const technicalToPersianMap: { [key: string]: string } = {
      'syncing_shop': 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡',
      'inquiries': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª',
      'barcode': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯',
      'email_settings': 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„',
      'database_backup': 'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡',
      'crm': 'Ù…Ø¯ÛŒØ±ÛŒØª CRM',
      'seo': 'Ù…Ø¯ÛŒØ±ÛŒØª SEO',
      'categories': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§',
      'sms': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©',
      'factory': 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡',
      'user_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†',
      'shop_management': 'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡',
      'procedures': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§',
      'order_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
      'product_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª',
      'payment_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª',
      'finance': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ',
      'wallet_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„',
      'geography_analytics': 'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ',
      'ai_settings': 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ',
      'refresh_control': 'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ',
      'content_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§',
      'warehouse_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±',
      'logistics_management': 'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©',
      'ticketing_system': 'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯',
      'remote_desktop': 'Ø¯Ø³Ú©ØªØ§Ù¾ Ø±ÛŒÙ…ÙˆØª',
      'server_config': 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±'
    };

    return technicalToPersianMap[moduleId] || moduleId;
  }

  // Get all admin permissions
  app.get("/api/admin/permissions", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, display_name, description, module, is_active
        FROM admin_permissions
        ORDER BY module, display_name
      `);
      
      const permissions = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        module: row.module,
        isActive: row.is_active
      }));

      res.json(permissions);
    } catch (error) {
      console.error("Error fetching permissions:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Sync modules with main system
  app.post("/api/admin/sync-modules", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Define the main system modules - these are the 26 Site Management modules
      const mainModules = [
        'syncing_shop',
        'inquiries', 
        'barcode',
        'email_settings',
        'database_backup',
        'crm',
        'seo',
        'categories',
        'sms',
        'factory',
        'user_management',
        'shop_management',
        'procedures',
        'order_management',
        'product_management',
        'payment_management',
        'wallet_management',
        'geography_analytics',
        'ai_settings',
        'refresh_control',
        'finance',
        'content_management',
        'warehouse_management',
        'logistics_management',
        'ticketing_system',
        'remote_desktop',
        'server_config'
      ];

      // Get super admin role (admin@momtazchem.com has user ID 7)
      const superAdminRoleId = '7';
      
      let syncedModules = 0;

      // Sync each main module to module_permissions for super admin
      for (const moduleId of mainModules) {
        // Check if module permission exists for super admin
        const existingPermission = await pool.query(
          'SELECT id FROM module_permissions WHERE role_id = $1 AND module_id = $2',
          [superAdminRoleId, moduleId]
        );

        if (existingPermission.rows.length === 0) {
          // Create the permission for super admin
          await pool.query(`
            INSERT INTO module_permissions (role_id, module_id, can_view, can_create, can_edit, can_delete, can_approve, created_at, updated_at)
            VALUES ($1, $2, true, true, true, true, true, NOW(), NOW())
          `, [superAdminRoleId, moduleId]);
          syncedModules++;
        } else {
          // Update existing permission to ensure it's active
          await pool.query(`
            UPDATE module_permissions SET
              can_view = true,
              can_create = true,
              can_edit = true,
              can_delete = true,
              can_approve = true,
              updated_at = NOW()
            WHERE role_id = $1 AND module_id = $2
          `, [superAdminRoleId, moduleId]);
        }
      }

      console.log(`âœ… Module sync completed: ${syncedModules} new modules synced for super admin`);
      
      res.json({
        success: true,
        message: "ØªÙ… Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
        syncedModules,
        totalModules: mainModules.length
      });
    } catch (error) {
      console.error("Error syncing modules:", error);
      res.status(500).json({ 
        success: false, 
        message: "ÙØ´Ù„ ÙÙŠ Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙˆØ­Ø¯Ø§Øª",
        error: error.message 
      });
    }
  });

  // User Management sync modules endpoint
  // Function to get current Site Management modules dynamically
  const getSiteManagementModules = () => {
    // This should be the SINGLE SOURCE OF TRUTH for all modules
    // Any changes here will automatically sync to User Management
    return [
      'syncing_shop',
      'shop_management', 
      'product_management',
      'order_management',
      'warehouse_management',
      'logistics_management',
      'inquiries',
      'crm',
      'barcode',
      'email_settings',
      'database_backup',
      'seo',
      'categories',
      'sms',
      'factory',
      'user_management',
      'procedures',
      'payment_management',
      'finance',
      'wallet_management',
      'geography_analytics',
      'ai_settings',
      'refresh_control',
      'content_management',
      'ticketing_system',
      'remote_desktop',
      'server_config'
      // Total: 26 modules - automatically synced with Site Management
    ];
  };

  app.post("/api/user-management/sync-modules", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get current modules from the single source of truth
      const mainModules = getSiteManagementModules();

      // Get super admin role (admin@momtazchem.com has user ID 7)
      const superAdminRoleId = '7';
      
      let syncedModules = 0;

      // Sync each main module to module_permissions for super admin
      for (const moduleId of mainModules) {
        // Check if module permission exists for super admin
        const existingPermission = await pool.query(
          'SELECT id FROM module_permissions WHERE role_id = $1 AND module_id = $2',
          [superAdminRoleId, moduleId]
        );

        if (existingPermission.rows.length === 0) {
          // Create the permission for super admin
          await pool.query(`
            INSERT INTO module_permissions (role_id, module_id, can_view, can_create, can_edit, can_delete, can_approve, created_at, updated_at)
            VALUES ($1, $2, true, true, true, true, true, NOW(), NOW())
          `, [superAdminRoleId, moduleId]);
          syncedModules++;
        }
      }

      console.log(`âœ… User Management sync completed: ${syncedModules} new modules synced`);
      
      res.json({
        success: true,
        message: `Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù†Ø¯. ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„: ${mainModules.length}`,
        syncedModules,
        totalModules: mainModules.length,
        modulesList: mainModules  // Return the current module list for frontend reference
      });
    } catch (error) {
      console.error("Error syncing modules from User Management:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§",
        error: error.message 
      });
    }
  });

  // NEW: API endpoint to get current Site Management modules list
  app.get("/api/site-management/modules", requireAuth, async (req, res) => {
    try {
      const modules = getSiteManagementModules();
      res.json({
        success: true,
        modules: modules,
        count: modules.length
      });
    } catch (error) {
      console.error("âŒ Error getting Site Management modules:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get Site Management modules"
      });
    }
  });

  // Create new admin user
  app.post("/api/admin/users", requireSuperAdmin, async (req, res) => {
    try {
      const { username, email, password, roleId } = req.body;
      
      // Hash password
      const passwordHash = await bcrypt.hash(password, 12);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO users (username, email, password_hash, role_id, is_active)
        VALUES ($1, $2, $3, $4, true)
        RETURNING id, username, email, role_id, is_active, created_at
      `, [username, email, passwordHash, roleId]);

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating user:", error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Username or email already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Update admin user
  app.put("/api/admin/users/:id", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { username, email, password, roleId } = req.body;
      
      let query = `
        UPDATE users 
        SET username = $1, email = $2, role_id = $3, updated_at = NOW()
      `;
      let params = [username, email, roleId];
      
      if (password && password.trim() !== '') {
        const passwordHash = await bcrypt.hash(password, 12);
        query += `, password_hash = $4`;
        params.push(passwordHash);
        query += ` WHERE id = $5`;
        params.push(id);
      } else {
        query += ` WHERE id = $4`;
        params.push(id);
      }
      
      query += ` RETURNING id, username, email, role_id, is_active`;

      const { pool } = await import('./db');
      const result = await pool.query(query, params);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "User not found" });
      }

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error updating user:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Username or email already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Toggle user active status
  app.put("/api/admin/users/:id/status", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE users 
        SET is_active = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING id, username, email, is_active
      `, [isActive, id]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "User not found" });
      }

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // ROLE MANAGEMENT ENDPOINTS (SUPER ADMIN ONLY)
  // =============================================================================

  // Create new role
  app.post("/api/admin/roles", requireSuperAdmin, async (req, res) => {
    try {
      const { name, displayName, description } = req.body;
      
      if (!name || !displayName) {
        return res.status(400).json({ success: false, message: "Name and display name are required" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO admin_roles (name, display_name, description, is_active)
        VALUES ($1, $2, $3, true)
        RETURNING id, name, display_name, description, is_active, created_at
      `, [name, displayName, description]);

      res.json({
        success: true,
        role: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating role:", error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Role name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Update role
  app.put("/api/admin/roles/:id", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, displayName, description, isActive } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE admin_roles 
        SET name = $1, display_name = $2, description = $3, is_active = $4, updated_at = NOW()
        WHERE id = $5
        RETURNING id, name, display_name, description, is_active, updated_at
      `, [name, displayName, description, isActive, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Role not found" });
      }

      res.json({
        success: true,
        role: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error updating role:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Role name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Delete role
  app.delete("/api/admin/roles/:id", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      
      // Check if role has users assigned
      const usersCheck = await pool.query(`
        SELECT COUNT(*) as user_count FROM users WHERE role_id = $1
      `, [id]);
      
      if (parseInt(usersCheck.rows[0].user_count) > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Cannot delete role that has users assigned to it" 
        });
      }

      // Delete role permissions first
      await pool.query(`DELETE FROM role_permissions WHERE role_id = $1`, [id]);
      
      // Delete role
      const result = await pool.query(`
        DELETE FROM admin_roles WHERE id = $1 RETURNING id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Role not found" });
      }

      res.json({
        success: true,
        message: "Role deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting role:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get role permissions
  app.get("/api/admin/roles/:id/permissions", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT p.id, p.name, p.display_name, p.description, p.module,
               CASE WHEN rp.permission_id IS NOT NULL THEN true ELSE false END as assigned
        FROM admin_permissions p
        LEFT JOIN role_permissions rp ON p.id = rp.permission_id AND rp.role_id = $1
        WHERE p.is_active = true
        ORDER BY p.module, p.display_name
      `, [id]);

      const permissions = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        module: row.module,
        assigned: row.assigned
      }));

      res.json(permissions);
    } catch (error) {
      console.error("Error fetching role permissions:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update role permissions
  app.put("/api/admin/roles/:id/permissions", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { permissionIds } = req.body;
      
      if (!Array.isArray(permissionIds)) {
        return res.status(400).json({ success: false, message: "Permission IDs must be an array" });
      }

      const { pool } = await import('./db');
      
      // Begin transaction
      await pool.query('BEGIN');
      
      try {
        // Remove existing permissions
        await pool.query(`DELETE FROM role_permissions WHERE role_id = $1`, [id]);
        
        // Add new permissions
        if (permissionIds.length > 0) {
          const values = permissionIds.map((permId: string, index: number) => 
            `($1, $${index + 2})`
          ).join(', ');
          
          const query = `INSERT INTO role_permissions (role_id, permission_id) VALUES ${values}`;
          await pool.query(query, [id, ...permissionIds]);
        }
        
        await pool.query('COMMIT');
        
        res.json({
          success: true,
          message: "Role permissions updated successfully"
        });
      } catch (error) {
        await pool.query('ROLLBACK');
        throw error;
      }
    } catch (error) {
      console.error("Error updating role permissions:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // CUSTOM USER MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all custom roles
  app.get("/api/admin/custom-roles", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          cr.*,
          COUNT(cu.id) as user_count
        FROM custom_roles cr
        LEFT JOIN custom_users cu ON cr.id = cu.role_id AND cu.is_active = true
        GROUP BY cr.id
        ORDER BY cr.priority DESC, cr.display_name
      `);

      const roles = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description,
        color: row.color,
        priority: row.priority,
        permissions: row.permissions || [],
        permissionCount: (row.permissions || []).length, // Ø´Ù…Ø§Ø±Ø´ Ø¯Ù‚ÛŒÙ‚ Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§
        userCount: parseInt(row.user_count),
        isActive: row.is_active,
        createdAt: row.created_at
      }));

      res.json({ success: true, data: roles });
    } catch (error) {
      console.error("Error fetching custom roles:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø´â€ŒÙ‡Ø§" });
    }
  });

  // Create custom role
  app.post("/api/admin/custom-roles", requireAuth, async (req, res) => {
    try {
      const { name, displayName, description, color, priority, permissions } = req.body;
      
      if (!name || !displayName) {
        return res.status(400).json({ success: false, message: "Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ù†Ù…Ø§ÛŒØ´ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO custom_roles (name, display_name, description, color, priority, permissions)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *
      `, [name, displayName, description, color || '#3b82f6', priority || 1, permissions || []]);

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ù†Ù‚Ø´ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error creating custom role:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ù†Ø§Ù… Ù†Ù‚Ø´ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù‚Ø´" });
      }
    }
  });

  // Update custom role
  app.patch("/api/admin/custom-roles/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, displayName, description, color, priority, permissions, isActive } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE custom_roles 
        SET 
          name = COALESCE($1, name),
          display_name = COALESCE($2, display_name),
          description = COALESCE($3, description),
          color = COALESCE($4, color),
          priority = COALESCE($5, priority),
          permissions = COALESCE($6, permissions),
          is_active = COALESCE($7, is_active),
          updated_at = NOW()
        WHERE id = $8
        RETURNING *
      `, [name, displayName, description, color, priority, permissions, isActive, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ù†Ù‚Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ù†Ù‚Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error updating custom role:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ù†Ø§Ù… Ù†Ù‚Ø´ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ù‚Ø´" });
      }
    }
  });

  // Delete custom role
  app.delete("/api/admin/custom-roles/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      
      // Check if role has users assigned
      const usersCheck = await pool.query(`
        SELECT COUNT(*) as user_count FROM custom_users WHERE role_id = $1
      `, [id]);
      
      if (parseInt(usersCheck.rows[0].user_count) > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù†Ù‚Ø´ÛŒ Ø±Ø§ Ø­Ø°Ù Ú©Ø±Ø¯ Ú©Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ù‡ Ø¢Ù† ØªØ®ØµÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯" 
        });
      }

      const result = await pool.query(`
        DELETE FROM custom_roles WHERE id = $1 RETURNING id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ù†Ù‚Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        message: "Ù†Ù‚Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting custom role:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù†Ù‚Ø´" });
    }
  });

  // Get all custom users
  app.get("/api/admin/custom-users", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          cu.*,
          cr.name as role_name,
          cr.display_name as role_display_name,
          cr.color as role_color
        FROM custom_users cu
        LEFT JOIN custom_roles cr ON cu.role_id = cr.id
        ORDER BY cu.created_at DESC
      `);

      const users = result.rows.map((row: any) => ({
        id: row.id,
        fullName: row.full_name,
        email: row.email,
        phone: row.phone,
        roleId: row.role_id,
        roleName: row.role_name,
        roleDisplayName: row.role_display_name,
        roleColor: row.role_color,
        isActive: row.is_active,
        smsNotifications: row.sms_notifications,
        emailNotifications: row.email_notifications,
        lastLogin: row.last_login,
        createdAt: row.created_at
      }));

      res.json({ success: true, data: users });
    } catch (error) {
      console.error("Error fetching custom users:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†" });
    }
  });

  // Create custom user
  app.post("/api/admin/custom-users", requireAuth, async (req, res) => {
    try {
      const { fullName, email, phone, password, roleId, smsNotifications, emailNotifications, isActive } = req.body;
      
      if (!fullName || !email || !phone || !password || !roleId) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Hash password
      const bcrypt = await import('bcryptjs');
      const passwordHash = await bcrypt.hash(password, 10);

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO custom_users (
          full_name, email, phone, password_hash, role_id, 
          sms_notifications, email_notifications, is_active
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id, full_name, email, phone, role_id, is_active, 
                  sms_notifications, email_notifications, created_at
      `, [fullName, email, phone, passwordHash, roleId, 
          smsNotifications ?? true, emailNotifications ?? true, isActive ?? true]);

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error creating custom user:", error);
      if (error.code === '23505') {
        if (error.constraint?.includes('email')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else if (error.constraint?.includes('phone')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else {
          res.status(400).json({ success: false, message: "Ø¯Ø§Ø¯Ù‡ ØªÚ©Ø±Ø§Ø±ÛŒ" });
        }
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±" });
      }
    }
  });

  // Update custom user
  app.patch("/api/admin/custom-users/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { fullName, email, phone, password, roleId, smsNotifications, emailNotifications, isActive } = req.body;
      
      let passwordHash = undefined;
      if (password) {
        const bcrypt = await import('bcryptjs');
        passwordHash = await bcrypt.hash(password, 10);
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE custom_users 
        SET 
          full_name = COALESCE($1, full_name),
          email = COALESCE($2, email),
          phone = COALESCE($3, phone),
          password_hash = COALESCE($4, password_hash),
          role_id = COALESCE($5, role_id),
          sms_notifications = COALESCE($6, sms_notifications),
          email_notifications = COALESCE($7, email_notifications),
          is_active = COALESCE($8, is_active),
          updated_at = NOW()
        WHERE id = $9
        RETURNING id, full_name, email, phone, role_id, is_active,
                  sms_notifications, email_notifications, updated_at
      `, [fullName, email, phone, passwordHash, roleId, smsNotifications, emailNotifications, isActive, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        data: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error: any) {
      console.error("Error updating custom user:", error);
      if (error.code === '23505') {
        if (error.constraint?.includes('email')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else if (error.constraint?.includes('phone')) {
          res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
        } else {
          res.status(400).json({ success: false, message: "Ø¯Ø§Ø¯Ù‡ ØªÚ©Ø±Ø§Ø±ÛŒ" });
        }
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±Ø¨Ø±" });
      }
    }
  });

  // Delete custom user
  app.delete("/api/admin/custom-users/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        DELETE FROM custom_users WHERE id = $1 RETURNING id
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Custom user login endpoint
  app.post("/api/custom-users/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ Ùˆ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const { pool } = await import('./db');
      const bcrypt = await import('bcryptjs');
      
      // Get custom user by email
      const result = await pool.query(`
        SELECT 
          cu.*,
          cr.name as role_name,
          cr.display_name as role_display_name,
          cr.permissions as role_permissions
        FROM custom_users cu
        LEFT JOIN custom_roles cr ON cu.role_id = cr.id
        WHERE cu.email = $1 AND cu.is_active = true
      `, [email]);

      if (result.rows.length === 0) {
        return res.status(401).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª"
        });
      }

      const user = result.rows[0];
      
      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.password_hash);
      if (!isValidPassword) {
        // Update login attempts
        await pool.query(`
          UPDATE custom_users 
          SET login_attempts = login_attempts + 1, updated_at = NOW()
          WHERE id = $1
        `, [user.id]);
        
        return res.status(401).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª"
        });
      }

      // Update last login and reset login attempts
      await pool.query(`
        UPDATE custom_users 
        SET last_login = NOW(), login_attempts = 0, updated_at = NOW()
        WHERE id = $1
      `, [user.id]);

      // Set session
      req.session.customUserId = user.id;
      req.session.customUserEmail = user.email;
      req.session.customUserName = user.full_name;
      req.session.customUserRole = user.role_name;
      req.session.customUserPermissions = user.role_permissions;
      req.session.isAuthenticated = true;

      res.json({
        success: true,
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚",
        user: {
          id: user.id,
          fullName: user.full_name,
          email: user.email,
          role: user.role_name,
          roleDisplayName: user.role_display_name,
          permissions: user.role_permissions
        }
      });

    } catch (error) {
      console.error("Error in custom user login:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯"
      });
    }
  });

  // Custom user logout endpoint
  app.post("/api/custom-users/logout", async (req, res) => {
    try {
      // Clear all session data (single session mode)
      req.session.customUserId = undefined;
      req.session.customUserEmail = undefined;
      req.session.customUserName = undefined;
      req.session.customUserRole = undefined;
      req.session.customUserPermissions = undefined;
      req.session.adminId = undefined;
      req.session.customerId = undefined;
      req.session.customerEmail = undefined;
      req.session.crmCustomerId = undefined;
      req.session.isAuthenticated = undefined;
      
      // Always destroy entire session for clean logout
      req.session.destroy((err) => {
        if (err) {
          console.error("Error destroying session:", err);
          return res.status(500).json({
            success: false,
            message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬"
          });
        }
        console.log('ðŸ”„ Complete custom user logout - all sessions cleared');
        res.json({
          success: true,
          message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚"
        });
      });
    } catch (error) {
      console.error("Error logging out custom user:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬"
      });
    }
  });

  // Get current custom user profile
  app.get("/api/custom-users/me", async (req, res) => {
    try {
      const customUserId = req.session.customUserId;
      
      if (!customUserId) {
        return res.status(401).json({
          success: false,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡"
        });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          cu.id, cu.full_name, cu.email, cu.phone, cu.is_active,
          cu.sms_notifications, cu.email_notifications, cu.last_login,
          cr.name as role_name, cr.display_name as role_display_name,
          cr.permissions as role_permissions
        FROM custom_users cu
        LEFT JOIN custom_roles cr ON cu.role_id = cr.id
        WHERE cu.id = $1 AND cu.is_active = true
      `, [customUserId]);

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const user = result.rows[0];
      res.json({
        success: true,
        user: {
          id: user.id,
          fullName: user.full_name,
          email: user.email,
          phone: user.phone,
          role: user.role_name,
          roleDisplayName: user.role_display_name,
          permissions: user.role_permissions,
          isActive: user.is_active,
          smsNotifications: user.sms_notifications,
          emailNotifications: user.email_notifications,
          lastLogin: user.last_login
        }
      });

    } catch (error) {
      console.error("Error fetching custom user profile:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø±ÙˆÙØ§ÛŒÙ„"
      });
    }
  });

  // Send SMS to users
  app.post("/api/admin/send-sms", requireAuth, async (req, res) => {
    try {
      const { userIds, message } = req.body;
      
      if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ø´ÙˆØ¯" 
        });
      }

      if (!message || message.trim().length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù…ØªÙ† Ù¾ÛŒØ§Ù…Ú© Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const { pool } = await import('./db');
      
      // Get users who have SMS notifications enabled
      const usersResult = await pool.query(`
        SELECT id, full_name, phone, sms_notifications
        FROM custom_users 
        WHERE id = ANY($1) AND is_active = true AND sms_notifications = true
      `, [userIds]);

      if (usersResult.rows.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ø§Ù„ÛŒ Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ SMS ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Log SMS notifications
      const insertPromises = usersResult.rows.map((user: any) => 
        pool.query(`
          INSERT INTO sms_notifications (recipient_id, recipient_phone, message)
          VALUES ($1, $2, $3)
        `, [user.id, user.phone, message])
      );

      await Promise.all(insertPromises);

      // Here you would integrate with actual SMS service
      // For now, we'll just mark them as sent
      await pool.query(`
        UPDATE sms_notifications 
        SET status = 'sent', sent_at = NOW()
        WHERE recipient_id = ANY($1) AND message = $2 AND status = 'pending'
      `, [userIds, message]);

      res.json({
        success: true,
        message: `Ù¾ÛŒØ§Ù…Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø§ÛŒ ${usersResult.rows.length} Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`,
        sentTo: usersResult.rows.length
      });
    } catch (error) {
      console.error("Error sending SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú©" });
    }
  });

  // ============================================
  // CUSTOM USER MANAGEMENT SYSTEM ENDPOINTS
  // ============================================

  // Get all custom roles
  app.get("/api/custom-roles", requireAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT cr.*, 
               COUNT(cu.id) as user_count
        FROM custom_roles cr
        LEFT JOIN custom_users cu ON cr.id = cu.role_id AND cu.is_active = true
        WHERE cr.is_active = true
        GROUP BY cr.id
        ORDER BY cr.priority DESC, cr.name
      `);

      res.json({
        success: true,
        roles: result.rows
      });
    } catch (error) {
      console.error("Error fetching custom roles:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø´â€ŒÙ‡Ø§" });
    }
  });

  // Create custom role
  app.post("/api/custom-roles", requireAdmin, async (req, res) => {
    try {
      const { name, displayName, description, color, priority, permissions } = req.body;
      
      if (!name || !displayName) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ù†Ù…Ø§ÛŒØ´ÛŒ Ù†Ù‚Ø´ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const { pool } = await import('./db');
      
      // Check if role with same name already exists
      const existingRole = await pool.query(
        'SELECT id FROM custom_roles WHERE name = $1',
        [name]
      );

      if (existingRole.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ù‚Ø´ Ø¨Ø§ Ø§ÛŒÙ† Ù†Ø§Ù… Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"
        });
      }

      const result = await pool.query(`
        INSERT INTO custom_roles (name, display_name, description, color, priority, permissions)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *
      `, [name, displayName, description || '', color || '#3b82f6', priority || 1, permissions || []]);

      res.json({
        success: true,
        role: result.rows[0],
        message: "Ù†Ù‚Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error creating custom role:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù‚Ø´" });
    }
  });

  // Get all custom users
  app.get("/api/custom-users", requireAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT cu.id, cu.full_name, cu.email, cu.phone, cu.is_active,
               cu.sms_notifications, cu.email_notifications, cu.last_login,
               cu.created_at, cu.updated_at,
               cr.id as role_id, cr.name as role_name, 
               cr.display_name as role_display_name, cr.color as role_color
        FROM custom_users cu
        JOIN custom_roles cr ON cu.role_id = cr.id
        ORDER BY cu.created_at DESC
      `);

      res.json({
        success: true,
        users: result.rows
      });
    } catch (error) {
      console.error("Error fetching custom users:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†" });
    }
  });

  // Create custom user
  app.post("/api/custom-users", requireAdmin, async (req, res) => {
    try {
      const { fullName, email, phone, roleId, password, smsNotifications, emailNotifications } = req.body;
      
      if (!fullName || !email || !phone || !roleId || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø¨Ø§ÛŒØ¯ Ù¾Ø± Ø´ÙˆÙ†Ø¯" 
        });
      }

      const { pool } = await import('./db');
      const bcrypt = await import('bcryptjs');
      
      // Check if user with same email or phone already exists
      const existingUser = await pool.query(
        'SELECT id FROM custom_users WHERE email = $1 OR phone = $2',
        [email, phone]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"
        });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 12);

      const result = await pool.query(`
        INSERT INTO custom_users (full_name, email, phone, password_hash, role_id, sms_notifications, email_notifications)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, full_name, email, phone, role_id, is_active, sms_notifications, email_notifications, created_at
      `, [fullName, email, phone, passwordHash, roleId, smsNotifications !== false, emailNotifications !== false]);

      // Send SMS notification if enabled
      if (smsNotifications !== false) {
        try {
          await pool.query(`
            INSERT INTO sms_notifications (recipient_id, recipient_phone, message, status)
            VALUES ($1, $2, $3, 'pending')
          `, [
            result.rows[0].id,
            phone,
            `Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ ${fullName}! Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±: ${password}`
          ]);
        } catch (smsError) {
          console.error("Error creating SMS notification:", smsError);
        }
      }

      res.json({
        success: true,
        user: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error creating custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Update custom user
  app.put("/api/custom-users/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { fullName, roleId, isActive, smsNotifications, emailNotifications, password } = req.body;
      
      const { pool } = await import('./db');
      let query = `
        UPDATE custom_users 
        SET full_name = $1, role_id = $2, is_active = $3, 
            sms_notifications = $4, email_notifications = $5, updated_at = NOW()
      `;
      let values = [fullName, roleId, isActive, smsNotifications, emailNotifications];
      
      // If password is provided, hash and update it
      if (password) {
        const bcrypt = await import('bcryptjs');
        const passwordHash = await bcrypt.hash(password, 12);
        query += `, password_hash = $6`;
        values.push(passwordHash);
      }
      
      query += ` WHERE id = $${values.length + 1} RETURNING *`;
      values.push(id);

      const result = await pool.query(query, values);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        user: result.rows[0],
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error updating custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Delete custom user
  app.delete("/api/custom-users/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { pool } = await import('./db');
      
      const result = await pool.query('DELETE FROM custom_users WHERE id = $1 RETURNING *', [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({
        success: true,
        message: "Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting custom user:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Send SMS to users with specific role
  app.post("/api/custom-roles/:roleId/send-sms", requireAdmin, async (req, res) => {
    try {
      const { roleId } = req.params;
      const { message } = req.body;
      
      if (!message) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù…ØªÙ† Ù¾ÛŒØ§Ù…Ú© Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const { pool } = await import('./db');
      
      // Get all active users with this role who have SMS notifications enabled
      const usersResult = await pool.query(`
        SELECT id, full_name, phone 
        FROM custom_users 
        WHERE role_id = $1 AND is_active = true AND sms_notifications = true
      `, [roleId]);

      if (usersResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø± ÙØ¹Ø§Ù„ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù†Ù‚Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Create SMS notifications for all users
      for (const user of usersResult.rows) {
        await pool.query(`
          INSERT INTO sms_notifications (recipient_id, recipient_phone, message, status)
          VALUES ($1, $2, $3, 'pending')
        `, [user.id, user.phone, message]);
      }

      res.json({
        success: true,
        message: `Ù¾ÛŒØ§Ù…Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø§ÛŒ ${usersResult.rows.length} Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`,
        sentTo: usersResult.rows.length
      });
    } catch (error) {
      console.error("Error sending SMS to role users:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú©" });
    }
  });

  // Server Configuration Routes
  app.get("/api/server/config", requireAdmin, async (req, res) => {
    try {
      const { CONFIG } = await import('./config');
      
      const config = {
        frontendUrl: process.env.FRONTEND_URL || CONFIG.getBaseUrl(req),
        nodeEnv: process.env.NODE_ENV || 'development',
        smtpHost: process.env.SMTP_HOST || 'smtp.zoho.com',
        smtpPort: process.env.SMTP_PORT || '587',
        smtpUser: process.env.SMTP_USER || '',
        // Don't send sensitive data
        databaseUrl: process.env.DATABASE_URL ? '***configured***' : '',
        sessionSecret: process.env.SESSION_SECRET ? '***configured***' : '',
        smtpPass: process.env.SMTP_PASS ? '***configured***' : ''
      };

      res.json({
        success: true,
        config
      });
    } catch (error) {
      console.error("Error getting server config:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±" });
    }
  });

  app.post("/api/server/test-config", requireAdmin, async (req, res) => {
    try {
      const { frontendUrl, databaseUrl, smtpHost, smtpPort, smtpUser } = req.body;
      
      const testResults = {
        domain: false,
        database: false,
        smtp: false
      };

      // Test domain URL format
      if (frontendUrl) {
        try {
          new URL(frontendUrl);
          testResults.domain = true;
        } catch {
          testResults.domain = false;
        }
      }

      // Test database connection if provided
      if (databaseUrl && databaseUrl !== '***configured***') {
        try {
          // Simple URL validation for PostgreSQL
          if (databaseUrl.startsWith('postgresql://') || databaseUrl.startsWith('postgres://')) {
            testResults.database = true;
          }
        } catch {
          testResults.database = false;
        }
      } else if (process.env.DATABASE_URL) {
        testResults.database = true;
      }

      // Test SMTP configuration
      if (smtpHost && smtpPort && smtpUser) {
        try {
          const port = parseInt(smtpPort);
          if (port > 0 && port < 65536 && smtpHost.includes('.')) {
            testResults.smtp = true;
          }
        } catch {
          testResults.smtp = false;
        }
      }

      const allPassed = testResults.domain && testResults.database && testResults.smtp;

      res.json({
        success: allPassed,
        testResults,
        message: allPassed ? "Ù‡Ù…Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØµØ­ÛŒØ­ Ø§Ø³Øª" : "Ø¨Ø±Ø®ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø±Ù†Ø¯"
      });
    } catch (error) {
      console.error("Error testing server config:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Get available modules/permissions - synchronized with Site Management modules
  app.get("/api/custom-modules", requireAdmin, async (req, res) => {
    try {
      // Get current modules from the single source of truth
      const currentModules = getSiteManagementModules();
      
      // Map module IDs to their display information
      const moduleMapping = {
        'server_config': { name: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ù†ÙÛŒÚ¯ Ø³Ø±ÙˆØ± Ùˆ Ù…Ù‡Ø§Ø¬Ø±Øª', category: 'system' },
        'syncing_shop': { name: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡', description: 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª Ú©Ø§Ø±Ø¯Ú©Ø³ Ø¨Ø§ ÙØ±ÙˆØ´Ú¯Ø§Ù‡', category: 'commerce' },
        'shop_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§ØªØŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ùˆ ÙØ±ÙˆØ´', category: 'commerce' },
        'product_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¯Ú©Ø³ Ùˆ Ù…Ø­ØµÙˆÙ„Ø§Øª', category: 'commerce' },
        'order_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª', description: 'Ù¾Ø±Ø¯Ø§Ø²Ø´ Ùˆ ØªØ§ÛŒÛŒØ¯ Ø³ÙØ§Ø±Ø´Ø§Øª', category: 'commerce' },
        'warehouse_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±', description: 'Ú©Ù†ØªØ±Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ùˆ Ø§Ù†Ø¨Ø§Ø±Ø¯Ø§Ø±ÛŒ', category: 'warehouse' },
        'logistics_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ùˆ ØªØ­ÙˆÛŒÙ„', category: 'logistics' },
        'inquiries': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª', description: 'Ù¾Ø§Ø³Ø® Ø¨Ù‡ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ù…Ø´ØªØ±ÛŒØ§Ù†', category: 'customer' },
        'crm': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª CRM', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø´ØªØ±ÛŒØ§Ù† Ùˆ Ø±ÙˆØ§Ø¨Ø·', category: 'customer' },
        'barcode': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯', description: 'ØªÙˆÙ„ÛŒØ¯ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯Ù‡Ø§', category: 'inventory' },
        'email_settings': { name: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„', description: 'Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ø³ÛŒØ³ØªÙ… Ø§ÛŒÙ…ÛŒÙ„', category: 'communication' },
        'database_backup': { name: 'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ', category: 'system' },
        'seo': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª SEO', description: 'Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆØªÙˆØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ', category: 'content' },
        'categories': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§', description: 'ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª', category: 'content' },
        'sms': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©', description: 'Ø§Ø±Ø³Ø§Ù„ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©â€ŒÙ‡Ø§', category: 'communication' },
        'factory': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø· ØªÙˆÙ„ÛŒØ¯', category: 'production' },
        'user_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†', description: 'Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø³ÛŒØ³ØªÙ…', category: 'admin' },
        'procedures': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³Ù†Ø§Ø¯ Ùˆ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ', category: 'content' },
        'payment_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª', description: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª', category: 'finance' },
        'finance': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ', description: 'Ø¨Ø±Ø±Ø³ÛŒ Ùˆ ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª', category: 'finance' },
        'wallet_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„', description: 'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù…Ø´ØªØ±ÛŒØ§Ù†', category: 'finance' },
        'geography_analytics': { name: 'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ', description: 'ØªØ­Ù„ÛŒÙ„ Ø¢Ù…Ø§Ø± Ù…Ù†Ø·Ù‚Ù‡â€ŒØ§ÛŒ', category: 'analytics' },
        'ai_settings': { name: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ', description: 'Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ AI Ùˆ SKU', category: 'system' },
        'refresh_control': { name: 'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ', description: 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±', category: 'system' },
        'content_management': { name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§', description: 'ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø­ØªÙˆØ§ÛŒ ÙˆØ¨Ø³Ø§ÛŒØª', category: 'content' },
        'ticketing_system': { name: 'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯', description: 'Ù…Ø¯ÛŒØ±ÛŒØª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ Ùˆ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ', category: 'support' }
      };
      
      // Build modules array from current active modules
      const modules = currentModules.map(moduleId => ({
        id: moduleId,
        name: moduleMapping[moduleId]?.name || moduleId,
        description: moduleMapping[moduleId]?.description || `Ù…Ø§Ú˜ÙˆÙ„ ${moduleId}`,
        category: moduleMapping[moduleId]?.category || 'general'
      }));

      res.json({
        success: true,
        modules
      });
    } catch (error) {
      console.error("Error fetching modules:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§" });
    }
  });

  // Assign role to user
  app.put("/api/admin/users/:id/role", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { roleId } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE users 
        SET role_id = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING id, username, email, role_id
      `, [roleId, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "User not found" });
      }

      res.json({
        success: true,
        user: result.rows[0]
      });
    } catch (error) {
      console.error("Error assigning role to user:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get users by role
  app.get("/api/admin/roles/:id/users", requireSuperAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT u.id, u.username, u.email, u.is_active, u.created_at,
               r.display_name as role_name
        FROM users u
        JOIN admin_roles r ON u.role_id = r.id
        WHERE u.role_id = $1
        ORDER BY u.username
      `, [id]);

      const users = result.rows.map((row: any) => ({
        id: row.id,
        username: row.username,
        email: row.email,
        isActive: row.is_active,
        createdAt: row.created_at,
        roleName: row.role_name
      }));

      res.json(users);
    } catch (error) {
      console.error("Error fetching users by role:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get available modules for permissions
  app.get("/api/admin/modules", requireSuperAdmin, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT DISTINCT module FROM admin_permissions WHERE is_active = true ORDER BY module
      `);

      const modules = result.rows.map((row: any) => row.module);
      res.json(modules);
    } catch (error) {
      console.error("Error fetching modules:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // FACTORY MANAGEMENT ENDPOINTS
  // =============================================================================

  // Production Lines
  app.get("/api/factory/production-lines", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, description, capacity_per_hour, status, location, supervisor_name, created_at, updated_at
        FROM production_lines
        ORDER BY created_at DESC
      `);
      
      const productionLines = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        description: row.description,
        capacityPerHour: row.capacity_per_hour,
        status: row.status,
        location: row.location,
        supervisorName: row.supervisor_name,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(productionLines);
    } catch (error) {
      console.error("Error fetching production lines:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Raw Materials
  app.get("/api/factory/raw-materials", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, code, unit, current_stock, minimum_stock, maximum_stock, 
               unit_price, supplier, storage_location, expiry_date, quality_grade, created_at, updated_at
        FROM raw_materials
        ORDER BY name
      `);
      
      const rawMaterials = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        code: row.code,
        unit: row.unit,
        currentStock: row.current_stock,
        minimumStock: row.minimum_stock,
        maximumStock: row.maximum_stock,
        unitPrice: row.unit_price,
        supplier: row.supplier,
        storageLocation: row.storage_location,
        expiryDate: row.expiry_date,
        qualityGrade: row.quality_grade,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(rawMaterials);
    } catch (error) {
      console.error("Error fetching raw materials:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Production Orders
  app.get("/api/factory/production-orders", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, order_number, product_name, quantity_planned, quantity_produced, unit,
               production_line_id, status, priority, planned_start_date, actual_start_date,
               planned_end_date, actual_end_date, supervisor_notes, quality_check_status, created_at, updated_at
        FROM production_orders
        ORDER BY created_at DESC
      `);
      
      const productionOrders = result.rows.map((row: any) => ({
        id: row.id,
        orderNumber: row.order_number,
        productName: row.product_name,
        quantityPlanned: row.quantity_planned,
        quantityProduced: row.quantity_produced,
        unit: row.unit,
        productionLineId: row.production_line_id,
        status: row.status,
        priority: row.priority,
        plannedStartDate: row.planned_start_date,
        actualStartDate: row.actual_start_date,
        plannedEndDate: row.planned_end_date,
        actualEndDate: row.actual_end_date,
        supervisorNotes: row.supervisor_notes,
        qualityCheckStatus: row.quality_check_status,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(productionOrders);
    } catch (error) {
      console.error("Error fetching production orders:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Equipment Maintenance
  app.get("/api/factory/equipment-maintenance", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, equipment_name, equipment_code, production_line_id, maintenance_type,
               scheduled_date, completed_date, status, technician_name, description,
               cost, downtime_hours, created_at, updated_at
        FROM equipment_maintenance
        ORDER BY scheduled_date DESC
      `);
      
      const equipmentMaintenance = result.rows.map((row: any) => ({
        id: row.id,
        equipmentName: row.equipment_name,
        equipmentCode: row.equipment_code,
        productionLineId: row.production_line_id,
        maintenanceType: row.maintenance_type,
        scheduledDate: row.scheduled_date,
        completedDate: row.completed_date,
        status: row.status,
        technicianName: row.technician_name,
        description: row.description,
        cost: row.cost,
        downtimeHours: row.downtime_hours,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(equipmentMaintenance);
    } catch (error) {
      console.error("Error fetching equipment maintenance:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create Production Line
  app.post("/api/factory/production-lines", requireAuth, async (req, res) => {
    try {
      const { name, description, capacityPerHour, location, supervisorName } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO production_lines (name, description, capacity_per_hour, location, supervisor_name)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, name, description, capacity_per_hour, status, location, supervisor_name, created_at
      `, [name, description, capacityPerHour, location, supervisorName]);

      res.json({
        success: true,
        productionLine: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating production line:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Production line name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Create Raw Material
  app.post("/api/factory/raw-materials", requireAuth, async (req, res) => {
    try {
      const { name, code, unit, currentStock, minimumStock, maximumStock, unitPrice, supplier, storageLocation, qualityGrade } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO raw_materials (name, code, unit, current_stock, minimum_stock, maximum_stock, unit_price, supplier, storage_location, quality_grade)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, name, code, unit, current_stock, minimum_stock, maximum_stock, unit_price, supplier, storage_location, quality_grade, created_at
      `, [name, code, unit, currentStock, minimumStock, maximumStock, unitPrice, supplier, storageLocation, qualityGrade]);

      res.json({
        success: true,
        rawMaterial: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating raw material:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Raw material code already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Create Production Order
  app.post("/api/factory/production-orders", requireAuth, async (req, res) => {
    try {
      const { productName, quantityPlanned, unit, productionLineId, priority, plannedStartDate, plannedEndDate } = req.body;
      
      // Generate order number
      const orderNumber = `PO-${new Date().getFullYear()}-${String(Date.now()).slice(-6)}`;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO production_orders (order_number, product_name, quantity_planned, unit, production_line_id, priority, planned_start_date, planned_end_date)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id, order_number, product_name, quantity_planned, quantity_produced, unit, production_line_id, status, priority, planned_start_date, planned_end_date, created_at
      `, [orderNumber, productName, quantityPlanned, unit, productionLineId, priority, plannedStartDate, plannedEndDate]);

      res.json({
        success: true,
        productionOrder: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating production order:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // =============================================================================
  // ORDER TRACKING MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all orders for tracking (read-only)
  app.get("/api/orders/tracking/all", requireAuth, async (req, res) => {
    try {
      const orders = await orderManagementStorage.getAllOrdersWithDetails();
      
      const formattedOrders = orders.map(order => ({
        id: order.id,
        customerOrderId: order.customerOrderId || order.id,
        customerName: order.customerName,
        customerEmail: order.customerEmail,
        customerPhone: order.customerPhone,
        totalAmount: order.totalAmount,
        currency: order.currency || 'IQD',
        status: order.status,
        paymentMethod: order.paymentMethod,
        paymentReceiptUrl: order.paymentReceiptUrl,
        trackingNumber: order.trackingNumber,
        deliveryCode: order.deliveryCode,
        estimatedDeliveryDate: order.estimatedDeliveryDate,
        actualDeliveryDate: order.actualDeliveryDate,
        deliveryPersonName: order.deliveryPersonName,
        deliveryPersonPhone: order.deliveryPersonPhone,
        financialNotes: order.financialNotes,
        warehouseNotes: order.warehouseNotes,
        logisticsNotes: order.logisticsNotes,
        createdAt: order.createdAt,
        updatedAt: order.updatedAt
      }));

      res.json({ 
        success: true, 
        orders: formattedOrders 
      });
    } catch (error) {
      console.error("Error fetching tracking orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get order statistics for tracking dashboard
  app.get("/api/order-management/statistics", requireAuth, async (req, res) => {
    try {
      const orders = await orderManagementStorage.getAllOrdersWithDetails();
      
      const totalOrders = orders.length;
      const pendingOrders = orders.filter(order => 
        ['pending', 'pending_payment', 'financial_review', 'warehouse_processing'].includes(order.status)
      ).length;
      const completedOrders = orders.filter(order => 
        ['completed', 'delivered'].includes(order.status)
      ).length;
      
      // Calculate total revenue (only completed orders)
      const totalRevenue = orders
        .filter(order => ['completed', 'delivered'].includes(order.status))
        .reduce((sum, order) => {
          const amount = typeof order.totalAmount === 'string' 
            ? parseFloat(order.totalAmount) 
            : order.totalAmount || 0;
          return sum + amount;
        }, 0);
      
      const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;
      
      // Today's orders
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todaysOrders = orders.filter(order => {
        const orderDate = new Date(order.createdAt);
        orderDate.setHours(0, 0, 0, 0);
        return orderDate.getTime() === today.getTime();
      }).length;

      res.json({
        totalOrders,
        pendingOrders,
        completedOrders,
        totalRevenue,
        averageOrderValue,
        todaysOrders
      });
    } catch (error) {
      console.error("Error fetching order statistics:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get financial orders (orders requiring financial review)
  app.get("/api/order-management/financial", requireAuth, async (req, res) => {
    try {
      console.log('ðŸ” [ROUTES] Financial endpoint called - using getOrdersByDepartment');
      const orders = await orderManagementStorage.getOrdersByDepartment('financial');
      
      console.log('ðŸ” [ROUTES] Received', orders.length, 'orders from financial department');
      
      // Log first order structure for debugging
      if (orders.length > 0) {
        console.log('ðŸ” [ROUTES] First order structure:', JSON.stringify(orders[0], null, 2));
      }
      
      // Transform orders to ensure compatibility with frontend interface
      const transformedOrders = orders.map(order => ({
        ...order,
        // Extract customer fields from nested customer object
        customerFirstName: order.customer?.firstName || '',
        customerLastName: order.customer?.lastName || '',
        customerEmail: order.customer?.email || '',
        customerPhone: order.customer?.phone || '',
        // Also provide receipt info in legacy format
        receiptUrl: order.receipt?.url || order.paymentReceiptUrl,
        receiptFileName: order.receipt?.fileName || '',
        receiptMimeType: order.receipt?.mimeType || ''
      }));
      
      res.json({ 
        success: true, 
        orders: transformedOrders 
      });
    } catch (error) {
      console.error("Error fetching financial orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get order status history
  app.get("/api/orders/:orderId/status-history", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (isNaN(orderId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid order ID" 
        });
      }

      // For now, return empty history - can be implemented later with proper status history table
      const history = [
        {
          id: 1,
          fromStatus: null,
          toStatus: 'pending',
          changedBy: null,
          changedByDepartment: 'system',
          notes: 'Ø³ÙØ§Ø±Ø´ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯',
          createdAt: new Date().toISOString()
        }
      ];

      res.json({ 
        success: true, 
        history 
      });
    } catch (error) {
      console.error("Error fetching order status history:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // =============================================================================
  // SIMPLE ORDER NUMBERING ENDPOINTS
  // =============================================================================

  // Generate simple order number
  app.get("/api/orders/generate-simple-number", async (req, res) => {
    try {
      const simpleNumber = await orderManagementStorage.generateSimpleOrderNumber();
      
      res.json({ 
        success: true, 
        orderNumber: simpleNumber,
        message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ø³Ø§Ø¯Ù‡ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error generating simple order number:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´" 
      });
    }
  });

  // Reset order counter (admin only)
  app.post("/api/orders/reset-counter", async (req, res) => {
    try {
      await orderManagementStorage.resetOrderCounter();
      
      res.json({ 
        success: true, 
        message: "Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø³ÙØ§Ø±Ø´Ø§Øª Ø¨Ù‡ Ø­Ø§Ù„Øª Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø§Ø²Ú¯Ø´Øª (1001)"
      });
    } catch (error) {
      console.error("Error resetting order counter:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡" 
      });
    }
  });

  // Get warehouse approved orders ready for invoice generation
  app.get("/api/orders/warehouse-approved", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get orders that have been approved by warehouse (shipped)
      const result = await pool.query(`
        SELECT 
          id,
          order_number as "orderNumber",
          customer_name as "customerName", 
          billing_address as "billingAddress",
          total_amount as "totalAmount",
          status,
          payment_status as "paymentStatus",
          shipping_address as "shippingAddress",
          created_at as "createdAt",
          warehouse_approved_at as "warehouseApprovedAt",
          notes
        FROM order_management 
        WHERE status IN ('warehouse_approved', 'logistics_pending', 'logistics_approved', 'delivered')
        AND payment_status = 'paid'
        ORDER BY warehouse_approved_at DESC, created_at DESC
        LIMIT 50
      `);
      
      const orders = result.rows.map((row: any) => ({
        ...row,
        totalAmount: parseFloat(row.totalAmount) || 0,
        billingAddress: typeof row.billingAddress === 'string' ? row.billingAddress : 
                       row.billingAddress ? JSON.stringify(row.billingAddress) : '',
        shippingAddress: typeof row.shippingAddress === 'string' ? row.shippingAddress : 
                        row.shippingAddress ? JSON.stringify(row.shippingAddress) : ''
      }));
      
      console.log(`ðŸ“‹ [WAREHOUSE ORDERS] Found ${orders.length} warehouse-approved orders ready for invoicing`);
      
      res.json(orders);
    } catch (error) {
      console.error("Error fetching warehouse approved orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ Ø§Ù†Ø¨Ø§Ø±" 
      });
    }
  });

  // =============================================================================
  // PROCEDURES MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get procedure categories
  app.get("/api/procedures/categories", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, name, description, color_code, display_order, is_active, created_at, updated_at
        FROM procedure_categories
        WHERE is_active = true
        ORDER BY display_order, name
      `);
      
      const categories = result.rows.map((row: any) => ({
        id: row.id,
        name: row.name,
        description: row.description,
        colorCode: row.color_code,
        displayOrder: row.display_order,
        isActive: row.is_active,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(categories);
    } catch (error) {
      console.error("Error fetching procedure categories:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get procedures
  app.get("/api/procedures", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, title, category_id, description, content, version, status, priority, 
               language, author_id, approver_id, approved_at, effective_date, review_date, 
               tags, access_level, view_count, last_viewed_at, created_at, updated_at
        FROM procedures
        ORDER BY created_at DESC
      `);
      
      const procedures = result.rows.map((row: any) => ({
        id: row.id,
        title: row.title,
        categoryId: row.category_id,
        description: row.description,
        content: row.content,
        version: row.version,
        status: row.status,
        priority: row.priority,
        language: row.language,
        authorId: row.author_id,
        approverId: row.approver_id,
        approvedAt: row.approved_at,
        effectiveDate: row.effective_date,
        reviewDate: row.review_date,
        tags: row.tags || [],
        accessLevel: row.access_level,
        viewCount: row.view_count,
        lastViewedAt: row.last_viewed_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(procedures);
    } catch (error) {
      console.error("Error fetching procedures:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get safety protocols
  app.get("/api/procedures/safety-protocols", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, title, category, description, severity_level, required_ppe, 
               procedures, first_aid_steps, evacuation_plan, is_mandatory, 
               compliance_notes, last_updated_by, created_at, updated_at
        FROM safety_protocols
        ORDER BY severity_level DESC, created_at DESC
      `);
      
      const safetyProtocols = result.rows.map((row: any) => ({
        id: row.id,
        title: row.title,
        category: row.category,
        description: row.description,
        severityLevel: row.severity_level,
        requiredPpe: row.required_ppe || [],
        procedures: row.procedures,
        firstAidSteps: row.first_aid_steps,
        evacuationPlan: row.evacuation_plan,
        isMandatory: row.is_mandatory,
        complianceNotes: row.compliance_notes,
        lastUpdatedBy: row.last_updated_by,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(safetyProtocols);
    } catch (error) {
      console.error("Error fetching safety protocols:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create procedure category
  app.post("/api/procedures/categories", requireAuth, async (req, res) => {
    try {
      const { name, description, colorCode, displayOrder } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_categories (name, description, color_code, display_order)
        VALUES ($1, $2, $3, $4)
        RETURNING id, name, description, color_code, display_order, is_active, created_at
      `, [name, description, colorCode, displayOrder]);

      res.json({
        success: true,
        category: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error creating procedure category:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Category name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // Create procedure
  app.post("/api/procedures", requireAuth, async (req, res) => {
    try {
      const { title, categoryId, description, content, priority, effectiveDate, reviewDate, tags, accessLevel } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process tags
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];
      
      // Handle empty date strings - convert to null
      const processedEffectiveDate = effectiveDate && effectiveDate.trim() !== '' ? effectiveDate : null;
      const processedReviewDate = reviewDate && reviewDate.trim() !== '' ? reviewDate : null;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedures (title, category_id, description, content, priority, author_id, 
                               effective_date, review_date, tags, access_level)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, title, category_id, description, version, status, priority, created_at
      `, [title, categoryId, description, content, priority, userId, processedEffectiveDate, processedReviewDate, tagsArray, accessLevel]);

      res.json({
        success: true,
        procedure: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating procedure:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update procedure
  app.put("/api/procedures/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { title, categoryId, description, content, priority, effectiveDate, reviewDate, tags, accessLevel } = req.body;
      
      // Process tags
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE procedures SET
          title = $1, category_id = $2, description = $3, content = $4,
          priority = $5, effective_date = $6, review_date = $7, tags = $8,
          access_level = $9, updated_at = NOW()
        WHERE id = $10
        RETURNING id, title, category_id, description, version, status, priority, updated_at
      `, [title, categoryId, description, content, priority, effectiveDate, reviewDate, tagsArray, accessLevel, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Procedure not found" });
      }

      res.json({
        success: true,
        procedure: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating procedure:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create safety protocol
  app.post("/api/procedures/safety-protocols", requireAuth, async (req, res) => {
    try {
      const { title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, requiredPpe } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process PPE
      const ppeArray = requiredPpe ? requiredPpe.split(',').map((ppe: string) => ppe.trim()).filter((ppe: string) => ppe.length > 0) : [];
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO safety_protocols (title, category, description, severity_level, procedures, 
                                     first_aid_steps, evacuation_plan, required_ppe, last_updated_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id, title, category, severity_level, is_mandatory, created_at
      `, [title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, ppeArray, userId]);

      res.json({
        success: true,
        safetyProtocol: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating safety protocol:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get procedure outlines
  app.get("/api/procedures/:procedureId/outlines", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT id, procedure_id, parent_id, level, order_number, title, content, 
               is_collapsible, is_expanded, created_at, updated_at
        FROM procedure_outlines
        WHERE procedure_id = $1
        ORDER BY level, order_number
      `, [procedureId]);
      
      const outlines = result.rows.map((row: any) => ({
        id: row.id,
        procedureId: row.procedure_id,
        parentId: row.parent_id,
        level: row.level,
        orderNumber: row.order_number,
        title: row.title,
        content: row.content,
        isCollapsible: row.is_collapsible,
        isExpanded: row.is_expanded,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      }));

      res.json(outlines);
    } catch (error) {
      console.error("Error fetching procedure outlines:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create procedure outline
  app.post("/api/procedures/:procedureId/outlines", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      const { parentId, level, orderNumber, title, content, isCollapsible } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_outlines (procedure_id, parent_id, level, order_number, title, content, is_collapsible)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, procedure_id, level, order_number, title, created_at
      `, [procedureId, parentId, level, orderNumber, title, content, isCollapsible]);

      res.json({
        success: true,
        outline: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating procedure outline:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Create safety protocol
  app.post("/api/procedures/safety-protocols", requireAuth, async (req, res) => {
    try {
      const { title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, requiredPpe } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process PPE array
      const ppeArray = Array.isArray(requiredPpe) ? requiredPpe : 
                      (requiredPpe ? requiredPpe.split(',').map((ppe: string) => ppe.trim()).filter((ppe: string) => ppe.length > 0) : []);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO safety_protocols (title, category, description, severity_level, procedures, 
                                     first_aid_steps, evacuation_plan, required_ppe, last_updated_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id, title, category, severity_level, is_mandatory, created_at
      `, [title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, ppeArray, userId]);

      res.json({
        success: true,
        safetyProtocol: result.rows[0]
      });
    } catch (error) {
      console.error("Error creating safety protocol:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update safety protocol
  app.put("/api/procedures/safety-protocols/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, requiredPpe } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process PPE array
      const ppeArray = Array.isArray(requiredPpe) ? requiredPpe : 
                      (requiredPpe ? requiredPpe.split(',').map((ppe: string) => ppe.trim()).filter((ppe: string) => ppe.length > 0) : []);
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE safety_protocols SET
          title = $1, category = $2, description = $3, severity_level = $4,
          procedures = $5, first_aid_steps = $6, evacuation_plan = $7, 
          required_ppe = $8, last_updated_by = $9, updated_at = NOW()
        WHERE id = $10
        RETURNING id, title, category, severity_level, updated_at
      `, [title, category, description, severityLevel, procedures, firstAidSteps, evacuationPlan, ppeArray, userId, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Safety protocol not found" });
      }

      res.json({
        success: true,
        safetyProtocol: result.rows[0]
      });
    } catch (error) {
      console.error("Error updating safety protocol:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get safety protocol documents
  app.get("/api/procedures/safety-protocols/:protocolId/documents", requireAuth, async (req, res) => {
    try {
      const { protocolId } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT d.id, d.procedure_id, d.outline_id, d.title, d.description, d.file_name, 
               d.file_path, d.file_size, d.file_type, d.upload_date, d.uploaded_by, 
               d.version, d.is_active, d.download_count, d.last_downloaded_at, d.tags,
               u.username as uploaded_by_name
        FROM procedure_documents d
        LEFT JOIN users u ON d.uploaded_by = u.id
        WHERE d.procedure_id = $1 AND d.is_active = true AND d.document_type = 'safety_protocol'
        ORDER BY d.upload_date DESC
      `, [protocolId]);
      
      const documents = result.rows.map((row: any) => ({
        id: row.id,
        procedureId: row.procedure_id,
        outlineId: row.outline_id,
        title: row.title || 'Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†',
        description: row.description,
        fileName: row.file_name || 'ÙØ§ÛŒÙ„ Ù†Ø§Ù…Ø´Ø®Øµ',
        filePath: row.file_path,
        fileSize: row.file_size || 0,
        fileType: row.file_type || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        uploadDate: row.upload_date,
        uploadedBy: row.uploaded_by,
        uploadedByName: row.uploaded_by_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        version: row.version || '1.0',
        isActive: row.is_active,
        downloadCount: row.download_count || 0,
        lastDownloadedAt: row.last_downloaded_at,
        tags: row.tags || []
      }));

      res.json(documents);
    } catch (error) {
      console.error("Error fetching safety protocol documents:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Upload safety protocol document
  app.post("/api/procedures/safety-protocols/:protocolId/documents", requireAuth, upload.single('document'), async (req, res) => {
    try {
      const { protocolId } = req.params;
      const { title, description, version, tags } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ success: false, message: "No file uploaded" });
      }

      const userId = req.session.adminId;
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];

      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_documents (
          procedure_id, title, description, file_name, file_path, 
          file_size, file_type, uploaded_by, version, tags, document_type
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'safety_protocol')
        RETURNING *
      `, [
        protocolId, 
        title || file.originalname, 
        description || null, 
        file.originalname, 
        file.path, 
        file.size, 
        file.mimetype, 
        userId, 
        version || '1.0', 
        tagsArray
      ]);

      res.json({
        success: true,
        document: result.rows[0],
        message: "Document uploaded successfully"
      });
    } catch (error) {
      console.error("Error uploading safety protocol document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Download safety protocol document
  app.get("/api/procedures/safety-protocols/documents/:documentId/download", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info
      const docResult = await pool.query(`
        SELECT file_path, file_name, file_type
        FROM procedure_documents
        WHERE id = $1 AND is_active = true AND document_type = 'safety_protocol'
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Update download count
      await pool.query(`
        UPDATE procedure_documents 
        SET download_count = download_count + 1, 
            last_downloaded_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Handle both absolute and relative paths
      let filePath = document.file_path;
      if (!path.isAbsolute(filePath)) {
        filePath = path.resolve(process.cwd(), filePath);
      }

      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ success: false, message: "File not found on server" });
      }

      res.setHeader('Content-Disposition', `attachment; filename="${document.file_name}"`);
      res.setHeader('Content-Type', document.file_type || 'application/octet-stream');
      
      res.sendFile(filePath);

    } catch (error) {
      console.error("Error downloading safety protocol document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Delete safety protocol document
  app.delete("/api/procedures/safety-protocols/documents/:documentId", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info before deletion
      const docResult = await pool.query(`
        SELECT file_path, file_name
        FROM procedure_documents
        WHERE id = $1 AND is_active = true AND document_type = 'safety_protocol'
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Mark document as inactive (soft delete)
      await pool.query(`
        UPDATE procedure_documents 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Optionally delete the physical file
      try {
        let filePath = document.file_path;
        if (!path.isAbsolute(filePath)) {
          filePath = path.resolve(process.cwd(), filePath);
        }
        
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      } catch (fileError) {
        console.log('Could not delete physical file:', fileError);
        // Continue even if file deletion fails
      }

      res.json({
        success: true,
        message: "Document deleted successfully"
      });

    } catch (error) {
      console.error("Error deleting safety protocol document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update procedure category
  app.put("/api/procedures/categories/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, description, colorCode, displayOrder } = req.body;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        UPDATE procedure_categories SET
          name = $1, description = $2, color_code = $3, display_order = $4, updated_at = NOW()
        WHERE id = $5
        RETURNING id, name, description, color_code, display_order, is_active, updated_at
      `, [name, description, colorCode, displayOrder, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Category not found" });
      }

      res.json({
        success: true,
        category: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error updating procedure category:", error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: "Category name already exists" });
      } else {
        res.status(500).json({ success: false, message: "Internal server error" });
      }
    }
  });

  // =============================================================================
  // EMAIL LOGS MANAGEMENT API ENDPOINTS 
  // =============================================================================

  // Get all automatic email logs
  app.get("/api/admin/email/logs", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM automatic_email_logs 
        ORDER BY created_at DESC 
        LIMIT 100
      `);
      
      res.json({
        success: true,
        logs: result.rows
      });
    } catch (error: any) {
      console.error("Error fetching email logs:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„â€ŒÙ‡Ø§"
      });
    }
  });

  // Get email log by ID
  app.get("/api/admin/email/logs/:id", requireAuth, async (req, res) => {
    try {
      const logId = parseInt(req.params.id);
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM automatic_email_logs 
        WHERE id = $1
      `, [logId]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        log: result.rows[0]
      });
    } catch (error: any) {
      console.error("Error fetching email log:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„"
      });
    }
  });

  // Search email logs
  app.get("/api/admin/email/logs/search", requireAuth, async (req, res) => {
    try {
      const { emailType, recipientEmail, dateFrom, dateTo, deliveryStatus } = req.query;
      const { pool } = await import('./db');
      
      let query = `
        SELECT * FROM automatic_email_logs 
        WHERE 1=1
      `;
      const params: any[] = [];
      let paramCount = 0;
      
      if (emailType) {
        paramCount++;
        query += ` AND email_type = $${paramCount}`;
        params.push(emailType);
      }
      
      if (recipientEmail) {
        paramCount++;
        query += ` AND recipient_email ILIKE $${paramCount}`;
        params.push(`%${recipientEmail}%`);
      }
      
      if (deliveryStatus) {
        paramCount++;
        query += ` AND delivery_status = $${paramCount}`;
        params.push(deliveryStatus);
      }
      
      if (dateFrom) {
        paramCount++;
        query += ` AND created_at >= $${paramCount}`;
        params.push(dateFrom);
      }
      
      if (dateTo) {
        paramCount++;
        query += ` AND created_at <= $${paramCount}`;
        params.push(dateTo);
      }
      
      query += ` ORDER BY created_at DESC LIMIT 100`;
      
      const result = await pool.query(query, params);
      
      res.json({
        success: true,
        logs: result.rows
      });
    } catch (error: any) {
      console.error("Error searching email logs:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù„Ø§Ú¯ Ø§ÛŒÙ…ÛŒÙ„â€ŒÙ‡Ø§"
      });
    }
  });

  // =============================================================================
  // SMS MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Test SMS endpoint
  app.post("/api/admin/sms/test-sms", requireAuth, async (req, res) => {
    try {
      const { phoneNumber, message } = req.body;
      
      if (!phoneNumber || !message) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù…ØªÙ† Ù¾ÛŒØ§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Get current SMS settings
      const { pool } = await import('./db');
      const settingsResult = await pool.query(`
        SELECT * FROM sms_settings WHERE id = 1
      `);
      
      if (settingsResult.rows.length === 0 || !settingsResult.rows[0].is_enabled) {
        return res.status(400).json({
          success: false,
          message: "Ø³ÛŒØ³ØªÙ… SMS ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª"
        });
      }

      const settings = settingsResult.rows[0];
      
      // Log test SMS
      console.log(`ðŸ“± Test SMS Request:`, {
        phoneNumber,
        message,
        provider: settings.provider,
        isTestMode: settings.is_test_mode
      });

      // Use actual SMS service regardless of test mode
      try {
        let smsResult;
        
        if (settings.provider === 'infobip') {
          // Send via Infobip API
          const infobipResponse = await fetch(`https://${settings.api_endpoint}/sms/2/text/advanced`, {
            method: 'POST',
            headers: {
              'Authorization': `App ${settings.api_key}`,
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify({
              messages: [{
                from: settings.sender_number || 'InfoSMS',
                destinations: [{
                  to: phoneNumber
                }],
                text: message
              }]
            })
          });

          const infobipData = await infobipResponse.json();
          
          if (infobipResponse.ok && infobipData.messages && infobipData.messages[0]) {
            const messageData = infobipData.messages[0];
            smsResult = {
              success: true,
              messageId: messageData.messageId,
              status: messageData.status?.name || 'PENDING'
            };
          } else {
            throw new Error(`Infobip API Error: ${infobipData.requestError?.serviceException?.text || 'Unknown error'}`);
          }
        } else if (settings.provider === 'kavenegar') {
          // Send via Kavenegar API
          const kavenegarUrl = `https://api.kavenegar.com/v1/${settings.api_key}/sms/send.json`;
          const kavenegarResponse = await fetch(kavenegarUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
              receptor: phoneNumber,
              message: message,
              sender: settings.sender_number || '1000596446'
            })
          });

          const kavenegarData = await kavenegarResponse.json();
          
          if (kavenegarResponse.ok && kavenegarData.return && kavenegarData.return.status === 200) {
            smsResult = {
              success: true,
              messageId: kavenegarData.entries[0].messageid.toString(),
              status: 'PENDING'
            };
          } else {
            throw new Error(`Kavenegar API Error: ${kavenegarData.return?.message || 'Unknown error'}`);
          }
        } else {
          // For other providers, simulate for now
          smsResult = {
            success: true,
            messageId: `PROVIDER_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            status: 'SIMULATED'
          };
        }

        res.json({
          success: true,
          message: settings.is_test_mode ? 
            `Ù¾ÛŒØ§Ù… ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (${settings.provider})` : 
            "Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
          messageId: smsResult.messageId,
          status: smsResult.status,
          provider: settings.provider,
          testMode: settings.is_test_mode
        });
        
        console.log(`âœ… Real SMS sent via ${settings.provider} - ID: ${smsResult.messageId}, Phone: ${phoneNumber}, Status: ${smsResult.status}`);
        
      } catch (smsError) {
        console.error('SMS sending error:', smsError);
        res.json({
          success: false,
          message: `Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ SMS: ${smsError.message}`,
          provider: settings.provider,
          testMode: settings.is_test_mode
        });
      }
      
    } catch (error) {
      console.error("Error sending test SMS:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… ØªØ³Øª"
      });
    }
  });

  // Get SMS settings
  app.get("/api/admin/sms/settings", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM sms_settings WHERE id = 1
      `);
      
      const settings = result.rows[0] || {
        isEnabled: false,
        provider: 'asiacell',
        customProviderName: '',
        apiKey: '',
        apiSecret: '',
        username: '',
        password: '',
        senderNumber: '',
        apiEndpoint: '',
        serviceType: 'pattern',
        patternId: '',
        serviceCode: '',
        codeLength: 6,
        codeExpiry: 300,
        maxAttempts: 3,
        rateLimitMinutes: 5
      };

      res.json({ success: true, settings });
    } catch (error) {
      console.error("Error fetching SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Update SMS settings - POST
  app.post("/api/admin/sms/settings", requireAuth, async (req, res) => {
    try {
      const settings = req.body;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        INSERT INTO sms_settings (id, is_enabled, provider, custom_provider_name, api_key, api_secret, username, password, sender_number, api_endpoint, service_type, pattern_id, service_code, code_length, code_expiry, max_attempts, rate_limit_minutes, updated_at)
        VALUES (1, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW())
        ON CONFLICT (id) DO UPDATE SET
          is_enabled = $1,
          provider = $2,
          custom_provider_name = $3,
          api_key = $4,
          api_secret = $5,
          username = $6,
          password = $7,
          sender_number = $8,
          api_endpoint = $9,
          service_type = $10,
          pattern_id = $11,
          service_code = $12,
          code_length = $13,
          code_expiry = $14,
          max_attempts = $15,
          rate_limit_minutes = $16,
          updated_at = NOW()
        RETURNING *
      `, [
        settings.isEnabled,
        settings.provider,
        settings.customProviderName,
        settings.apiKey,
        settings.apiSecret,
        settings.username,
        settings.password,
        settings.senderNumber,
        settings.apiEndpoint,
        settings.serviceType,
        settings.patternId,
        settings.serviceCode,
        settings.codeLength,
        settings.codeExpiry,
        settings.maxAttempts,
        settings.rateLimitMinutes
      ]);

      res.json({ success: true, settings: result.rows[0] });
    } catch (error) {
      console.error("Error updating SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Update SMS settings - PUT (for compatibility)
  app.put("/api/admin/sms/settings", requireAuth, async (req, res) => {
    try {
      const settings = req.body;
      const { pool } = await import('./db');
      
      const result = await pool.query(`
        INSERT INTO sms_settings (id, is_enabled, provider, custom_provider_name, api_key, api_secret, username, password, sender_number, api_endpoint, service_type, pattern_id, service_code, code_length, code_expiry, max_attempts, rate_limit_minutes, updated_at)
        VALUES (1, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW())
        ON CONFLICT (id) DO UPDATE SET
          is_enabled = $1,
          provider = $2,
          custom_provider_name = $3,
          api_key = $4,
          api_secret = $5,
          username = $6,
          password = $7,
          sender_number = $8,
          api_endpoint = $9,
          service_type = $10,
          pattern_id = $11,
          service_code = $12,
          code_length = $13,
          code_expiry = $14,
          max_attempts = $15,
          rate_limit_minutes = $16,
          updated_at = NOW()
        RETURNING *
      `, [
        settings.isEnabled,
        settings.provider,
        settings.customProviderName,
        settings.apiKey,
        settings.apiSecret,
        settings.username,
        settings.password,
        settings.senderNumber,
        settings.apiEndpoint,
        settings.serviceType,
        settings.patternId,
        settings.serviceCode,
        settings.codeLength,
        settings.codeExpiry,
        settings.maxAttempts,
        settings.rateLimitMinutes
      ]);

      res.json({ success: true, settings: result.rows[0] });
    } catch (error) {
      console.error("Error updating SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Test SMS sending
  app.post("/api/admin/sms/test", requireAuth, async (req, res) => {
    try {
      const { phoneNumber, message } = req.body;
      
      if (!phoneNumber || !message) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù¾ÛŒØ§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { createSmsService } = await import('./sms-service.js');
      const smsService = await createSmsService();
      
      const result = await smsService.sendSms({
        to: phoneNumber,
        message: message
      });

      if (result.success) {
        res.json({ 
          success: true, 
          message: "Ù¾ÛŒØ§Ù…Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
          messageId: result.messageId 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: `Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú©: ${result.error}` 
        });
      }
    } catch (error) {
      console.error("Error testing SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª SMS" });
    }
  });

  // Test SMS connection
  app.post("/api/admin/sms/test-connection", requireAuth, async (req, res) => {
    try {
      const { createSmsService } = await import('./sms-service.js');
      const smsService = await createSmsService();
      
      const result = await smsService.testConnection();

      if (result.success) {
        res.json({ 
          success: true, 
          message: "Ø§ØªØµØ§Ù„ SMS Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ³Øª Ø´Ø¯",
          messageId: result.messageId 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: `Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§ØªØµØ§Ù„: ${result.error}` 
        });
      }
    } catch (error) {
      console.error("Error testing SMS connection:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§ØªØµØ§Ù„ SMS" });
    }
  });

  // Get SMS logs (simplified statistics)
  app.get("/api/admin/sms/logs", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get SMS logs from customer verification codes
      const logsResult = await pool.query(`
        SELECT 
          cvc.id,
          CONCAT(c.first_name, ' ', c.last_name) as recipient_name,
          cvc.phone_number as recipient_phone,
          'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø´Ù…Ø§: ' || cvc.verification_code as message_text,
          cvc.created_at as sent_at,
          CASE 
            WHEN cvc.is_used = true THEN 'delivered'
            ELSE 'sent'
          END as status
        FROM customer_verification_codes cvc
        LEFT JOIN crm_customers c ON c.phone = cvc.phone_number
        ORDER BY cvc.created_at DESC
        LIMIT 100
      `);

      const logs = logsResult.rows.map((row: any) => ({
        id: row.id,
        recipientName: row.recipient_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        recipientPhone: row.recipient_phone,
        messageText: row.message_text,
        sentAt: row.sent_at,
        status: row.status
      }));

      res.json({ success: true, data: logs });
    } catch (error) {
      console.error("Error fetching SMS logs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ SMS" });
    }
  });

  // Get customer SMS settings
  app.get("/api/admin/sms/customers", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          c.id,
          c.first_name,
          c.last_name,
          c.email,
          c.phone,
          c.company,
          c.customer_status,
          COALESCE(c.sms_enabled, true) as sms_enabled,
          (SELECT COUNT(*) FROM customer_orders WHERE customer_id = c.id) as total_orders,
          (SELECT MAX(created_at) FROM customer_orders WHERE customer_id = c.id) as last_order_date
        FROM crm_customers c
        WHERE c.is_active = true
        ORDER BY c.first_name, c.last_name
      `);

      const customers = result.rows.map((row: any) => ({
        id: row.id,
        firstName: row.first_name,
        lastName: row.last_name,
        email: row.email,
        phone: row.phone,
        company: row.company,
        smsEnabled: row.sms_enabled,
        customerStatus: row.customer_status,
        totalOrders: parseInt(row.total_orders || 0),
        lastOrderDate: row.last_order_date
      }));

      res.json({ success: true, customers });
    } catch (error) {
      console.error("Error fetching customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø´ØªØ±ÛŒØ§Ù†" });
    }
  });

  // Update customer SMS settings
  app.put("/api/admin/sms/customers/:customerId", requireAuth, async (req, res) => {
    try {
      const { customerId } = req.params;
      const { smsEnabled } = req.body;
      const { pool } = await import('./db');

      await pool.query(`
        UPDATE crm_customers 
        SET sms_enabled = $2
        WHERE id = $1
      `, [customerId, smsEnabled]);

      res.json({ success: true, message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø´ØªØ±ÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Bulk toggle SMS for customers
  app.post("/api/admin/sms/bulk-toggle", requireAuth, async (req, res) => {
    try {
      const { customerIds, smsEnabled } = req.body;
      const { pool } = await import('./db');

      if (!customerIds || !Array.isArray(customerIds)) {
        return res.status(400).json({ success: false, message: "Ù„ÛŒØ³Øª Ù…Ø´ØªØ±ÛŒØ§Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }

      const placeholders = customerIds.map((_, index) => `$${index + 2}`).join(',');
      const query = `
        UPDATE crm_customers 
        SET sms_enabled = $1
        WHERE id IN (${placeholders})
      `;

      await pool.query(query, [smsEnabled, ...customerIds]);

      res.json({ 
        success: true, 
        message: `ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS Ø¨Ø±Ø§ÛŒ ${customerIds.length} Ù…Ø´ØªØ±ÛŒ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯` 
      });
    } catch (error) {
      console.error("Error bulk updating SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª" });
    }
  });

  // Get SMS categories
  app.get("/api/admin/sms/categories", requireAuth, async (req, res) => {
    try {
      const categories = [
        {
          id: 'authentication',
          name: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª',
          description: 'Ú©Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ Ùˆ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø´ØªØ±ÛŒØ§Ù†',
          icon: 'Shield',
          enabled: true,
          messageTemplate: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø´Ù…Ø§: {{code}}',
          triggerConditions: ['Ø«Ø¨Øª Ù†Ø§Ù…', 'ÙˆØ±ÙˆØ¯', 'ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 245,
            lastSent: '2025-07-17T10:30:00Z',
            successRate: 98.5
          }
        },
        {
          id: 'order-management',
          name: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
          description: 'Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª',
          icon: 'ShoppingCart',
          enabled: true,
          messageTemplate: 'Ø³ÙØ§Ø±Ø´ {{orderNumber}} {{status}} Ø´Ø¯',
          triggerConditions: ['Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´', 'ØªØ§ÛŒÛŒØ¯ Ø³ÙØ§Ø±Ø´', 'Ø§Ø±Ø³Ø§Ù„ Ø³ÙØ§Ø±Ø´'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 156,
            lastSent: '2025-07-17T09:15:00Z',
            successRate: 97.2
          }
        },
        {
          id: 'delivery-verification',
          name: 'ØªØ§ÛŒÛŒØ¯ ØªØ­ÙˆÛŒÙ„',
          description: 'Ú©Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ù„Ø§',
          icon: 'Truck',
          enabled: true,
          messageTemplate: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„: {{deliveryCode}} - Ù¾ÛŒÚ©: {{courierName}} {{courierPhone}}',
          triggerConditions: ['Ø§Ø±Ø³Ø§Ù„ ØªÙˆØ³Ø· Ù„Ø¬Ø³ØªÛŒÚ©'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 89,
            lastSent: '2025-07-17T08:45:00Z',
            successRate: 99.1
          }
        },
        {
          id: 'logistics_delivery_codes',
          name: 'Ú©Ø¯Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ù„Ø¬Ø³ØªÛŒÚ©',
          description: 'Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯Ù‡Ø§ÛŒ Û´ Ø±Ù‚Ù…ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù„Ø¬Ø³ØªÛŒÚ© Ø¨Ø±Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ù…Ø­Ù…ÙˆÙ„Ù‡',
          icon: 'Shield',
          enabled: true,
          messageTemplate: 'Ù…Ø´ØªØ±ÛŒ Ù…Ø­ØªØ±Ù… {{customerName}}\nÚ©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø³ÙØ§Ø±Ø´ {{customerOrderId}}: {{verificationCode}}\nÙ‡Ù†Ú¯Ø§Ù… ØªØ­ÙˆÛŒÙ„ Ù…Ø­Ù…ÙˆÙ„Ù‡ Ø§ÛŒÙ† Ú©Ø¯ Ø±Ø§ Ø¨Ù‡ Ø­Ù…Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø§Ø¹Ù„Ø§Ù… Ù†Ù…Ø§ÛŒÛŒØ¯.\nØ´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ',
          triggerConditions: ['Logistics code generated', 'Delivery code resent'],
          recipients: ['Customers with pending deliveries'],
          frequency: 'On-demand by logistics department',
          priority: 'high' as const,
          statistics: {
            totalSent: 0,
            lastSent: undefined,
            successRate: 100
          }
        },
        {
          id: 'customer-communications',
          name: 'Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª Ù…Ø´ØªØ±ÛŒ',
          description: 'Ù¾ÛŒØ§Ù…Ú©â€ŒÙ‡Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ Ùˆ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ',
          icon: 'MessageSquare',
          enabled: true,
          messageTemplate: 'Ù¾ÛŒØ§Ù… Ø§Ø² {{company}}: {{message}}',
          triggerConditions: ['Ø¯Ø³ØªÛŒ', 'Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø´Ø¯Ù‡'],
          recipients: ['Ù…Ø´ØªØ±ÛŒ', 'Ú¯Ø±ÙˆÙ‡ Ù…Ø´ØªØ±ÛŒØ§Ù†'],
          frequency: 'Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø´Ø¯Ù‡',
          priority: 'medium' as const,
          statistics: {
            totalSent: 67,
            lastSent: '2025-07-16T15:20:00Z',
            successRate: 96.8
          }
        },
        {
          id: 'inventory-alerts',
          name: 'Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ø§Ù†Ø¨Ø§Ø±',
          description: 'Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ú©Ù…Ø¨ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ÛŒ',
          icon: 'Package',
          enabled: true,
          messageTemplate: 'Ù‡Ø´Ø¯Ø§Ø±: Ù…ÙˆØ¬ÙˆØ¯ÛŒ {{productName}} Ú©Ù…ØªØ± Ø§Ø² Ø­Ø¯ Ù…Ø¬Ø§Ø²',
          triggerConditions: ['Ú©Ù…Ø¨ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ÛŒ', 'Ø§ØªÙ…Ø§Ù… Ù…ÙˆØ¬ÙˆØ¯ÛŒ'],
          recipients: ['Ù…Ø¯ÛŒØ± Ø§Ù†Ø¨Ø§Ø±', 'Ù…Ø¯ÛŒØ± ÙØ±ÙˆØ´'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 23,
            lastSent: '2025-07-15T11:30:00Z',
            successRate: 100
          }
        },
        {
          id: 'admin-notifications',
          name: 'Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª',
          description: 'Ù¾ÛŒØ§Ù…Ú©â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ',
          icon: 'Bell',
          enabled: true,
          messageTemplate: 'Ø§Ø·Ù„Ø§Ø¹ Ø³ÛŒØ³ØªÙ…: {{message}}',
          triggerConditions: ['Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…', 'Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ'],
          recipients: ['Ù…Ø¯ÛŒØ±Ø§Ù† Ø³ÛŒØ³ØªÙ…'],
          frequency: 'ÙÙˆØ±ÛŒ',
          priority: 'high' as const,
          statistics: {
            totalSent: 12,
            lastSent: '2025-07-14T09:00:00Z',
            successRate: 100
          }
        }
      ];

      res.json({ success: true, categories });
    } catch (error) {
      console.error("Error fetching SMS categories:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§" });
    }
  });

  // Update SMS category
  app.put("/api/admin/sms/categories/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      const { enabled, messageTemplate, priority } = req.body;
      
      // In a real implementation, this would update database
      // For now, we'll just return success
      res.json({ 
        success: true, 
        message: `Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ${categoryId} Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯`,
        category: {
          id: categoryId,
          enabled,
          messageTemplate,
          priority
        }
      });
    } catch (error) {
      console.error("Error updating SMS category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ" });
    }
  });

  // Get delivery logs
  app.get("/api/admin/sms/delivery-logs", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          dvc.id,
          dvc.customer_order_id as order_id,
          dvc.customer_name,
          dvc.customer_phone as phone,
          dvc.verification_code,
          dvc.sms_status,
          dvc.created_at,
          dvc.sms_delivered_at as delivered_at,
          dvc.is_used as is_verified
        FROM delivery_verification_codes dvc
        WHERE dvc.sms_sent = true
        ORDER BY dvc.created_at DESC
        LIMIT 100
      `);

      const deliveryLogs = result.rows.map((row: any) => ({
        id: row.id,
        orderId: row.order_id,
        customerName: row.customer_name,
        phone: row.phone,
        verificationCode: row.verification_code,
        smsStatus: row.sms_status || 'sent',
        createdAt: row.created_at,
        deliveredAt: row.delivered_at,
        isVerified: row.is_verified
      }));

      res.json({ success: true, data: deliveryLogs });
    } catch (error) {
      console.error("Error fetching delivery logs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯â€ŒÙ‡Ø§" });
    }
  });

  // Get SMS template for logistics delivery codes
  app.get("/api/sms/template/logistics-delivery", async (req, res) => {
    try {
      const template = '{{customerName}} Ø¹Ø²ÛŒØ²ØŒ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø¯Ø± Ø±Ø§Ù‡ Ø§Ø³Øª.\nÚ©Ø¯ ØªØ­ÙˆÛŒÙ„: {{verificationCode}}\nØ§ÛŒÙ† Ú©Ø¯ Ø±Ø§ Ù‡Ù†Ú¯Ø§Ù… ØªØ­ÙˆÛŒÙ„ Ø¨Ù‡ Ù¾ÛŒÚ© Ø§Ø¹Ù„Ø§Ù… Ú©Ù†ÛŒØ¯.\nÙ…Ù…ØªØ§Ø²Ú©Ù…';
      
      res.json({
        success: true,
        template: template
      });
    } catch (error) {
      console.error("Error fetching SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…Ú©"
      });
    }
  });

  // SMS Template Categories Management
  app.get("/api/admin/sms/template-categories", requireAuth, async (req: Request, res: Response) => {
    try {
      const categories = await smsStorage.getAllTemplateCategories();
      res.json({ success: true, data: categories });
    } catch (error) {
      console.error("Error fetching template categories:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.post("/api/admin/sms/template-categories", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryName, categoryDescription, systemUsage, displayOrder } = req.body;
      
      if (!categoryName || !systemUsage) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const categoryNumber = await smsStorage.getNextCategoryNumber();
      
      const category = await smsStorage.createTemplateCategory({
        categoryNumber,
        categoryName,
        categoryDescription,
        systemUsage,
        displayOrder: displayOrder || 0
      });

      res.json({ success: true, data: category, message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error creating template category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.put("/api/admin/sms/template-categories/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const category = await smsStorage.updateTemplateCategory(parseInt(id), updates);
      res.json({ success: true, data: category, message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating template category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.delete("/api/admin/sms/template-categories/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await smsStorage.deleteTemplateCategory(parseInt(id));
      res.json({ success: true, message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting template category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  // SMS Templates Management
  app.get("/api/admin/sms/templates", requireAuth, async (req: Request, res: Response) => {
    try {
      const templates = await smsStorage.getAllTemplates();
      res.json({ success: true, data: templates });
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§" });
    }
  });

  app.get("/api/admin/sms/templates/category/:categoryId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryId } = req.params;
      const templates = await smsStorage.getTemplatesByCategory(parseInt(categoryId));
      res.json({ success: true, data: templates });
    } catch (error) {
      console.error("Error fetching templates by category:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ" });
    }
  });

  app.post("/api/admin/sms/templates", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryId, templateName, templateContent, variables, isDefault, createdBy } = req.body;
      
      if (!categoryId || !templateName || !templateContent) {
        return res.status(400).json({
          success: false,
          message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒØŒ Ù†Ø§Ù… Ù‚Ø§Ù„Ø¨ Ùˆ Ù…Ø­ØªÙˆØ§ÛŒ Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      const templateNumber = await smsStorage.getNextTemplateNumber(parseInt(categoryId));
      
      const template = await smsStorage.createTemplate({
        categoryId: parseInt(categoryId),
        templateNumber,
        templateName,
        templateContent,
        variables: variables || [],
        isDefault: isDefault || false,
        createdBy: createdBy || 'admin'
      });

      res.json({ success: true, data: template, message: "Ù‚Ø§Ù„Ø¨ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.put("/api/admin/sms/templates/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const template = await smsStorage.updateTemplate(parseInt(id), updates);
      res.json({ success: true, data: template, message: "Ù‚Ø§Ù„Ø¨ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.delete("/api/admin/sms/templates/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await smsStorage.deleteTemplate(parseInt(id));
      res.json({ success: true, message: "Ù‚Ø§Ù„Ø¨ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting template:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.get("/api/admin/sms/templates/usage/:systemUsage", requireAuth, async (req: Request, res: Response) => {
    try {
      const { systemUsage } = req.params;
      const { isDefault } = req.query;
      
      const template = await smsStorage.getTemplateBySystemUsage(
        systemUsage, 
        isDefault === 'true' ? true : undefined
      );
      
      if (!template) {
        return res.status(404).json({
          success: false,
          message: "Ù‚Ø§Ù„Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø³ÛŒØ³ØªÙ… ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      res.json({ success: true, data: template });
    } catch (error) {
      console.error("Error fetching template by system usage:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨" });
    }
  });

  app.post("/api/admin/sms/templates/:id/usage", requireAuth, async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      await smsStorage.incrementTemplateUsage(parseInt(id));
      res.json({ success: true, message: "Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚Ø§Ù„Ø¨ Ø«Ø¨Øª Ø´Ø¯" });
    } catch (error) {
      console.error("Error incrementing template usage:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‚Ø§Ù„Ø¨" });
    }
  });

  // Test SMS configuration
  app.post("/api/admin/sms/test", requireAuth, async (req, res) => {
    try {
      const { phone, message } = req.body;
      
      if (!phone || !message) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù¾ÛŒØ§Ù… Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // For demo purposes, we'll simulate a successful SMS send
      // In real implementation, this would use the SMS service
      res.json({
        success: true,
        message: "Ù¾ÛŒØ§Ù…Ú© ØªØ³Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        testResult: {
          phone,
          message,
          status: 'sent',
          provider: 'kavenegar',
          sentAt: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error("Error testing SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ú© ØªØ³Øª" });
    }
  });

  // Get batch information for a specific order
  app.get("/api/orders/:orderId/batch-info", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (!orderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const { unifiedInventoryManager } = await import('./unified-inventory-manager');
      const batchInfo = await unifiedInventoryManager.getBatchInfoForOrder(orderId);
      
      res.json({
        success: true,
        data: batchInfo,
        message: `Ø§Ø·Ù„Ø§Ø¹Ø§Øª ${batchInfo.length} Ø¨Ú† Ø¨Ø±Ø§ÛŒ Ø³ÙØ§Ø±Ø´ ${orderId} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error fetching batch info for order:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†" });
    }
  });



  // Get batch details for a specific product by barcode
  app.get("/api/inventory/product-batch-details/:barcode", requireAuth, async (req, res) => {
    try {
      const barcode = req.params.barcode;
      
      if (!barcode) {
        return res.status(400).json({
          success: false,
          message: "Ø¨Ø§Ø±Ú©Ø¯ Ù…Ø­ØµÙˆÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const batchDetails = await UnifiedInventoryManager.getProductBatchDetails(barcode);
      
      if (!batchDetails) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ø§ÛŒÙ† Ø¨Ø§Ø±Ú©Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }
      
      res.json({
        success: true,
        data: batchDetails,
        message: `Ø§Ø·Ù„Ø§Ø¹Ø§Øª ${batchDetails.batches.length} Ø¨Ú† Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„ ${batchDetails.productName} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error fetching product batch details:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú† Ù…Ø­ØµÙˆÙ„" });
    }
  });

  // Generate invoice PDF with batch information
  app.get("/api/orders/:orderId/invoice-with-batch", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      if (!orderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Get order details
      const order = await orderManagementStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Get customer details
      const customer = await crmStorage.getCrmCustomerById(order.customerId);
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Get batch information
      const { unifiedInventoryManager } = await import('./unified-inventory-manager');
      const batchInfo = await unifiedInventoryManager.getBatchInfoForOrder(orderId);

      // Generate PDF with batch information using PDFMake
      const { generateInvoicePDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateInvoicePDFWithPDFMake(
        customer,
        order,
        batchInfo,
        `ÙØ§Ú©ØªÙˆØ± Ø³ÙØ§Ø±Ø´ ${orderId}`
      );

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${orderId}-with-batch.pdf"`);
      res.setHeader('Content-Length', pdfBuffer.length.toString());

      // Send PDF
      res.send(pdfBuffer);

    } catch (error) {
      console.error("Error generating invoice with batch info:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ± Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ú†" });
    }
  });

  // Customer registration endpoint - CRM-centric approach
  app.post("/api/customers/register", async (req, res) => {
    try {
      const { 
        firstName, 
        lastName, 
        email, 
        password, 
        passwordHash, // Support both password and passwordHash
        phone, 
        company, 
        country, 
        city, 
        address,
        secondaryAddress,
        postalCode,
        alternatePhone,
        state,
        industry,
        businessType,
        companySize,
        communicationPreference,
        preferredLanguage,
        marketingConsent,
        customerType,
        customerSource,
        productInterests,
        creditLimit,
        paymentTerms,
        preferredPaymentMethod,
        assignedSalesRep,
        tags,
        publicNotes
      } = req.body;
      
      // Check if customer already exists in CRM (primary check)
      const existingCrmCustomer = await crmStorage.getCrmCustomerByEmail(email);
      if (existingCrmCustomer) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª. Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª." 
        });
      }

      // Check if phone number already exists in CRM
      const existingCrmPhone = await crmStorage.getCrmCustomerByPhone(phone);
      if (existingCrmPhone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª. Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª." 
        });
      }

      // Validate mandatory fields
      if (!email || !phone || !country || !city || !address) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ØŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†ØŒ Ú©Ø´ÙˆØ±ØŒ Ø´Ù‡Ø± Ùˆ Ø¢Ø¯Ø±Ø³ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ù‡Ø³ØªÙ†Ø¯" 
        });
      }

      // Hash password
      const finalPassword = password || passwordHash;
      const hashedPassword = await bcrypt.hash(finalPassword, 10);

      // Create CRM customer first (central repository) with password for unified auth
      const crmCustomerData = {
        email,
        passwordHash: hashedPassword,
        firstName,
        lastName,
        company: company || null,
        phone,
        alternatePhone: alternatePhone || null,
        country,
        state: state || null,
        city,
        address,
        secondaryAddress: secondaryAddress || null,
        postalCode: postalCode || null,
        industry: industry || null,
        businessType: businessType || null,
        companySize: companySize || null,
        communicationPreference: communicationPreference || 'email',
        preferredLanguage: preferredLanguage || 'en',
        marketingConsent: marketingConsent || false,
        productInterests: productInterests || null,
        creditLimit: creditLimit || null,
        paymentTerms: paymentTerms || 'immediate',
        preferredPaymentMethod: preferredPaymentMethod || null,
        assignedSalesRep: assignedSalesRep || null,
        tags: tags || null,
        publicNotes: publicNotes || null,
        customerType: customerType || 'retail',
        customerSource: customerSource || 'website',
        customerStatus: 'active',
        createdBy: 'customer_registration',
        internalNotes: 'Customer registered through online shop',
        isActive: true,
      };

      const crmCustomer = await crmStorage.createCrmCustomer(crmCustomerData);

      // Create corresponding customer portal entry with password (for authentication)
      let portalCustomer = null;
      try {
        const portalData = {
          email: crmCustomerData.email,
          passwordHash: hashedPassword, // Password stored only in portal for authentication
          firstName: crmCustomerData.firstName,
          lastName: crmCustomerData.lastName,
          company: crmCustomerData.company,
          phone: crmCustomerData.phone,
          country: crmCustomerData.country,
          city: crmCustomerData.city,
          address: crmCustomerData.address,
          postalCode: crmCustomerData.postalCode,
          isActive: true,
        };
        portalCustomer = await customerStorage.createCustomer(portalData);
      } catch (portalError) {
        console.log('Portal customer creation failed, CRM customer created successfully');
      }

      // Log registration activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: crmCustomer.id,
        activityType: 'registration',
        description: 'Customer registered through online shop',
        performedBy: 'system',
        activityData: {
          source: 'website',
          registrationDate: new Date().toISOString(),
          hasPortalAccess: !!portalCustomer,
          portalCustomerId: portalCustomer?.id,
        }
      });

      // Update customer metrics immediately after registration
      await crmStorage.updateCustomerMetrics(crmCustomer.id);

      // Send SMS verification after successful registration using template 4
      try {
        const verificationCode = Math.floor(1000 + Math.random() * 9000).toString(); // 4-digit code
        
        // Store verification code in database
        await db.execute(sql`
          INSERT INTO customer_verification_codes (customer_id, verification_code, phone_number, expires_at)
          VALUES (${crmCustomer.id}, ${verificationCode}, ${phone}, ${new Date(Date.now() + 10 * 60 * 1000)})
        `);
        
        // Get SMS template 4 for registration verification
        const template = await simpleSmsStorage.getTemplateById(4);
        
        if (template && template.templateContent && phone) {
          // Replace variables in template
          let smsMessage = template.templateContent;
          smsMessage = smsMessage.replace(/\{\{customer_name\}\}/g, `${firstName} ${lastName}`);
          smsMessage = smsMessage.replace(/\{\{verification_code\}\}/g, verificationCode);
          
          // Here you would integrate with your SMS provider
          // For now, we'll log the message and mark it as sent
          console.log(`ðŸ“± [SMS VERIFICATION] Registration verification sent to ${phone} - Template: ${template.templateName}`);
          
          // Increment template usage using direct SQL
          await simpleSmsDb.execute(sql`
            UPDATE simple_sms_templates 
            SET usage_count = usage_count + 1, 
                last_used = NOW(), 
                updated_at = NOW() 
            WHERE id = ${4}
          `);
          
          // Log SMS activity in CRM
          await crmStorage.logCustomerActivity({
            customerId: crmCustomer.id,
            activityType: 'sms_sent',
            description: 'Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯',
            performedBy: 'system',
            activityData: {
              phone: phone,
              template_id: 8,
              verification_code: verificationCode,
              sent_at: new Date().toISOString()
            }
          });
        }
      } catch (smsError) {
        console.error('SMS verification error:', smsError);
        // Don't fail registration if SMS fails
      }
      
      res.json({
        success: true,
        message: "Registration successful",
        customer: {
          id: portalCustomer?.id || crmCustomer.id,
          firstName: crmCustomer.firstName,
          lastName: crmCustomer.lastName,
          email: crmCustomer.email,
          crmId: crmCustomer.id,
        }
      });
    } catch (error) {
      console.error("Error registering customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Registration failed" 
      });
    }
  });

  // SMS Verification Endpoint
  app.post('/api/customer/verify-sms', async (req, res) => {
    try {
      const { phone, verificationCode } = req.body;
      
      if (!phone || !verificationCode) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
        });
      }

      // Find valid verification code
      const result = await db.execute(sql`
        SELECT * FROM customer_verification_codes 
        WHERE phone_number = ${phone} 
        AND verification_code = ${verificationCode}
        AND is_used = false 
        AND expires_at > NOW()
        ORDER BY created_at DESC
        LIMIT 1
      `);

      if (result.rows.length === 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      const verificationRecord = result.rows[0];
      
      // Mark verification code as used
      await db.execute(sql`
        UPDATE customer_verification_codes 
        SET is_used = true 
        WHERE id = ${verificationRecord.id}
      `);

      // Activate customer profile
      await db.execute(sql`
        UPDATE crm_customers 
        SET customer_status = 'active', 
            is_verified = true,
            verified_at = NOW()
        WHERE id = ${verificationRecord.customer_id}
      `);

      // Get customer data
      const customer = await crmStorage.getCrmCustomerById(verificationRecord.customer_id);
      
      if (customer) {
        // Log verification activity
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: 'sms_verification_completed',
          description: 'Customer verified phone number via SMS',
          performedBy: 'system',
          activityData: {
            phone: phone,
            verificationCode: verificationCode,
            verifiedAt: new Date().toISOString()
          }
        });

        // Set customer session
        req.session.isAuthenticated = true;
        req.session.customerId = customer.id;
        req.session.customerType = 'crm';
        
        res.json({
          success: true,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
          customer: {
            id: customer.id,
            firstName: customer.firstName,
            lastName: customer.lastName,
            email: customer.email,
            phone: customer.phone,
            isVerified: true
          }
        });
      } else {
        res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }
    } catch (error) {
      console.error("SMS verification error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª" 
      });
    }
  });

  // Resend SMS Verification Code
  app.post('/api/customer/resend-verification', async (req, res) => {
    try {
      const { phone } = req.body;
      
      if (!phone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø§Ø³Øª" 
        });
      }

      // Find customer by phone
      const customer = await crmStorage.getCrmCustomerByPhone(phone);
      if (!customer) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Generate new verification code
      const verificationCode = Math.floor(1000 + Math.random() * 9000).toString();
      
      // Store new verification code
      await db.execute(sql`
        INSERT INTO customer_verification_codes (customer_id, verification_code, phone_number, expires_at)
        VALUES (${customer.id}, ${verificationCode}, ${phone}, ${new Date(Date.now() + 10 * 60 * 1000)})
      `);

      // Get SMS template 4 for resend
      const template = await simpleSmsStorage.getTemplateById(4);
      
      if (template && template.templateContent) {
        let smsMessage = template.templateContent;
        smsMessage = smsMessage.replace(/\{\{customer_name\}\}/g, `${customer.firstName} ${customer.lastName}`);
        smsMessage = smsMessage.replace(/\{\{verification_code\}\}/g, verificationCode);
        
        console.log(`ðŸ“± [SMS RESEND] Verification code resent to ${phone}: ${smsMessage}`);
        
        // Increment template usage
        await simpleSmsDb.execute(sql`
          UPDATE simple_sms_templates 
          SET usage_count = usage_count + 1, 
              last_used = NOW(), 
              updated_at = NOW() 
          WHERE id = ${4}
        `);
        
        // Log resend activity
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: 'sms_resend',
          description: 'Verification code resent to customer',
          performedBy: 'system',
          activityData: {
            phone: phone,
            templateUsed: template.templateName,
            verificationCode: verificationCode
          }
        });
      }

      res.json({
        success: true,
        message: "Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("SMS resend error:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯" 
      });
    }
  });

  app.post("/api/customers/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      
      // ONLY authenticate via CRM (single source of truth)
      const crmCustomer = await crmStorage.getCrmCustomerByEmail(email);
      
      if (!crmCustomer || !crmCustomer.passwordHash) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }
      
      // Check password against CRM customer only
      const isValidPassword = await bcrypt.compare(password, crmCustomer.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Clear any existing admin session first (single session mode)
      req.session.adminId = undefined;
      req.session.customUserId = undefined;
      
      // Store customer session using CRM ID as primary
      (req.session as any).customerId = crmCustomer.id;
      (req.session as any).customerEmail = crmCustomer.email;
      (req.session as any).crmCustomerId = crmCustomer.id;
      (req.session as any).isAuthenticated = true;
      
      console.log(`âœ… [CUSTOMER LOGIN] Session configured for customer ${crmCustomer.id} (admin session cleared):`, {
        customerId: crmCustomer.id,
        customerEmail: crmCustomer.email,
        sessionId: req.sessionID
      });

      // Log login activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: crmCustomer.id,
        activityType: 'login',
        description: 'Ù…Ø´ØªØ±ÛŒ ÙˆØ§Ø±Ø¯ ÙØ±ÙˆØ´Ú¯Ø§Ù‡ Ø¢Ù†Ù„Ø§ÛŒÙ† Ø´Ø¯',
        performedBy: 'customer',
        activityData: {
          source: 'website',
          loginDate: new Date().toISOString(),
          userAgent: req.headers['user-agent'] || 'unknown',
          loginMethod: 'crm_direct'
        }
      });

      res.json({
        success: true,
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚",
        customer: {
          id: crmCustomer.id,
          firstName: crmCustomer.firstName,
          lastName: crmCustomer.lastName,
          email: crmCustomer.email,
          company: crmCustomer.company,
          phone: crmCustomer.phone,
          country: crmCustomer.country,
          city: crmCustomer.city,
          address: crmCustomer.address,
          crmId: crmCustomer.id,
        }
      });
    } catch (error) {
      console.error("Error logging in customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" 
      });
    }
  });

  app.post("/api/customers/logout", async (req, res) => {
    try {
      // Clear all session data (single session mode)
      req.session.customerId = undefined;
      req.session.customerEmail = undefined;
      req.session.crmCustomerId = undefined;
      req.session.adminId = undefined;
      req.session.customUserId = undefined;
      req.session.isAuthenticated = undefined;
      
      // Always destroy entire session for clean logout
      req.session.destroy((err) => {
        if (err) {
          console.error("Error destroying session:", err);
          return res.status(500).json({ 
            success: false, 
            message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬" 
          });
        }
        console.log('ðŸ”„ Complete customer logout - all sessions cleared');
        res.json({
          success: true,
          message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚"
        });
      });
    } catch (error) {
      console.error("Error logging out customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬" 
      });
    }
  });

  // Update customer profile
  app.patch("/api/customers/:id", async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const updateData = req.body;
      
      // Get session customer ID
      const sessionCustomerId = (req.session as any)?.customerId;
      const sessionCrmId = (req.session as any)?.crmCustomerId;
      
      // Ensure customer can only update their own profile
      if (customerId !== sessionCustomerId && customerId !== sessionCrmId) {
        return res.status(403).json({ 
          success: false, 
          message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª" 
        });
      }

      // Update customer in CRM (primary source)
      if (sessionCrmId) {
        const updatedCustomer = await crmStorage.updateCrmCustomer(sessionCrmId, updateData);
        res.json({
          success: true,
          message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
          customer: updatedCustomer
        });
      } else {
        // Fallback to portal customer update
        const updatedCustomer = await customerStorage.updateCustomer(customerId, updateData);
        res.json({
          success: true,
          message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
          customer: updatedCustomer
        });
      }
    } catch (error) {
      console.error("Error updating customer:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„" 
      });
    }
  });

  // Get complete CRM customer data for logged-in customer
  app.get("/api/customer/crm-profile", async (req, res) => {
    console.log('=== /api/customer/crm-profile endpoint called ===');
    try {
      const session = req.session as any;
      const crmCustomerId = session?.crmCustomerId;
      
      console.log('Session data:', {
        hasSession: !!session,
        customerId: session?.customerId,
        crmCustomerId: crmCustomerId,
        customerEmail: session?.customerEmail
      });
      
      if (!crmCustomerId) {
        console.log('No CRM customer ID found in session');
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡ ÛŒØ§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª CRM Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª" 
        });
      }

      console.log(`Fetching CRM customer with ID: ${crmCustomerId}`);
      const crmCustomer = await crmStorage.getCrmCustomerById(crmCustomerId);
      
      if (!crmCustomer) {
        console.log('CRM customer not found in database');
        return res.status(404).json({ 
          success: false, 
          message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ Ø¯Ø± CRM ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      console.log('CRM customer found:', {
        id: crmCustomer.id,
        email: crmCustomer.email,
        firstName: crmCustomer.firstName,
        lastName: crmCustomer.lastName,
        hasSecondaryAddress: !!crmCustomer.secondaryAddress,
        hasPostalCode: !!crmCustomer.postalCode
      });

      res.json({
        success: true,
        data: crmCustomer
      });
    } catch (error) {
      console.error("Error fetching CRM customer profile:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª CRM" 
      });
    }
  });

  app.get("/api/customers/me", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const adminId = (req.session as any)?.adminId;
      
      // If admin is logged in, don't allow customer data access
      if (adminId) {
        return res.status(401).json({ 
          success: false, 
          message: "Admin authenticated - not a customer" 
        });
      }
      
      if (!customerId && !crmCustomerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }

      // Prioritize CRM customer data
      let customer = null;
      let crmCustomer = null;

      if (crmCustomerId) {
        crmCustomer = await crmStorage.getCrmCustomerById(crmCustomerId);
        if (crmCustomer) {
          customer = crmCustomer; // Use CRM as primary source
        }
      }

      // Fallback to portal customer if CRM not available
      if (!customer && customerId) {
        const portalCustomer = await customerStorage.getCustomerById(customerId);
        if (portalCustomer) {
          customer = portalCustomer;
        }
      }

      if (!customer) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      res.json({
        success: true,
        customer: {
          id: customer.id,
          firstName: customer.firstName,
          lastName: customer.lastName,
          email: customer.email,
          company: customer.company || '',
          phone: customer.phone || '',
          country: customer.country || '',
          city: customer.city || '',
          address: customer.address || '',
          postalCode: customer.postalCode,
          crmId: crmCustomer?.id || customer.id,
          totalOrders: crmCustomer?.totalOrdersCount || 0,
          totalOrderValue: crmCustomer?.totalSpent || "0",
          averageOrderValue: crmCustomer?.averageOrderValue || "0",
          lastOrderDate: crmCustomer?.lastOrderDate,
          customerStatus: crmCustomer?.customerStatus || 'active',
          customerType: crmCustomer?.customerType || 'retail',
        }
      });
    } catch (error) {
      console.error("Error getting customer info:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª" 
      });
    }
  });

  // Create shop order and integrate with CRM
  app.post("/api/shop/orders", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const { items, customerInfo, recipientInfo, totalAmount, notes, shippingMethod, paymentMethod, walletAmountUsed, remainingAmount } = req.body;
      
      console.log('ðŸ›’ [ORDER DEBUG] Order data received:', {
        paymentMethod,
        walletAmountUsed,
        remainingAmount,
        totalAmount,
        customerId,
        crmCustomerId
      });

      let finalCustomerInfo = customerInfo;
      let finalCrmCustomerId = crmCustomerId;

      // If user is logged in, get customer info from database
      if (customerId && !customerInfo) {
        console.log('Getting customer info for customerId:', customerId);
        const customer = await customerStorage.getCustomerById(customerId);
        console.log('Retrieved customer:', customer);
        if (customer) {
          finalCustomerInfo = {
            email: customer.email,
            firstName: customer.firstName,
            lastName: customer.lastName,
            company: customer.company || '',
            phone: customer.phone || '',
            country: customer.country || 'Iraq',
            city: customer.city || 'Baghdad',
            address: customer.address || 'Default Address',
          };
          console.log('finalCustomerInfo set to:', finalCustomerInfo);
        }
      }

      console.log('Final customer info before order creation:', finalCustomerInfo);

      // If user is not logged in, create or update CRM customer from order info
      if (!customerId && customerInfo) {
        const orderData = {
          email: customerInfo.email,
          firstName: customerInfo.firstName,
          lastName: customerInfo.lastName,
          company: customerInfo.company,
          phone: customerInfo.phone,
          country: customerInfo.country,
          city: customerInfo.city,
          address: customerInfo.address,
          orderValue: totalAmount,
        };

        const crmCustomer = await crmStorage.createOrUpdateCustomerFromOrder(orderData);
        finalCrmCustomerId = crmCustomer.id;
        finalCustomerInfo = crmCustomer;
      }

      // Generate order number
      const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;

      // Handle wallet payments
      let finalPaymentStatus = "pending";
      let actualWalletUsed = 0;
      let finalPaymentMethod = paymentMethod || "bank_transfer";
      
      if (paymentMethod === 'wallet_full' || paymentMethod === 'wallet_partial') {
        const walletUsage = parseFloat(walletAmountUsed || 0);
        const remaining = parseFloat(remainingAmount || totalAmount);
        
        console.log('ðŸ’° [WALLET DEBUG] Processing wallet payment:', {
          walletUsage,
          remaining,
          finalCrmCustomerId,
          customerId
        });
        
        if (walletUsage > 0 && (finalCrmCustomerId || customerId)) {
          try {
            // Use the customer ID that exists (prioritize CRM customer)
            const customerIdToUse = finalCrmCustomerId || customerId;
            
            // Use walletStorage.debitWallet which handles all the logic
            const transaction = await walletStorage.debitWallet(
              customerIdToUse,
              walletUsage,
              `Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderNumber}`,
              'order',
              undefined, // reference ID will be set after order creation
              undefined  // no admin processing this
            );
            
            console.log(`âœ… Wallet payment processed: ${walletUsage} IQD deducted, transaction ID: ${transaction.id}`);
            actualWalletUsed = walletUsage;
            
            if (remaining === 0) {
              finalPaymentStatus = "paid"; // Fully paid by wallet
            } else {
              finalPaymentStatus = "partial"; // Partially paid by wallet
            }
          } catch (walletError) {
            console.log(`âŒ Wallet payment failed:`, walletError);
            return res.status(400).json({
              success: false,
              message: "Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª ÛŒØ§ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´"
            });
          }
        }
      }

      // Create order in customer orders table
      const orderData = {
        orderNumber,
        customerId: customerId || null,
        totalAmount: totalAmount.toString(),
        status: 'pending' as const,
        paymentStatus: finalPaymentStatus,
        paymentMethod: finalPaymentMethod,
        walletAmountUsed: actualWalletUsed.toString(),
        shippingAddress: {
          address: finalCustomerInfo.address,
          city: finalCustomerInfo.city,
          country: finalCustomerInfo.country,
        },
        notes: notes || '',
        ...(customerId ? {} : {
          guestEmail: finalCustomerInfo.email,
          guestName: `${finalCustomerInfo.firstName} ${finalCustomerInfo.lastName}`,
        }),
        // Store shipping method information
        carrier: shippingMethod === 'standard' ? 'Standard Shipping (5-7 days)' : 
                shippingMethod === 'express' ? 'Express Shipping (2-3 days)' : 
                shippingMethod === 'overnight' ? 'Overnight Shipping' : 
                'Standard Shipping',
        // Store recipient information (can be different from customer)
        recipientName: recipientInfo?.recipientName || '',
        recipientPhone: recipientInfo?.recipientPhone || '',
        recipientAddress: recipientInfo?.recipientAddress || '',
      };

      const order = await customerStorage.createOrder(orderData);

      // Create order items and update stock
      for (const item of items) {
        const unitPrice = item.unitPrice || item.price || 0;
        
        await customerStorage.createOrderItem({
          orderId: order.id,
          productId: item.productId,
          productName: item.productName || 'Unknown Product',
          quantity: String(item.quantity),
          unitPrice: String(unitPrice),
          totalPrice: String(item.quantity * unitPrice),
          productSku: item.productSku || '',
        });

        // Update product stock using unified inventory manager
        try {
          console.log(`ðŸ›’ UNIFIED STOCK UPDATE - Product ${item.productName} (ID: ${item.productId})`);
          
          // Use unified inventory manager for single source of truth
          const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
          const success = await UnifiedInventoryManager.reduceInventoryForOrder([{
            productName: item.productName,
            quantity: item.quantity
          }]);
          
          if (success) {
            console.log(`âœ… Stock updated successfully using unified system for product ${item.productId}`);
          } else {
            console.log(`âš ï¸ Failed to update stock for product ${item.productId}`);
          }
        } catch (stockError) {
          console.error(`Error updating stock for product ${item.productId}:`, stockError);
          // Continue with other products even if stock update fails
        }
      }

      // Log order activity in CRM
      if (finalCrmCustomerId) {
        await crmStorage.logCustomerActivity({
          customerId: finalCrmCustomerId,
          activityType: 'order_placed',
          description: `Ø³ÙØ§Ø±Ø´ Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ù…Ø¨Ù„Øº $${totalAmount} Ø«Ø¨Øª Ø´Ø¯`,
          activityData: {
            orderId: order.id,
            totalAmount,
            itemCount: items.length,
            source: 'website',
            orderDate: new Date().toISOString(),
          },
          relatedOrderId: order.id,
        });

        // Update customer metrics in CRM
        await crmStorage.updateCustomerMetrics(finalCrmCustomerId);
      }

      res.json({
        success: true,
        message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯",
        order: {
          id: order.id,
          totalAmount: order.totalAmount,
          status: order.status,
          paymentStatus: finalPaymentStatus,
          paymentMethod: finalPaymentMethod,
          walletAmountUsed: actualWalletUsed,
          crmCustomerId: finalCrmCustomerId,
        }
      });

    } catch (error) {
      console.error("Error creating shop order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´"
      });
    }
  });

  // Create customer order (from BilingualPurchaseForm)
  app.post("/api/customers/orders", async (req, res) => {
    console.log('ðŸš€ [ENDPOINT] /api/customers/orders called with timestamp:', req.query.t);
    console.log('ðŸš€ [ENDPOINT] Request method:', req.method);
    console.log('ðŸš€ [ENDPOINT] Request URL:', req.url);
    console.log('ðŸš€ [ENDPOINT] Request headers:', JSON.stringify(req.headers, null, 2));
    
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      const orderData = req.body;
      
      console.log('ðŸš€ [ENDPOINT] Session data:', {
        customerId,
        crmCustomerId,
        hasSession: !!req.session,
        sessionId: req.sessionID
      });
      
      console.log('ðŸ›’ [BILINGUAL ORDER DEBUG] Order data received:', {
        paymentMethod: orderData.paymentMethod,
        walletAmountUsed: orderData.walletAmountUsed,
        remainingAmount: orderData.remainingAmount,
        totalAmount: orderData.totalAmount,
        customerId,
        crmCustomerId,
        'Will process wallet?': orderData.paymentMethod === 'wallet_full' || orderData.paymentMethod === 'wallet_partial',
        'Wallet amount to deduct': orderData.walletAmountUsed,
        'Entire order data': orderData
      });

      // Extract customer information from form data
      const customerInfo = {
        name: orderData.customerName,
        phone: orderData.phone,
        address: orderData.address,
        city: orderData.city,
        postalCode: orderData.postalCode || '',
        country: orderData.country || 'Iraq', // Add country from form
        notes: orderData.notes || '', // Add notes from form
      };

      // Generate unique order number
      const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`;
      
      // Calculate order totals
      const subtotal = orderData.totalAmount || 0;
      const taxAmount = subtotal * 0.1; // 10% tax
      const shippingAmount = 50; // Fixed shipping amount
      const totalAmount = subtotal + taxAmount + shippingAmount;

      // Create order with proper customer linking
      let finalCustomerId = customerId;
      if (!customerId && crmCustomerId) {
        // Link to CRM customer if available
        finalCustomerId = crmCustomerId;
      }

      if (!finalCustomerId) {
        return res.status(401).json({
          success: false,
          message: "User must be logged in to place order"
        });
      }

      // Handle payment method processing
      let finalPaymentStatus = "pending";
      let walletAmountUsed = 0;
      let remainingAmount = totalAmount;
      let finalPaymentMethod = orderData.paymentMethod || "traditional";

      // Handle wallet payments
      if (orderData.paymentMethod === 'wallet_full' || orderData.paymentMethod === 'wallet_partial') {
        walletAmountUsed = parseFloat(orderData.walletAmountUsed || 0);
        remainingAmount = parseFloat(orderData.remainingAmount || totalAmount);
        
        console.log('ðŸ’° [BILINGUAL WALLET DEBUG] Processing wallet payment:', {
          walletAmountUsed,
          remainingAmount,
          finalCustomerId,
          paymentMethod: orderData.paymentMethod
        });
        
        if (walletAmountUsed > 0) {
          try {
            // Use walletStorage.debitWallet which handles all the logic
            const transaction = await walletStorage.debitWallet(
              finalCustomerId,
              walletAmountUsed,
              `Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${orderNumber}`,
              'order',
              undefined, // reference ID will be set after order creation
              undefined  // no admin processing this
            );
            
            console.log(`âœ… Wallet payment processed: ${walletAmountUsed} IQD deducted, transaction ID: ${transaction.id}`);
            
            if (remainingAmount === 0) {
              finalPaymentStatus = "paid"; // Fully paid by wallet
            } else {
              finalPaymentStatus = "partial"; // Partially paid by wallet
            }
          } catch (walletError) {
            console.log(`âŒ Wallet payment failed:`, walletError);
            return res.status(400).json({
              success: false,
              message: "Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª ÛŒØ§ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´"
            });
          }
        }
      }
      
      // Handle online payment method
      else if (orderData.paymentMethod === 'online_payment') {
        finalPaymentStatus = "pending";
        finalPaymentMethod = "online_payment";
        console.log("âœ… Online payment method selected - order will redirect to payment gateway");
      }
      
      // Handle bank receipt method
      else if (orderData.paymentMethod === 'bank_receipt') {
        finalPaymentStatus = "pending";
        finalPaymentMethod = "bank_receipt";
        console.log("âœ… Bank receipt method selected - customer will upload receipt");
      }
      
      // Handle bank transfer with grace period method
      else if (orderData.paymentMethod === 'bank_transfer_grace') {
        finalPaymentStatus = "grace_period";
        finalPaymentMethod = "bank_transfer_grace";
        console.log("âœ… Bank transfer with grace period method selected - 3-day grace period activated");
      }

      const order = await customerStorage.createOrder({
        customerId: finalCustomerId,
        orderNumber,
        status: "pending",
        paymentStatus: finalPaymentStatus,
        paymentMethod: finalPaymentMethod,
        totalAmount: totalAmount.toString(),
        currency: orderData.currency || "IQD",
        notes: orderData.notes || "",
        billingAddress: JSON.stringify({
          name: customerInfo.name,
          phone: customerInfo.phone,
          address: customerInfo.address,
          city: customerInfo.city,
          postalCode: customerInfo.postalCode,
        }),
        shippingAddress: JSON.stringify({
          name: customerInfo.name,
          phone: customerInfo.phone,
          address: customerInfo.address,
          city: customerInfo.city,
          postalCode: customerInfo.postalCode,
          gpsLatitude: orderData.gpsLatitude,
          gpsLongitude: orderData.gpsLongitude,
        }),
        trackingNumber: null,
        carrier: null,

      });

      // Create order items from cart
      if (orderData.cart) {
        for (const [productId, quantity] of Object.entries(orderData.cart)) {
          try {
            const product = await shopStorage.getShopProductById(parseInt(productId as string));
            if (product) {
              await customerStorage.createOrderItem({
                orderId: order.id,
                productId: parseInt(productId as string),
                productName: product.name,
                productSku: product.sku || `SKU-${productId}`,
                quantity: (quantity as number).toString(),
                unitPrice: product.price || "0",
                totalPrice: (parseFloat(product.price || "0") * (quantity as number)).toString(),
              });

              // Update product stock with batch tracking
              if (product.stockQuantity !== null && product.stockQuantity !== undefined) {
                const currentStock = product.stockQuantity;
                const quantityToSell = quantity as number;
                
                console.log(`ðŸ›’ STOCK UPDATE WITH BATCH TRACKING - Product ${product.name} (ID: ${productId})`);
                console.log(`   Current Stock: ${currentStock}`);
                console.log(`   Quantity Sold: ${quantityToSell}`);
                
                try {
                  // Use unified inventory manager for batch tracking
                  const { unifiedInventoryManager } = await import('./unified-inventory-manager');
                  
                  // Process inventory reduction with batch tracking
                  const result = await unifiedInventoryManager.processOrderWithBatchTracking(
                    parseInt(productId as string),
                    quantityToSell,
                    order.id,
                    `Order ${orderNumber} - Customer purchase`
                  );
                  
                  console.log(`âœ… Stock updated with batch tracking for product ${productId}:`, result);
                  
                  // Track batch usage for this sale
                  await unifiedInventoryManager.trackBatchUsageInSale(
                    order.id,
                    product.name,
                    result.batchesUsed
                  );
                  
                  console.log(`âœ… Batch usage tracked for order ${order.id}`);
                  
                } catch (batchError) {
                  console.error(`âŒ Batch tracking failed for product ${productId}:`, batchError);
                  
                  // Fallback to simple stock update if batch tracking fails
                  const newQuantity = Math.max(0, currentStock - quantityToSell);
                  await shopStorage.updateProductStock(
                    parseInt(productId as string),
                    newQuantity,
                    `Order ${orderNumber} - Sold ${quantityToSell} units (fallback)`
                  );
                  
                  console.log(`âš ï¸ Fallback stock update completed for product ${productId}`);
                }
              } else {
                console.log(`âš ï¸ No stock quantity available for product ${productId}`);
              }
            }
          } catch (productError) {
            console.error(`Error processing product ${productId}:`, productError);
            // Continue with other products even if one fails
          }
        }
      }

      // Auto-capture customer data in CRM system
      try {
        // Get customer details for CRM capture
        let customerForCrm = null;
        if (finalCustomerId) {
          try {
            customerForCrm = await customerStorage.getCustomerById(finalCustomerId);
          } catch (err) {
            console.log("Customer not found in customer storage, checking CRM...");
            try {
              customerForCrm = await crmStorage.getCrmCustomerById(finalCustomerId);
            } catch (crmErr) {
              console.log("Customer not found in CRM either, will create from order data");
            }
          }
        }

        // Extract customer information from order data - enhanced with all form fields
        const nameParts = customerInfo.name.split(' ');
        const firstName = nameParts[0] || 'Unknown';
        const lastName = nameParts.slice(1).join(' ') || 'Customer';
        
        const crmOrderData = {
          email: customerForCrm?.email || `customer${finalCustomerId}@temp.local`,
          firstName: firstName,
          lastName: lastName,
          company: customerForCrm?.company || null,
          phone: customerInfo.phone,
          country: customerInfo.country || 'Iraq', // Use form country or default
          city: customerInfo.city || 'Unknown',
          address: customerInfo.address,
          postalCode: customerInfo.postalCode || null,
          orderValue: totalAmount,
        };
        
        console.log('CRM Order Data being captured:', {
          firstName,
          lastName,
          phone: customerInfo.phone,
          country: customerInfo.country,
          city: customerInfo.city,
          address: customerInfo.address,
          postalCode: customerInfo.postalCode,
          orderValue: totalAmount
        });

        await crmStorage.createOrUpdateCustomerFromOrder(crmOrderData);
        console.log(`âœ… Customer auto-captured in CRM for order ${orderNumber}`);
      } catch (crmError) {
        console.error("âŒ Error auto-capturing customer in CRM:", crmError);
        // Don't fail the order if CRM capture fails
      }

      // Create order_management record for financial department workflow
      try {
        let orderMgmtData = {
          customerOrderId: order.id,
          customerId: finalCustomerId,
          currentStatus: finalPaymentStatus === 'grace_period' ? 'payment_grace_period' : 'pending',
          currentDepartment: 'customer',
          totalAmount: totalAmount.toString(),
          currency: orderData.currency || "IQD",
          notes: orderData.notes || "",
        };

        // Add grace period fields for bank_transfer_grace payment method
        if (orderData.paymentMethod === 'bank_transfer_grace') {
          const gracePeriodStart = new Date();
          const gracePeriodEnd = new Date();
          gracePeriodEnd.setDate(gracePeriodEnd.getDate() + 3); // 3 days grace period

          orderMgmtData = {
            ...orderMgmtData,
            paymentGracePeriodStart: gracePeriodStart,
            paymentGracePeriodEnd: gracePeriodEnd,
            isOrderLocked: true, // Lock order details during grace period
          };

          console.log(`ðŸ•’ Grace period activated for order ${orderNumber} - expires: ${gracePeriodEnd.toISOString()}`);
        }

        await orderManagementStorage.createOrderManagement(orderMgmtData);
        console.log(`âœ… Order management record created for order ${orderNumber}`);
      } catch (orderMgmtError) {
        console.error("âŒ Error creating order management record:", orderMgmtError);
        // Don't fail the order if order management creation fails
      }

      // Prepare response based on payment method
      let responseData = {
        success: true,
        message: "Order created successfully",
        orderId: order.id,
        orderNumber: order.orderNumber,
        paymentMethod: finalPaymentMethod,
        totalAmount: remainingAmount > 0 ? remainingAmount : totalAmount,
        walletAmountUsed: walletAmountUsed,
      };

      // Add redirect URL for online payment
      if (finalPaymentMethod === 'online_payment') {
        responseData.redirectToPayment = true;
        responseData.paymentGatewayUrl = `/payment?orderId=${order.id}&amount=${remainingAmount > 0 ? remainingAmount : totalAmount}`;
        console.log(`âœ… Order ${orderNumber} created - redirecting to payment gateway for ${remainingAmount > 0 ? remainingAmount : totalAmount} IQD`);
      }

      res.json(responseData);
    } catch (error) {
      console.error("Error creating customer order:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create order"
      });
    }
  });

  // Get customer order history (including grace period orders)
  app.get("/api/customers/orders", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      const crmCustomerId = (req.session as any)?.crmCustomerId;
      
      console.log('ðŸ” [CUSTOMER ORDERS] Session check:', { customerId, crmCustomerId });
      
      if (!customerId && !crmCustomerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }
      
      // Use CRM customer ID if available, otherwise use legacy customer ID
      const finalCustomerId = crmCustomerId || customerId;
      console.log('ðŸ” [CUSTOMER ORDERS] Using customer ID:', finalCustomerId);

      // Get regular orders
      const orders = await customerStorage.getOrdersByCustomer(finalCustomerId);
      
      // Get detailed order information with items
      const detailedOrders = await Promise.all(
        orders.map(async (order) => {
          const items = await customerStorage.getOrderItems(order.id);
          return {
            ...order,
            items,
            orderType: 'regular'
          };
        })
      );

      // Get grace period orders and all customer orders for this customer
      const { pool } = await import('./db');
      
      // Get all orders for this customer from customer_orders table
      // Include both temporary orders (before financial approval) and regular orders (after conversion)
      const allOrdersResult = await pool.query(`
        SELECT 
          co.id,
          co.order_number,
          co.customer_id,
          co.total_amount,
          co.status,
          co.currency,
          co.payment_status,
          co.payment_method,
          co.guest_name,
          co.guest_email,
          co.recipient_phone,
          co.recipient_name,
          co.recipient_address,
          co.created_at,
          co.updated_at,
          om.payment_grace_period_start,
          om.payment_grace_period_end,
          om.is_order_locked,
          om.current_status,
          om.financial_reviewed_at,
          EXTRACT(EPOCH FROM (om.payment_grace_period_end - NOW()))/3600 as hours_remaining,
          CASE 
            WHEN om.payment_grace_period_end > NOW() THEN 'active'
            ELSE 'expired'
          END as grace_period_status,
          CASE 
            WHEN om.payment_grace_period_start IS NOT NULL AND om.financial_reviewed_at IS NULL THEN 'temporary'
            WHEN om.financial_reviewed_at IS NOT NULL THEN 'regular'
            ELSE 'regular'
          END as order_category
        FROM customer_orders co
        LEFT JOIN order_management om ON om.customer_order_id = co.id
        WHERE co.customer_id = $1
        ORDER BY co.created_at DESC
      `, [finalCustomerId]);
      
      // Get order items for each order
      const allOrdersWithItems = await Promise.all(
        allOrdersResult.rows.map(async (order: any) => {
          const itemsResult = await pool.query(`
            SELECT 
              oi.id,
              oi.product_id,
              oi.quantity,
              oi.unit_price,
              oi.total_price,
              p.name as product_name,
              p.sku,
              p.category
            FROM order_items oi
            LEFT JOIN shop_products p ON oi.product_id = p.id
            WHERE oi.order_id = $1
          `, [order.id]);
          
          return {
            ...order,
            items: itemsResult.rows
          };
        })
      );

      // Format customer orders to match regular order structure
      const customerOrders = allOrdersWithItems.map((row: any) => ({
        id: row.id,
        orderNumber: row.order_number,
        status: row.status,
        totalAmount: row.total_amount,
        currency: row.currency,
        paymentStatus: row.payment_status,
        paymentMethod: row.payment_method,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        items: row.items || [],
        orderType: row.order_category, // 'temporary' or 'regular'
        orderCategory: row.order_category, // New field for order classification
        currentStatus: row.current_status, // Current order status in workflow
        financiallyApproved: row.financial_reviewed_at !== null,
        gracePeriodExpires: row.payment_grace_period_end,
        gracePeriodStatus: row.grace_period_status,
        hoursRemaining: Math.max(0, Math.floor(row.hours_remaining || 0)),
        isOrderLocked: row.is_order_locked,
        paymentGracePeriodStart: row.payment_grace_period_start,
        paymentGracePeriodEnd: row.payment_grace_period_end,
        customerName: row.guest_name,
        customerEmail: row.guest_email,
        customerPhone: row.recipient_phone,
        recipientName: row.recipient_name,
        recipientAddress: row.recipient_address
      }));

      // Remove duplicate orders and combine all orders
      const allOrders = [...customerOrders].sort((a, b) => 
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );

      res.json({
        success: true,
        orders: allOrders,
      });
    } catch (error) {
      console.error("Error getting customer orders:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª"
      });
    }
  });

  // Activate grace period order (continue with order after uploading receipt)
  app.post("/api/customers/orders/:orderId/activate-grace-period", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" 
        });
      }

      const { orderId } = req.params;
      const { pool } = await import('./db');

      // Check if this is a valid grace period order for this customer
      const checkResult = await pool.query(`
        SELECT om.*, co.guest_email, co.customer_id
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE om.customer_order_id = $1 
          AND om.current_status = 'payment_grace_period'
          AND om.payment_grace_period_end > NOW()
          AND (co.guest_email = (
            SELECT email FROM crm_customers WHERE id = $2
          ) OR co.customer_id = $2)
      `, [orderId, customerId]);

      if (checkResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª"
        });
      }

      // Update order status to continue processing
      const updateResult = await pool.query(`
        UPDATE order_management 
        SET 
          current_status = 'financial_pending',
          is_order_locked = false,
          updated_at = NOW()
        WHERE customer_order_id = $1
        RETURNING *
      `, [orderId]);

      if (updateResult.rows.length === 0) {
        return res.status(500).json({
          success: false,
          message: "Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÙØ§Ø±Ø´"
        });
      }

      res.json({
        success: true,
        message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙØ¹Ø§Ù„ Ø´Ø¯ Ùˆ ÙˆØ§Ø±Ø¯ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø§Ù„ÛŒ Ø´Ø¯",
        order: updateResult.rows[0]
      });

    } catch (error) {
      console.error("Error activating grace period order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª"
      });
    }
  });

  // Reset admin password (development only)
  app.post("/api/admin/reset-password-dev", async (req, res) => {
    try {
      const { username, newPassword } = req.body;
      
      if (!username || !newPassword) {
        return res.status(400).json({
          success: false,
          message: "Username and new password required"
        });
      }

      const hashedPassword = await bcrypt.hash(newPassword, 12);
      
      const { pool } = await import('./db');
      const result = await pool.query(
        'UPDATE users SET password_hash = $1 WHERE username = $2 RETURNING id, username',
        [hashedPassword, username]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }

      res.json({
        success: true,
        message: "Password updated successfully"
      });

    } catch (error) {
      console.error("Error resetting admin password:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // Customer password reset - Request reset
  app.post("/api/customers/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({
          success: false,
          message: "Email is required"
        });
      }

      // Check if customer exists
      const customer = await customerStorage.getCustomerByEmail(email);
      if (!customer) {
        // Don't reveal if email exists or not for security
        return res.json({
          success: true,
          message: "If the email is valid, password reset link has been sent"
        });
      }

      // Generate reset token
      const token = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      const expiresAt = new Date(Date.now() + 3600000); // 1 hour

      const { pool } = await import('./db');
      
      // Clear any existing tokens for this email
      await pool.query('DELETE FROM password_resets WHERE email = $1', [email]);
      
      // Insert new reset token
      await pool.query(
        'INSERT INTO password_resets (email, token, expires_at, used, created_at) VALUES ($1, $2, $3, false, NOW())',
        [email, token, expiresAt]
      );

      // Send password reset email
      const { sendPasswordResetEmail } = await import('./email');
      await sendPasswordResetEmail({
        email,
        firstName: customer?.firstName,
        lastName: customer?.lastName,
        token
      }, req);

      res.json({
        success: true,
        message: "Password reset link sent to your email"
      });

    } catch (error) {
      console.error("Error in forgot password:", error);
      res.status(500).json({
        success: false,
        message: "Error in password reset request"
      });
    }
  });

  // Customer password reset - Reset with token
  app.post("/api/customers/reset-password", async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      
      if (!token || !newPassword) {
        return res.status(400).json({
          success: false,
          message: "Token and new password are required"
        });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({
          success: false,
          message: "Password must be at least 6 characters"
        });
      }

      const { pool } = await import('./db');
      
      // Check if token is valid and not expired
      const tokenResult = await pool.query(
        'SELECT email FROM password_resets WHERE token = $1 AND expires_at > NOW() AND used = false',
        [token]
      );

      if (tokenResult.rows.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Invalid or expired token"
        });
      }

      const email = tokenResult.rows[0].email;
      
      // Get customer
      const customer = await customerStorage.getCustomerByEmail(email);
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Customer not found"
        });
      }

      // Update password
      await customerStorage.updateCustomerPassword(customer.id, newPassword);
      
      // Mark token as used AND delete all tokens for this email to prevent reuse
      await pool.query('DELETE FROM password_resets WHERE email = $1', [email]);
      
      console.log(`âœ… Password reset completed for customer: ${email}`);

      res.json({
        success: true,
        message: "Password successfully changed"
      });

    } catch (error) {
      console.error("Error in reset password:", error);
      res.status(500).json({
        success: false,
        message: "Error changing password"
      });
    }
  });

  // Get procedure documents
  app.get("/api/procedures/:procedureId/documents", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT d.id, d.procedure_id, d.outline_id, d.title, d.description, d.file_name, 
               d.file_path, d.file_size, d.file_type, d.upload_date, d.uploaded_by, 
               d.version, d.is_active, d.download_count, d.last_downloaded_at, d.tags,
               u.username as uploaded_by_name,
               o.title as outline_title
        FROM procedure_documents d
        LEFT JOIN users u ON d.uploaded_by = u.id
        LEFT JOIN procedure_outlines o ON d.outline_id = o.id
        WHERE d.procedure_id = $1 AND d.is_active = true
        ORDER BY d.upload_date DESC
      `, [procedureId]);
      
      const documents = result.rows.map((row: any) => ({
        id: row.id,
        procedureId: row.procedure_id,
        outlineId: row.outline_id,
        title: row.title || 'Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†',
        description: row.description,
        fileName: row.file_name || 'ÙØ§ÛŒÙ„ Ù†Ø§Ù…Ø´Ø®Øµ',
        filePath: row.file_path,
        fileSize: row.file_size || 0,
        fileType: row.file_type || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        uploadDate: row.upload_date,
        uploadedBy: row.uploaded_by,
        uploadedByName: row.uploaded_by_name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
        version: row.version || '1.0',
        isActive: row.is_active,
        downloadCount: row.download_count || 0,
        lastDownloadedAt: row.last_downloaded_at,
        tags: row.tags || [],
        outlineTitle: row.outline_title
      }));

      res.json(documents);
    } catch (error) {
      console.error("Error fetching procedure documents:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Upload procedure document
  app.post("/api/procedures/:procedureId/documents", requireAuth, (req, res, next) => {
    upload.single('document')(req, res, (err) => {
      if (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
      next();
    });
  }, async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, message: "No file uploaded" });
      }

      const { procedureId } = req.params;
      const { title, description, outlineId, version, tags } = req.body;
      const userId = (req.session as any)?.adminId;
      
      // Process tags
      const tagsArray = tags ? tags.split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag.length > 0) : [];
      
      const { pool } = await import('./db');
      const result = await pool.query(`
        INSERT INTO procedure_documents (
          procedure_id, outline_id, title, description, file_name, 
          file_path, file_size, file_type, uploaded_by, version, tags,
          upload_date, is_active, download_count
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, COALESCE($10, '1.0'), $11, NOW(), true, 0)
        RETURNING id, title, file_name, upload_date, version
      `, [
        procedureId, 
        outlineId || null, 
        title || req.file.originalname, 
        description || null, 
        req.file.originalname, 
        req.file.path, 
        req.file.size, 
        req.file.mimetype, 
        userId, 
        version || '1.0', 
        tagsArray
      ]);

      res.json({
        success: true,
        document: result.rows[0],
        message: "Document uploaded successfully"
      });
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Download procedure document
  app.get("/api/procedures/documents/:documentId/download", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info
      const docResult = await pool.query(`
        SELECT file_path, file_name, file_type
        FROM procedure_documents
        WHERE id = $1 AND is_active = true
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Update download count
      await pool.query(`
        UPDATE procedure_documents 
        SET download_count = download_count + 1, last_downloaded_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Handle both absolute and relative paths
      let filePath = document.file_path;
      if (!path.isAbsolute(filePath)) {
        filePath = path.resolve(process.cwd(), filePath);
      }

      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ success: false, message: "File not found on server" });
      }

      res.setHeader('Content-Disposition', `attachment; filename="${document.file_name}"`);
      res.setHeader('Content-Type', document.file_type || 'application/octet-stream');
      
      res.sendFile(filePath);

    } catch (error) {
      console.error("Error downloading document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Upload procedure document
  app.post("/api/procedures/:procedureId/documents", requireAuth, upload.single('document'), async (req, res) => {
    try {
      const { procedureId } = req.params;
      const { title, description } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ success: false, message: "No file uploaded" });
      }

      const { pool } = await import('./db');
      
      const result = await pool.query(`
        INSERT INTO procedure_documents (
          procedure_id, title, description, file_name, file_path, 
          file_size, file_type, upload_date, uploaded_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), $8)
        RETURNING *
      `, [
        procedureId,
        title || file.originalname,
        description || null,
        file.originalname,
        file.path,
        file.size,
        file.mimetype,
        req.session.adminId
      ]);

      res.json({ 
        success: true, 
        message: "Document uploaded successfully",
        document: result.rows[0] 
      });

    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Delete procedure document
  app.delete("/api/procedures/documents/:documentId", requireAuth, async (req, res) => {
    try {
      const { documentId } = req.params;
      
      const { pool } = await import('./db');
      
      // Get document info before deletion
      const docResult = await pool.query(`
        SELECT file_path, file_name
        FROM procedure_documents
        WHERE id = $1 AND is_active = true
      `, [documentId]);

      if (docResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Document not found" });
      }

      const document = docResult.rows[0];

      // Mark document as inactive (soft delete)
      await pool.query(`
        UPDATE procedure_documents 
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
      `, [documentId]);

      // Optionally delete the physical file
      try {
        let filePath = document.file_path;
        if (!path.isAbsolute(filePath)) {
          filePath = path.resolve(process.cwd(), filePath);
        }
        
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      } catch (fileError) {
        console.log('Could not delete physical file:', fileError);
        // Continue even if file deletion fails
      }

      res.json({
        success: true,
        message: "Document deleted successfully"
      });

    } catch (error) {
      console.error("Error deleting document:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Generate procedure text document
  app.get("/api/procedures/:procedureId/export", requireAuth, async (req, res) => {
    try {
      const { procedureId } = req.params;
      const { pool } = await import('./db');
      
      // Get procedure details
      const procedureResult = await pool.query(`
        SELECT p.id, p.title, p.description, p.content, p.version, p.status, p.priority, 
               p.created_at, c.name as category_name
        FROM procedures p
        LEFT JOIN procedure_categories c ON p.category_id = c.id
        WHERE p.id = $1
      `, [procedureId]);

      if (procedureResult.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Procedure not found" });
      }

      const procedure = procedureResult.rows[0];

      // Generate simple text content
      const textContent = `Ø¯Ø³ØªÙˆØ±Ø§Ù„Ø¹Ù…Ù„: ${procedure.title}
Ù†Ø³Ø®Ù‡: ${procedure.version}
ÙˆØ¶Ø¹ÛŒØª: ${procedure.status}
Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: ${procedure.category_name || 'Ù†Ø§Ù…Ø´Ø®Øµ'}

ØªÙˆØ¶ÛŒØ­Ø§Øª:
${procedure.description || 'Ù†Ø¯Ø§Ø±Ø¯'}

Ù…Ø­ØªÙˆØ§:
${procedure.content}

ØªØ§Ø±ÛŒØ® ØªÙˆÙ„ÛŒØ¯: ${new Date().toLocaleDateString('en-US', {
  year: 'numeric',
  month: 'short',
  day: 'numeric'
})}
`;

      res.setHeader('Content-Type', 'text/plain; charset=utf-8');
      res.setHeader('Content-Disposition', 'attachment; filename=procedure-export.txt');
      res.send(textContent);

    } catch (error) {
      console.error("Error exporting procedure:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get database statistics
  app.get("/api/admin/database/stats", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get actual row counts for major tables
      const getTableCount = async (tableName: string) => {
        try {
          const result = await pool.query(`SELECT COUNT(*) FROM ${tableName}`);
          return parseInt(result.rows[0].count);
        } catch {
          return 0;
        }
      };

      // Get table sizes and statistics
      const tableStats = await pool.query(`
        SELECT 
          t.table_name as tablename,
          COALESCE(s.n_tup_ins, 0) as total_inserts,
          COALESCE(s.n_tup_upd, 0) as total_updates,
          COALESCE(s.n_tup_del, 0) as total_deletes,
          COALESCE(s.n_live_tup, 0) as live_rows,
          pg_size_pretty(pg_total_relation_size(c.oid)) as table_size,
          pg_total_relation_size(c.oid) as size_bytes
        FROM information_schema.tables t
        LEFT JOIN pg_stat_user_tables s ON s.relname = t.table_name
        LEFT JOIN pg_class c ON c.relname = t.table_name
        WHERE t.table_schema = 'public' 
          AND t.table_type = 'BASE TABLE'
        ORDER BY pg_total_relation_size(c.oid) DESC
        LIMIT 20;
      `);

      // Get actual counts for important tables
      const importantTables = ['users', 'products', 'showcase_products', 'shop_products', 'orders', 'crm_customers', 'customer_orders'];
      const tableStatsWithCounts = await Promise.all(
        tableStats.rows.map(async (table) => {
          let actualCount = table.live_rows;
          if (importantTables.includes(table.tablename)) {
            actualCount = await getTableCount(table.tablename);
          }
          return {
            ...table,
            live_rows: actualCount,
            actual_count: actualCount
          };
        })
      );
      
      const dbSize = await pool.query(`
        SELECT pg_size_pretty(pg_database_size(current_database())) as database_size;
      `);
      
      const tableCount = await pool.query(`
        SELECT COUNT(*) as table_count 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
      `);

      // Get total records across all main tables
      const totalRecords = await Promise.all([
        getTableCount('users'),
        getTableCount('products'),
        getTableCount('showcase_products'),
        getTableCount('shop_products'),
        getTableCount('orders'),
        getTableCount('customer_orders'),
        getTableCount('crm_customers'),
        getTableCount('leads'),
        getTableCount('customer_inquiries')
      ]);

      const sumRecords = totalRecords.reduce((sum, count) => sum + count, 0);
      
      res.json({
        database_size: dbSize.rows[0].database_size,
        table_count: parseInt(tableCount.rows[0].table_count),
        total_records: sumRecords,
        table_stats: tableStatsWithCounts.sort((a, b) => b.actual_count - a.actual_count)
      });
    } catch (error) {
      console.error("Error getting database stats:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get detailed inventory with batch information for all products
  app.get("/api/inventory/detailed-with-batches", requireAuth, async (req, res) => {
    try {
      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const detailedInventory = await UnifiedInventoryManager.getDetailedInventoryWithBatches();
      
      res.json({
        success: true,
        data: detailedInventory,
        message: `Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ${detailedInventory.length} Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨Ú† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error fetching detailed inventory with batches:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø§ Ø¨Ú†" });
    }
  });

  // Create inventory transaction and update stock
  app.post("/api/inventory/transaction", requireAuth, async (req, res) => {
    try {
      const { productId, transactionType, quantity, reason, reference, scannedBarcode } = req.body;
      
      // Get current product
      const product = await shopStorage.getShopProductById(productId);
      if (!product) {
        return res.status(404).json({ 
          success: false, 
          message: "Product not found" 
        });
      }
      
      const previousStock = product.stockQuantity || 0;
      let newStock;
      
      if (transactionType === 'in') {
        newStock = previousStock + Math.abs(quantity);
      } else if (transactionType === 'out') {
        newStock = Math.max(0, previousStock - Math.abs(quantity));
      } else if (transactionType === 'audit') {
        newStock = Math.abs(quantity);
      } else {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid transaction type" 
        });
      }
      
      // Update product stock
      await shopStorage.updateShopProduct(productId, { stockQuantity: newStock });
      
      // Log transaction
      console.log('Inventory transaction:', {
        productId,
        transactionType,
        quantity,
        previousStock,
        newStock,
        reason,
        reference,
        scannedBarcode,
        userId: req.session.adminId,
        timestamp: new Date().toISOString()
      });
      
      res.json({
        success: true,
        previousStock,
        newStock,
        quantity: transactionType === 'out' ? -Math.abs(quantity) : Math.abs(quantity)
      });
    } catch (error) {
      console.error("Error creating inventory transaction:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Get mock inventory transactions for now
  app.get("/api/inventory/transactions", requireAuth, async (req, res) => {
    try {
      // Return empty array for now - can be extended with actual transaction storage
      res.json([]);
    } catch (error) {
      console.error("Error fetching inventory transactions:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Product inquiry routes
  app.post("/api/inquiries", async (req, res) => {
    try {
      const inquiryData = insertCustomerInquirySchema.parse(req.body);
      const inquiry = await simpleCustomerStorage.createInquiry(inquiryData);
      
      // Send email notification for the inquiry
      try {
        // Get product name for email
        let productName = 'Product';
        if (inquiryData.productIds && Array.isArray(inquiryData.productIds) && inquiryData.productIds.length > 0) {
          const product = await shopStorage.getShopProductById(inquiryData.productIds[0]);
          if (product) {
            productName = product.name;
          }
        }

        // Data for Universal Email Service
        const emailData = {
          contactEmail: inquiryData.contactEmail,
          contactPhone: inquiryData.contactPhone,
          company: inquiryData.company,
          subject: inquiryData.subject,
          message: inquiryData.message,
          type: inquiryData.type,
          priority: inquiryData.priority || 'normal',
          category: inquiryData.category || 'general',
          productName: productName,
          inquiryNumber: inquiry.inquiryNumber,
        };

        // Send inquiry email using Universal Email Service
        const { UniversalEmailService } = await import('./universal-email-service');
        
        // Map inquiry category to email category
        const categoryMap: { [key: string]: string } = {
          'fuel-additives': 'fuel-additives',
          'water-treatment': 'water-treatment', 
          'paint-solvents': 'paint-thinner',
          'agricultural-products': 'agricultural-fertilizers',
          'agricultural-fertilizers': 'agricultural-fertilizers',
          'industrial-chemicals': 'admin',
          'paint-thinner': 'paint-thinner',
          'technical-equipment': 'admin',
          'commercial-goods': 'orders',
          'general': 'admin',
          'support': 'notifications'
        };
        
        const emailCategory = categoryMap[inquiryData.category] || 'admin';
        
        // Send admin notification email  
        await UniversalEmailService.sendEmail({
          categoryKey: emailCategory,
          to: [],
          cc: ['info@momtazchem.com'],
          subject: `New Product Inquiry: ${inquiryData.subject || 'General Inquiry'}`,
          html: `
            <h2>New Product Inquiry</h2>
            <p><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
            <p><strong>Product:</strong> ${productName || 'General'}</p>
            <p><strong>Contact Email:</strong> ${inquiryData.contactEmail}</p>
            <p><strong>Contact Phone:</strong> ${inquiryData.contactPhone || 'Not provided'}</p>
            <p><strong>Company:</strong> ${inquiryData.company || 'Not provided'}</p>
            <p><strong>Category:</strong> ${inquiryData.category}</p>
            <p><strong>Type:</strong> ${inquiryData.type}</p>
            <p><strong>Priority:</strong> ${inquiryData.priority}</p>
            <p><strong>Message:</strong></p>
            <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px;">
              ${(inquiryData.message || '').replace(/\n/g, '<br>')}
            </div>
            <hr>
            <p style="color: #d32f2f; font-weight: bold;">â° Response Required: Within 24 hours</p>
          `,
          variables: {
            inquiryNumber: inquiry.inquiryNumber,
            productName: productName || 'General',
            contactEmail: inquiryData.contactEmail,
            contactPhone: inquiryData.contactPhone || 'Not provided',
            company: inquiryData.company || 'Not provided',
            category: inquiryData.category,
            type: inquiryData.type,
            priority: inquiryData.priority,
            message: inquiryData.message || ''
          }
        });
        
        console.log(`Admin inquiry notification sent via Universal Email Service for category: ${inquiryData.category} â†’ ${emailCategory}`);

        // Send confirmation email to customer using Template #05 - Follow-up Response
        try {
          const { emailStorage } = await import('./email-storage');
          const followUpTemplate = await emailStorage.getTemplateByNumber('#05');
          
          if (followUpTemplate) {
            console.log(`ðŸ“§ Using Template #05 - ${followUpTemplate.templateName}`);
            
            const templateVariables = {
              customer_name: inquiryData.contactEmail.split('@')[0] || 'Valued Customer',
              inquiry_number: inquiry.inquiryNumber,
              inquiry_subject: inquiryData.subject || 'General Inquiry',
              inquiry_category: inquiryData.category || 'general',
              customer_message: inquiryData.message || 'No specific message provided',
              response_text: `Dear ${inquiryData.contactEmail.split('@')[0] || 'Customer'},

Thank you for your inquiry about our ${inquiryData.category || 'chemical products'}. We are pleased to provide you with detailed information about this product. 

Our technical team has reviewed your requirements and will send you a comprehensive quote including pricing, specifications, and availability within 24 hours. 

If you need immediate assistance or have specific technical questions, please feel free to contact us directly.

Best regards,
Momtaz Chemical Technical Team`,
              contact_phone: '+964 770 999 6771',
              contact_email: 'info@momtazchem.com'
            };

            // Process template content with variables
            let processedHtml = followUpTemplate.htmlContent;
            let processedSubject = followUpTemplate.subject;
            
            for (const [key, value] of Object.entries(templateVariables)) {
              const placeholder = `{{${key}}}`;
              processedHtml = processedHtml.replace(new RegExp(placeholder, 'g'), value);
              processedSubject = processedSubject.replace(new RegExp(placeholder, 'g'), value);
            }

            await UniversalEmailService.sendEmail({
              categoryKey: 'notifications',
              to: [inquiryData.contactEmail],
              subject: processedSubject,
              html: processedHtml,
              templateNumber: '#05',
              variables: templateVariables
            });
            
            console.log(`âœ… Follow-up email sent using Template #05 to: ${inquiryData.contactEmail}`);
          } else {
            console.warn(`âš ï¸ Template #05 not found, using fallback template`);
            // Fallback to hardcoded template
            await UniversalEmailService.sendEmail({
              categoryKey: 'notifications',
              to: [inquiryData.contactEmail],
              cc: [],
              subject: `Inquiry Confirmation - ${inquiry.inquiryNumber}`,
              html: `
              <div style="font-family: 'Arial', 'Helvetica', sans-serif; max-width: 600px; margin: 0 auto; background: #ffffff; padding: 30px; border: 1px solid #e0e0e0; border-radius: 8px;">
                
                <div style="text-align: center; margin-bottom: 30px;">
                  <h1 style="color: #2c3e50; font-size: 24px; font-weight: bold; margin: 0;">Momtaz Chemical Solutions</h1>
                  <p style="color: #7f8c8d; font-size: 14px; margin: 5px 0 0 0;">Ø´Ø±Ú©Øª Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ</p>
                </div>
                
                <p style="color: #2c3e50; font-size: 16px; line-height: 1.6; margin: 0 0 20px 0;">
                  Dear Valued Customer,
                </p>
                
                <p style="color: #2c3e50; font-size: 16px; line-height: 1.6; margin: 0 0 25px 0;">
                  Thank you for your inquiry. We have prepared a follow-up response regarding your request:
                </p>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 6px; margin: 25px 0; border-left: 4px solid #3498db;">
                  <h3 style="color: #2c3e50; font-size: 16px; font-weight: bold; margin: 0 0 15px 0;">Your Original Inquiry:</h3>
                  <p style="margin: 8px 0; color: #34495e; font-size: 14px;"><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
                  <p style="margin: 8px 0; color: #34495e; font-size: 14px;"><strong>Subject:</strong> ${inquiryData.subject || 'General Inquiry'}</p>
                  <p style="margin: 8px 0; color: #34495e; font-size: 14px;"><strong>Category:</strong> ${inquiryData.category || 'General'}</p>
                  
                  <hr style="border: none; height: 1px; background: linear-gradient(to right, #3498db, #e74c3c, #3498db); margin: 15px 0;">
                  
                  <div style="background: #ffffff; padding: 15px; border-radius: 4px; border: 1px solid #ddd;">
                    <h4 style="color: #2c3e50; font-size: 14px; font-weight: bold; margin: 0 0 10px 0;">Your Message:</h4>
                    <p style="color: #555; font-size: 14px; line-height: 1.6; margin: 0; font-style: italic;">
                      "${inquiryData.message || 'No specific message provided'}"
                    </p>
                  </div>
                </div>
                
                <div style="background: #e8f4fd; padding: 20px; border-radius: 6px; margin: 25px 0; border-left: 4px solid #27ae60;">
                  <h3 style="color: #2c3e50; font-size: 16px; font-weight: bold; margin: 0 0 15px 0;">Our Response:</h3>
                  
                  <hr style="border: none; height: 2px; background: linear-gradient(to right, #27ae60, #3498db, #27ae60); margin: 15px 0;">
                  
                  <div style="background: #ffffff; padding: 18px; border-radius: 4px; border: 1px solid #27ae60; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <p style="color: #2c3e50; font-size: 15px; line-height: 1.6; margin: 0;">
                      Thank you for your inquiry about our <strong>${productName || 'chemical products'}</strong>. We are pleased to provide you with detailed information about this product. Our technical team has reviewed your requirements and will send you a comprehensive quote including pricing, specifications, and availability within <strong>24 hours</strong>. Please feel free to contact us if you have any additional questions.
                    </p>
                  </div>
                </div>
                
                <div style="background: #fff3cd; padding: 20px; border-radius: 6px; margin: 25px 0; border-left: 4px solid #f39c12;">
                  <h3 style="color: #2c3e50; font-size: 16px; font-weight: bold; margin: 0 0 15px 0;">Need Further Assistance?</h3>
                  <p style="color: #2c3e50; font-size: 14px; line-height: 1.6; margin: 0 0 15px 0;">
                    If you have any additional questions or need clarification, please don't hesitate to contact us:
                  </p>
                  <p style="margin: 5px 0; color: #2c3e50; font-size: 14px;"><strong>Email:</strong> info@momtazchem.com</p>
                  <p style="margin: 5px 0; color: #2c3e50; font-size: 14px;"><strong>Phone:</strong> +964 770 999 6771</p>
                  <p style="margin: 5px 0; color: #2c3e50; font-size: 14px;"><strong>Website:</strong> www.momtazchem.com</p>
                </div>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ecf0f1;">
                  <p style="color: #2c3e50; font-size: 16px; line-height: 1.6; margin: 0 0 10px 0;">
                    Best regards,
                  </p>
                  <p style="color: #3498db; font-size: 16px; font-weight: bold; margin: 0 0 5px 0;">
                    Momtaz Chemical Team
                  </p>
                  <p style="color: #7f8c8d; font-size: 14px; margin: 0;">
                    Leading Chemical Solutions Provider
                  </p>
                </div>
                
                <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ecf0f1;">
                  <p style="color: #95a5a6; font-size: 12px; margin: 0;">
                    Â© 2025 Momtaz Chemical Solutions. All rights reserved.
                  </p>
                </div>
              </div>
            `
            });
            
            console.log(`âœ… Customer confirmation email sent to: ${inquiryData.contactEmail} (using fallback)`);
          }
        } catch (customerEmailError) {
          console.error("âŒ Failed to send customer confirmation email:", customerEmailError);
        }
      } catch (emailError) {
        console.error("Failed to send inquiry email:", emailError);
        // Don't fail the inquiry creation if email fails
      }

      // Auto-capture customer data in CRM system
      try {
        // Check if customer exists in CRM
        let existingCustomer = null;
        if (inquiryData.contactEmail) {
          existingCustomer = await crmStorage.getCrmCustomerByEmail(inquiryData.contactEmail);
        }

        if (existingCustomer) {
          // Log inquiry activity for existing customer
          await crmStorage.logCustomerActivity({
            customerId: existingCustomer.id,
            activityType: 'product_inquiry',
            description: `Product inquiry: ${inquiryData.subject || 'General inquiry'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_product_inquiry',
              inquiryType: inquiryData.type,
              category: inquiryData.category,
              priority: inquiryData.priority,
              productName: 'General',
              inquiryNumber: inquiry.inquiryNumber,
              message: inquiryData.message
            }
          });
          console.log(`âœ… Product inquiry logged to existing CRM customer: ${inquiryData.contactEmail}`);
        } else {
          // Create new CRM customer from inquiry
          const newCrmCustomer = await crmStorage.createCrmCustomer({
            email: inquiryData.contactEmail,
            firstName: (inquiryData.contactEmail.split('@')[0] || 'Customer').split('.')[0],
            lastName: '',
            company: inquiryData.company || null,
            phone: inquiryData.contactPhone || null,
            customerType: 'prospect',
            customerSource: 'website_inquiry',
            isActive: true,
            passwordHash: '', // Will be set when customer creates account
          });

          // Log initial inquiry activity
          await crmStorage.logCustomerActivity({
            customerId: newCrmCustomer.id,
            activityType: 'first_contact',
            description: `First contact via product inquiry: ${inquiryData.subject || 'General inquiry'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_product_inquiry',
              inquiryType: inquiryData.type,
              category: inquiryData.category,
              priority: inquiryData.priority,
              productName: 'General',
              inquiryNumber: inquiry.inquiryNumber,
              message: inquiryData.message
            }
          });
          console.log(`âœ… New CRM customer created from product inquiry: ${inquiryData.contactEmail}`);
        }
      } catch (crmError) {
        console.error("âŒ Error auto-capturing customer in CRM from product inquiry:", crmError);
        // Don't fail the inquiry if CRM capture fails
      }
      
      res.status(201).json({ 
        success: true, 
        message: "Inquiry submitted successfully",
        inquiry 
      });
    } catch (error) {
      console.error("Error creating inquiry:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid inquiry data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });



  app.patch("/api/inquiries/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid inquiry ID" 
        });
      }

      const updates = req.body;
      const inquiry = await simpleCustomerStorage.updateInquiry(id, updates);
      res.json({ 
        success: true, 
        message: "Inquiry updated successfully",
        inquiry 
      });
    } catch (error) {
      console.error("Error updating inquiry:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // CRM Lead management routes
  app.post("/api/leads", requireAuth, async (req, res) => {
    try {
      console.log('Creating lead with data:', req.body);
      const leadData = insertLeadSchema.parse(req.body);
      console.log('Parsed lead data:', leadData);
      const lead = await storage.createLead(leadData);
      res.status(201).json(lead);
    } catch (error) {
      console.error('Lead creation error:', error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid lead data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  });

  app.get("/api/leads", requireAuth, async (req, res) => {
    try {
      const { status, priority, assignedTo, search } = req.query;
      const filters = {
        status: status as string,
        priority: priority as string,
        assignedTo: assignedTo ? parseInt(assignedTo as string) : undefined,
        search: search as string,
      };
      
      const leads = await storage.getLeads(filters);
      res.json(leads);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/leads/statistics", requireAuth, async (req, res) => {
    try {
      const stats = await storage.getLeadStatistics();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/leads/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const lead = await storage.getLeadById(id);
      if (!lead) {
        return res.status(404).json({ 
          success: false, 
          message: "Lead not found" 
        });
      }

      res.json(lead);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.patch("/api/leads/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const leadData = insertLeadSchema.partial().parse(req.body);
      const lead = await storage.updateLead(id, leadData);
      res.json(lead);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid lead data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  app.delete("/api/leads/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      await storage.deleteLead(id);
      res.json({ success: true, message: "Lead deleted successfully" });
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Convert contact to lead
  app.post("/api/contacts/:id/convert-to-lead", requireAuth, async (req, res) => {
    try {
      const contactId = parseInt(req.params.id);
      if (isNaN(contactId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid contact ID" 
        });
      }

      const additionalData = req.body || {};
      const lead = await storage.convertContactToLead(contactId, additionalData);
      res.status(201).json(lead);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : "Internal server error" 
      });
    }
  });

  // Lead activities routes
  app.post("/api/leads/:leadId/activities", requireAuth, async (req, res) => {
    try {
      const leadId = parseInt(req.params.leadId);
      if (isNaN(leadId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const activityData = insertLeadActivitySchema.parse({
        ...req.body,
        leadId,
        createdBy: req.session.adminId
      });
      
      const activity = await storage.createLeadActivity(activityData);
      res.status(201).json(activity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid activity data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  app.get("/api/leads/:leadId/activities", requireAuth, async (req, res) => {
    try {
      const leadId = parseInt(req.params.leadId);
      if (isNaN(leadId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid lead ID" 
        });
      }

      const activities = await storage.getLeadActivities(leadId);
      res.json(activities);
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Shop/E-commerce API endpoints - Inventory-based product management
  app.get("/api/shop/products", async (req, res) => {
    try {
      const products = await shopStorage.getShopProducts();
      
      // Map database fields to frontend expected format
      const mappedProducts = products.map(product => ({
        ...product,
        imageUrl: product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls[0] : null,
        unitPrice: product.price,
        currency: (product.priceUnit === 'IQD' || !product.priceUnit || product.priceUnit === 'unit') ? 'IQD' : product.priceUnit,
        weight: product.weight,
        weightUnit: product.weightUnit
      }));
      
      res.json(mappedProducts);
    } catch (error) {
      console.error("Error fetching shop products:", error);
      res.status(500).json({ success: false, message: "Failed to fetch products" });
    }
  });

  app.get("/api/shop/categories", async (req, res) => {
    try {
      const categories = await shopStorage.getShopCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching shop categories:", error);
      res.status(500).json({ success: false, message: "Failed to fetch categories" });
    }
  });

  app.get("/api/shop/products/:id", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      const product = await shopStorage.getShopProductById(productId);
      if (!product) {
        return res.status(404).json({ success: false, message: "Product not found" });
      }
      
      // Map database fields to frontend expected format
      const mappedProduct = {
        ...product,
        imageUrl: product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls[0] : null,
        unitPrice: product.price,
        currency: (product.priceUnit === 'IQD' || !product.priceUnit || product.priceUnit === 'unit') ? 'IQD' : product.priceUnit,
        weight: product.weight,
        weightUnit: product.weightUnit
      };
      
      res.json(mappedProduct);
    } catch (error) {
      console.error("Error fetching shop product:", error);
      res.status(500).json({ success: false, message: "Failed to fetch product" });
    }
  });

  app.post("/api/shop/products", requireAuth, async (req, res) => {
    try {
      const productData = insertShopProductSchema.parse(req.body);
      const product = await shopStorage.createShopProduct(productData);
      res.json({ success: true, product });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid product data", 
          errors: error.errors 
        });
      } else {
        console.error("Error creating shop product:", error);
        res.status(500).json({ success: false, message: "Failed to create product" });
      }
    }
  });

  app.patch("/api/shop/products/:id", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      const updates = req.body;
      const product = await shopStorage.updateShopProduct(productId, updates);
      res.json(product);
    } catch (error) {
      console.error("Error updating shop product:", error);
      res.status(500).json({ success: false, message: "Failed to update product" });
    }
  });

  app.delete("/api/shop/products/:id", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      await shopStorage.deleteShopProduct(productId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting shop product:", error);
      res.status(500).json({ success: false, message: "Failed to delete product" });
    }
  });

  // Advanced shop product search
  app.get("/api/shop/search", async (req, res) => {
    try {
      const {
        q: query = '',
        category,
        priceMin,
        priceMax,
        inStock,
        tags,
        sortBy = 'relevance',
        sortOrder = 'desc',
        limit = 50,
        offset = 0
      } = req.query;

      const filters = {
        category: category as string,
        priceMin: priceMin ? parseFloat(priceMin as string) : undefined,
        priceMax: priceMax ? parseFloat(priceMax as string) : undefined,
        inStock: inStock ? inStock === 'true' : undefined,
        tags: tags ? (Array.isArray(tags) ? tags as string[] : [tags as string]) : undefined,
        sortBy: sortBy as 'name' | 'price' | 'created' | 'relevance',
        sortOrder: sortOrder as 'asc' | 'desc',
        limit: parseInt(limit as string) || 50,
        offset: parseInt(offset as string) || 0
      };

      const searchResults = await shopStorage.searchShopProducts(query as string, filters);
      
      // Map database fields to frontend expected format
      const mappedProducts = searchResults.products.map(product => ({
        ...product,
        imageUrl: product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls[0] : null,
        unitPrice: product.price,
        currency: (product.priceUnit === 'IQD' || !product.priceUnit || product.priceUnit === 'unit') ? 'IQD' : product.priceUnit,
        weight: product.weight,
        weightUnit: product.weightUnit
      }));
      
      res.json({
        success: true,
        data: {
          ...searchResults,
          products: mappedProducts
        },
        query: {
          searchTerm: query,
          filters: filters,
          pagination: {
            limit: filters.limit,
            offset: filters.offset,
            total: searchResults.total,
            pages: Math.ceil(searchResults.total / filters.limit)
          }
        }
      });
    } catch (error) {
      console.error("Error searching shop products:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to search products",
        error: error.message 
      });
    }
  });

  // Shop categories management
  app.post("/api/shop/categories", requireAuth, async (req, res) => {
    try {
      const categoryData = insertShopCategorySchema.parse(req.body);
      const category = await shopStorage.createShopCategory(categoryData);
      res.json({ success: true, category });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid category data", 
          errors: error.errors 
        });
      } else {
        console.error("Error creating shop category:", error);
        res.status(500).json({ success: false, message: "Failed to create category" });
      }
    }
  });

  app.patch("/api/shop/categories/:id", requireAuth, async (req, res) => {
    try {
      const categoryId = parseInt(req.params.id);
      if (isNaN(categoryId)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const updates = req.body;
      const category = await shopStorage.updateShopCategory(categoryId, updates);
      res.json(category);
    } catch (error) {
      console.error("Error updating shop category:", error);
      res.status(500).json({ success: false, message: "Failed to update category" });
    }
  });

  // Goods in Transit management endpoints
  app.get("/api/shop/goods-in-transit", async (req, res) => {
    try {
      const { status } = req.query;
      const goodsInTransit = await shopStorage.getGoodsInTransit(status as string);
      res.json(goodsInTransit);
    } catch (error) {
      console.error("Error fetching goods in transit:", error);
      res.status(500).json({ success: false, message: "Failed to fetch goods in transit" });
    }
  });

  app.get("/api/shop/inventory-movements", async (req, res) => {
    try {
      const { productId } = req.query;
      const movements = await shopStorage.getShopInventoryMovements(productId ? parseInt(productId as string) : undefined);
      res.json(movements);
    } catch (error) {
      console.error("Error fetching inventory movements:", error);
      res.status(500).json({ success: false, message: "Failed to fetch inventory movements" });
    }
  });

  app.post("/api/shop/goods-in-transit", requireAuth, async (req, res) => {
    try {
      const transitData = req.body;
      const newTransit = await shopStorage.createGoodsInTransit(transitData);
      res.json({ success: true, data: newTransit });
    } catch (error) {
      console.error("Error creating goods in transit:", error);
      res.status(500).json({ success: false, message: "Failed to create goods in transit" });
    }
  });

  app.patch("/api/shop/goods-in-transit/:id", requireAuth, async (req, res) => {
    try {
      const transitId = parseInt(req.params.id);
      if (isNaN(transitId)) {
        return res.status(400).json({ success: false, message: "Invalid transit ID" });
      }
      
      const updates = req.body;
      const updatedTransit = await shopStorage.updateGoodsInTransit(transitId, updates);
      res.json({ success: true, data: updatedTransit });
    } catch (error) {
      console.error("Error updating goods in transit:", error);
      res.status(500).json({ success: false, message: "Failed to update goods in transit" });
    }
  });

  // Inventory synchronization endpoints  
  app.post("/api/inventory/sync/force", async (req, res) => {
    try {
      const { InventorySyncManager } = await import("./inventory-sync-manager");
      await InventorySyncManager.forceBidirectionalSync();
      res.json({ success: true, message: "Bidirectional sync completed successfully" });
    } catch (error) {
      console.error("Error in force sync:", error);
      res.status(500).json({ success: false, message: "Failed to sync inventories" });
    }
  });

  // Unified inventory endpoint - single source of truth
  app.get("/api/inventory/unified/products", async (req, res) => {
    try {
      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const products = await UnifiedInventoryManager.getAllProductsWithInventory();
      res.json(products);
    } catch (error) {
      console.error("Error getting unified products:", error);
      res.status(500).json({ success: false, message: "Failed to get unified products" });
    }
  });

  // Get specific product inventory
  app.get("/api/products/:name/inventory", async (req, res) => {
    try {
      const productName = decodeURIComponent(req.params.name);
      const { UnifiedInventoryManager } = await import('./unified-inventory-manager');
      const inventory = await UnifiedInventoryManager.getProductInventory(productName);
      
      if (!inventory) {
        return res.status(404).json({ success: false, message: "Product not found" });
      }
      
      res.json({ success: true, inventory });
    } catch (error) {
      console.error("Error getting product inventory:", error);
      res.status(500).json({ success: false, message: "Failed to get product inventory" });
    }
  });

  app.post("/api/inventory/sync/product/:name", async (req, res) => {
    try {
      const productName = decodeURIComponent(req.params.name);
      const { InventorySyncManager } = await import("./inventory-sync-manager");
      await InventorySyncManager.syncProductByName(productName);
      res.json({ success: true, message: `Product ${productName} synchronized successfully` });
    } catch (error) {
      console.error("Error syncing product:", error);
      res.status(500).json({ success: false, message: "Failed to sync product" });
    }
  });

  // Inventory management endpoints
  app.get("/api/shop/inventory/:productId", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.productId);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }
      
      const transactions = await shopStorage.getShopInventoryMovements(productId);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching inventory transactions:", error);
      res.status(500).json({ success: false, message: "Failed to fetch inventory data" });
    }
  });

  app.post("/api/shop/inventory/update", requireAuth, async (req, res) => {
    try {
      const { productId, newQuantity, reason } = req.body;
      
      if (!productId || newQuantity === undefined || !reason) {
        return res.status(400).json({ 
          success: false, 
          message: "Missing required fields: productId, newQuantity, reason" 
        });
      }
      
      await shopStorage.updateProductStock(productId, newQuantity, reason);
      res.json({ success: true, message: "Inventory updated successfully" });
    } catch (error) {
      console.error("Error updating inventory:", error);
      res.status(500).json({ success: false, message: "Failed to update inventory" });
    }
  });

  // Order management endpoints - REMOVED DUPLICATE ENDPOINT TO PREVENT WALLET PAYMENT OVERRIDE

  app.get("/api/shop/orders", requireAuth, async (req, res) => {
    try {
      // Get customer orders from the customer_orders table
      const orders = await customerStorage.getAllOrders();
      
      // Get detailed order information with items and customer details
      const detailedOrders = await Promise.all(
        orders.map(async (order) => {
          const items = await customerStorage.getOrderItems(order.id);
          let customer = null;
          if (order.customerId) {
            customer = await customerStorage.getCustomerById(order.customerId);
          }
          return {
            ...order,
            items,
            customer,
            orderDate: order.createdAt, // Map for compatibility
            orderNumber: order.orderNumber,
            // Include shipping method information
            carrier: order.carrier,
            paymentMethod: order.paymentMethod,
          };
        })
      );

      res.json(detailedOrders);
    } catch (error) {
      console.error("Error fetching customer orders:", error);
      res.status(500).json({ success: false, message: "Failed to fetch customer orders" });
    }
  });

  app.get("/api/shop/orders/:id", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }
      
      const order = await shopStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Order not found" });
      }

      const orderItems = await shopStorage.getOrderItems(orderId);
      res.json({ ...order, items: orderItems });
    } catch (error) {
      console.error("Error fetching order:", error);
      res.status(500).json({ success: false, message: "Failed to fetch order" });
    }
  });

  app.patch("/api/shop/orders/:id", requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }
      
      const updates = req.body;
      const currentOrder = await customerStorage.getOrderById(orderId);
      
      if (!currentOrder) {
        return res.status(404).json({ success: false, message: "Order not found" });
      }
      
      // Update the customer order status
      const updatedOrder = await customerStorage.updateOrder(orderId, updates);
      
      res.json({
        success: true,
        message: "Order status updated successfully",
        order: updatedOrder
      });
    } catch (error) {
      console.error("Error updating customer order:", error);
      res.status(500).json({ success: false, message: "Failed to update customer order" });
    }
  });

  // Product Returns endpoints
  app.get("/api/shop/returns", requireAuth, async (req, res) => {
    try {
      const returns = await shopStorage.getProductReturns();
      res.json({ success: true, data: returns });
    } catch (error) {
      console.error("Error fetching product returns:", error);
      res.status(500).json({ success: false, message: "Failed to fetch product returns" });
    }
  });

  app.post("/api/shop/returns", requireAuth, async (req, res) => {
    try {
      const returnData = req.body;
      
      // Find customer by phone number
      const customer = await shopStorage.findCustomerByPhone(returnData.customerPhone);
      if (customer) {
        returnData.customerName = `${customer.firstName} ${customer.lastName}`;
      }
      
      // Get product information
      const product = await shopStorage.getShopProductById(returnData.productId);
      if (!product) {
        return res.status(404).json({ success: false, message: "Product not found" });
      }
      
      returnData.productName = product.name;
      returnData.productSku = product.sku;
      returnData.unitPrice = product.price;
      
      // Ensure returnDate is a proper Date object
      if (returnData.returnDate && typeof returnData.returnDate === 'string') {
        returnData.returnDate = new Date(returnData.returnDate);
      } else if (!returnData.returnDate) {
        returnData.returnDate = new Date();
      }
      
      const newReturn = await shopStorage.createProductReturn(returnData);
      res.json({ success: true, data: newReturn });
    } catch (error) {
      console.error("Error creating product return:", error);
      res.status(500).json({ success: false, message: "Failed to create product return" });
    }
  });

  app.get("/api/shop/returns/:id", requireAuth, async (req, res) => {
    try {
      const returnId = parseInt(req.params.id);
      if (isNaN(returnId)) {
        return res.status(400).json({ success: false, message: "Invalid return ID" });
      }
      
      const returnRecord = await shopStorage.getProductReturnById(returnId);
      if (!returnRecord) {
        return res.status(404).json({ success: false, message: "Return not found" });
      }
      
      res.json({ success: true, data: returnRecord });
    } catch (error) {
      console.error("Error fetching product return:", error);
      res.status(500).json({ success: false, message: "Failed to fetch product return" });
    }
  });

  app.patch("/api/shop/returns/:id", requireAuth, async (req, res) => {
    try {
      const returnId = parseInt(req.params.id);
      if (isNaN(returnId)) {
        return res.status(400).json({ success: false, message: "Invalid return ID" });
      }
      
      const updateData = req.body;
      const updatedReturn = await shopStorage.updateProductReturn(returnId, updateData);
      res.json({ success: true, data: updatedReturn });
    } catch (error) {
      console.error("Error updating product return:", error);
      res.status(500).json({ success: false, message: "Failed to update product return" });
    }
  });

  app.delete("/api/shop/returns/:id", requireAuth, async (req, res) => {
    try {
      const returnId = parseInt(req.params.id);
      if (isNaN(returnId)) {
        return res.status(400).json({ success: false, message: "Invalid return ID" });
      }
      
      await shopStorage.deleteProductReturn(returnId);
      res.json({ success: true, message: "Product return deleted successfully" });
    } catch (error) {
      console.error("Error deleting product return:", error);
      res.status(500).json({ success: false, message: "Failed to delete product return" });
    }
  });

  app.get("/api/shop/returns/stats", requireAuth, async (req, res) => {
    try {
      console.log("ðŸ”„ Attempting to fetch return statistics...");
      const stats = await shopStorage.getReturnStatistics();
      console.log("âœ… Return statistics fetched successfully:", stats);
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("âŒ Error fetching return statistics:", error);
      res.status(400).json({ success: false, message: "Invalid request for return statistics" });
    }
  });

  // Find customer by phone for returns
  app.get("/api/shop/customers/phone/:phone", requireAuth, async (req, res) => {
    try {
      const phone = req.params.phone;
      const customer = await shopStorage.findCustomerByPhone(phone);
      if (customer) {
        res.json({ success: true, data: customer });
      } else {
        res.json({ success: false, message: "Customer not found" });
      }
    } catch (error) {
      console.error("Error finding customer by phone:", error);
      res.status(500).json({ success: false, message: "Failed to find customer" });
    }
  });

  // Order statistics for dashboard
  app.get("/api/shop/statistics", requireAuth, async (req, res) => {
    try {
      // Get customer order statistics from the correct table
      const customerStats = await customerStorage.getCustomerStats();
      
      // Get all customer orders for additional calculations
      const allOrders = await customerStorage.getAllOrders();
      
      // Calculate statistics based on customer orders
      const totalOrders = allOrders.length;
      const pendingOrders = allOrders.filter(order => order.status === 'pending').length;
      const shippedOrders = allOrders.filter(order => order.status === 'shipped').length;
      const deliveredOrders = allOrders.filter(order => order.status === 'delivered').length;
      
      // Calculate total revenue from customer orders
      const totalRevenue = allOrders.reduce((sum, order) => {
        return sum + parseFloat(order.totalAmount || '0');
      }, 0);

      const stats = {
        totalOrders,
        pendingOrders,
        shippedOrders,
        deliveredOrders,
        totalRevenue: totalRevenue.toFixed(2),
        totalCustomers: customerStats.totalCustomers,
        openInquiries: customerStats.openInquiries
      };
      
      res.json(stats);
    } catch (error) {
      console.error("Error fetching customer order statistics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch customer order statistics" });
    }
  });

  // Payment processing endpoints
  app.post("/api/shop/orders/:id/payment", async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }

      const { paymentStatus, paymentMethod, transactionId, paymentData } = req.body;
      
      // Get the order from customer_orders table
      const order = await customerStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Order not found" });
      }

      // Update order with payment information
      const updatedOrder = await customerStorage.updateOrder(orderId, {
        status: paymentStatus === 'paid' ? 'payment_confirmed' : order.status,
        notes: order.notes ? `${order.notes}\n\nPayment processed: ${paymentMethod}${transactionId ? ` (ID: ${transactionId})` : ''}` 
               : `Payment processed: ${paymentMethod}${transactionId ? ` (ID: ${transactionId})` : ''}`
      });

      // Log the payment activity in CRM if customer exists
      if (order.customerId) {
        try {
          await crmStorage.logCustomerActivity({
            customerId: order.customerId,
            activityType: 'payment_processed',
            description: `Payment of ${order.totalAmount} processed via ${paymentMethod}${transactionId ? ` (Transaction: ${transactionId})` : ''}`,
            performedBy: 'System',
            relatedOrderId: orderId
          });
        } catch (crmError) {
          console.warn("Failed to log payment activity to CRM:", crmError);
        }
      }

      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error("Error updating payment status:", error);
      res.status(500).json({ success: false, message: "Failed to update payment status" });
    }
  });

  // Sales Reports API
  app.get("/api/reports/sales", requireAuth, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      
      if (!startDate || !endDate) {
        return res.status(400).json({ 
          success: false, 
          message: "Start date and end date are required" 
        });
      }

      // Get all orders within date range
      const orders = await customerStorage.getAllOrders();
      const filteredOrders = orders.filter(order => {
        const orderDate = new Date(order.createdAt);
        const start = new Date(startDate as string);
        const end = new Date(endDate as string);
        end.setHours(23, 59, 59, 999); // Include full end date
        
        return orderDate >= start && orderDate <= end;
      });

      // Calculate total sales metrics
      const totalSales = filteredOrders.reduce((sum, order) => 
        sum + parseFloat(order.totalAmount), 0
      );
      const totalOrders = filteredOrders.length;

      // Get detailed order items for product analysis
      const productSalesMap = new Map<string, { productName: string; quantity: number; totalAmount: number; orders: Set<number> }>();
      let totalQuantity: number = 0;

      for (const order of filteredOrders) {
        const items = await customerStorage.getOrderItems(order.id);
        
        for (const item of items) {
          const key = item.productName;
          const existing = productSalesMap.get(key) || {
            productName: item.productName,
            quantity: 0,
            totalAmount: 0,
            orders: new Set()
          };
          
          existing.quantity += Number(item.quantity);
          existing.totalAmount += parseFloat(String(item.unitPrice)) * Number(item.quantity);
          existing.orders.add(order.id);
          totalQuantity += Number(item.quantity);
          
          productSalesMap.set(key, existing);
        }
      }

      // Convert to array and add order count
      const productSales = Array.from(productSalesMap.values()).map(product => ({
        ...product,
        orders: product.orders.size
      })).sort((a, b) => b.totalAmount - a.totalAmount);

      // Create top products for pie chart (top 8 products)
      const topProducts = productSales.slice(0, 8).map(product => {
        const percentage = totalSales > 0 ? ((product.totalAmount / totalSales) * 100) : 0;
        return {
          name: product.productName,
          value: product.totalAmount,
          percentage: Math.round(percentage * 10) / 10
        };
      });

      // Create daily breakdown
      const dailyMap = new Map();
      filteredOrders.forEach(order => {
        const date = new Date(order.createdAt).toISOString().split('T')[0];
        const existing = dailyMap.get(date) || { date, sales: 0, orders: 0 };
        existing.sales += parseFloat(order.totalAmount);
        existing.orders += 1;
        dailyMap.set(date, existing);
      });

      const dailyBreakdown = Array.from(dailyMap.values()).sort((a, b) => 
        new Date(a.date).getTime() - new Date(b.date).getTime()
      );

      const reportData = {
        totalSales,
        totalOrders,
        totalQuantity,
        productSales,
        dailyBreakdown,
        topProducts
      };

      res.json(reportData);
    } catch (error) {
      console.error("Error generating sales report:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate sales report" 
      });
    }
  });

  // Discount settings management
  app.get("/api/shop/discounts", async (req, res) => {
    try {
      const discounts = await shopStorage.getDiscountSettings();
      res.json({ success: true, data: discounts });
    } catch (error) {
      console.error("Error fetching discounts:", error);
      res.status(500).json({ success: false, message: "Failed to fetch discounts" });
    }
  });

  app.get("/api/shop/discounts/active", async (req, res) => {
    try {
      const discounts = await shopStorage.getActiveDiscountSettings();
      res.json({ success: true, data: discounts });
    } catch (error) {
      console.error("Error fetching active discounts:", error);
      res.status(500).json({ success: false, message: "Failed to fetch active discounts" });
    }
  });

  // Get specific discount by ID
  app.get("/api/shop/discounts/:id", async (req, res) => {
    try {
      const discountId = parseInt(req.params.id);
      if (!discountId || isNaN(discountId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Valid discount ID is required" 
        });
      }

      const discount = await shopStorage.getDiscountSettingById(discountId);
      if (!discount) {
        return res.status(404).json({ 
          success: false, 
          message: "Discount not found" 
        });
      }

      res.json({ success: true, data: discount });
    } catch (error) {
      console.error('Error fetching discount:', error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to fetch discount" 
      });
    }
  });

  app.post("/api/shop/discounts", requireAuth, async (req, res) => {
    try {
      const discountData = req.body;
      console.log("ðŸŽ¯ [DISCOUNT API] Creating new discount with data:", discountData);
      
      const discount = await shopStorage.createDiscountSetting(discountData);
      console.log("ðŸŽ¯ [DISCOUNT API] Discount created successfully:", discount);
      
      res.json({ success: true, data: discount });
    } catch (error) {
      console.error("ðŸŽ¯ [DISCOUNT API] Error creating discount:", error);
      console.error("ðŸŽ¯ [DISCOUNT API] Error details:", error instanceof Error ? error.message : error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to create discount",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.patch("/api/shop/discounts/:id", requireAuth, async (req, res) => {
    try {
      const discountId = parseInt(req.params.id);
      if (isNaN(discountId)) {
        return res.status(400).json({ success: false, message: "Invalid discount ID" });
      }
      
      const updates = req.body;
      console.log("ðŸŽ¯ [DISCOUNT API] Updating discount", discountId, "with updates:", updates);
      
      const discount = await shopStorage.updateDiscountSetting(discountId, updates);
      console.log("ðŸŽ¯ [DISCOUNT API] Discount updated successfully:", discount);
      
      // Fetch the updated discount to ensure we return the latest data
      const updatedDiscount = await shopStorage.getDiscountSettingById(discountId);
      console.log("ðŸŽ¯ [DISCOUNT API] Fresh discount data:", updatedDiscount);
      
      res.json({ success: true, data: updatedDiscount });
    } catch (error) {
      console.error("ðŸŽ¯ [DISCOUNT API] Error updating discount:", error);
      console.error("ðŸŽ¯ [DISCOUNT API] Error details:", error instanceof Error ? error.message : error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to update discount",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.delete("/api/shop/discounts/:id", requireAuth, async (req, res) => {
    try {
      const discountId = parseInt(req.params.id);
      if (isNaN(discountId)) {
        return res.status(400).json({ success: false, message: "Invalid discount ID" });
      }
      
      await shopStorage.deleteDiscountSetting(discountId);
      res.json({ success: true, message: "Discount deleted successfully" });
    } catch (error) {
      console.error("Error deleting discount:", error);
      res.status(500).json({ success: false, message: "Failed to delete discount" });
    }
  });

  // Sync centralized discount settings to all products
  app.post("/api/shop/discounts/sync-to-products", requireAuth, async (req, res) => {
    try {
      // Get active discount settings
      const activeDiscounts = await shopStorage.getActiveDiscountSettings();
      
      // Convert to product quantityDiscounts format
      const quantityDiscounts = activeDiscounts.map((discount: any) => ({
        minQty: discount.minQuantity,
        discount: parseFloat(discount.discountPercentage) / 100
      })).sort((a: any, b: any) => a.minQty - b.minQty);

      // Get all products without quantity discounts
      const products = await shopStorage.getShopProducts();
      const productsToUpdate = products.filter((product: any) => 
        !product.quantityDiscounts || product.quantityDiscounts === null
      );

      // Update each product with the centralized discounts
      let updatedCount = 0;
      for (const product of productsToUpdate) {
        await shopStorage.updateShopProduct(product.id, {
          quantityDiscounts: JSON.stringify(quantityDiscounts)
        });
        updatedCount++;
      }

      res.json({
        success: true,
        message: `Applied centralized discounts to ${updatedCount} products`,
        discountsApplied: quantityDiscounts,
        productsUpdated: updatedCount,
        totalProducts: products.length
      });
    } catch (error) {
      console.error("Error syncing discounts to products:", error);
      res.status(500).json({ success: false, message: "Failed to sync discounts to products" });
    }
  });

  // Financial transactions endpoints for accounting
  app.get("/api/shop/financial-transactions", async (req, res) => {
    try {
      const { type, startDate, endDate, orderId } = req.query;
      const filters: any = {};
      
      if (type) filters.type = type as string;
      if (orderId) filters.orderId = parseInt(orderId as string);
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);

      const transactions = await shopStorage.getFinancialTransactions(filters);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching financial transactions:", error);
      res.status(500).json({ success: false, message: "Failed to fetch financial transactions" });
    }
  });

  app.post("/api/shop/financial-transactions", async (req, res) => {
    try {
      const transaction = await shopStorage.createFinancialTransaction(req.body);
      res.json(transaction);
    } catch (error) {
      console.error("Error creating financial transaction:", error);
      res.status(500).json({ success: false, message: "Failed to create financial transaction" });
    }
  });

  // Sales reports endpoints
  app.get("/api/shop/sales-reports", async (req, res) => {
    try {
      const { reportType, startDate, endDate } = req.query;
      const filters: any = {};
      
      if (reportType) filters.reportType = reportType as string;
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);

      const reports = await shopStorage.getSalesReports(filters);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching sales reports:", error);
      res.status(500).json({ success: false, message: "Failed to fetch sales reports" });
    }
  });

  app.post("/api/shop/sales-reports", async (req, res) => {
    try {
      const report = await shopStorage.createSalesReport(req.body);
      res.json(report);
    } catch (error) {
      console.error("Error creating sales report:", error);
      res.status(500).json({ success: false, message: "Failed to create sales report" });
    }
  });

  // Real-time accounting statistics
  app.get("/api/shop/accounting-stats", async (req, res) => {
    try {
      const stats = await shopStorage.getAccountingStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching accounting stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch accounting stats" });
    }
  });

  // Process refund/return
  app.post("/api/shop/orders/:id/refund", async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { amount, reason, type } = req.body;
      
      await shopStorage.processOrderRefund(orderId, amount, reason, type);
      res.json({ success: true, message: `${type === 'refund' ? 'Refund' : 'Return'} processed successfully` });
    } catch (error) {
      console.error("Error processing refund/return:", error);
      res.status(500).json({ success: false, message: "Failed to process refund/return" });
    }
  });

  // Product synchronization endpoint - sync showcase products to shop
  app.post("/api/sync-products", async (req, res) => {
    try {
      console.log("ðŸ”„ Starting complete product synchronization from showcase to shop...");
      
      // Get all showcase products
      const showcaseProducts = await storage.getProducts();
      
      // Get existing shop products for comparison
      const existingShopProducts = await shopStorage.getShopProducts();
      
      let syncedCount = 0;
      let skippedCount = 0;
      
      for (const showcaseProduct of showcaseProducts) {
        // Check if product already exists in shop
        const existingShopProduct = existingShopProducts.find(sp => sp.name === showcaseProduct.name);
        
        if (existingShopProduct) {
          console.log(`âš ï¸  Product already exists in shop: ${showcaseProduct.name}`);
          skippedCount++;
          continue;
        }
        
        // Create new shop product from showcase product
        const shopProductData = {
          name: showcaseProduct.name,
          category: showcaseProduct.category,
          description: showcaseProduct.description,
          shortDescription: showcaseProduct.shortDescription || showcaseProduct.description,
          price: showcaseProduct.unitPrice || showcaseProduct.price || 0,
          priceUnit: showcaseProduct.currency || showcaseProduct.priceUnit || 'IQD',
          inStock: (showcaseProduct.stockQuantity || 0) > 0 || (showcaseProduct.showWhenOutOfStock || false),
          stockQuantity: showcaseProduct.stockQuantity || 0,
          lowStockThreshold: 10,
          minStockLevel: showcaseProduct.minStockLevel || 5,
          maxStockLevel: showcaseProduct.maxStockLevel || 100,
          showWhenOutOfStock: showcaseProduct.showWhenOutOfStock || false,
          sku: showcaseProduct.sku || `SKU-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
          barcode: showcaseProduct.barcode,
          imageUrls: showcaseProduct.imageUrl ? [showcaseProduct.imageUrl] : [],
          specifications: showcaseProduct.specifications || {},
          features: showcaseProduct.features || [],
          applications: showcaseProduct.applications || [],
          isActive: true,
          isFeatured: false,
          metaTitle: showcaseProduct.name,
          metaDescription: showcaseProduct.description
        };
        
        await shopStorage.createShopProduct(shopProductData);
        console.log(`âœ… Synced to shop: ${showcaseProduct.name}`);
        syncedCount++;
      }
      
      console.log(`ðŸ”„ Sync completed: ${syncedCount} products added, ${skippedCount} already existed`);
      
      res.json({ 
        success: true, 
        message: `Successfully synchronized ${syncedCount} products to shop. ${skippedCount} products already existed.`,
        syncedCount,
        skippedCount,
        totalShowcaseProducts: showcaseProducts.length
      });
    } catch (error) {
      console.error("Error syncing products:", error);
      res.status(500).json({ success: false, message: "Failed to sync products" });
    }
  });

  // Reverse sync: Update showcase inventory from shop sales
  app.post("/api/sync-products-reverse", async (req, res) => {
    try {
      // No sync needed - unified table approach
      res.json({ success: true, message: "All products synchronized from shop to showcase successfully" });
    } catch (error) {
      console.error("Error syncing products from shop:", error);
      res.status(500).json({ success: false, message: "Failed to sync products from shop" });
    }
  });

  // Sales analytics endpoint
  app.get("/api/analytics/sales", requireAuth, async (req, res) => {
    try {
      // Get all orders with order items
      const orders = await shopStorage.getOrders();
      
      // Build comprehensive order data with items
      const ordersWithItems = [];
      for (const order of orders) {
        const orderItems = await shopStorage.getOrderItems(order.id);
        for (const item of orderItems) {
          ordersWithItems.push({
            ...order,
            product_name: item.productName,
            quantity: item.quantity,
            unit_price: item.unitPrice,
            item_total: parseFloat(item.unitPrice) * item.quantity
          });
        }
      }

      // Calculate key metrics
      const totalRevenue = orders.reduce((sum, order) => sum + parseFloat(order.totalAmount || '0'), 0);
      const totalOrders = orders.length;
      const averageOrderValue = totalRevenue / totalOrders || 0;
      
      // Get unique customers from shop_customers
      const customers = await shopStorage.getCustomers();
      const uniqueCustomers = customers.length;
      
      // Calculate growth rate (comparing last 15 days vs previous 15 days)
      const now = new Date();
      const fifteenDaysAgo = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      
      const recentOrders = orders.filter(o => new Date(o.createdAt) >= fifteenDaysAgo);
      const previousOrders = orders.filter(o => 
        new Date(o.createdAt) >= thirtyDaysAgo && new Date(o.createdAt) < fifteenDaysAgo
      );
      
      const recentRevenue = recentOrders.reduce((sum, o) => sum + parseFloat(o.totalAmount || '0'), 0);
      const previousRevenue = previousOrders.reduce((sum, o) => sum + parseFloat(o.totalAmount || '0'), 0);
      const growthRate = previousRevenue > 0 ? ((recentRevenue - previousRevenue) / previousRevenue) * 100 : 0;

      // Generate daily sales data for last 30 days
      const dailySales = [];
      const ordersByDate = new Map();
      
      orders.forEach(order => {
        const date = order.createdAt.toISOString().split('T')[0];
        if (!ordersByDate.has(date)) {
          ordersByDate.set(date, { revenue: 0, orderIds: new Set() });
        }
        ordersByDate.get(date).revenue += parseFloat(order.totalAmount || '0');
        ordersByDate.get(date).orderIds.add(order.id);
      });

      for (let i = 29; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        
        const dayData = ordersByDate.get(dateStr);
        dailySales.push({
          date: dateStr,
          revenue: dayData?.revenue || 0,
          orders: dayData?.orderIds.size || 0
        });
      }

      // Top products by revenue
      const productSales = new Map();
      ordersWithItems.forEach(orderItem => {
        if (orderItem.product_name) {
          const key = orderItem.product_name;
          if (!productSales.has(key)) {
            productSales.set(key, { 
              name: key, 
              revenue: 0, 
              quantity: 0, 
              orderIds: new Set() 
            });
          }
          const product = productSales.get(key);
          product.revenue += orderItem.item_total;
          product.quantity += orderItem.quantity;
          product.orderIds.add(orderItem.id);
        }
      });

      const topProducts = Array.from(productSales.values())
        .map(p => ({ ...p, orders: p.orderIds.size }))
        .sort((a, b) => b.revenue - a.revenue)
        .slice(0, 10);

      // Orders by status
      const statusCounts = new Map();
      orders.forEach(order => {
        const status = order.status;
        statusCounts.set(status, (statusCounts.get(status) || 0) + 1);
      });

      const ordersByStatus = Array.from(statusCounts.entries()).map(([status, count]) => ({
        status: status || 'unknown',
        count,
        percentage: (count / totalOrders) * 100
      }));

      // Revenue by category - analyze product names
      const categoryMapping = {
        'Chemicals': ['chemical', 'thinner', 'clarifier', 'stabilizer'],
        'Fertilizers': ['fertilizer', 'npk'],
        'Additives': ['additive', 'anti-gel'],
        'Cleaners': ['cleaner', 'system']
      };

      const revenueByCategory = Object.entries(categoryMapping).map(([category, keywords]) => {
        const categoryRevenue = topProducts
          .filter(p => keywords.some(keyword => 
            p.name.toLowerCase().includes(keyword.toLowerCase())
          ))
          .reduce((sum, p) => sum + p.revenue, 0);
        
        return {
          category,
          revenue: categoryRevenue,
          percentage: totalRevenue > 0 ? (categoryRevenue / totalRevenue) * 100 : 0
        };
      }).filter(c => c.revenue > 0);

      const analyticsData = {
        totalRevenue,
        totalOrders,
        averageOrderValue,
        totalCustomers: uniqueCustomers,
        conversionRate: totalOrders > 0 ? (totalOrders / (totalOrders + 5)) * 100 : 0, // Simple conversion estimate
        growthRate,
        dailySales,
        topProducts,
        ordersByStatus,
        revenueByCategory
      };

      res.json(analyticsData);
    } catch (error) {
      console.error("Error fetching sales analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch analytics" });
    }
  });

  // Export sales report endpoint
  app.get("/api/analytics/sales/export", requireAuth, async (req, res) => {
    try {
      const format = req.query.format as string || 'csv';
      
      // Get all orders with items
      const orders = await shopStorage.getOrders();
      
      // Build detailed report data
      const reportData = [];
      for (const order of orders) {
        const orderItems = await shopStorage.getOrderItems(order.id);
        const customer = await shopStorage.getCustomerById(order.customerId);
        
        for (const item of orderItems) {
          reportData.push({
            orderNumber: order.orderNumber,
            orderDate: order.createdAt.toISOString().split('T')[0],
            customerName: customer ? `${customer.firstName} ${customer.lastName}` : 'N/A',
            customerEmail: customer?.email || 'N/A',
            productName: item.productName,
            quantity: item.quantity,
            unitPrice: parseFloat(item.unitPrice),
            itemTotal: parseFloat(item.unitPrice) * item.quantity,
            orderStatus: order.status,
            paymentStatus: order.paymentStatus,
            subtotal: parseFloat(order.subtotal || '0'),
            taxAmount: parseFloat(order.taxAmount || '0'),
            shippingAmount: parseFloat(order.shippingAmount || '0'),
            totalAmount: parseFloat(order.totalAmount || '0'),
            currency: order.currency || 'USD'
          });
        }
      }

      if (format === 'csv') {
        // Generate CSV with proper UTF-8 encoding for Arabic/Persian text
        const csvHeaders = [
          'Order Number', 'Order Date', 'Customer Name', 'Customer Email',
          'Product Name', 'Quantity', 'Unit Price', 'Item Total',
          'Order Status', 'Payment Status', 'Subtotal', 'Tax Amount',
          'Shipping Amount', 'Total Amount', 'Currency'
        ].join(',');
        
        const csvRows = reportData.map(row => {
          // Ensure all text fields are properly escaped and encoded
          const escapeForCsv = (str) => {
            if (str == null) return '';
            return `"${String(str).replace(/"/g, '""')}"`;
          };
          
          return [
            escapeForCsv(row.orderNumber),
            escapeForCsv(row.orderDate),
            escapeForCsv(row.customerName),
            escapeForCsv(row.customerEmail),
            escapeForCsv(row.productName),
            row.quantity,
            row.unitPrice.toFixed(2),
            row.itemTotal.toFixed(2),
            escapeForCsv(row.orderStatus),
            escapeForCsv(row.paymentStatus),
            row.subtotal.toFixed(2),
            row.taxAmount.toFixed(2),
            row.shippingAmount.toFixed(2),
            row.totalAmount.toFixed(2),
            escapeForCsv(row.currency)
          ].join(',');
        });
        
        const csvContent = [csvHeaders, ...csvRows].join('\r\n');
        
        // Add UTF-8 BOM for Excel compatibility with Arabic/Persian text
        const bom = Buffer.from([0xEF, 0xBB, 0xBF]);
        const csvBuffer = Buffer.from(csvContent, 'utf8');
        const finalBuffer = Buffer.concat([bom, csvBuffer]);
        
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''sales-report-${new Date().toISOString().split('T')[0]}.csv`);
        res.send(finalBuffer);
      } else {
        // Return JSON for other formats or direct download
        res.json({
          success: true,
          data: reportData,
          summary: {
            totalOrders: orders.length,
            totalRevenue: reportData.reduce((sum, item) => sum + item.itemTotal, 0),
            reportDate: new Date().toISOString().split('T')[0]
          }
        });
      }
    } catch (error) {
      console.error("Error generating sales report:", error);
      res.status(500).json({ success: false, message: "Failed to generate sales report" });
    }
  });

  // Email template management routes - remove auth requirement temporarily
  app.get("/api/email-templates", async (req, res) => {
    try {
      console.log("ðŸ“§ GET /api/email-templates - Fetching templates...");
      const templates = await customerStorage.getEmailTemplates();
      console.log("ðŸ“§ Found templates:", templates?.length || 0);
      res.json(templates);
    } catch (error) {
      console.error("âŒ Error fetching email templates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/email-templates/category/:category", async (req, res) => {
    try {
      const { category } = req.params;
      const templates = await customerStorage.getEmailTemplatesByCategory(category);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates by category:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.get("/api/email-templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      const template = await customerStorage.getEmailTemplateById(id);
      if (!template) {
        return res.status(404).json({ 
          success: false, 
          message: "Template not found" 
        });
      }

      res.json(template);
    } catch (error) {
      console.error("Error fetching email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/email-templates", requireAuth, async (req, res) => {
    try {
      const sessionData = req.session;
      const templateData = insertEmailTemplateSchema.parse({
        ...req.body,
        createdBy: sessionData.adminId
      });
      
      const template = await customerStorage.createEmailTemplate(templateData);
      res.status(201).json({ 
        success: true, 
        message: "Email template created successfully",
        template 
      });
    } catch (error) {
      console.error("Error creating email template:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Invalid template data", 
          errors: error.errors 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: "Internal server error" 
        });
      }
    }
  });

  app.patch("/api/email-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      const updates = req.body;
      const template = await customerStorage.updateEmailTemplate(id, updates);
      res.json({ 
        success: true, 
        message: "Email template updated successfully",
        template 
      });
    } catch (error) {
      console.error("Error updating email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.delete("/api/email-templates/:id", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      await customerStorage.deleteEmailTemplate(id);
      res.json({ 
        success: true, 
        message: "Email template deleted successfully" 
      });
    } catch (error) {
      console.error("Error deleting email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/email-templates/:id/set-default", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      const { category } = req.body;
      if (!category) {
        return res.status(400).json({ 
          success: false, 
          message: "Category is required" 
        });
      }

      await customerStorage.setDefaultTemplate(id, category);
      res.json({ 
        success: true, 
        message: "Default template set successfully" 
      });
    } catch (error) {
      console.error("Error setting default template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  // Admin Email Templates Management - New endpoints for the admin interface
  app.get("/api/admin/email/templates", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const templates = await emailStorage.getAllTemplates();
      
      // Convert database fields to frontend expected fields
      const formattedTemplates = templates.map(template => ({
        id: template.id,
        name: template.templateName || template.name,
        templateName: template.templateName || template.name,
        subject: template.subject,
        html_content: template.htmlContent || template.html_content,
        htmlContent: template.htmlContent || template.html_content,
        text_content: template.textContent || template.text_content,
        textContent: template.textContent || template.text_content,
        category: template.categoryName || template.category,
        categoryName: template.categoryName || template.category,
        variables: template.variables || [],
        is_active: template.isActive !== false,
        isActive: template.isActive !== false,
        is_default: template.isDefault || false,
        isDefault: template.isDefault || false,
        language: template.language || 'fa',
        created_by: template.createdBy || template.created_by,
        createdBy: template.createdBy || template.created_by,
        usage_count: template.usageCount || template.usage_count || 0,
        usageCount: template.usageCount || template.usage_count || 0,
        last_used: template.lastUsed || template.last_used,
        lastUsed: template.lastUsed || template.last_used,
        created_at: template.createdAt || template.created_at,
        createdAt: template.createdAt || template.created_at,
        updated_at: template.updatedAt || template.updated_at,
        updatedAt: template.updatedAt || template.updated_at
      }));
      
      console.log(`ðŸ“§ Formatted ${formattedTemplates.length} templates for frontend`);
      res.json(formattedTemplates);
    } catch (error) {
      console.error("Error fetching admin email templates:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ…ÛŒÙ„",
        error: error.message
      });
    }
  });

  app.post("/api/admin/email/templates", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const { insertEmailTemplateSchema } = await import("../shared/email-schema");
      
      const templateData = {
        ...req.body,
        createdBy: req.session.adminId
      };
      
      const template = await emailStorage.createTemplate(templateData);
      res.status(201).json({ 
        success: true, 
        message: "Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯",
        template 
      });
    } catch (error) {
      console.error("Error creating admin email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  // Simple endpoint to update phone number in template
  app.put("/api/admin/email/templates/:id/phone", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { phoneNumber } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      console.log('ðŸ“§ Updating phone number for template ID:', id);
      console.log('ðŸ“§ New phone number:', phoneNumber);
      
      // Update phone number in HTML content using direct SQL
      const result = await sql`
        UPDATE email_templates 
        SET html_content = replace(html_content, '+964 771 234 5678', ${phoneNumber}),
            text_content = replace(text_content, '+964 770 999 6771', ${phoneNumber})
        WHERE id = ${id}
      `;
      
      console.log('ðŸ“§ Phone number updated successfully');
      
      res.json({ 
        success: true, 
        message: "Phone number updated successfully" 
      });
    } catch (error) {
      console.error("Error updating phone number:", error);
      res.status(500).json({ 
        success: false, 
        message: "Error updating phone number: " + error.message 
      });
    }
  });

  // Simple endpoint to update subject
  app.put("/api/admin/email/templates/:id/subject", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { subject } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      console.log('ðŸ“§ Updating subject for template ID:', id);
      console.log('ðŸ“§ New subject:', subject);
      
      // Update subject using direct SQL
      const result = await sql`
        UPDATE email_templates 
        SET subject = ${subject}
        WHERE id = ${id}
      `;
      
      console.log('ðŸ“§ Subject updated successfully');
      
      res.json({ 
        success: true, 
        message: "Subject updated successfully" 
      });
    } catch (error) {
      console.error("Error updating subject:", error);
      res.status(500).json({ 
        success: false, 
        message: "Error updating subject: " + error.message 
      });
    }
  });

  app.put("/api/admin/email/templates/:id", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid template ID" 
        });
      }

      console.log('ðŸ“§ Updating template ID:', id);
      console.log('ðŸ“§ Request body keys:', Object.keys(req.body));
      
      // Simple approach - just use req.body directly
      const requestData = req.body;
      
      // Clean and prepare update data
      const updates: any = {};
      
      if (requestData.templateName !== undefined) {
        updates.templateName = String(requestData.templateName).trim();
      }
      if (requestData.name !== undefined) {
        updates.templateName = String(requestData.name).trim();
      }
      if (requestData.categoryName !== undefined) {
        updates.categoryName = String(requestData.categoryName).trim();
      }
      if (requestData.category !== undefined) {
        updates.categoryName = String(requestData.category).trim();
      }
      if (requestData.subject !== undefined) {
        updates.subject = String(requestData.subject).trim();
      }
      if (requestData.htmlContent !== undefined) {
        updates.htmlContent = String(requestData.htmlContent);
      }
      if (requestData.textContent !== undefined) {
        updates.textContent = String(requestData.textContent);
      }
      if (requestData.variables !== undefined) {
        if (Array.isArray(requestData.variables)) {
          updates.variables = requestData.variables;
        } else if (typeof requestData.variables === 'string') {
          // Parse comma-separated string into array
          updates.variables = requestData.variables.split(',').map((v: string) => v.trim()).filter((v: string) => v.length > 0);
        }
      }
      if (requestData.isActive !== undefined) {
        updates.isActive = Boolean(requestData.isActive);
      }
      if (requestData.isDefault !== undefined) {
        updates.isDefault = Boolean(requestData.isDefault);
      }
      if (requestData.language !== undefined) {
        updates.language = String(requestData.language).trim();
      }

      console.log('ðŸ“§ Cleaned update data fields:', Object.keys(updates));

      const template = await emailStorage.updateTemplate(id, updates);
      
      console.log('ðŸ“§ Template updated successfully:', template.templateName);
      
      res.json({ 
        success: true, 
        message: "Email template updated successfully",
        template 
      });
    } catch (error) {
      console.error("Error updating admin email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Error updating email template: " + error.message 
      });
    }
  });

  // Toggle template status (active/inactive)
  app.patch("/api/admin/email/templates/:id/toggle", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }
      
      const template = await emailStorage.toggleTemplateStatus(id);
      
      console.log(`ðŸ“§ Template ${template.templateName} status toggled to: ${template.isActive ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'}`);
      
      res.json({ 
        success: true, 
        message: `ÙˆØ¶Ø¹ÛŒØª Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø­Ø§Ù„Øª ${template.isActive ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`,
        template
      });
    } catch (error) {
      console.error("Error toggling template status:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù‚Ø§Ù„Ø¨: " + error.message 
      });
    }
  });

  app.delete("/api/admin/email/templates/:id", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      await emailStorage.deleteTemplate(id);
      res.json({ 
        success: true, 
        message: "Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" 
      });
    } catch (error) {
      console.error("Error deleting admin email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  app.put("/api/admin/email/templates/:id/toggle", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      const { isActive } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      const template = await emailStorage.updateTemplate(id, { isActive });
      res.json({ 
        success: true, 
        message: isActive ? "Ù‚Ø§Ù„Ø¨ ÙØ¹Ø§Ù„ Ø´Ø¯" : "Ù‚Ø§Ù„Ø¨ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯",
        template 
      });
    } catch (error) {
      console.error("Error toggling email template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù‚Ø§Ù„Ø¨" 
      });
    }
  });

  app.put("/api/admin/email/templates/:id/set-default", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø§Ù„Ø¨ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      // Get the template to find its category
      const template = await emailStorage.getTemplateById(id);
      if (!template) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      await emailStorage.setDefaultTemplate(id, template.category);
      res.json({ 
        success: true, 
        message: "Ù‚Ø§Ù„Ø¨ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯" 
      });
    } catch (error) {
      console.error("Error setting default template:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ´â€ŒÙØ±Ø¶" 
      });
    }
  });

  app.get("/api/admin/email/categories", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const categories = await emailStorage.getCategories();
      
      // Enhanced categories with SMTP settings and recipients
      const enhancedCategories = await Promise.all(
        categories.map(async (category) => {
          const smtp = await emailStorage.getSmtpSettingByCategory(category.id);
          const recipients = await emailStorage.getRecipientsByCategory(category.id);
          
          console.log(`[EMAIL API] Category ${category.categoryName}:`, {
            hasSmtp: !!smtp,
            smtpData: smtp ? {
              id: smtp.id,
              host: smtp.host,
              port: smtp.port,
              username: smtp.username,
              fromName: smtp.fromName,
              fromEmail: smtp.fromEmail,
              testStatus: smtp.testStatus
            } : null
          });
          
          return {
            ...category,
            smtp,
            recipients
          };
        })
      );
      
      res.json({ 
        success: true, 
        categories: enhancedCategories 
      });
    } catch (error) {
      console.error("Error fetching email categories:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  // Create new email category
  app.post("/api/admin/email/categories", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const { categoryKey, categoryName, description } = req.body;

      if (!categoryKey || !categoryName) {
        return res.status(400).json({
          success: false,
          message: "Ù†Ø§Ù… Ùˆ Ú©Ù„ÛŒØ¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª"
        });
      }

      // Check if category key already exists
      const existing = await emailStorage.getCategoryByKey(categoryKey);
      if (existing) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ† Ú©Ù„ÛŒØ¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"
        });
      }

      const newCategory = await emailStorage.createCategory({
        categoryKey,
        categoryName,
        description: description || ""
      });

      res.json({
        success: true,
        message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯",
        category: newCategory
      });
    } catch (error) {
      console.error("Error creating email category:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÛŒÙ…ÛŒÙ„"
      });
    }
  });

  // Delete email category
  app.delete("/api/admin/email/categories/:id", requireAuth, async (req, res) => {
    try {
      const { emailStorage } = await import("./email-storage");
      const categoryId = parseInt(req.params.id);

      if (isNaN(categoryId)) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      // Check if category exists
      const category = await emailStorage.getCategoryById(categoryId);
      if (!category) {
        return res.status(404).json({
          success: false,
          message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Delete related SMTP settings first
      const smtp = await emailStorage.getSmtpSettingByCategory(categoryId);
      if (smtp) {
        await emailStorage.deleteSmtpSetting(smtp.id);
      }

      // Delete related recipients
      const recipients = await emailStorage.getRecipientsByCategory(categoryId);
      for (const recipient of recipients) {
        await emailStorage.deleteRecipient(recipient.id);
      }

      // Delete the category
      await emailStorage.deleteCategory(categoryId);

      res.json({
        success: true,
        message: "Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error deleting email category:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÛŒÙ…ÛŒÙ„"
      });
    }
  });

  // Template processing routes
  app.post("/api/templates/send-response", requireAuth, async (req, res) => {
    try {
      const { inquiryId, templateId, customVariables, customContent } = req.body;
      
      if (!inquiryId || !templateId) {
        return res.status(400).json({
          success: false,
          message: "Inquiry ID and Template ID are required"
        });
      }

      await TemplateProcessor.sendTemplatedResponse(
        inquiryId,
        templateId,
        customVariables,
        customContent
      );

      res.json({
        success: true,
        message: "Email response sent successfully"
      });
    } catch (error) {
      console.error("Error sending templated response:", error);
      res.status(500).json({
        success: false,
        message: "Failed to send email response"
      });
    }
  });

  app.post("/api/templates/preview", requireAuth, async (req, res) => {
    try {
      const { templateId, variables } = req.body;
      
      const template = await customerStorage.getEmailTemplateById(templateId);
      if (!template) {
        return res.status(404).json({
          success: false,
          message: "Template not found"
        });
      }

      const preview = TemplateProcessor.previewTemplate(template, variables || {});
      
      res.json({
        success: true,
        preview
      });
    } catch (error) {
      console.error("Error previewing template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to preview template"
      });
    }
  });

  app.get("/api/templates/suggestions/:category", requireAuth, async (req, res) => {
    try {
      const { category } = req.params;
      const { language = 'en' } = req.query;
      
      const suggestions = await TemplateProcessor.getTemplateSuggestions(
        category, 
        language as string
      );
      
      res.json(suggestions);
    } catch (error) {
      console.error("Error getting template suggestions:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get template suggestions"
      });
    }
  });

  // Dashboard and inquiry tracking routes (public)
  app.get("/api/inquiries", async (req, res) => {
    try {
      const inquiries = await simpleCustomerStorage.getAllInquiries();
      res.json(inquiries);
    } catch (error) {
      console.error("Error fetching inquiries:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiries"
      });
    }
  });

  app.get("/api/inquiries/stats", async (req, res) => {
    try {
      const stats = await simpleCustomerStorage.getCustomerStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching inquiry stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiry statistics"
      });
    }
  });

  app.get("/api/inquiries/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const inquiry = await simpleCustomerStorage.getInquiryById(id);
      if (!inquiry) {
        return res.status(404).json({
          success: false,
          message: "Inquiry not found"
        });
      }

      res.json(inquiry);
    } catch (error) {
      console.error("Error fetching inquiry:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiry"
      });
    }
  });

  app.get("/api/inquiries/:id/responses", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const responses = await simpleCustomerStorage.getInquiryResponses(id);
      res.json(responses);
    } catch (error) {
      console.error("Error fetching inquiry responses:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch inquiry responses"
      });
    }
  });

  // Create inquiry response (admin only)
  app.post("/api/inquiries/:id/response", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const { responseText, responseType = 'follow_up' } = req.body;
      
      if (!responseText?.trim()) {
        return res.status(400).json({
          success: false,
          message: "Response text is required"
        });
      }

      // Get the inquiry first to verify it exists
      const inquiry = await simpleCustomerStorage.getInquiryById(id);
      if (!inquiry) {
        return res.status(404).json({
          success: false,
          message: "Inquiry not found"
        });
      }

      // Try to get customer language preference from CRM
      let customerLanguage = 'en'; // Default to English
      try {
        const { pool } = await import('./db');
        const customerResult = await pool.query(`
          SELECT preferred_language 
          FROM crm_customers 
          WHERE email = $1 AND is_active = true
        `, [inquiry.contactEmail]);
        
        if (customerResult.rows.length > 0 && customerResult.rows[0].preferred_language) {
          customerLanguage = customerResult.rows[0].preferred_language;
          console.log(`ðŸ“ž Customer language preference found: ${customerLanguage} for ${inquiry.contactEmail}`);
        } else {
          console.log(`ðŸ“ž No language preference found for ${inquiry.contactEmail}, using default: ${customerLanguage}`);
        }
      } catch (langError) {
        console.log(`âŒ Error fetching customer language preference: ${langError.message}, using default: ${customerLanguage}`);
      }

      // Create the response
      const response = await simpleCustomerStorage.createInquiryResponse({
        inquiryId: id,
        senderId: req.session.adminId,
        senderType: 'admin',
        message: responseText,
        isInternal: false,
      });

      // Send follow-up email to customer
      try {
        // Create transporter using existing email system
        const createTransporter = async (categoryKey: string) => {
          const categorySettings = await emailStorage.getCategoryWithSettings(categoryKey);
          
          if (!categorySettings?.smtp) {
            throw new Error(`No SMTP configuration found for category: ${categoryKey}`);
          }

          const smtp = categorySettings.smtp;
          
          return nodemailer.createTransport({
            host: smtp.host,
            port: smtp.port,
            secure: smtp.port === 465,
            auth: {
              user: smtp.username,
              pass: smtp.password,
            },
          });
        };

        // Determine the correct category for email routing based on inquiry category
        let emailCategory = 'admin'; // Default fallback
        
        if (inquiry.category) {
          // Map inquiry category to email category key
          const categoryMap: { [key: string]: string } = {
            'fuel-additives': 'fuel-additives',
            'water-treatment': 'water-treatment', 
            'paint-solvents': 'paint-solvents',
            'agricultural-products': 'agricultural-products',
            'agricultural-fertilizers': 'agricultural-fertilizers',
            'industrial-chemicals': 'industrial-chemicals',
            'paint-thinner': 'paint-thinner',
            'technical-equipment': 'technical-equipment',
            'commercial-goods': 'commercial-goods',
            'general': 'admin',
            'support': 'support'
          };
          
          emailCategory = categoryMap[inquiry.category] || 'admin';
          console.log(`ðŸ“§ Inquiry response routing: inquiry category '${inquiry.category}' â†’ email category '${emailCategory}'`);
        }

        // Try to get category-specific settings, fallback to admin if not found
        let categorySettings, smtp, transporter;
        
        try {
          categorySettings = await emailStorage.getCategoryWithSettings(emailCategory);
          if (!categorySettings?.smtp) {
            throw new Error(`No SMTP configuration found for category: ${emailCategory}`);
          }
          transporter = await createTransporter(emailCategory);
          smtp = categorySettings.smtp;
          console.log(`âœ… Using SMTP settings for category '${emailCategory}': ${smtp.fromEmail}`);
        } catch (categoryError) {
          console.log(`âŒ Category '${emailCategory}' not configured, falling back to admin: ${categoryError.message}`);
          // Fallback to admin category
          categorySettings = await emailStorage.getCategoryWithSettings('admin');
          if (!categorySettings?.smtp) {
            throw new Error('No SMTP configuration found for admin fallback category');
          }
          transporter = await createTransporter('admin');
          smtp = categorySettings.smtp;
          console.log(`âœ… Using fallback admin SMTP settings: ${smtp.fromEmail}`);
        }

        if (smtp) {
          // Get the "#05 - Momtaz Chemical Follow-up Response" template from database
          let emailTemplate;
          try {
            const templates = await emailStorage.getAllTemplates();
            emailTemplate = templates.find(t => t.templateName === '#05 - Momtaz Chemical Follow-up Response');
            console.log(`ðŸ“§ Using template: ${emailTemplate ? emailTemplate.templateName : 'Default hardcoded template'}`);
          } catch (templateError) {
            console.log(`âŒ Error loading template: ${templateError.message}, using default`);
          }

          let htmlContent, textContent;
          
          if (emailTemplate) {
            // Use template from database with variable substitution
            htmlContent = emailTemplate.htmlContent
              .replace(/\{\{customer_name\}\}/g, inquiry.contactName || 'Valued Customer')
              .replace(/\{\{inquiry_number\}\}/g, inquiry.inquiryNumber)
              .replace(/\{\{inquiry_subject\}\}/g, inquiry.subject || 'Product Inquiry')
              .replace(/\{\{inquiry_category\}\}/g, inquiry.category || 'General')
              .replace(/\{\{response_text\}\}/g, responseText);
              
            textContent = emailTemplate.textContent || `
Follow-up Response - Momtaz Chemical

Dear ${inquiry.contactName || 'Valued Customer'},

Thank you for your inquiry. We have prepared a follow-up response regarding your request.

Your Original Inquiry:
Inquiry Number: ${inquiry.inquiryNumber}
Subject: ${inquiry.subject || 'Product Inquiry'}
Category: ${inquiry.category || 'General'}

Our Response:
${responseText}

Need Further Assistance?
If you have any additional questions or need clarification, please don't hesitate to contact us:
- Email: info@momtazchem.com
- Phone: +964 771 234 5678
- Website: www.momtazchem.com

Best regards,
Momtaz Chemical Team
Leading Chemical Solutions Provider
            `;
          } else {
            // Fallback to hardcoded template with updated phone number
            htmlContent = `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; text-align: center;">
                  <h1 style="margin: 0; font-size: 24px;">Momtaz Chemical</h1>
                  <p style="margin: 5px 0 0 0; opacity: 0.9;">Follow-up Response</p>
                </div>
                
                <div style="padding: 30px; background-color: #f9f9f9;">
                  <p style="font-size: 16px; color: #333; margin-bottom: 20px;">
                    Dear ${inquiry.contactName || 'Valued Customer'},
                  </p>
                  
                  <p style="color: #666; margin-bottom: 15px;">
                    Thank you for your inquiry. We have prepared a follow-up response regarding your request:
                  </p>
                  
                  <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #667eea;">
                    <h3 style="color: #333; margin-top: 0;">Your Original Inquiry:</h3>
                    <p style="color: #666; margin-bottom: 15px;"><strong>Inquiry Number:</strong> ${inquiry.inquiryNumber}</p>
                    <p style="color: #666; margin-bottom: 15px;"><strong>Subject:</strong> ${inquiry.subject || 'Product Inquiry'}</p>
                    <p style="color: #666;"><strong>Category:</strong> ${inquiry.category || 'General'}</p>
                  </div>
                  
                  <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #28a745;">
                    <h3 style="color: #333; margin-top: 0;">Our Response:</h3>
                    <p style="color: #444; line-height: 1.6; white-space: pre-wrap;">${responseText}</p>
                  </div>
                  
                  <div style="margin-top: 30px; padding: 20px; background: #e8f4f8; border-radius: 8px;">
                    <h4 style="color: #333; margin-top: 0;">Need Further Assistance?</h4>
                    <p style="color: #666; margin-bottom: 15px;">
                      If you have any additional questions or need clarification, please don't hesitate to contact us:
                    </p>
                    <ul style="color: #666; margin: 0;">
                      <li>Email: info@momtazchem.com</li>
                      <li>Phone: +964 771 234 5678</li>
                      <li>Website: www.momtazchem.com</li>
                    </ul>
                  </div>
                  
                  <p style="color: #888; font-size: 14px; margin-top: 30px; text-align: center;">
                    Best regards,<br>
                    <strong>Momtaz Chemical Team</strong><br>
                    Leading Chemical Solutions Provider
                  </p>
                </div>
              </div>
            `;
            
            textContent = `
Follow-up Response - Momtaz Chemical

Dear ${inquiry.contactName || 'Valued Customer'},

Thank you for your inquiry. We have prepared a follow-up response regarding your request.

Your Original Inquiry:
Inquiry Number: ${inquiry.inquiryNumber}
Subject: ${inquiry.subject || 'Product Inquiry'}
Category: ${inquiry.category || 'General'}

Our Response:
${responseText}

Need Further Assistance?
If you have any additional questions or need clarification, please don't hesitate to contact us:
- Email: info@momtazchem.com
- Phone: +964 771 234 5678
- Website: www.momtazchem.com

Best regards,
Momtaz Chemical Team
Leading Chemical Solutions Provider
            `;
          }

          // Use multilingual email service if language preference is available
          if (customerLanguage && customerLanguage !== 'en') {
            try {
              const { emailService } = await import('./email-service');
              const { getLocalizedEmailSubject } = await import('./multilingual-messages');
              
              // Get localized subject line for inquiry response
              const localizedSubject = getLocalizedEmailSubject('inquiryResponse', customerLanguage);
              
              const emailSent = await emailService.sendLocalizedEmail(
                inquiry.contactEmail,
                'inquiryResponse',
                customerLanguage,
                {
                  customerName: inquiry.contactName || 'Valued Customer',
                  inquiryNumber: inquiry.inquiryNumber,
                  inquirySubject: inquiry.subject || 'Product Inquiry',
                  inquiryCategory: inquiry.category || 'General',
                  responseText
                },
                emailCategory,
                localizedSubject + ` - ${inquiry.inquiryNumber}`
              );
              
              if (emailSent) {
                console.log(`ðŸ“§ Multilingual follow-up email sent successfully to: ${inquiry.contactEmail} in ${customerLanguage}`);
              } else {
                throw new Error('Multilingual email sending failed');
              }
            } catch (multilingualError) {
              console.log(`âŒ Multilingual email failed, using standard template: ${multilingualError.message}`);
              // Fallback to standard email
              await transporter.sendMail({
                from: `${smtp.fromName} <${smtp.fromEmail}>`,
                to: inquiry.contactEmail,
                subject: `Follow-up: ${inquiry.subject || 'Your Inquiry'} - ${inquiry.inquiryNumber}`,
                html: htmlContent,
                text: textContent
              });
            }
          } else {
            // Send standard email
            await transporter.sendMail({
              from: `${smtp.fromName} <${smtp.fromEmail}>`,
              to: inquiry.contactEmail,
              subject: `Follow-up: ${inquiry.subject || 'Your Inquiry'} - ${inquiry.inquiryNumber}`,
              html: htmlContent,
              text: textContent
            });
          }

          console.log(`Follow-up email sent successfully to: ${inquiry.contactEmail}`);
        }
      } catch (emailError) {
        console.error('Error sending follow-up email:', emailError);
        // Don't fail the response creation if email fails
      }

      // Update inquiry status to 'in_progress' if it was 'open'
      if (inquiry.status === 'open') {
        await simpleCustomerStorage.updateInquiry(id, { status: 'in_progress' });
      }

      res.json({
        success: true,
        message: "Follow-up response sent successfully to customer's email",
        response
      });
    } catch (error) {
      console.error("Error creating inquiry response:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create response"
      });
    }
  });

  // Update inquiry status (admin only)
  app.patch("/api/inquiries/:id/status", requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid inquiry ID"
        });
      }

      const { status } = req.body;
      if (!status) {
        return res.status(400).json({
          success: false,
          message: "Status is required"
        });
      }

      // Validate status values
      const validStatuses = ['open', 'in_progress', 'resolved', 'closed'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({
          success: false,
          message: "Invalid status value"
        });
      }

      const updatedInquiry = await simpleCustomerStorage.updateInquiryStatus(id, status);
      
      res.json({
        success: true,
        message: "Inquiry status updated successfully",
        inquiry: updatedInquiry
      });
    } catch (error) {
      console.error("Error updating inquiry status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update inquiry status"
      });
    }
  });

  // Quote request routes (public)
  app.post("/api/quote-requests", async (req, res) => {
    try {
      const { firstName, lastName, email, phone, company, productName, category, quantity, urgency, message } = req.body;
      
      if (!firstName || !lastName || !email || !productName || !company) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields"
        });
      }

      // Generate quote number
      const quoteNumber = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      const quoteRequest = await customerStorage.createQuoteRequest({
        quoteNumber,
        contactEmail: email,
        contactPhone: phone,
        company,
        deliveryLocation: "To be determined",
        requestedProducts: [{
          name: productName,
          category: category || "general",
          quantity: quantity || "To be discussed",
          urgency: urgency || "normal"
        }],
        specialRequirements: message || "",
        priority: urgency || "normal",
        notes: `Contact: ${firstName} ${lastName}`,
      });

      // Auto-capture customer data in CRM system
      try {
        // Check if customer exists in CRM
        let existingCustomer = await crmStorage.getCrmCustomerByEmail(email);

        if (existingCustomer) {
          // Log quote request activity for existing customer
          await crmStorage.logCustomerActivity({
            customerId: existingCustomer.id,
            activityType: 'quote_request',
            description: `Quote requested for ${productName} - Category: ${category || 'general'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_quote_form',
              productName: productName,
              category: category,
              quantity: quantity,
              urgency: urgency,
              quoteNumber: quoteRequest.quoteNumber,
              message: message
            }
          });
          console.log(`âœ… Quote request logged to existing CRM customer: ${email}`);
        } else {
          // Create new CRM customer from quote request
          const newCrmCustomer = await crmStorage.createCrmCustomer({
            email: email,
            firstName: firstName,
            lastName: lastName,
            company: company,
            phone: phone || null,
            customerType: 'prospect',
            customerSource: 'website_quote',
            isActive: true,
            passwordHash: '', // Will be set when customer creates account
          });

          // Log initial quote request activity
          await crmStorage.logCustomerActivity({
            customerId: newCrmCustomer.id,
            activityType: 'first_contact',
            description: `First contact via quote request: ${productName} - Category: ${category || 'general'}`,
            performedBy: 'system',
            activityData: {
              source: 'website_quote_form',
              productName: productName,
              category: category,
              quantity: quantity,
              urgency: urgency,
              quoteNumber: quoteRequest.quoteNumber,
              message: message
            }
          });
          console.log(`âœ… New CRM customer created from quote request: ${email}`);
        }
      } catch (crmError) {
        console.error("âŒ Error auto-capturing customer in CRM from quote request:", crmError);
        // Don't fail the quote request if CRM capture fails
      }

      res.json({
        success: true,
        message: "Quote request submitted successfully",
        quoteNumber: quoteRequest.quoteNumber
      });
    } catch (error) {
      console.error("Error creating quote request:", error);
      res.status(500).json({
        success: false,
        message: "Failed to submit quote request"
      });
    }
  });

  // Inventory monitoring routes
  app.post("/api/inventory/check-all", requireAuth, async (req, res) => {
    try {
      await InventoryAlertService.checkInventoryLevels();
      res.json({
        success: true,
        message: "Inventory check completed and alerts sent if needed"
      });
    } catch (error) {
      console.error("Error checking inventory:", error);
      res.status(500).json({
        success: false,
        message: "Failed to check inventory levels"
      });
    }
  });

  app.post("/api/inventory/check-product/:id", requireAuth, async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      const alertSent = await InventoryAlertService.checkProductInventory(productId);
      
      res.json({
        success: true,
        alertSent,
        message: alertSent ? "Alert sent for low stock" : "Stock levels are adequate"
      });
    } catch (error) {
      console.error("Error checking product inventory:", error);
      res.status(500).json({
        success: false,
        message: "Failed to check product inventory"
      });
    }
  });





  // SMTP Configuration Validator
  app.post("/api/admin/validate-smtp", requireAuth, async (req, res) => {
    try {
      const { email, password, customHost, customPort, categoryId } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: "Email and password are required"
        });
      }

      const { SMTPValidator } = await import('./smtp-validator');
      const result = await SMTPValidator.validateConfiguration(
        email, 
        password, 
        customHost, 
        customPort
      );
      
      // Update database with test result if categoryId is provided
      if (categoryId) {
        console.log(`ðŸ”„ Attempting to update SMTP test status for category ${categoryId}`);
        const { emailStorage } = await import("./email-storage");
        try {
          const smtp = await emailStorage.getSmtpSettingByCategory(categoryId);
          console.log(`ðŸ“§ Found SMTP setting:`, smtp);
          if (smtp) {
            const updateResult = await emailStorage.updateSmtpSetting(smtp.id, {
              testStatus: result.isValid ? "success" : "failed",
              lastTested: new Date()
            });
            console.log(`âœ… Updated SMTP test status for category ${categoryId}: ${result.isValid ? "success" : "failed"}`, updateResult);
          } else {
            console.log(`âŒ No SMTP setting found for category ${categoryId}`);
          }
        } catch (dbError) {
          console.error("âŒ Error updating SMTP test status:", dbError);
        }
      } else {
        console.log("âš ï¸ No categoryId provided for SMTP test update");
      }
      
      res.json({
        success: result.isValid,
        ...result
      });
    } catch (error) {
      console.error("Error validating SMTP:", error);
      res.status(500).json({
        success: false,
        message: "Failed to validate SMTP configuration"
      });
    }
  });

  // Initialize default email categories if they don't exist
  app.post("/api/admin/email/init-categories", requireAuth, async (req, res) => {
    try {
      const defaultCategories = [
        {
          categoryKey: "admin",
          categoryName: "Admin & General Contact",
          description: "Main administrative and general contact email",
        },
        {
          categoryKey: "fuel-additives",
          categoryName: "Fuel Additives Department",
          description: "Dedicated email for fuel additives inquiries and orders",
        },
        {
          categoryKey: "water-treatment",
          categoryName: "Water Treatment Department",
          description: "Dedicated email for water treatment solutions",
        },
        {
          categoryKey: "agricultural-fertilizers",
          categoryName: "Agricultural Fertilizers Department",
          description: "Dedicated email for fertilizer products and agricultural solutions",
        },
        {
          categoryKey: "paint-thinner",
          categoryName: "Paint & Thinner Department",
          description: "Dedicated email for paint and thinner products",
        },
        {
          categoryKey: "orders",
          categoryName: "Order Processing",
          description: "Handles order confirmations and processing",
        },
        {
          categoryKey: "notifications",
          categoryName: "System Notifications",
          description: "Receives system alerts and notifications",
        }
      ];

      const createdCategories = [];
      
      for (const categoryData of defaultCategories) {
        const existing = await emailStorage.getCategoryByKey(categoryData.categoryKey);
        if (!existing) {
          const category = await emailStorage.createCategory(categoryData);
          createdCategories.push(category);
        }
      }

      res.json({
        success: true,
        message: `Initialized ${createdCategories.length} categories`,
        categories: createdCategories
      });
    } catch (error) {
      console.error("Error initializing categories:", error);
      res.status(500).json({
        success: false,
        message: "Failed to initialize categories"
      });
    }
  });

  // Get all email categories with their settings
  app.get("/api/admin/email/categories", requireAuth, async (req, res) => {
    try {
      const categories = await emailStorage.getCategories();
      const categoriesWithSettings = [];

      for (const category of categories) {
        const smtp = await emailStorage.getSmtpSettingByCategory(category.id);
        const recipients = await emailStorage.getRecipientsByCategory(category.id);
        
        categoriesWithSettings.push({
          ...category,
          smtp: smtp || null,
          recipients
        });
      }

      res.json({
        success: true,
        categories: categoriesWithSettings
      });
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch categories"
      });
    }
  });

  // Create/Update SMTP settings for a category
  app.post("/api/admin/email/smtp/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      console.log("Received SMTP data:", req.body);
      
      // Manual validation instead of strict schema
      const {
        host,
        port,
        secure,
        username,
        password,
        fromName,
        fromEmail
      } = req.body;

      if (!host || !username || !password || !fromName || !fromEmail) {
        return res.status(400).json({
          success: false,
          message: "All SMTP fields are required"
        });
      }

      const smtpData = {
        host: host.toString(),
        port: parseInt(port) || 587,
        secure: Boolean(secure),
        username: username.toString(),
        password: password.toString(),
        fromName: fromName.toString(),
        fromEmail: fromEmail.toString(),
        categoryId: parseInt(categoryId)
      };

      console.log("Processed SMTP data:", smtpData);
      
      // Check if SMTP settings already exist for this category
      const existing = await emailStorage.getSmtpSettingByCategory(parseInt(categoryId));
      
      let smtp;
      if (existing) {
        console.log("Updating existing SMTP settings");
        smtp = await emailStorage.updateSmtpSetting(existing.id, smtpData);
      } else {
        console.log("Creating new SMTP settings");
        smtp = await emailStorage.createSmtpSetting(smtpData);
      }

      res.json({
        success: true,
        message: "SMTP settings saved successfully",
        smtp
      });
    } catch (error) {
      console.error("Error saving SMTP settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save SMTP settings",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Test SMTP connection for a category
  app.post("/api/admin/email/test-smtp/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      const smtp = await emailStorage.getSmtpSettingByCategory(parseInt(categoryId));
      
      if (!smtp) {
        return res.status(404).json({
          success: false,
          message: "SMTP settings not found for this category"
        });
      }

      const success = await emailStorage.testSmtpConnection(smtp.id);
      
      res.json({
        success,
        message: success ? "SMTP connection test successful" : "SMTP connection test failed"
      });
    } catch (error) {
      console.error("SMTP test failed:", error);
      res.status(500).json({
        success: false,
        message: `SMTP test failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  });

  // Add/Update email recipients for a category
  app.post("/api/admin/email/recipients/:categoryId", requireAuth, async (req, res) => {
    try {
      const { categoryId } = req.params;
      const { recipients } = req.body;
      
      // Validate categoryId
      const categoryIdNum = parseInt(categoryId);
      if (isNaN(categoryIdNum)) {
        return res.status(400).json({
          success: false,
          message: "Invalid category ID"
        });
      }
      
      // Delete existing recipients for this category
      const existingRecipients = await emailStorage.getRecipientsByCategory(categoryIdNum);
      for (const recipient of existingRecipients) {
        await emailStorage.deleteRecipient(recipient.id);
      }
      
      // Add new recipients
      const createdRecipients = [];
      for (const recipientData of recipients) {
        // Clean the recipient data to remove any invalid fields
        const cleanedData = {
          email: recipientData.email,
          name: recipientData.name || null,
          isPrimary: Boolean(recipientData.isPrimary),
          isActive: Boolean(recipientData.isActive !== false), // default to true
          receiveTypes: Array.isArray(recipientData.receiveTypes) ? recipientData.receiveTypes : [],
          recipientType: recipientData.recipientType || 'to', // 'to', 'cc', 'bcc'
          categoryId: categoryIdNum
        };
        
        const recipient = await emailStorage.createRecipient(cleanedData);
        createdRecipients.push(recipient);
      }

      res.json({
        success: true,
        message: "Recipients updated successfully",
        recipients: createdRecipients
      });
    } catch (error) {
      console.error("Error updating recipients:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update recipients",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Legacy endpoint for compatibility
  app.get("/api/admin/email-settings", requireAuth, async (req, res) => {
    try {
      const categories = await emailStorage.getCategories();
      const emailSettings = [];

      for (const category of categories) {
        const recipients = await emailStorage.getRecipientsByCategory(category.id);
        const primaryRecipient = recipients.find(r => r.isPrimary);
        
        emailSettings.push({
          id: category.id,
          category: category.categoryKey,
          name: category.categoryName,
          description: category.description,
          emailAddress: primaryRecipient?.email || "info@momtazchem.com",
          isActive: category.isActive,
          isPrimary: category.categoryKey === "admin",
          usage: recipients.flatMap(r => r.receiveTypes || [])
        });
      }

      // Get SMTP settings from database only
      const smtpSettings = null; // No fallback - only use database settings

      res.json({
        success: true,
        emailSettings,
        smtpSettings
      });
    } catch (error) {
      console.error("Error fetching email settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch email settings"
      });
    }
  });

  app.post("/api/admin/email-settings", requireAuth, async (req, res) => {
    try {
      const { emailSettings } = req.body;
      
      // In a real implementation, you would save these to database
      // For now, we'll just return success
      console.log("Email settings updated:", emailSettings);
      
      res.json({
        success: true,
        message: "Email settings saved successfully"
      });
    } catch (error) {
      console.error("Error saving email settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save email settings"
      });
    }
  });

  app.post("/api/admin/smtp-settings", requireAuth, async (req, res) => {
    try {
      const { host, port, secure, user, pass, fromName, fromEmail } = req.body;
      
      // In a real implementation, you would save these to environment or database
      console.log("SMTP settings updated:", { host, port, secure, user, fromName, fromEmail });
      
      res.json({
        success: true,
        message: "SMTP settings saved successfully"
      });
    } catch (error) {
      console.error("Error saving SMTP settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save SMTP settings"
      });
    }
  });

  app.post("/api/admin/test-smtp", requireAuth, async (req, res) => {
    try {
      const { host, port, secure, user, pass } = req.body;
      
      if (!host || !port || !user || !pass) {
        return res.status(400).json({
          success: false,
          message: "All SMTP fields are required for testing"
        });
      }

      // Nodemailer is already imported at the top
      
      const transporter = nodemailer.createTransport({
        host,
        port: parseInt(port),
        secure: secure || port == 465,
        auth: {
          user,
          pass,
        },
        connectionTimeout: 10000,
        greetingTimeout: 5000,
      });

      await transporter.verify();
      
      res.json({
        success: true,
        message: "SMTP connection test successful"
      });
    } catch (error) {
      console.error("SMTP test failed:", error);
      res.status(500).json({
        success: false,
        message: `SMTP test failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  });

  // Detect email provider
  app.post("/api/admin/detect-provider", requireAuth, async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({
          success: false,
          message: "Email is required"
        });
      }

      const { SMTPValidator } = await import('./smtp-validator');
      const provider = SMTPValidator.detectProvider(email);
      const config = SMTPValidator.generateOptimalConfig(email);
      
      res.json({
        success: true,
        provider,
        recommendedConfig: config
      });
    } catch (error) {
      console.error("Error detecting provider:", error);
      res.status(500).json({
        success: false,
        message: "Failed to detect email provider"
      });
    }
  });

  // =============================================================================
  // CRM ROUTES - Professional Customer Relationship Management
  // =============================================================================

  // Get CRM dashboard statistics
  app.get("/api/crm/dashboard", requireAuth, async (req, res) => {
    try {
      const stats = await crmStorage.getCrmDashboardStats();
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching CRM dashboard stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch dashboard statistics"
      });
    }
  });

  // Get all CRM customers with pagination
  app.get("/api/crm/customers", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      
      const customers = await crmStorage.getCrmCustomers(limit, offset);
      res.json({
        success: true,
        data: customers,
        pagination: {
          limit,
          offset,
          count: customers.length
        }
      });
    } catch (error) {
      console.error("Error fetching CRM customers:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch customers"
      });
    }
  });

  // Search CRM customers
  app.get("/api/crm/customers/search", requireAuth, async (req, res) => {
    try {
      const query = req.query.q as string;
      if (!query || query.length < 2) {
        return res.status(400).json({
          success: false,
          message: "Search query must be at least 2 characters"
        });
      }

      const customers = await crmStorage.searchCrmCustomers(query);
      res.json({
        success: true,
        data: customers
      });
    } catch (error) {
      console.error("Error searching CRM customers:", error);
      res.status(500).json({
        success: false,
        message: "Failed to search customers"
      });
    }
  });

  // Search CRM customers by phone for dropdown suggestions
  app.get("/api/crm/customers/search-phone/:phone", requireAuth, async (req, res) => {
    try {
      const phone = decodeURIComponent(req.params.phone);
      
      if (!phone || phone.length < 3) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const customers = await crmStorage.searchCrmCustomersByPhone(phone);
      
      // Format customers for dropdown
      const formattedCustomers = customers.map(customer => ({
        id: customer.id,
        phone: customer.phone,
        firstName: customer.firstName || customer.first_name,
        lastName: customer.lastName || customer.last_name,
        email: customer.email,
        displayName: `${customer.firstName || customer.first_name} ${customer.lastName || customer.last_name}`,
        displayText: `${customer.phone} - ${customer.firstName || customer.first_name} ${customer.lastName || customer.last_name}`
      }));

      res.json({
        success: true,
        customers: formattedCustomers,
        count: formattedCustomers.length,
        message: `${formattedCustomers.length} Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error searching customers by phone:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†"
      });
    }
  });

  // Get CRM customer by phone number
  app.get("/api/crm/customers/by-phone/:phone", requireAuth, async (req, res) => {
    try {
      const phone = decodeURIComponent(req.params.phone);
      
      if (!phone || phone.length < 3) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      const customer = await crmStorage.getCrmCustomerByPhone(phone);
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Ù…Ø´ØªØ±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Map database fields to frontend expected format - ensure proper field mapping
      const formattedCustomer = {
        ...customer,
        firstName: customer.firstName || customer.first_name,
        lastName: customer.lastName || customer.last_name,
        // Keep original fields for debugging
        first_name: customer.first_name,
        last_name: customer.last_name
      };
      
      console.log('[CUSTOMER LOOKUP] Original customer:', customer);
      console.log('[CUSTOMER LOOKUP] Formatted customer:', formattedCustomer);

      res.json({
        success: true,
        customer: formattedCustomer,
        message: "Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error fetching customer by phone:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ"
      });
    }
  });

  // Get specific CRM customer by ID
  app.get("/api/crm/customers/:id", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Customer not found"
        });
      }

      // Get customer analytics
      const analytics = await crmStorage.getCustomerAnalytics(customerId);
      
      // Get customer activities
      const activities = await crmStorage.getCustomerActivities(customerId, 20);

      res.json({
        success: true,
        data: {
          customer,
          analytics,
          activities
        }
      });
    } catch (error) {
      console.error("Error fetching CRM customer:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch customer"
      });
    }
  });

  // Create new CRM customer (enhanced with password handling)
  app.post("/api/crm/customers", requireAuth, async (req, res) => {
    try {
      const { password, ...customerData } = req.body;
      
      // Hash password if provided
      let passwordHash = '';
      if (password && password.trim()) {
        passwordHash = await bcrypt.hash(password.trim(), 10);
      }
      
      // Validate mandatory fields
      if (!customerData.email || !customerData.phone || !customerData.country || !customerData.city || !customerData.address) {
        return res.status(400).json({
          success: false,
          message: "Ø§ÛŒÙ…ÛŒÙ„ØŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†ØŒ Ú©Ø´ÙˆØ±ØŒ Ø´Ù‡Ø± Ùˆ Ø¢Ø¯Ø±Ø³ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ù‡Ø³ØªÙ†Ø¯"
        });
      }

      const validatedData = {
        ...customerData,
        passwordHash,
        createdBy: "admin",
        isActive: true,
        customerStatus: customerData.customerStatus || "active",
        emailVerified: false,
      };
      
      // Create CRM customer
      const crmCustomer = await crmStorage.createCrmCustomer(validatedData);
      
      // Also create in customer portal system if password provided
      if (passwordHash) {
        try {
          const portalCustomer = await customerStorage.createCustomer({
            ...validatedData,
            crmCustomerId: crmCustomer.id,
          });
          
          // Log activity
          await crmStorage.logCustomerActivity({
            customerId: crmCustomer.id,
            activityType: 'created',
            description: 'Customer created with portal access from CRM',
            performedBy: 'admin',
            activityData: { hasPortalAccess: true, portalCustomerId: portalCustomer.id }
          });
        } catch (portalError) {
          console.log('Portal customer creation failed, continuing with CRM-only customer');
        }
      }
      
      res.status(201).json({
        success: true,
        data: crmCustomer
      });
    } catch (error: any) {
      console.error("Error creating CRM customer:", error);
      // Check if it's a duplicate error message
      if (error.message && (error.message.includes("Ø§ÛŒÙ…ÛŒÙ„ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª") || error.message.includes("Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª"))) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      res.status(500).json({
        success: false,
        message: "Failed to create customer"
      });
    }
  });

  // Update CRM customer
  app.put("/api/crm/customers/:id", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const updateData = req.body;
      
      const customer = await crmStorage.updateCrmCustomer(customerId, updateData);
      res.json({
        success: true,
        data: customer
      });
    } catch (error: any) {
      console.error("Error updating CRM customer:", error);
      // Check if it's a duplicate error message
      if (error.message && (error.message.includes("Ø§ÛŒÙ…ÛŒÙ„ ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª") || error.message.includes("Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª"))) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      res.status(500).json({
        success: false,
        message: "Failed to update customer"
      });
    }
  });

  // Delete CRM customer
  app.delete("/api/crm/customers/:id", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      
      await crmStorage.deleteCrmCustomer(customerId);
      res.json({
        success: true,
        message: "Customer deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting CRM customer:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete customer"
      });
    }
  });

  // Bulk toggle verification settings for all customers
  app.post("/api/crm/customers/bulk-toggle-verification", async (req, res) => {
    try {
      const { type, enabled } = req.body;
      
      if (!type || (type !== 'sms' && type !== 'email')) {
        return res.status(400).json({
          success: false,
          message: "Ù†ÙˆØ¹ Ø¨Ø§ÛŒØ¯ 'sms' ÛŒØ§ 'email' Ø¨Ø§Ø´Ø¯"
        });
      }

      if (typeof enabled !== 'boolean') {
        return res.status(400).json({
          success: false,
          message: "ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ø§Ù„/ØºÛŒØ±ÙØ¹Ø§Ù„ Ø¨Ø§ÛŒØ¯ boolean Ø¨Ø§Ø´Ø¯"
        });
      }

      const { pool } = await import('./db');
      
      // Determine which field to update
      const fieldToUpdate = type === 'sms' ? 'sms_enabled' : 'email_enabled';
      
      // Update all customers
      const result = await pool.query(`
        UPDATE crm_customers 
        SET ${fieldToUpdate} = $1,
            updated_at = CURRENT_TIMESTAMP
        WHERE is_active = true
      `, [enabled]);

      const updatedCount = result.rowCount || 0;
      
      console.log(`ðŸ“¢ Bulk ${type} verification ${enabled ? 'enabled' : 'disabled'} for ${updatedCount} customers`);

      res.json({
        success: true,
        message: `ØªÙ†Ø¸ÛŒÙ…Ø§Øª ${type === 'sms' ? 'SMS' : 'Ø§ÛŒÙ…ÛŒÙ„'} Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù…Ø´ØªØ±ÛŒØ§Ù† ${enabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯`,
        updatedCount
      });
    } catch (error) {
      console.error("Error bulk toggling verification:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÛŒÚ©Ø¬Ø§"
      });
    }
  });

  // Log customer activity
  app.post("/api/crm/customers/:id/activities", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { activityType, description, activityData } = req.body;
      
      const activity = await crmStorage.logCustomerActivity({
        customerId,
        activityType,
        description,
        activityData,
        performedBy: "admin"
      });

      res.status(201).json({
        success: true,
        data: activity
      });
    } catch (error) {
      console.error("Error logging customer activity:", error);
      res.status(500).json({
        success: false,
        message: "Failed to log activity"
      });
    }
  });

  // Get customer activities
  app.get("/api/crm/customers/:id/activities", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const limit = parseInt(req.query.limit as string) || 20;
      
      const activities = await crmStorage.getCustomerActivities(customerId, limit);
      res.json({
        success: true,
        data: activities
      });
    } catch (error) {
      console.error("Error fetching customer activities:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch activities"
      });
    }
  });

  // Duplicate route removed - using main route at line 2959

  // Customer profile update endpoint
  app.put("/api/customers/profile", async (req: Request, res: Response) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({
          success: false,
          message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡"
        });
      }

      const {
        firstName,
        lastName,
        phone,
        company,
        country,
        city,
        address,
        postalCode,
        businessType,
        notes
      } = req.body;

      // Validate required fields
      if (!firstName || !lastName || !phone || !country || !city || !address) {
        return res.status(400).json({
          success: false,
          message: "ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø§Ø¬Ø¨Ø§Ø±ÛŒ Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯"
        });
      }

      // Update customer profile in CRM
      const updatedCustomer = await crmStorage.updateCrmCustomer(customerId, {
        firstName,
        lastName,
        phone,
        company: company || null,
        country,
        city,
        address,
        postalCode: postalCode || null,
        businessType: businessType || null
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId,
        activityType: 'profile_updated',
        description: `Customer updated their profile information`,
        performedBy: 'Customer'
      });

      res.json({
        success: true,
        message: "Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        customer: updatedCustomer
      });

    } catch (error) {
      console.error("Error updating customer profile:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„"
      });
    }
  });

  // Create customer segment
  app.post("/api/crm/segments", requireAuth, async (req, res) => {
    try {
      const { name, description, criteria } = req.body;
      
      const segment = await crmStorage.createCustomerSegment({
        name,
        description,
        criteria
      });

      res.status(201).json({
        success: true,
        data: segment
      });
    } catch (error) {
      console.error("Error creating customer segment:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create segment"
      });
    }
  });

  // Get all customer segments
  app.get("/api/crm/segments", requireAuth, async (req, res) => {
    try {
      const segments = await crmStorage.getCustomerSegments();
      res.json({
        success: true,
        data: segments
      });
    } catch (error) {
      console.error("Error fetching customer segments:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch segments"
      });
    }
  });

  // =============================================================================
  // CONTACT SALES AND QUOTE REQUEST ENDPOINTS
  // =============================================================================

  // Contact sales team
  app.post("/api/contact/sales", async (req, res) => {
    try {
      const { name, email, company, phone, message, type } = req.body;

      if (!name || !email || !message) {
        return res.status(400).json({
          success: false,
          message: "Name, email, and message are required"
        });
      }

      // Send email to sales team using direct nodemailer approach
      try {
        const nodemailer = await import('nodemailer');
        const { emailStorage } = await import('./email-storage');
        
        // Get admin SMTP settings
        const categorySettings = await emailStorage.getCategoryWithSettings('admin');
        
        if (!categorySettings?.smtp) {
          throw new Error('No SMTP configuration found');
        }

        const smtp = categorySettings.smtp;
        
        // Create transporter
        const transporter = nodemailer.createTransport({
          host: smtp.host,
          port: smtp.port,
          secure: smtp.port === 465,
          auth: {
            user: smtp.username,
            pass: smtp.password,
          },
        });

        // Send email directly to sales team
        await transporter.sendMail({
          from: `${smtp.fromName} <${smtp.fromEmail}>`,
          to: "sales@momtazchem.com",
          replyTo: email,
          subject: "New Sales Inquiry from Website",
          html: `
            <h2>New Sales Inquiry</h2>
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Company:</strong> ${company || 'Not specified'}</p>
            <p><strong>Phone:</strong> ${phone || 'Not provided'}</p>
            <p><strong>Message:</strong></p>
            <p>${message}</p>
          `,
          text: `
New Sales Inquiry

Name: ${name}
Email: ${email}
Company: ${company || 'Not specified'}
Phone: ${phone || 'Not provided'}

Message:
${message}
          `
        });

        // Also log this as a CRM activity if we can match to existing customer
        try {
          const existingCustomer = await crmStorage.getCrmCustomerByEmail(email);
          if (existingCustomer) {
            await crmStorage.logCustomerActivity({
              customerId: existingCustomer.id,
              activityType: 'contact_form',
              description: `Sales inquiry submitted via website: ${message.substring(0, 100)}...`,
              activityData: {
                source: 'website_contact_form',
                contactType: 'sales_inquiry',
                company: company,
                phone: phone,
                fullMessage: message
              }
            });
          } else {
            // Create new CRM customer for this inquiry
            const newCrmCustomer = await crmStorage.createCrmCustomer({
              firstName: name.split(' ')[0] || name,
              lastName: name.split(' ').slice(1).join(' ') || '',
              email: email,
              company: company || null,
              phone: phone || null,
              customerType: 'prospect'
            });

            await crmStorage.logCustomerActivity({
              customerId: newCrmCustomer.id,
              activityType: 'contact_form',
              description: `First contact via sales inquiry form: ${message.substring(0, 100)}...`,
              activityData: {
                source: 'website_contact_form',
                contactType: 'sales_inquiry',
                company: company,
                phone: phone,
                fullMessage: message
              }
            });
          }
        } catch (crmError) {
          console.error("Error logging to CRM:", crmError);
          // Don't fail the request if CRM logging fails
        }

        res.json({
          success: true,
          message: "Your message has been sent to our sales team. We'll contact you within 24 hours."
        });
      } catch (emailError) {
        console.error("Error sending sales contact email:", emailError);
        res.status(500).json({
          success: false,
          message: "Failed to send message. Please try again or contact us directly."
        });
      }
    } catch (error) {
      console.error("Error in sales contact endpoint:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // Quote request
  app.post("/api/contact/quote", async (req, res) => {
    try {
      const { 
        name, 
        email, 
        company, 
        phone, 
        productCategory, 
        quantity, 
        specifications, 
        timeline, 
        message 
      } = req.body;

      if (!name || !email || !company || !productCategory || !quantity || !specifications) {
        return res.status(400).json({
          success: false,
          message: "Name, email, company, product category, quantity, and specifications are required"
        });
      }

      // Send detailed quote request email to sales team using direct approach
      try {
        const nodemailer = await import('nodemailer');
        const { emailStorage } = await import('./email-storage');
        
        // Get admin SMTP settings
        const categorySettings = await emailStorage.getCategoryWithSettings('admin');
        
        if (!categorySettings?.smtp) {
          throw new Error('No SMTP configuration found');
        }

        const smtp = categorySettings.smtp;
        
        // Create transporter
        const transporter = nodemailer.createTransport({
          host: smtp.host,
          port: smtp.port,
          secure: smtp.port === 465,
          auth: {
            user: smtp.username,
            pass: smtp.password,
          },
        });

        // Send quote request email
        await transporter.sendMail({
          from: `${smtp.fromName} <${smtp.fromEmail}>`,
          to: "sales@momtazchem.com",
          replyTo: email,
          subject: `New Quote Request - ${productCategory}`,
          html: `
            <h2>New Quote Request</h2>
            <h3>Customer Information</h3>
            <p><strong>Name:</strong> ${name}</p>
            <p><strong>Email:</strong> ${email}</p>
            <p><strong>Company:</strong> ${company}</p>
            <p><strong>Phone:</strong> ${phone || 'Not provided'}</p>
            
            <h3>Product Requirements</h3>
            <p><strong>Product Category:</strong> ${productCategory}</p>
            <p><strong>Quantity:</strong> ${quantity}</p>
            <p><strong>Timeline:</strong> ${timeline || 'Not specified'}</p>
            
            <h3>Specifications</h3>
            <p>${specifications}</p>
            
            ${message ? `<h3>Additional Requirements</h3><p>${message}</p>` : ''}
          `,
          text: `
New Quote Request

Customer Information:
Name: ${name}
Email: ${email}
Company: ${company}
Phone: ${phone || 'Not provided'}

Product Requirements:
Product Category: ${productCategory}
Quantity: ${quantity}
Timeline: ${timeline || 'Not specified'}

Specifications:
${specifications}

${message ? `Additional Requirements:\n${message}` : ''}
          `
        });

        // Log this in CRM system
        try {
          let crmCustomer = await crmStorage.getCrmCustomerByEmail(email);
          
          if (!crmCustomer) {
            // Create new CRM customer for this quote request
            crmCustomer = await crmStorage.createCrmCustomer({
              firstName: name.split(' ')[0] || name,
              lastName: name.split(' ').slice(1).join(' ') || '',
              email: email,
              company: company,
              phone: phone || null,
              customerType: 'prospect'
            });
          }

          await crmStorage.logCustomerActivity({
            customerId: crmCustomer.id,
            activityType: 'quote_request',
            description: `Quote requested for ${productCategory} - Qty: ${quantity}`,
            activityData: {
              source: 'website_quote_form',
              productCategory: productCategory,
              quantity: quantity,
              specifications: specifications,
              timeline: timeline,
              additionalMessage: message,
              estimatedValue: 0 // Could be calculated based on product category
            }
          });

          // Update customer metrics
          await crmStorage.updateCustomerMetrics(crmCustomer.id);
        } catch (crmError) {
          console.error("Error logging quote request to CRM:", crmError);
          // Don't fail the request if CRM logging fails
        }

        res.json({
          success: true,
          message: "Your quote request has been submitted. Our team will prepare a detailed quote and respond within 24 hours."
        });
      } catch (emailError) {
        console.error("Error sending quote request email:", emailError);
        res.status(500).json({
          success: false,
          message: "Failed to submit quote request. Please try again or contact us directly."
        });
      }
    } catch (error) {
      console.error("Error in quote request endpoint:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });

  // =============================================================================
  // CATEGORY MANAGEMENT API ROUTES
  // =============================================================================

  // Get all categories
  app.get("/api/admin/categories", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const categories = await shopStorage.getCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ success: false, message: "Failed to fetch categories" });
    }
  });

  // Get category by ID
  app.get("/api/admin/categories/:id", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const category = await shopStorage.getCategoryById(id);
      if (!category) {
        return res.status(404).json({ success: false, message: "Category not found" });
      }
      
      res.json(category);
    } catch (error) {
      console.error("Error fetching category:", error);
      res.status(500).json({ success: false, message: "Failed to fetch category" });
    }
  });

  // Create new category
  app.post("/api/admin/categories", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const { insertShopCategorySchema } = await import('../shared/shop-schema');
      
      const categoryData = insertShopCategorySchema.parse(req.body);
      const category = await shopStorage.createCategory(categoryData);
      
      res.json({
        success: true,
        message: "Category created successfully",
        category
      });
    } catch (error) {
      console.error("Error creating category:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          message: "Invalid category data",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create category" });
    }
  });

  // Update category
  app.put("/api/admin/categories/:id", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const { insertShopCategorySchema } = await import('../shared/shop-schema');
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const categoryData = insertShopCategorySchema.partial().parse(req.body);
      const category = await shopStorage.updateCategory(id, categoryData);
      
      res.json({
        success: true,
        message: "Category updated successfully",
        category
      });
    } catch (error) {
      console.error("Error updating category:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          message: "Invalid category data",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to update category" });
    }
  });

  // Delete category
  app.delete("/api/admin/categories/:id", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      // Check if category has products
      const products = await shopStorage.getProductsByCategory(id);
      if (products.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Cannot delete category with existing products"
        });
      }
      
      // Check if category has subcategories
      const subcategories = await shopStorage.getSubcategories(id);
      if (subcategories.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Cannot delete category with existing subcategories"
        });
      }
      
      await shopStorage.deleteCategory(id);
      
      res.json({
        success: true,
        message: "Category deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting category:", error);
      res.status(500).json({ success: false, message: "Failed to delete category" });
    }
  });

  // Get products by category
  app.get("/api/admin/categories/:id/products", requireAuth, async (req, res) => {
    try {
      const { shopStorage } = await import('./shop-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid category ID" });
      }
      
      const products = await shopStorage.getProductsByCategory(id);
      res.json(products);
    } catch (error) {
      console.error("Error fetching products by category:", error);
      res.status(500).json({ success: false, message: "Failed to fetch products" });
    }
  });

  // =============================================================================
  // AI SEO ASSISTANT ROUTES
  // =============================================================================

  // AI Content Generation
  app.post('/api/ai/seo/generate', requireAuth, async (req, res) => {
    try {
      const { generateAISeoContent } = await import('./ai-seo-generator');
      const result = await generateAISeoContent(req.body);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error generating AI SEO content:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to generate AI content'
      });
    }
  });

  // AI Keyword Research
  app.post('/api/ai/seo/keywords', requireAuth, async (req, res) => {
    try {
      const { generateKeywordSuggestions } = await import('./ai-seo-generator');
      const { seedKeywords, language, industry, targetMarket } = req.body;
      
      const result = await generateKeywordSuggestions(seedKeywords, language, industry);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error researching keywords:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to research keywords'
      });
    }
  });

  // AI Content Optimization
  app.post('/api/ai/seo/optimize', requireAuth, async (req, res) => {
    try {
      const { optimizeContentForSeo } = await import('./ai-seo-generator');
      const { content, targetKeywords, language } = req.body;
      
      const result = await optimizeContentForSeo(content, targetKeywords, language);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error optimizing content:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to optimize content'
      });
    }
  });

  // AI SEO Performance Analysis
  app.post('/api/ai/seo/analyze', requireAuth, async (req, res) => {
    try {
      const { analyzeSeoPerformance } = await import('./ai-seo-generator');
      const { url, targetKeywords } = req.body;
      
      const result = await analyzeSeoPerformance(url, targetKeywords);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error analyzing SEO performance:', error);
      res.status(500).json({
        success: false,
        message: error.message || 'Failed to analyze SEO performance'
      });
    }
  });

  // =============================================================================
  // SEO MANAGEMENT ROUTES
  // =============================================================================

  // Get all SEO settings
  app.get("/api/admin/seo/settings", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const language = req.query.language as string;
      const settings = await seoStorage.getSeoSettings(language);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching SEO settings:", error);
      res.status(500).json({ success: false, message: "Failed to fetch SEO settings" });
    }
  });

  // Get supported languages
  app.get("/api/admin/seo/languages", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const languages = await seoStorage.getSupportedLanguages();
      res.json(languages);
    } catch (error) {
      console.error("Error fetching supported languages:", error);
      res.status(500).json({ success: false, message: "Failed to fetch supported languages" });
    }
  });

  // Create supported language
  app.post("/api/admin/seo/languages", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertSupportedLanguageSchema } = await import('../shared/schema');
      
      const validatedData = insertSupportedLanguageSchema.parse(req.body);
      const language = await seoStorage.createSupportedLanguage(validatedData);
      
      res.status(201).json({
        success: true,
        message: "Language created successfully",
        data: language
      });
    } catch (error) {
      console.error("Error creating language:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create language" });
    }
  });

  // Get multilingual analytics
  app.get("/api/admin/seo/multilingual-analytics", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const analytics = await seoStorage.getMultilingualAnalytics();
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching multilingual analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch multilingual analytics" });
    }
  });

  // Get keywords performance
  app.get("/api/admin/seo/keywords/performance", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const language = req.query.language as string;
      const performance = await seoStorage.getKeywordPerformance(language);
      res.json(performance);
    } catch (error) {
      console.error("Error fetching keyword performance:", error);
      res.status(500).json({ success: false, message: "Failed to fetch keyword performance" });
    }
  });

  // Create multilingual keyword
  app.post("/api/admin/seo/keywords", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertMultilingualKeywordSchema } = await import('../shared/schema');
      
      const validatedData = insertMultilingualKeywordSchema.parse(req.body);
      const keyword = await seoStorage.createMultilingualKeyword(validatedData);
      
      res.status(201).json({
        success: true,
        message: "Keyword created successfully",
        data: keyword
      });
    } catch (error) {
      console.error("Error creating keyword:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create keyword" });
    }
  });

  // Generate hreflang tags
  app.get("/api/admin/seo/hreflang/:pageType", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { pageType } = req.params;
      const pageIdentifier = req.query.pageIdentifier as string;
      
      const hreflangTags = await seoStorage.generateHreflangTags(pageType, pageIdentifier);
      res.json({ tags: hreflangTags });
    } catch (error) {
      console.error("Error generating hreflang tags:", error);
      res.status(500).json({ success: false, message: "Failed to generate hreflang tags" });
    }
  });

  // Generate multilingual sitemap
  app.get("/api/admin/seo/sitemap/multilingual", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const sitemapXml = await seoStorage.generateMultilingualSitemap();
      res.set('Content-Type', 'application/xml');
      res.send(sitemapXml);
    } catch (error) {
      console.error("Error generating multilingual sitemap:", error);
      res.status(500).send("Error generating multilingual sitemap");
    }
  });

  // Generate language-specific sitemap
  app.get("/sitemap-:language.xml", async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { language } = req.params;
      const sitemapXml = await seoStorage.generateSitemap(language);
      res.set('Content-Type', 'application/xml');
      res.send(sitemapXml);
    } catch (error) {
      console.error("Error generating language-specific sitemap:", error);
      res.status(500).send("Error generating sitemap");
    }
  });

  // Create SEO setting
  app.post("/api/admin/seo/settings", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertSeoSettingSchema } = await import('../shared/schema');
      
      const validatedData = insertSeoSettingSchema.parse(req.body);
      
      // Validate SEO settings
      const validationErrors = await seoStorage.validateSeoSettings(validatedData);
      if (validationErrors.length > 0) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: validationErrors
        });
      }
      
      const setting = await seoStorage.createSeoSetting(validatedData);
      res.status(201).json({
        success: true,
        message: "SEO setting created successfully",
        data: setting
      });
    } catch (error) {
      console.error("Error creating SEO setting:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create SEO setting" });
    }
  });

  // Update SEO setting
  app.put("/api/admin/seo/settings/:id", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertSeoSettingSchema } = await import('../shared/schema');
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid SEO setting ID" });
      }
      
      const validatedData = insertSeoSettingSchema.partial().parse(req.body);
      const setting = await seoStorage.updateSeoSetting(id, validatedData);
      
      res.json({
        success: true,
        message: "SEO setting updated successfully",
        data: setting
      });
    } catch (error) {
      console.error("Error updating SEO setting:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to update SEO setting" });
    }
  });

  // Delete SEO setting
  app.delete("/api/admin/seo/settings/:id", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ success: false, message: "Invalid SEO setting ID" });
      }
      
      await seoStorage.deleteSeoSetting(id);
      res.json({
        success: true,
        message: "SEO setting deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting SEO setting:", error);
      res.status(500).json({ success: false, message: "Failed to delete SEO setting" });
    }
  });

  // Get SEO analytics summary
  app.get("/api/admin/seo/analytics", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const summary = await seoStorage.getSeoAnalyticsSummary();
      res.json(summary);
    } catch (error) {
      console.error("Error fetching SEO analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch SEO analytics" });
    }
  });

  // Get sitemap entries
  app.get("/api/admin/seo/sitemap", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const entries = await seoStorage.getSitemapEntries();
      res.json(entries);
    } catch (error) {
      console.error("Error fetching sitemap entries:", error);
      res.status(500).json({ success: false, message: "Failed to fetch sitemap entries" });
    }
  });

  // Generate and serve XML sitemap
  app.get("/sitemap.xml", async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const sitemapXml = await seoStorage.generateSitemap();
      res.set('Content-Type', 'application/xml');
      res.send(sitemapXml);
    } catch (error) {
      console.error("Error generating sitemap:", error);
      res.status(500).send("Error generating sitemap");
    }
  });

  // Generate and serve robots.txt
  app.get("/robots.txt", async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const robotsTxt = await seoStorage.generateRobotsTxt();
      res.set('Content-Type', 'text/plain');
      res.send(robotsTxt);
    } catch (error) {
      console.error("Error generating robots.txt:", error);
      res.status(500).send("Error generating robots.txt");
    }
  });

  // Get redirects
  app.get("/api/admin/seo/redirects", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const redirectsList = await seoStorage.getRedirects();
      res.json(redirectsList);
    } catch (error) {
      console.error("Error fetching redirects:", error);
      res.status(500).json({ success: false, message: "Failed to fetch redirects" });
    }
  });

  // Create redirect
  app.post("/api/admin/seo/redirects", requireAuth, async (req, res) => {
    try {
      const { seoStorage } = await import('./seo-storage');
      const { insertRedirectSchema } = await import('../shared/schema');
      
      const validatedData = insertRedirectSchema.parse(req.body);
      const redirect = await seoStorage.createRedirect(validatedData);
      
      res.status(201).json({
        success: true,
        message: "Redirect created successfully",
        data: redirect
      });
    } catch (error) {
      console.error("Error creating redirect:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Validation failed",
          errors: error.errors
        });
      }
      res.status(500).json({ success: false, message: "Failed to create redirect" });
    }
  });

  // Customer PDF export routes
  app.get("/api/crm/customers/:id/export-pdf", requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      if (isNaN(customerId)) {
        return res.status(400).json({ success: false, message: "Invalid customer ID" });
      }

      // Get customer data
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Customer not found" });
      }

      // Get customer analytics
      const analytics = await crmStorage.getCustomerAnalytics(customerId);
      
      // Get customer activities
      const activities = await crmStorage.getCustomerActivities(customerId, 20);

      // Generate PDF using PDFMake with Vazir font support
      const { generateCustomerPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateCustomerPDFWithPDFMake(customer, analytics.orders || [], activities, `Ù…Ø´ØªØ±ÛŒ ${customer.name}`);

      // Validate PDF buffer before sending
      if (!pdfBuffer || pdfBuffer.length === 0) {
        throw new Error('Generated PDF is empty');
      }
      
      console.log('Customer report PDF generated successfully, size:', pdfBuffer.length, 'bytes');
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="customer-report-${customerId}-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Send PDF buffer
      res.end(pdfBuffer);
      
    } catch (error) {
      console.error("Error generating customer PDF:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate customer PDF report" 
      });
    }
  });

  // CRM Analytics PDF export
  app.get("/api/crm/analytics/export-pdf", requireAuth, async (req, res) => {
    try {
      // Get dashboard statistics
      const dashboardStats = await crmStorage.getCrmDashboardStats();
      
      // Generate PDF using PDFMake with Vazir font support
      const { generateAnalyticsPDFWithPDFMake } = await import('./pdfmake-generator.js');
      const pdfBuffer = await generateAnalyticsPDFWithPDFMake(dashboardStats, 'Ú¯Ø²Ø§Ø±Ø´ Ø¢Ù…Ø§Ø±Ù‡Ø§');

      // Validate PDF buffer before sending
      if (!pdfBuffer || pdfBuffer.length === 0) {
        throw new Error('Generated PDF is empty');
      }
      
      console.log('Analytics report PDF generated successfully, size:', pdfBuffer.length, 'bytes');
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="customer-analytics-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.setHeader('Cache-Control', 'no-cache');
      
      // Send PDF buffer
      res.end(pdfBuffer);
      
    } catch (error) {
      console.error("Error generating analytics PDF:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to generate analytics PDF report" 
      });
    }
  });



  // Toggle SMS system (admin only)
  app.post("/api/admin/sms/toggle", requireAuth, async (req: Request, res: Response) => {
    try {
      const { enabled } = req.body;
      const adminId = req.session.adminId;
      const adminUsername = 'Admin';
      
      const settings = await smsStorage.toggleSmsSystem(enabled, adminUsername);
      
      res.json({ 
        success: true, 
        data: settings, 
        message: enabled ? "Ø³ÛŒØ³ØªÙ… SMS ÙØ¹Ø§Ù„ Ø´Ø¯" : "Ø³ÛŒØ³ØªÙ… SMS ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error toggling SMS system:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ… SMS" });
    }
  });

  // Get customer SMS settings (admin only)
  app.get("/api/admin/customers/:customerId/sms", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerId } = req.params;
      const settings = await smsStorage.getCustomerSmsSettings(parseInt(customerId));
      
      res.json({ 
        success: true, 
        data: settings || { 
          customerId: parseInt(customerId),
          smsAuthEnabled: false
        }
      });
    } catch (error) {
      console.error("Error fetching customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS Ù…Ø´ØªØ±ÛŒ" });
    }
  });

  // Enable SMS for customer (admin only)
  app.post("/api/admin/customers/:customerId/sms/enable", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerId } = req.params;
      const adminId = req.session.adminId;
      
      // Get admin username for logging
      const adminUsername = 'Admin';
      
      const settings = await smsStorage.enableCustomerSms(parseInt(customerId), adminUsername);
      
      // Log activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: parseInt(customerId),
        activityType: 'sms_enabled',
        description: `SMS authentication enabled by admin: ${adminUsername}`,
        performedBy: adminUsername
      });
      
      res.json({ 
        success: true, 
        data: settings, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error enabling customer SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ SMS Ù…Ø´ØªØ±ÛŒ" });
    }
  });

  // Disable SMS for customer (admin only)
  app.post("/api/admin/customers/:customerId/sms/disable", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerId } = req.params;
      const adminId = req.session.adminId;
      
      // Get admin username for logging
      const adminUsername = 'Admin';
      
      const settings = await smsStorage.disableCustomerSms(parseInt(customerId), adminUsername);
      
      // Log activity in CRM
      await crmStorage.logCustomerActivity({
        customerId: parseInt(customerId),
        activityType: 'sms_disabled',
        description: `SMS authentication disabled by admin: ${adminUsername}`,
        performedBy: adminUsername
      });
      
      res.json({ 
        success: true, 
        data: settings, 
        message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error disabling customer SMS:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØºÛŒØ±ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ SMS Ù…Ø´ØªØ±ÛŒ" });
    }
  });

  // Get all customers with SMS settings (admin only)
  app.get("/api/admin/sms/customers", requireAuth, async (req: Request, res: Response) => {
    try {
      const customers = await crmStorage.getCrmCustomers(100, 0);
      
      const customerSmsData = customers.map(customer => ({
        id: customer.id,
        firstName: customer.firstName,
        lastName: customer.lastName,
        email: customer.email,
        phone: customer.phone || '',
        company: customer.company,
        smsEnabled: customer.smsEnabled === true, // Explicit boolean check
        customerStatus: customer.customerStatus,
        totalOrders: customer.totalOrdersCount || 0,
        lastOrderDate: customer.lastOrderDate ? new Date(customer.lastOrderDate).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        }) : null
      }));
      
      res.json({ success: true, data: customerSmsData });
    } catch (error) {
      console.error("Error fetching customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS Ù…Ø´ØªØ±ÛŒØ§Ù†" });
    }
  });

  // Update individual customer SMS setting (admin only)
  app.put("/api/admin/sms/customers/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const customerId = parseInt(req.params.id);
      const { smsEnabled } = req.body;
      
      if (typeof smsEnabled !== 'boolean') {
        return res.status(400).json({ success: false, message: "Ù…Ù‚Ø¯Ø§Ø± SMS Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }
      
      // First check if customer exists
      const existingCustomer = await crmStorage.getCrmCustomerById(customerId);
      if (!existingCustomer) {
        return res.status(404).json({ 
          success: false, 
          message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }
      
      // Update customer SMS setting
      await crmStorage.updateCrmCustomer(customerId, { smsEnabled });
      
      // Log activity
      await crmStorage.logCustomerActivity({
        customerId,
        activityType: "sms_setting_changed",
        description: `SMS ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†`,
        performedBy: req.session?.adminId?.toString() || 'admin',
        activityData: { smsEnabled, changedBy: 'admin' }
      });
      
      res.json({ 
        success: true, 
        message: `SMS Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒ ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error updating customer SMS setting:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS" });
    }
  });

  // Bulk enable/disable SMS for all customers (admin only)
  app.post("/api/admin/sms/customers/bulk", requireAuth, async (req: Request, res: Response) => {
    try {
      const { action } = req.body; // 'enable' or 'disable'
      
      if (!['enable', 'disable'].includes(action)) {
        return res.status(400).json({ success: false, message: "Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
      }
      
      const smsEnabled = action === 'enable';
      
      // Get all customers
      const customers = await crmStorage.getCrmCustomers(1000, 0);
      
      // Update all customers
      for (const customer of customers) {
        await crmStorage.updateCrmCustomer(customer.id, { smsEnabled });
        
        // Log activity for each customer
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: "sms_bulk_setting_changed",
          description: `SMS ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù…Ø´ØªØ±ÛŒØ§Ù† ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†`,
          performedBy: req.session?.adminId?.toString() || 'admin',
          activityData: { smsEnabled, action: 'bulk', changedBy: 'admin' }
        });
      }
      
      res.json({ 
        success: true, 
        message: `SMS Ø¨Ø±Ø§ÛŒ ${customers.length} Ù…Ø´ØªØ±ÛŒ ${smsEnabled ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„'} Ø´Ø¯`
      });
    } catch (error) {
      console.error("Error bulk updating customer SMS settings:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù†Ø¨ÙˆÙ‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª SMS" });
    }
  });

  // Get SMS statistics (admin only)
  app.get("/api/admin/sms/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const stats = await smsStorage.getSmsStats();
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching SMS stats:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± SMS" });
    }
  });

  // Get delivery SMS logs (admin only)
  app.get("/api/admin/sms/delivery-logs", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { smsLogs } = await import("../shared/schema");
      const { eq, desc } = await import("drizzle-orm");
      
      const deliveryLogs = await db
        .select()
        .from(smsLogs)
        .where(eq(smsLogs.purpose, 'delivery_notification'))
        .orderBy(desc(smsLogs.createdAt))
        .limit(50);
      
      res.json({ success: true, data: deliveryLogs });
    } catch (error) {
      console.error("Error fetching delivery SMS logs:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ SMS ØªØ­ÙˆÛŒÙ„" });
    }
  });

  // Send SMS verification code (public endpoint for customer login)
  app.post("/api/sms/send-verification", async (req: Request, res: Response) => {
    try {
      const { phone, purpose } = req.body;
      
      if (!phone || !purpose) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ù‡Ø¯Ù Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }
      
      // Check if SMS system is enabled
      const settings = await smsStorage.getSmsSettings();
      if (!settings?.isEnabled) {
        return res.status(503).json({ success: false, message: "Ø³ÛŒØ³ØªÙ… Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª SMS ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª" });
      }
      
      // Generate verification code
      const code = Math.random().toString().slice(2, 2 + (settings.codeLength || 6));
      const expiresAt = new Date(Date.now() + (settings.codeExpiry || 300) * 1000);
      
      // Save verification code
      await smsStorage.createVerification({
        phone,
        code,
        purpose,
        expiresAt
      });
      
      // Here you would integrate with SMS provider (Kavenegar, etc.)
      // For now, we'll just log the code for development
      console.log(`SMS Verification Code for ${phone}: ${code}`);
      
      res.json({ 
        success: true, 
        message: "Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        // In production, don't send the code in response
        ...(process.env.NODE_ENV === 'development' && { code })
      });
    } catch (error) {
      console.error("Error sending SMS verification:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯" });
    }
  });

  // Verify SMS code (public endpoint for customer login)
  app.post("/api/sms/verify-code", async (req: Request, res: Response) => {
    try {
      const { phone, code, purpose } = req.body;
      
      if (!phone || !code || !purpose) {
        return res.status(400).json({ success: false, message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†ØŒ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ùˆ Ù‡Ø¯Ù Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }
      
      // Find verification
      const verification = await smsStorage.getVerification(phone, code, purpose);
      
      if (!verification) {
        return res.status(400).json({ success: false, message: "Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }
      
      // Mark as used
      await smsStorage.markVerificationUsed(verification.id);
      
      res.json({ 
        success: true, 
        message: "Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ£ÛŒÛŒØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error verifying SMS code:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø¯" });
    }
  });

  // ============================================================================
  // CUSTOMER ADDRESS MANAGEMENT ROUTES
  // ============================================================================

  // Get customer addresses
  app.get("/api/customers/addresses", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addresses = await customerAddressStorage.getCustomerAddresses(req.session.customerId);
      res.json({ success: true, addresses });
    } catch (error) {
      console.error("Error fetching customer addresses:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§" });
    }
  });

  // Create new address
  app.post("/api/customers/addresses", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      // Get customer info to auto-fill firstName and lastName
      const customer = await crmStorage.getCrmCustomerById(req.session.customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const addressData = insertCustomerAddressSchema.parse({
        ...req.body,
        customerId: req.session.customerId,
        firstName: customer.firstName,
        lastName: customer.lastName
      });

      const newAddress = await customerAddressStorage.createAddress(addressData);
      res.json({ success: true, address: newAddress, message: "Ø¢Ø¯Ø±Ø³ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error creating address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¢Ø¯Ø±Ø³ Ø¬Ø¯ÛŒØ¯" });
    }
  });

  // Update address
  app.put("/api/customers/addresses/:id", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addressId = parseInt(req.params.id);
      const existingAddress = await customerAddressStorage.getAddressById(addressId);
      
      if (!existingAddress || existingAddress.customerId !== req.session.customerId) {
        return res.status(404).json({ success: false, message: "Ø¢Ø¯Ø±Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const updatedAddress = await customerAddressStorage.updateAddress(addressId, req.body);
      res.json({ success: true, address: updatedAddress, message: "Ø¢Ø¯Ø±Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error("Error updating address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ø¯Ø±Ø³" });
    }
  });

  // Delete address
  app.delete("/api/customers/addresses/:id", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addressId = parseInt(req.params.id);
      const existingAddress = await customerAddressStorage.getAddressById(addressId);
      
      if (!existingAddress || existingAddress.customerId !== req.session.customerId) {
        return res.status(404).json({ success: false, message: "Ø¢Ø¯Ø±Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      await customerAddressStorage.deleteAddress(addressId);
      res.json({ success: true, message: "Ø¢Ø¯Ø±Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¢Ø¯Ø±Ø³" });
    }
  });

  // Set default address
  app.post("/api/customers/addresses/:id/set-default", async (req: Request, res: Response) => {
    try {
      if (!req.session?.customerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      const addressId = parseInt(req.params.id);
      const existingAddress = await customerAddressStorage.getAddressById(addressId);
      
      if (!existingAddress || existingAddress.customerId !== req.session.customerId) {
        return res.status(404).json({ success: false, message: "Ø¢Ø¯Ø±Ø³ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      await customerAddressStorage.setDefaultAddress(req.session.customerId, addressId);
      res.json({ success: true, message: "Ø¢Ø¯Ø±Ø³ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯" });
    } catch (error) {
      console.error("Error setting default address:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ø¢Ø¯Ø±Ø³ Ù¾ÛŒØ´â€ŒÙØ±Ø¶" });
    }
  });

  // =============================================================================
  // WIDGET RECOMMENDATION API ROUTES
  // =============================================================================

  // Get available dashboard widgets
  app.get("/api/admin/widgets", requireAuth, async (req: Request, res: Response) => {
    try {
      const { category, userLevel } = req.query;
      const widgets = await widgetRecommendationStorage.getWidgets(
        category as string, 
        userLevel as string || 'admin'
      );
      res.json({ success: true, data: widgets });
    } catch (error) {
      console.error("Error fetching widgets:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§" });
    }
  });

  // Get user's widget preferences
  app.get("/api/admin/widgets/preferences", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const preferences = await widgetRecommendationStorage.getUserPreferences(userId);
      res.json({ success: true, data: preferences });
    } catch (error) {
      console.error("Error fetching widget preferences:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§" });
    }
  });

  // Toggle widget visibility
  app.post("/api/admin/widgets/:widgetId/toggle", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const widgetId = parseInt(req.params.widgetId);
      const preference = await widgetRecommendationStorage.toggleWidgetVisibility(userId, widgetId);
      
      res.json({ 
        success: true, 
        data: preference,
        message: `ÙˆÛŒØ¬Øª ${preference.isVisible ? 'Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯' : 'Ù…Ø®ÙÛŒ Ø´Ø¯'}` 
      });
    } catch (error) {
      console.error("Error toggling widget visibility:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ù†Ù…Ø§ÛŒØ´ ÙˆÛŒØ¬Øª" });
    }
  });

  // Track widget usage
  app.post("/api/admin/widgets/:widgetId/track", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const widgetId = parseInt(req.params.widgetId);
      const { action, duration, sessionId } = req.body;

      await widgetRecommendationStorage.trackWidgetUsage({
        userId,
        widgetId,
        action,
        duration,
        sessionId,
        userAgent: req.headers['user-agent'],
        ipAddress: req.ip
      });

      res.json({ success: true, message: "Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆÛŒØ¬Øª Ø«Ø¨Øª Ø´Ø¯" });
    } catch (error) {
      console.error("Error tracking widget usage:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆÛŒØ¬Øª" });
    }
  });

  // Get widget recommendations for user
  app.get("/api/admin/widgets/recommendations", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendations = await widgetRecommendationStorage.getRecommendationsForUser(userId);
      res.json({ success: true, data: recommendations });
    } catch (error) {
      console.error("Error fetching recommendations:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª" });
    }
  });

  // Generate new recommendations
  app.post("/api/admin/widgets/recommendations/generate", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendations = await widgetRecommendationStorage.generateRecommendations(userId);
      res.json({ 
        success: true, 
        data: recommendations,
        message: `${recommendations.length} Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯` 
      });
    } catch (error) {
      console.error("Error generating recommendations:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª" });
    }
  });

  // Accept recommendation
  app.post("/api/admin/widgets/recommendations/:recommendationId/accept", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendationId = parseInt(req.params.recommendationId);
      await widgetRecommendationStorage.acceptRecommendation(userId, recommendationId);
      
      res.json({ success: true, message: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù¾Ø°ÛŒØ±ÙØªÙ‡ Ø´Ø¯ Ùˆ ÙˆÛŒØ¬Øª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯" });
    } catch (error) {
      console.error("Error accepting recommendation:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø°ÛŒØ±Ø´ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯" });
    }
  });

  // Dismiss recommendation
  app.post("/api/admin/widgets/recommendations/:recommendationId/dismiss", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const recommendationId = parseInt(req.params.recommendationId);
      await widgetRecommendationStorage.dismissRecommendation(userId, recommendationId);
      
      res.json({ success: true, message: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø±Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error("Error dismissing recommendation:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯" });
    }
  });

  // Get popular widgets
  app.get("/api/admin/widgets/popular", requireAuth, async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 10;
      const popularWidgets = await widgetRecommendationStorage.getPopularWidgets(limit);
      res.json({ success: true, data: popularWidgets });
    } catch (error) {
      console.error("Error fetching popular widgets:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¬Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø­Ø¨ÙˆØ¨" });
    }
  });

  // Get user activity summary
  app.get("/api/admin/widgets/activity", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.session?.adminId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const days = parseInt(req.query.days as string) || 30;
      const activity = await widgetRecommendationStorage.getUserActivitySummary(userId, days);
      res.json({ success: true, data: activity });
    } catch (error) {
      console.error("Error fetching user activity:", error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ¹Ø§Ù„ÛŒØª Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // =============================================================================
  // FINANCIAL DEPARTMENT SPECIFIC API ROUTES
  // =============================================================================

  // Financial department authentication check
  app.get('/api/financial/auth/me', async (req: Request, res: Response) => {
    try {
      // Check if user has admin session first
      if (req.session?.isAuthenticated && req.session?.adminId) {
        // Return admin user as financial user
        const adminUser = {
          id: req.session.adminId,
          username: 'admin_financial',
          email: 'admin@momtazchem.com',
          department: 'financial',
          isAdmin: true
        };
        return res.json({ success: true, user: adminUser });
      }

      // For now, return a default financial user for testing
      // In production, this would check actual financial department authentication
      const defaultFinancialUser = {
        id: 1,
        username: 'financial_admin',
        email: 'financial@momtazchem.com',
        department: 'financial'
      };
      
      res.json({ success: true, user: defaultFinancialUser });
    } catch (error) {
      console.error('Error in financial auth check:', error);
      res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…Ø§Ù„ÛŒ Ù†Ø´Ø¯Ù‡' });
    }
  });

  // Financial department logout
  app.post('/api/financial/logout', async (req: Request, res: Response) => {
    try {
      // Clear session if needed
      res.json({ success: true, message: 'Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚ÛŒØªâ€ŒØ¢Ù…ÛŒØ²' });
    } catch (error) {
      console.error('Error in financial logout:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø®Ø±ÙˆØ¬' });
    }
  });



  // Approve financial order (public access for financial department)
  app.post('/api/finance/orders/:id/approve', async (req: Request, res: Response) => {
    try {
      const orderId = parseInt(req.params.id);
      const { notes } = req.body;
      const adminId = 1; // Default financial admin ID

      console.log(`âœ… [FINANCE] Approving order ${orderId} - converting to regular order and moving to warehouse`);

      const { pool } = await import('./db');
      
      // First try to find by order management ID
      let orderManagementResult = await pool.query(`
        SELECT om.*, co.payment_method, co.status
        FROM order_management om
        JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE om.id = $1
      `, [orderId]);

      // If not found, try to find by customer_order_id (for frontend compatibility)
      if (orderManagementResult.rows.length === 0) {
        console.log(`ðŸ” [FINANCE] Order management ID ${orderId} not found, searching by customer_order_id`);
        orderManagementResult = await pool.query(`
          SELECT om.*, co.payment_method, co.status
          FROM order_management om
          JOIN customer_orders co ON om.customer_order_id = co.id
          WHERE om.customer_order_id = $1
        `, [orderId]);
      }

      if (orderManagementResult.rows.length === 0) {
        console.log(`âŒ [FINANCE] Order ${orderId} not found in either order_management.id or customer_order_id`);
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const orderData = orderManagementResult.rows[0];
      const isTemporaryOrder = orderData.payment_grace_period_start !== null;
      const orderManagementId = orderData.id; // Use correct order management ID

      console.log(`ðŸ“Š [FINANCE] Order details - Management ID: ${orderManagementId}, Customer Order ID: ${orderData.customer_order_id}, Is Temporary: ${isTemporaryOrder}`);

      // When financial approves, move to warehouse_pending for warehouse approval
      const { orderStatuses } = await import('../shared/order-management-schema');
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderManagementId, // Use correct order management ID
        orderStatuses.WAREHOUSE_PENDING, // Use constant from schema
        adminId, 
        'financial', 
        notes || 'Payment approved by financial department - moving to warehouse'
      );

      // If this was a temporary order (grace period), convert it to regular order
      if (isTemporaryOrder) {
        console.log(`ðŸ”„ [FINANCE] Converting temporary order ${orderId} to regular order`);
        
        // Clear grace period fields and unlock the order
        await pool.query(`
          UPDATE order_management 
          SET payment_grace_period_start = NULL,
              payment_grace_period_end = NULL,
              is_order_locked = false
          WHERE id = $1
        `, [orderManagementId]);

        // Update customer order status to 'confirmed' (regular order status)
        await pool.query(`
          UPDATE customer_orders 
          SET status = 'confirmed',
              payment_status = 'paid'
          WHERE id = $1
        `, [orderData.customer_order_id]);

        console.log(`âœ… [FINANCE] Order ${orderManagementId} (Customer Order ${orderData.customer_order_id}) converted from temporary to regular order and moved to warehouse`);
        res.json({ success: true, order: updatedOrder, message: 'Ø³ÙØ§Ø±Ø´ Ù…ÙˆÙ‚Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¨Ù‡ Ø³ÙØ§Ø±Ø´ Ù…Ø¹Ù…ÙˆÙ„ÛŒ ØªØ¨Ø¯ÛŒÙ„ Ø´Ø¯' });
      } else {
        console.log(`âœ… [FINANCE] Regular order ${orderManagementId} (Customer Order ${orderData.customer_order_id}) approved and moved to warehouse department`);
        res.json({ success: true, order: updatedOrder, message: 'Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ú¯Ø±Ø¯ÛŒØ¯' });
      }
    } catch (error) {
      console.error('Error approving financial order:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª' });
    }
  });

  // Reject financial order (public access for financial department)
  app.post('/api/finance/orders/:id/reject', async (req: Request, res: Response) => {
    try {
      const orderId = parseInt(req.params.id);
      const { notes } = req.body;
      const adminId = 1; // Default financial admin ID

      console.log(`âŒ [FINANCE] Rejecting order ${orderId}`);

      // When financial rejects, set to financial_rejected (stays in financial for rejected list)
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderId, 
        'financial_rejected', 
        adminId, 
        'financial', 
        notes || 'Payment rejected by financial department'
      );

      console.log(`âŒ [FINANCE] Order ${orderId} rejected by financial department`);
      res.json({ success: true, order: updatedOrder, message: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø¯ Ø´Ø¯' });
    } catch (error) {
      console.error('Error rejecting financial order:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª' });
    }
  });



  // =============================================================================
  // ORDER MANAGEMENT API ROUTES (3-Department System)
  // =============================================================================

  // Get orders for specific department (respects workflow sequence)
  app.get('/api/order-management/:department', async (req, res) => {
    try {
      const department = req.params.department as 'financial' | 'warehouse' | 'logistics';
      
      if (!['financial', 'warehouse', 'logistics'].includes(department)) {
        return res.status(400).json({ success: false, message: 'Ø¨Ø®Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' });
      }

      // For financial department, allow access without admin auth
      if (department === 'financial') {
        const orders = await orderManagementStorage.getOrdersByDepartment(department);
        return res.json({ success: true, orders });
      }

      // For other departments, require admin auth
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const orders = await orderManagementStorage.getOrdersByDepartment(department);
      res.json({ success: true, orders });
    } catch (error) {
      console.error(`Error fetching ${req.params.department} orders:`, error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // =============================================================================
  // ORDER TRACKING MANAGEMENT API ROUTES (Read-Only System)
  // =============================================================================

  // Get all orders for tracking (read-only overview)
  app.get('/api/orders/tracking/all', async (req, res) => {
    try {
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const { pool } = await import('./db');
      
      // Get all orders with complete information for tracking
      const query = `
        SELECT DISTINCT
          o.id,
          o.order_number as customerOrderId,
          crm.first_name || ' ' || crm.last_name as customerName,
          crm.email as customerEmail,
          crm.phone as customerPhone,
          o.total_amount as totalAmount,
          o.currency,
          o.status,
          o.payment_method as paymentMethod,
          o.payment_receipt_url as paymentReceiptUrl,
          o.tracking_number as trackingNumber,
          o.delivery_code as deliveryCode,
          o.estimated_delivery_date as estimatedDeliveryDate,
          o.actual_delivery_date as actualDeliveryDate,
          o.delivery_person_name as deliveryPersonName,
          o.delivery_person_phone as deliveryPersonPhone,
          om.financial_notes as financialNotes,
          om.warehouse_notes as warehouseNotes,
          om.logistics_notes as logisticsNotes,
          o.created_at as createdAt,
          o.updated_at as updatedAt
        FROM customer_orders o
        LEFT JOIN crm_customers crm ON o.customer_id = crm.id
        LEFT JOIN order_management om ON o.id = om.customer_order_id
        ORDER BY o.created_at DESC
        LIMIT 1000
      `;
      
      const result = await pool.query(query);
      console.log('ðŸ“‹ [ORDER TRACKING] Retrieved', result.rows.length, 'orders for tracking');
      
      res.json({ success: true, orders: result.rows });
    } catch (error) {
      console.error('âŒ [ORDER TRACKING] Error fetching tracking orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ù¾ÛŒÚ¯ÛŒØ±ÛŒ' });
    }
  });

  // Get order statistics for dashboard
  app.get('/api/orders/statistics', async (req, res) => {
    try {
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const { pool } = await import('./db');
      
      // Get comprehensive order statistics
      const statsQuery = `
        SELECT
          COUNT(*) as total_orders,
          COUNT(CASE WHEN status IN ('pending_payment', 'payment_uploaded', 'financial_reviewing', 'warehouse_processing', 'logistics_processing') THEN 1 END) as pending_orders,
          COUNT(CASE WHEN status IN ('delivered', 'completed') THEN 1 END) as completed_orders,
          COALESCE(SUM(CASE WHEN status IN ('delivered', 'completed') THEN total_amount ELSE 0 END), 0) as total_revenue,
          COALESCE(AVG(CASE WHEN status IN ('delivered', 'completed') THEN total_amount ELSE NULL END), 0) as average_order_value,
          COUNT(CASE WHEN DATE(created_at) = CURRENT_DATE THEN 1 END) as todays_orders
        FROM customer_orders
        WHERE created_at >= CURRENT_DATE - INTERVAL '1 year'
      `;
      
      const result = await pool.query(statsQuery);
      const stats = result.rows[0];
      
      console.log('ðŸ“Š [ORDER STATS] Retrieved order statistics:', stats);
      
      res.json({ 
        success: true, 
        stats: {
          totalOrders: parseInt(stats.total_orders) || 0,
          pendingOrders: parseInt(stats.pending_orders) || 0,
          completedOrders: parseInt(stats.completed_orders) || 0,
          totalRevenue: parseFloat(stats.total_revenue) || 0,
          averageOrderValue: parseFloat(stats.average_order_value) || 0,
          todaysOrders: parseInt(stats.todays_orders) || 0
        }
      });
    } catch (error) {
      console.error('âŒ [ORDER STATS] Error fetching order statistics:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¢Ù…Ø§Ø± Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // Get order history for specific order
  app.get('/api/orders/:id/history', async (req, res) => {
    try {
      if (!req.session?.adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      const orderId = parseInt(req.params.id);
      const { pool } = await import('./db');
      
      // Get order status history
      const historyQuery = `
        SELECT 
          osh.id,
          osh.from_status as fromStatus,
          osh.to_status as toStatus,
          osh.changed_by as changedBy,
          osh.changed_by_department as changedByDepartment,
          osh.notes,
          osh.created_at as createdAt
        FROM order_status_history osh
        WHERE osh.order_management_id = (
          SELECT id FROM order_management WHERE customer_order_id = $1
        )
        ORDER BY osh.created_at DESC
      `;
      
      const result = await pool.query(historyQuery, [orderId]);
      console.log('ðŸ“œ [ORDER HISTORY] Retrieved', result.rows.length, 'history items for order', orderId);
      
      res.json({ success: true, history: result.rows });
    } catch (error) {
      console.error('âŒ [ORDER HISTORY] Error fetching order history:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø³ÙØ§Ø±Ø´' });
    }
  });



  // Update order status (department-specific)
  app.put('/api/order-management/:id/status', async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { newStatus, department, notes } = req.body;
      
      // For financial department, use default admin ID (financial department operations)
      let adminId = req.session.adminId;
      if (department === 'financial' && !adminId) {
        adminId = 1; // Default financial admin ID for financial operations
      }

      if (!adminId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª' });
      }

      // Validate that admin can perform this action
      const canView = await orderManagementStorage.canDepartmentViewOrder(orderId, department);
      if (!canView) {
        return res.status(403).json({ success: false, message: 'Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª' });
      }

      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderId, 
        newStatus, 
        adminId, 
        department, 
        notes
      );

      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error updating order status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Get order status history
  app.get('/api/order-management/:id/history', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const history = await orderManagementStorage.getOrderStatusHistory(orderId);
      res.json({ success: true, history });
    } catch (error) {
      console.error('Error fetching order history:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø³ÙØ§Ø±Ø´' });
    }
  });

  // =============================================================================
  // WAREHOUSE DEPARTMENT API ROUTES
  // =============================================================================

  // Warehouse orders - Get orders approved by financial department
  app.get('/api/order-management/warehouse', requireAuth, async (req, res) => {
    try {
      console.log('ðŸ“¦ [WAREHOUSE] Fetching warehouse orders...');
      
      // Get orders that are approved by financial department and ready for warehouse processing
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          o.id,
          o.customer_name as "customerName",
          o.customer_email as "customerEmail", 
          o.total_amount as "totalAmount",
          o.status,
          o.created_at as "createdAt",
          o.shipping_address as "shippingAddress",
          o.payment_method as "paymentMethod",
          o.notes,
          o.warehouse_notes as "warehouseNotes",
          o.financial_approved_at as "financialApprovedAt",
          o.fulfilled_at as "fulfilledAt",
          o.fulfilled_by as "fulfilledBy",
          COALESCE(
            json_agg(
              json_build_object(
                'id', oi.id,
                'name', oi.name,
                'quantity', oi.quantity,
                'price', oi.price,
                'sku', oi.sku,
                'barcode', oi.barcode
              )
            ) FILTER (WHERE oi.id IS NOT NULL),
            '[]'::json
          ) as items
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE o.status = 'financial_approved'
        GROUP BY o.id, o.customer_name, o.customer_email, o.total_amount, o.status, 
                 o.created_at, o.shipping_address, o.payment_method, o.notes, 
                 o.warehouse_notes, o.financial_approved_at, o.fulfilled_at, o.fulfilled_by
        ORDER BY o.financial_approved_at DESC
      `);
      
      const orders = result.rows;
      console.log('ðŸ“¦ [WAREHOUSE] Found financial approved orders:', orders.length);
      console.log('ðŸ“¦ [WAREHOUSE] Orders ready for warehouse processing:', JSON.stringify(orders, null, 2));
      res.json({ success: true, orders });
    } catch (error) {
      console.error('âŒ [WAREHOUSE] Error fetching warehouse orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ù†Ø¨Ø§Ø±' });
    }
  });

  // Process warehouse order - support both admin and custom users
  app.patch('/api/order-management/warehouse/:id/process', async (req, res) => {
    
    console.log('âœ… [DEBUG] Authentication successful');
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      // Support both admin and custom users - convert UUID to numeric for database compatibility
      const userId = req.session?.adminId || (req.session?.customUserId ? 2 : 1); // Use 2 for custom users, 1 for fallback
      
      console.log('ðŸ“¦ [WAREHOUSE] Processing order:', { 
        id, 
        status, 
        notes, 
        userId,
        originalCustomUserId: req.session?.customUserId,
        sessionType: req.session?.adminId ? 'admin' : 'custom' 
      });
      
      // Use order management storage to update order status
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        parseInt(id),
        status,
        userId,
        'warehouse',
        notes
      );
      
      if (!updatedOrder) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      
      console.log('ðŸ“¦ [WAREHOUSE] Order updated successfully:', updatedOrder);
      
      // Auto-generate and send delivery code when order is approved to logistics
      if (status === 'warehouse_approved') {
        try {
          console.log('ðŸšš [AUTO-CODE] Order approved to logistics, auto-generating delivery code...');
          
          // Get order details for customer info
          const orderDetails = await orderManagementStorage.getOrderById(parseInt(id));
          if (orderDetails && orderDetails.customerPhone && orderDetails.customerFirstName) {
            const customerName = `${orderDetails.customerFirstName} ${orderDetails.customerLastName || ''}`.trim();
            
            console.log('ðŸšš [AUTO-CODE] Customer info:', {
              orderId: orderDetails.customerOrderId,
              phone: orderDetails.customerPhone,
              name: customerName
            });
            
            // Generate delivery code using logistics storage
            const { logisticsStorage } = await import('./logistics-storage');
            const codeResult = await logisticsStorage.generateDeliveryCode(
              orderDetails.customerOrderId,
              orderDetails.customerPhone,
              customerName
            );
            
            if (codeResult.success) {
              console.log('âœ… [AUTO-CODE] Delivery code generated and sent automatically:', codeResult.deliveryCode);
            } else {
              console.log('âŒ [AUTO-CODE] Failed to generate delivery code:', codeResult.message);
            }
          } else {
            console.log('âŒ [AUTO-CODE] Missing customer information for auto-code generation');
          }
        } catch (autoCodeError) {
          console.error('âŒ [AUTO-CODE] Error in auto-code generation:', autoCodeError);
          // Don't fail the warehouse approval if code generation fails
        }
      }
      
      res.json({ success: true, data: updatedOrder });
    } catch (error) {
      console.error('âŒ [WAREHOUSE] Error processing warehouse order:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Get order items for warehouse processing - shows what products are in each order
  app.get('/api/order-management/warehouse/:customerOrderId/items', async (req, res) => {
    
    try {
      const { customerOrderId } = req.params;
      
      console.log('ðŸ“¦ [WAREHOUSE-ITEMS] Getting order items for customer order:', customerOrderId);
      
      // Get order items using direct pool query to avoid Drizzle issues
      const result = await customerPool.query(
        `SELECT 
          id, 
          product_id, 
          product_name, 
          product_sku, 
          quantity, 
          unit, 
          unit_price, 
          total_price, 
          specifications, 
          notes,
          created_at
        FROM order_items 
        WHERE order_id = $1 
        ORDER BY id`,
        [parseInt(customerOrderId)]
      );
      
      const orderItemsData = result.rows;
      
      console.log(`ðŸ“¦ [WAREHOUSE-ITEMS] Found ${orderItemsData.length} items for order ${customerOrderId}`);
      
      if (orderItemsData.length > 0) {
        console.log('ðŸ“¦ [WAREHOUSE-ITEMS] First item sample:', JSON.stringify(orderItemsData[0], null, 2));
      }
      
      res.json({ 
        success: true, 
        orderItems: orderItemsData,
        totalItems: orderItemsData.length 
      });
    } catch (error) {
      console.error('âŒ [WAREHOUSE-ITEMS] Error fetching order items:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø§Ù‚Ù„Ø§Ù… Ø³ÙØ§Ø±Ø´' 
      });
    }
  });

  // Get complete order details with customer info and items
  app.get('/api/order-management/warehouse/:customerOrderId/details', async (req, res) => {
    
    try {
      const { customerOrderId } = req.params;
      
      console.log('ðŸ“¦ [ORDER-DETAILS] Getting complete order details for customer order:', customerOrderId);
      
      // Get order details using order management storage
      const orderDetails = await orderManagementStorage.getOrderWithItems(parseInt(customerOrderId));
      
      console.log('âœ… [ORDER-DETAILS] Successfully retrieved order details');
      
      res.json({ 
        success: true, 
        order: orderDetails 
      });
    } catch (error) {
      console.error('âŒ [ORDER-DETAILS] Error fetching order details:', error);
      res.status(500).json({ 
        success: false, 
        message: error.message || 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ø³ÙØ§Ø±Ø´' 
      });
    }
  });

  // =============================================================================
  // LOGISTICS DEPARTMENT API ROUTES
  // =============================================================================

  // Logistics authentication check
  app.get('/api/logistics/auth/me', async (req, res) => {
    try {
      // Check if user is authenticated as admin (temporary solution)
      if (req.session?.adminId || req.session?.isAuthenticated) {
        res.json({ success: true, authenticated: true });
      } else {
        res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù…ÙˆÙÙ‚' });
      }
    } catch (error) {
      res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø§Ù…ÙˆÙÙ‚' });
    }
  });



  // Shipping rates management endpoints (removed duplicates)

  // Shipping cost calculation endpoint
  app.post('/api/logistics/calculate-shipping', async (req, res) => {
    try {
      const { deliveryMethod, city, province, orderTotal, weight } = req.body;
      const shippingCost = await orderManagementStorage.calculateShippingCost({
        deliveryMethod,
        city,
        province,
        orderTotal: parseFloat(orderTotal) || 0,
        weight: parseFloat(weight) || 0,
      });
      res.json({ success: true, data: { shippingCost } });
    } catch (error) {
      console.error('Error calculating shipping cost:', error);
      res.status(500).json({ 
        success: false, 
        message: error.message || 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„' 
      });
    }
  });

  // Get available shipping methods for location/order
  app.post('/api/logistics/available-methods', async (req, res) => {
    try {
      const { city, province, orderTotal } = req.body;
      const availableMethods = await orderManagementStorage.getAvailableShippingMethods({
        city,
        province,
        orderTotal: parseFloat(orderTotal) || 0,
      });
      res.json({ success: true, data: availableMethods });
    } catch (error) {
      console.error('Error fetching available shipping methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ù…ÙˆØ¬ÙˆØ¯' });
    }
  });

  // Update order delivery information (enhanced logistics details)
  app.post('/api/logistics/orders/:orderId/delivery-info', async (req, res) => {
    try {
      const { orderId } = req.params;
      const updatedOrder = await orderManagementStorage.updateDeliveryInfo(
        parseInt(orderId),
        req.body
      );
      res.json({ success: true, data: updatedOrder });
    } catch (error) {
      console.error('Error updating delivery info:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Update delivery information for an order
  app.put('/api/logistics/orders/:id/delivery-info', async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const deliveryInfo = req.body;
      
      const updatedOrder = await orderManagementStorage.updateDeliveryInfo(orderId, deliveryInfo);
      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error updating delivery info:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Complete delivery for an order
  app.post('/api/logistics/orders/:id/complete', async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const adminId = req.session?.adminId || 1; // Default for logistics operations
      
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        orderId,
        'logistics_delivered',
        adminId,
        'logistics',
        'Order delivered successfully'
      );
      
      res.json({ success: true, order: updatedOrder });
    } catch (error) {
      console.error('Error completing delivery:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÚ©Ù…ÛŒÙ„ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // =============================================================================
  // DELIVERY METHODS MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all delivery methods for logistics department
  app.get('/api/logistics/delivery-methods', requireAuth, async (req, res) => {
    try {
      const { db } = await import('./db');
      const result = await db.select().from(deliveryMethods).orderBy(deliveryMethods.sortOrder);
      res.json(result);
    } catch (error) {
      console.error('Error fetching delivery methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Create new delivery method (logistics)
  app.post('/api/logistics/delivery-methods', requireAuth, async (req, res) => {
    try {
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const result = await db.insert(deliveryMethods).values({
        value,
        label,
        icon: icon || 'package',
        color: color || 'blue',
        baseCost: baseCost ? parseFloat(baseCost) : 0,
        costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
        minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
        freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
        estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
        maxDistance: maxDistance ? parseInt(maxDistance) : null,
        availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
        description: description || null,
        isActive: isActive !== undefined ? isActive : true,
        sortOrder: sortOrder || 0
      }).returning();

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error creating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Update delivery method (logistics)
  app.put('/api/logistics/delivery-methods/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.update(deliveryMethods)
        .set({
          value,
          label,
          icon: icon || 'package',
          color: color || 'blue',
          baseCost: baseCost ? parseFloat(baseCost) : 0,
          costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
          minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
          freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
          estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
          maxDistance: maxDistance ? parseInt(maxDistance) : null,
          availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
          description: description || null,
          isActive: isActive !== undefined ? isActive : true,
          sortOrder: sortOrder || 0,
          updatedAt: new Date()
        })
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error updating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Delete delivery method (logistics)
  app.delete('/api/logistics/delivery-methods/:id', requireAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.delete(deliveryMethods)
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting delivery method:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Get all delivery methods (public endpoint)
  app.get('/api/delivery-methods', async (req, res) => {
    try {
      const { db } = await import('./db');
      const result = await db.select().from(deliveryMethods).orderBy(deliveryMethods.sortOrder);
      res.json(result);
    } catch (error) {
      console.error('Error fetching delivery methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Get active delivery methods for customer checkout
  app.get('/api/checkout/delivery-methods', async (req, res) => {
    try {
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.select().from(deliveryMethods)
        .where(eq(deliveryMethods.isActive, true))
        .orderBy(deliveryMethods.sortOrder);
      
      res.json(result);
    } catch (error) {
      console.error('Error fetching active delivery methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Create new delivery method
  app.post('/api/delivery-methods', async (req, res) => {
    try {
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const result = await db.insert(deliveryMethods).values({
        value,
        label,
        icon: icon || 'package',
        color: color || 'blue',
        baseCost: baseCost ? parseFloat(baseCost) : 0,
        costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
        minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
        freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
        estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
        maxDistance: maxDistance ? parseInt(maxDistance) : null,
        availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
        description: description || null,
        isActive: isActive !== undefined ? isActive : true,
        sortOrder: sortOrder || 0
      }).returning();

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error creating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Update delivery method
  app.put('/api/delivery-methods/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { 
        value, label, icon, color, isActive, sortOrder,
        baseCost, costPerKg, minimumOrder, freeShippingThreshold,
        estimatedDays, maxDistance, availableAreas, description
      } = req.body;
      
      if (!value || !label) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ù…Ù‚Ø¯Ø§Ø± Ùˆ Ø¨Ø±Ú†Ø³Ø¨ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.update(deliveryMethods)
        .set({
          value,
          label,
          icon: icon || 'package',
          color: color || 'blue',
          baseCost: baseCost ? parseFloat(baseCost) : 0,
          costPerKg: costPerKg ? parseFloat(costPerKg) : 0,
          minimumOrder: minimumOrder ? parseFloat(minimumOrder) : 0,
          freeShippingThreshold: freeShippingThreshold ? parseFloat(freeShippingThreshold) : null,
          estimatedDays: estimatedDays ? parseInt(estimatedDays) : 1,
          maxDistance: maxDistance ? parseInt(maxDistance) : null,
          availableAreas: availableAreas ? availableAreas.split(',').map((s: string) => s.trim()).filter(Boolean) : null,
          description: description || null,
          isActive: isActive !== undefined ? isActive : true,
          sortOrder: sortOrder || 0,
          updatedAt: new Date()
        })
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: result[0] });
    } catch (error: any) {
      console.error('Error updating delivery method:', error);
      if (error.code === '23505') {
        res.status(400).json({ success: false, message: 'Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯' });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
      }
    }
  });

  // Delete delivery method
  app.delete('/api/delivery-methods/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.delete(deliveryMethods)
        .where(eq(deliveryMethods.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting delivery method:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // =============================================================================
  // SHIPPING RATES MANAGEMENT ENDPOINTS
  // =============================================================================

  // Get all shipping rates
  app.get('/api/logistics/shipping-rates', async (req, res) => {
    try {
      const { db } = await import('./db');
      const result = await db.select().from(shippingRates).orderBy(shippingRates.deliveryMethod);
      res.json(result);
    } catch (error) {
      console.error('Error fetching shipping rates:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Create new shipping rate
  app.post('/api/logistics/shipping-rates', async (req, res) => {
    try {
      const {
        deliveryMethod, cityName, provinceName, minWeight, maxWeight, maxDimensions,
        basePrice, pricePerKg, freeShippingThreshold, estimatedDays, 
        trackingAvailable, insuranceAvailable, insuranceRate, isActive,
        smsVerificationEnabled, description, internalNotes
      } = req.body;
      
      if (!deliveryMethod || !basePrice || !minWeight) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ØŒ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÙ‡ Ùˆ Ø­Ø¯Ø§Ù‚Ù„ ÙˆØ²Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const result = await db.insert(shippingRates).values({
        deliveryMethod,
        cityName: cityName || null,
        provinceName: provinceName || null,
        minWeight,
        maxWeight: maxWeight || null,
        maxDimensions: maxDimensions || null,
        basePrice,
        pricePerKg: pricePerKg || '0',
        freeShippingThreshold: freeShippingThreshold || null,
        estimatedDays: estimatedDays || null,
        trackingAvailable: trackingAvailable || false,
        insuranceAvailable: insuranceAvailable || false,
        insuranceRate: insuranceRate || '0',
        isActive: isActive !== undefined ? isActive : true,
        smsVerificationEnabled: smsVerificationEnabled || false,
        description: description || null,
        internalNotes: internalNotes || null
      }).returning();

      res.json({ success: true, data: result[0] });
    } catch (error) {
      console.error('Error creating shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Update shipping rate
  app.put('/api/logistics/shipping-rates/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const {
        deliveryMethod, cityName, provinceName, minWeight, maxWeight, maxDimensions,
        basePrice, pricePerKg, freeShippingThreshold, estimatedDays, 
        trackingAvailable, insuranceAvailable, insuranceRate, isActive,
        smsVerificationEnabled, description, internalNotes
      } = req.body;
      
      if (!deliveryMethod || !basePrice || !minWeight) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ØŒ Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÙ‡ Ùˆ Ø­Ø¯Ø§Ù‚Ù„ ÙˆØ²Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.update(shippingRates)
        .set({
          deliveryMethod,
          cityName: cityName || null,
          provinceName: provinceName || null,
          minWeight,
          maxWeight: maxWeight || null,
          maxDimensions: maxDimensions || null,
          basePrice,
          pricePerKg: pricePerKg || '0',
          freeShippingThreshold: freeShippingThreshold || null,
          estimatedDays: estimatedDays || null,
          trackingAvailable: trackingAvailable || false,
          insuranceAvailable: insuranceAvailable || false,
          insuranceRate: insuranceRate || '0',
          isActive: isActive !== undefined ? isActive : true,
          smsVerificationEnabled: smsVerificationEnabled || false,
          description: description || null,
          internalNotes: internalNotes || null,
          updatedAt: new Date()
        })
        .where(eq(shippingRates.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: result[0] });
    } catch (error) {
      console.error('Error updating shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Delete shipping rate
  app.delete('/api/logistics/shipping-rates/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      
      const result = await db.delete(shippingRates)
        .where(eq(shippingRates.id, id))
        .returning();

      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting shipping rate:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Second set of duplicate shipping rate endpoints removed

  // Get available shipping methods for checkout
  app.get('/api/shipping/methods', async (req, res) => {
    try {
      const { city, province, orderTotal } = req.query;
      const methods = await orderManagementStorage.getAvailableShippingMethods({
        city: city as string,
        province: province as string,
        orderTotal: orderTotal ? parseFloat(orderTotal as string) : 0
      });
      res.json({ success: true, methods });
    } catch (error) {
      console.error('Error fetching shipping methods:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Calculate shipping cost
  app.post('/api/shipping/calculate', async (req, res) => {
    try {
      const { deliveryMethod, city, province, orderTotal, weight } = req.body;
      const cost = await orderManagementStorage.calculateShippingCost({
        deliveryMethod,
        city,
        province,
        orderTotal: parseFloat(orderTotal),
        weight: weight ? parseFloat(weight) : 1
      });
      res.json({ success: true, cost });
    } catch (error) {
      console.error('Error calculating shipping cost:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø§Ø±Ø³Ø§Ù„' });
    }
  });

  // Upload payment receipt (customer action)
  app.post('/api/order-management/:customerOrderId/payment-receipt', upload.single('receipt'), async (req, res) => {
    try {
      const customerOrderId = parseInt(req.params.customerOrderId);
      const customerId = req.session.customerId;

      if (!customerId) {
        return res.status(401).json({ success: false, message: 'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡' });
      }

      if (!req.file) {
        return res.status(400).json({ success: false, message: 'ÙØ§ÛŒÙ„ Ø±Ø³ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' });
      }

      // Save payment receipt
      const receipt = await orderManagementStorage.uploadPaymentReceipt({
        customerOrderId,
        customerId,
        receiptUrl: `/uploads/documents/${req.file.filename}`,
        originalFileName: req.file.originalname,
        fileSize: req.file.size,
        mimeType: req.file.mimetype,
        notes: req.body.notes || ''
      });

      // Update order status to PAYMENT_UPLOADED
      const orderMgmt = await orderManagementStorage.getOrderManagementByCustomerOrderId(customerOrderId);
      if (orderMgmt) {
        await orderManagementStorage.updateOrderStatus(
          orderMgmt.id,
          'payment_uploaded' as any,
          customerId,
          'financial' as any,
          'Ø±Ø³ÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª ØªÙˆØ³Ø· Ù…Ø´ØªØ±ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯'
        );
      }

      res.json({ success: true, receipt });
    } catch (error) {
      console.error('Error uploading payment receipt:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ Ø±Ø³ÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª' });
    }
  });

  // Verify delivery code (logistics department)
  app.post('/api/order-management/verify-delivery', requireAuth, async (req, res) => {
    try {
      const { code, verifiedBy } = req.body;
      const verified = await orderManagementStorage.verifyDeliveryCode(code, verifiedBy);
      
      if (verified) {
        res.json({ success: true, message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯' });
      } else {
        res.status(400).json({ success: false, message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡' });
      }
    } catch (error) {
      console.error('Error verifying delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Generate delivery code for order (logistics department)
  app.post('/api/order-management/:orderManagementId/generate-delivery-code', requireAuth, async (req, res) => {
    try {
      const orderManagementId = parseInt(req.params.orderManagementId);
      
      // Get order and customer information
      const orderWithCustomer = await db
        .select({
          customerPhone: crmCustomers.phone,
          customerOrderId: orderManagement.customerOrderId,
          deliveryCode: orderManagement.deliveryCode,
          customerFirstName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.id, orderManagementId))
        .limit(1);

      if (!orderWithCustomer[0]) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const { customerPhone, customerOrderId } = orderWithCustomer[0];

      if (!customerPhone) {
        return res.status(400).json({ success: false, message: 'Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Generate new delivery code using logistics storage
      const deliveryCode = await logisticsStorage.getNextSequentialCode();
      
      // Update order with new delivery code
      await db
        .update(orderManagement)
        .set({ 
          deliveryCode: deliveryCode,
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderManagementId));

      // Send SMS with new delivery code
      const smsSent = await orderManagementStorage.sendDeliveryCodeSms(customerPhone, deliveryCode, customerOrderId);
      
      if (smsSent) {
        console.log(`âœ… [GENERATE SMS] Delivery code ${deliveryCode} generated and sent to ${customerPhone} for order ${orderManagementId}`);
        res.json({ 
          success: true, 
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ ØªÙˆÙ„ÛŒØ¯ Ùˆ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯',
          deliveryCode: deliveryCode
        });
      } else {
        // Even if SMS failed, we generated the code
        console.log(`âš ï¸ [GENERATE SMS] Delivery code ${deliveryCode} generated but SMS failed for order ${orderManagementId}`);
        res.json({ 
          success: true, 
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯ Ø§Ù…Ø§ SMS Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯',
          deliveryCode: deliveryCode
        });
      }
    } catch (error) {
      console.error('Error generating delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Resend delivery code (logistics department)
  app.post('/api/order-management/:orderManagementId/resend-delivery-code', requireAuth, async (req, res) => {
    try {
      const orderManagementId = parseInt(req.params.orderManagementId);
      
      // Get order and customer information
      const orderWithCustomer = await db
        .select({
          customerPhone: crmCustomers.phone,
          customerOrderId: orderManagement.customerOrderId,
          deliveryCode: orderManagement.deliveryCode,
          customerFirstName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.id, orderManagementId))
        .limit(1);

      if (!orderWithCustomer[0]) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      const { customerPhone, customerOrderId, deliveryCode } = orderWithCustomer[0];

      if (!customerPhone) {
        return res.status(400).json({ success: false, message: 'Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      if (!deliveryCode) {
        return res.status(400).json({ success: false, message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Resend SMS with existing delivery code
      const smsSent = await orderManagementStorage.sendDeliveryCodeSms(customerPhone, deliveryCode, customerOrderId);
      
      if (smsSent) {
        console.log(`âœ… [RESEND SMS] Delivery code ${deliveryCode} resent to ${customerPhone} for order ${orderManagementId}`);
        res.json({ 
          success: true, 
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯',
          deliveryCode: deliveryCode
        });
      } else {
        res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
      }
    } catch (error) {
      console.error('Error resending delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Assign user to department
  app.post('/api/order-management/assign-department', requireAuth, async (req, res) => {
    try {
      const { adminUserId, department } = req.body;
      const assignedBy = req.session.adminId!;

      const assignment = await orderManagementStorage.assignUserToDepartment({
        adminUserId,
        department,
        assignedBy
      });

      res.json({ success: true, assignment });
    } catch (error) {
      console.error('Error assigning user to department:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ®ØµÛŒØµ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ø¨Ø®Ø´' });
    }
  });

  // Get department stats
  app.get('/api/order-management/stats/:department', requireAuth, async (req, res) => {
    try {
      const department = req.params.department as 'financial' | 'warehouse' | 'logistics';
      const stats = await orderManagementStorage.getDepartmentStats(department);
      res.json({ success: true, stats });
    } catch (error) {
      console.error('Error fetching department stats:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø¨Ø®Ø´' });
    }
  });

  // Get orders overview (admin dashboard)
  app.get('/api/order-management/overview', requireAuth, async (req, res) => {
    try {
      const overview = await orderManagementStorage.getOrdersOverview();
      res.json({ success: true, overview });
    } catch (error) {
      console.error('Error fetching orders overview:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // ============================================================================
  // DEPARTMENT-SPECIFIC AUTHENTICATION & ROUTES
  // ============================================================================

  // Department authentication middleware
  function requireDepartmentAuth(department: string) {
    return (req: any, res: any, next: any) => {
      // Temporary workaround for session consistency issue with financial department
      if (department === 'financial') {
        const tempUser = {
          id: 1,
          username: 'financial_temp',
          department: 'financial'
        };
        req.session.departmentUser = tempUser;
        return next();
      }
      
      // Temporary workaround for logistics department - allow admin access
      if (department === 'logistics' && (req.session?.adminId || req.session?.isAuthenticated)) {
        console.log('âœ… Logistics auth: Admin access granted', {
          adminId: req.session.adminId,
          isAuthenticated: req.session.isAuthenticated
        });
        const tempUser = {
          id: req.session.adminId || 1,
          username: 'logistics_admin',
          department: 'logistics'
        };
        req.session.departmentUser = tempUser;
        return next();
      }
      
      console.log(`Auth check for ${department}:`, {
        sessionExists: !!req.session,
        departmentUser: req.session?.departmentUser,
        sessionId: req.sessionID
      });
      
      if (!req.session?.departmentUser || req.session.departmentUser.department !== department) {
        console.log(`Authentication failed for ${department}:`, {
          hasDepartmentUser: !!req.session?.departmentUser,
          userDepartment: req.session?.departmentUser?.department,
          expectedDepartment: department
        });
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      next();
    };
  }

  // ============================================================================
  // LOGISTICS DEPARTMENT ROUTES
  // ============================================================================

  // Logistics login
  app.post('/api/logistics/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      // Check if user exists and has logistics department access
      const [user] = await db
        .select()
        .from(schema.users)
        .where(and(
          eq(schema.users.username, username),
          eq(schema.users.department, 'logistics'),
          eq(schema.users.isActive, true)
        ));

      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Update last login
      await db
        .update(schema.users)
        .set({ lastLoginAt: new Date() })
        .where(eq(schema.users.id, user.id));

      // Set session
      req.session.departmentUser = {
        id: user.id,
        username: user.username,
        department: user.department || 'logistics'
      };

      res.json({ 
        success: true, 
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚", 
        user: { 
          id: user.id, 
          username: user.username, 
          department: user.department 
        } 
      });
    } catch (error) {
      console.error('Logistics login error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" });
    }
  });

  // Logistics logout
  app.post('/api/logistics/logout', (req, res) => {
    req.session.departmentUser = undefined;
    res.json({ success: true, message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚" });
  });

  // Logistics auth check
  app.get('/api/logistics/auth/me', requireDepartmentAuth('logistics'), (req: any, res) => {
    res.json({ 
      success: true, 
      user: req.session.departmentUser 
    });
  });

  // Get logistics pending orders - only warehouse_approved orders
  app.get('/api/logistics/orders', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orders = await orderManagementStorage.getLogisticsPendingOrders();
      
      // Calculate total weight for each order
      const ordersWithWeight = await Promise.all(
        orders.map(async (order) => {
          try {
            const weight = await orderManagementStorage.calculateOrderWeight(order.customerOrderId);
            return {
              ...order,
              calculatedWeight: weight,
              weightUnit: 'kg'
            };
          } catch (error) {
            console.error(`Error calculating weight for order ${order.customerOrderId}:`, error);
            return {
              ...order,
              calculatedWeight: 0,
              weightUnit: 'kg'
            };
          }
        })
      );
      
      res.json({ success: true, orders: ordersWithWeight });
    } catch (error) {
      console.error('Error fetching logistics orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª" });
    }
  });

  // Calculate order weight endpoint - accessible by all authenticated users
  app.post('/api/orders/:customerOrderId/calculate-weight', requireAuth, async (req, res) => {
    try {
      const customerOrderId = parseInt(req.params.customerOrderId);
      
      if (!customerOrderId) {
        return res.status(400).json({
          success: false,
          message: "Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }

      console.log(`ðŸ”„ [WEIGHT] Calculating weight for order ${customerOrderId}...`);
      
      // Calculate the weight using enhanced method
      const weight = await orderManagementStorage.calculateOrderWeight(customerOrderId);
      
      // Update the order_management table with the calculated weight
      try {
        await orderManagementStorage.updateOrderWeight(customerOrderId, weight);
        console.log(`âœ… [WEIGHT] Updated order ${customerOrderId} weight: ${weight} kg`);
      } catch (updateError) {
        console.error(`âŒ [WEIGHT] Failed to update weight in database:`, updateError);
      }
      
      res.json({
        success: true,
        message: `ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´ ${customerOrderId} Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯`,
        data: {
          customerOrderId,
          totalWeight: weight,
          weightUnit: 'kg'
        }
      });
    } catch (error) {
      console.error(`âŒ [WEIGHT] Error calculating weight for order ${req.params.customerOrderId}:`, error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´" 
      });
    }
  });

  // Process logistics order
  app.post('/api/logistics/orders/:id/process', requireDepartmentAuth('logistics'), async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { 
        action, 
        notes, 
        reviewerId, 
        trackingNumber, 
        estimatedDeliveryDate, 
        deliveryPersonName, 
        deliveryPersonPhone,
        // Delivery method and transportation details
        deliveryMethod,
        transportationType,
        // Postal service details
        postalServiceName,
        postalTrackingCode,
        postalWeight,
        postalPrice,
        postalInsurance,
        // Vehicle details
        vehicleType,
        vehiclePlate,
        vehicleModel,
        vehicleColor,
        driverName,
        driverPhone,
        driverLicense,
        // Delivery company details
        deliveryCompanyName,
        deliveryCompanyPhone,
        deliveryCompanyAddress
      } = req.body;
      
      if (action === 'approve') {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'logistics_approved',
          reviewerId,
          'logistics',
          notes || 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù„Ø¬Ø³ØªÛŒÚ©'
        );
        
        // Update comprehensive delivery information
        await orderManagementStorage.updateDeliveryInfo(orderId, {
          trackingNumber,
          estimatedDeliveryDate: estimatedDeliveryDate ? new Date(estimatedDeliveryDate) : undefined,
          deliveryPersonName,
          deliveryPersonPhone,
          deliveryMethod,
          transportationType,
          postalServiceName,
          postalTrackingCode,
          postalWeight,
          postalPrice,
          postalInsurance,
          vehicleType,
          vehiclePlate,
          vehicleModel,
          vehicleColor,
          driverName,
          driverPhone,
          driverLicense,
          deliveryCompanyName,
          deliveryCompanyPhone,
          deliveryCompanyAddress
        });
      } else {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'logistics_rejected',
          reviewerId,
          'logistics',
          notes || 'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù„Ø¬Ø³ØªÛŒÚ©'
        );
      }

      res.json({ success: true, message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯" });
    } catch (error) {
      console.error('Error processing logistics order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´" });
    }
  });

  // ============================================================================
  // DELIVERY METHODS MANAGEMENT (LOGISTICS DEPARTMENT)
  // ============================================================================

  // Get all delivery methods (for logistics admin)
  app.get('/api/logistics/delivery-methods', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methods = await db
        .select()
        .from(deliveryMethods)
        .orderBy(deliveryMethods.sortOrder, deliveryMethods.label);
      
      res.json(methods);
    } catch (error) {
      console.error('Error fetching delivery methods:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Get active delivery methods (for customer checkout - no auth required)
  app.get('/api/delivery-methods', async (req, res) => {
    try {
      const methods = await db
        .select()
        .from(deliveryMethods)
        .where(eq(deliveryMethods.isActive, true))
        .orderBy(deliveryMethods.sortOrder, deliveryMethods.label);
      
      res.json(methods);
    } catch (error) {
      console.error('Error fetching active delivery methods:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Create new delivery method
  app.post('/api/logistics/delivery-methods', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methodData = req.body;
      
      const [newMethod] = await db
        .insert(deliveryMethods)
        .values({
          ...methodData,
          createdAt: new Date(),
          updatedAt: new Date(),
        })
        .returning();
      
      res.json({ success: true, data: newMethod, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error creating delivery method:', error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„" });
      }
    }
  });

  // Update delivery method
  app.put('/api/logistics/delivery-methods/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methodId = parseInt(req.params.id);
      const updateData = req.body;
      
      const [updatedMethod] = await db
        .update(deliveryMethods)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(deliveryMethods.id, methodId))
        .returning();
      
      if (!updatedMethod) {
        return res.status(404).json({ success: false, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, data: updatedMethod, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error('Error updating delivery method:', error);
      if (error.code === '23505') { // Unique constraint violation
        res.status(400).json({ success: false, message: "Ø§ÛŒÙ† Ø´Ù†Ø§Ø³Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      } else {
        res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„" });
      }
    }
  });

  // Delete delivery method
  app.delete('/api/logistics/delivery-methods/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const methodId = parseInt(req.params.id);
      
      // Check if this delivery method is used in shipping rates
      const usedInShippingRates = await db
        .select({ count: sql`count(*)` })
        .from(shippingRates)
        .where(eq(shippingRates.deliveryMethod, sql`(SELECT value FROM delivery_methods WHERE id = ${methodId})`));
      
      if (usedInShippingRates[0]?.count > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ† Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø± ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ Ø­Ø°Ù Ù†ÛŒØ³Øª" 
        });
      }
      
      const deletedRows = await db
        .delete(deliveryMethods)
        .where(eq(deliveryMethods.id, methodId))
        .returning();
      
      if (deletedRows.length === 0) {
        return res.status(404).json({ success: false, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting delivery method:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // ============================================================================
  // SHIPPING RATES MANAGEMENT (LOGISTICS DEPARTMENT)
  // ============================================================================

  // Get all shipping rates (for logistics admin)
  app.get('/api/logistics/shipping-rates', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rates = await db
        .select()
        .from(shippingRates)
        .orderBy(shippingRates.deliveryMethod, shippingRates.transportationType);
      
      res.json({ success: true, data: rates });
    } catch (error) {
      console.error('Error fetching shipping rates:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Get active shipping rates (for customer checkout - no auth required)
  app.get('/api/shipping-rates', async (req, res) => {
    try {
      const rates = await db
        .select()
        .from(shippingRates)
        .where(eq(shippingRates.isActive, true))
        .orderBy(shippingRates.deliveryMethod, shippingRates.transportationType);
      
      res.json({ success: true, data: rates });
    } catch (error) {
      console.error('Error fetching active shipping rates:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ¹Ø±ÙÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Create new shipping rate
  app.post('/api/logistics/shipping-rates', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rateData = req.body;
      
      const [newRate] = await db
        .insert(shippingRates)
        .values(rateData)
        .returning();
      
      res.json({ success: true, data: newRate, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error creating shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Update shipping rate
  app.put('/api/logistics/shipping-rates/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      const updateData = req.body;
      
      const [updatedRate] = await db
        .update(shippingRates)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(shippingRates.id, rateId))
        .returning();
      
      if (!updatedRate) {
        return res.status(404).json({ success: false, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, rate: updatedRate, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" });
    } catch (error) {
      console.error('Error updating shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Delete shipping rate
  app.delete('/api/logistics/shipping-rates/:id', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const rateId = parseInt(req.params.id);
      
      const [deletedRate] = await db
        .delete(shippingRates)
        .where(eq(shippingRates.id, rateId))
        .returning();
      
      if (!deletedRate) {
        return res.status(404).json({ success: false, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ success: true, message: "ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error('Error deleting shipping rate:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªØ¹Ø±ÙÙ‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // ============================================================================
  // SMS VERIFICATION SYSTEM FOR DELIVERY
  // ============================================================================

  // Generate SMS verification code for order
  app.post('/api/logistics/orders/:orderId/generate-sms-code', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      // Get order details
      const [order] = await db
        .select()
        .from(orders)
        .where(eq(orders.id, orderId))
        .limit(1);

      if (!order) {
        return res.status(404).json({ success: false, message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      // Generate verification code
      const verificationCode = await deliveryVerificationStorage.generateVerificationCode(
        order.id, // Using order ID as orderManagementId for now
        orderId,
        order.phone || order.customerPhone || ''
      );

      // Send SMS
      const smsResult = await smsService.sendDeliveryVerificationSms(
        order.phone || order.customerPhone || '',
        verificationCode.verificationCode,
        order.firstName || 'Ù…Ø´ØªØ±ÛŒ',
        verificationCode.id
      );

      res.json({
        success: true,
        message: 'Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ù¾ÛŒØ§Ù…Ú© Ø´Ø¯',
        verificationCode: verificationCode.verificationCode,
        smsSent: smsResult.success
      });
    } catch (error) {
      console.error('Error generating SMS verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯' });
    }
  });

  // Verify delivery code
  app.post('/api/logistics/verify-delivery', async (req, res) => {
    try {
      const { verificationCode, customerOrderId, courierName, verificationNotes } = req.body;

      const result = await deliveryVerificationStorage.verifyDeliveryCode({
        verificationCode,
        customerOrderId,
        courierName,
        verificationNotes
      });

      if (result.success) {
        // Update order status to delivered
        await db
          .update(orders)
          .set({
            status: 'delivered',
            deliveredAt: new Date(),
            deliveryNotes: verificationNotes || 'ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Ù¾ÛŒØ§Ù…Ú©'
          })
          .where(eq(orders.id, customerOrderId));
      }

      res.json(result);
    } catch (error) {
      console.error('Error verifying delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // Get delivery verification history for order
  app.get('/api/logistics/orders/:orderId/verification-history', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const history = await deliveryVerificationStorage.getVerificationHistory(orderId);
      res.json({ success: true, history });
    } catch (error) {
      console.error('Error fetching verification history:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªØ£ÛŒÛŒØ¯' });
    }
  });

  // Get daily SMS statistics
  app.get('/api/logistics/sms-stats/:date', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const date = req.params.date;
      const stats = await deliveryVerificationStorage.getDailyStats(date);
      res.json({ success: true, stats });
    } catch (error) {
      console.error('Error fetching SMS stats:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ù¾ÛŒØ§Ù…Ú©' });
    }
  });

  // Increment delivery attempts
  app.post('/api/logistics/orders/:orderId/increment-attempts', requireDepartmentAuth('logistics'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      await deliveryVerificationStorage.incrementDeliveryAttempts(orderId);
      res.json({ success: true, message: 'ØªÙ„Ø§Ø´ ØªØ­ÙˆÛŒÙ„ Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØª' });
    } catch (error) {
      console.error('Error incrementing delivery attempts:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÙØ²Ø§ÛŒØ´ ØªÙ„Ø§Ø´ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  // ============================================================================
  // CUSTOMER SHIPPING COST CALCULATION
  // ============================================================================

  // Calculate shipping cost for customer checkout
  app.post('/api/shipping/calculate', async (req, res) => {
    try {
      const { deliveryMethod, transportationType, customerCity, orderTotal, totalWeight } = req.body;
      
      // Find applicable shipping rate
      const applicableRates = await db
        .select()
        .from(shippingRates)
        .where(and(
          eq(shippingRates.deliveryMethod, deliveryMethod),
          transportationType ? eq(shippingRates.transportationType, transportationType) : sql`1=1`,
          eq(shippingRates.isActive, true),
          or(
            isNull(shippingRates.cityName), // National shipping
            eq(shippingRates.cityName, customerCity) // City-specific
          ),
          or(
            isNull(shippingRates.maxWeight), // No weight limit
            sql`${totalWeight} <= ${shippingRates.maxWeight}` // Within weight limit
          ),
          sql`${totalWeight} >= ${shippingRates.minWeight}` // Above minimum weight
        ))
        .orderBy(shippingRates.cityName); // City-specific rates first
      
      if (applicableRates.length === 0) {
        return res.json({ 
          success: false, 
          message: "Ø±ÙˆØ´ Ø§Ø±Ø³Ø§Ù„ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ù†Ø·Ù‚Ù‡ Ø´Ù…Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª" 
        });
      }
      
      const rate = applicableRates[0]; // Use most specific rate (city-specific if available)
      
      // Check for free shipping threshold
      if (rate.freeShippingThreshold && orderTotal >= parseFloat(rate.freeShippingThreshold)) {
        return res.json({
          success: true,
          shippingCost: 0,
          isFreeShipping: true,
          rate: {
            id: rate.id,
            deliveryMethod: rate.deliveryMethod,
            transportationType: rate.transportationType,
            description: rate.description,
            estimatedDays: rate.estimatedDays,
            trackingAvailable: rate.trackingAvailable
          }
        });
      }
      
      // Calculate shipping cost
      const basePrice = parseFloat(rate.basePrice);
      const weightCost = totalWeight * parseFloat(rate.pricePerKg || "0");
      const insuranceCost = rate.insuranceAvailable && rate.insuranceRate ? 
        orderTotal * parseFloat(rate.insuranceRate) : 0;
      
      const totalShippingCost = basePrice + weightCost + insuranceCost;
      
      res.json({
        success: true,
        shippingCost: totalShippingCost,
        isFreeShipping: false,
        breakdown: {
          basePrice,
          weightCost,
          insuranceCost,
          totalWeight
        },
        rate: {
          id: rate.id,
          deliveryMethod: rate.deliveryMethod,
          transportationType: rate.transportationType,
          description: rate.description,
          estimatedDays: rate.estimatedDays,
          trackingAvailable: rate.trackingAvailable,
          insuranceAvailable: rate.insuranceAvailable
        }
      });
    } catch (error) {
      console.error('Error calculating shipping cost:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // Get available shipping methods for customer location
  app.get('/api/shipping/methods', async (req, res) => {
    try {
      const { city, orderTotal, totalWeight } = req.query;
      
      const availableMethods = await db
        .selectDistinct({
          deliveryMethod: shippingRates.deliveryMethod,
          transportationType: shippingRates.transportationType,
          description: shippingRates.description,
          estimatedDays: shippingRates.estimatedDays,
          trackingAvailable: shippingRates.trackingAvailable,
          basePrice: shippingRates.basePrice,
          freeShippingThreshold: shippingRates.freeShippingThreshold
        })
        .from(shippingRates)
        .where(and(
          eq(shippingRates.isActive, true),
          or(
            isNull(shippingRates.cityName), // National shipping
            eq(shippingRates.cityName, city as string) // City-specific
          ),
          or(
            isNull(shippingRates.maxWeight), // No weight limit
            sql`${totalWeight} <= ${shippingRates.maxWeight}` // Within weight limit
          ),
          sql`${totalWeight || 0} >= ${shippingRates.minWeight}` // Above minimum weight
        ))
        .orderBy(shippingRates.basePrice);
      
      res.json({ success: true, methods: availableMethods });
    } catch (error) {
      console.error('Error fetching shipping methods:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" });
    }
  });

  // ============================================================================
  // VAT MANAGEMENT (FINANCIAL DEPARTMENT)
  // ============================================================================

  // Get current VAT settings
  app.get('/api/financial/vat-settings', (req: any, res: any) => {
    // Set temporary session for consistency
    req.session.departmentUser = {
      id: 1,
      username: 'financial_temp',
      department: 'financial'
    };
    
    // Execute the actual VAT settings logic
    (async () => {
    try {
      const [currentVat] = await db
        .select()
        .from(vatSettings)
        .where(eq(vatSettings.isActive, true))
        .orderBy(desc(vatSettings.effectiveDate))
        .limit(1);
      
      res.json({ success: true, vatSettings: currentVat || null });
    } catch (error) {
      console.error('Error fetching VAT settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
    })();
  });

  // Update VAT settings
  app.put('/api/financial/vat-settings', (req: any, res: any) => {
    // Set temporary session for consistency
    req.session.departmentUser = {
      id: 1,
      username: 'financial_temp',
      department: 'financial'
    };
    
    // Execute the actual VAT settings logic
    (async () => {
    try {
      const vatData = req.body;
      
      // Deactivate current VAT settings
      await db
        .update(vatSettings)
        .set({ isActive: false, updatedAt: new Date() })
        .where(eq(vatSettings.isActive, true));
      
      // Create new VAT settings
      const [newVatSettings] = await db
        .insert(vatSettings)
        .values({
          ...vatData,
          isActive: true,
          effectiveDate: new Date()
        })
        .returning();
      
      res.json({ 
        success: true, 
        vatSettings: newVatSettings, 
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('Error updating VAT settings:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø§Ù„ÛŒØ§Øª" });
    }
    })();
  });

  // Calculate VAT for order (for checkout)
  app.post('/api/financial/calculate-vat', async (req, res) => {
    try {
      const { orderItems, orderTotal, shippingCost, customerRegion } = req.body;
      
      // Get current VAT settings
      const [currentVat] = await db
        .select()
        .from(vatSettings)
        .where(and(
          eq(vatSettings.isActive, true),
          eq(vatSettings.vatEnabled, true)
        ))
        .orderBy(desc(vatSettings.effectiveDate))
        .limit(1);
      
      if (!currentVat) {
        return res.json({
          success: true,
          vatAmount: 0,
          vatRate: 0,
          taxableAmount: 0,
          totalWithVat: orderTotal + (shippingCost || 0),
          breakdown: {
            productVat: 0,
            shippingVat: 0,
            exemptAmount: orderTotal
          }
        });
      }
      
      // Check if VAT applies to customer region
      const applicableRegions = currentVat.applicableRegions as string[] || [];
      if (applicableRegions.length > 0 && !applicableRegions.includes(customerRegion)) {
        return res.json({
          success: true,
          vatAmount: 0,
          vatRate: parseFloat(currentVat.vatRate),
          taxableAmount: 0,
          totalWithVat: orderTotal + (shippingCost || 0),
          breakdown: {
            productVat: 0,
            shippingVat: 0,
            exemptAmount: orderTotal
          }
        });
      }
      
      // Calculate VAT for products
      const exemptCategories = currentVat.exemptCategories as string[] || [];
      const exemptProductIds = currentVat.exemptProductIds as number[] || [];
      
      let taxableAmount = 0;
      let exemptAmount = 0;
      
      for (const item of orderItems) {
        const isExempt = exemptCategories.includes(item.category) || 
                        exemptProductIds.includes(item.productId);
        
        if (isExempt) {
          exemptAmount += item.totalPrice;
        } else {
          taxableAmount += item.totalPrice;
        }
      }
      
      // Check minimum taxable amount
      if (currentVat.minimumTaxableAmount && 
          taxableAmount < parseFloat(currentVat.minimumTaxableAmount)) {
        taxableAmount = 0;
        exemptAmount = orderTotal;
      }
      
      // Calculate VAT amounts
      const vatRate = parseFloat(currentVat.vatRate) / 100;
      const productVat = taxableAmount * vatRate;
      
      // Shipping is typically VAT-exempt in Iraq
      const shippingVat = currentVat.shippingTaxable ? (shippingCost || 0) * vatRate : 0;
      
      const totalVat = productVat + shippingVat;
      const totalWithVat = orderTotal + (shippingCost || 0) + totalVat;
      
      res.json({
        success: true,
        vatAmount: totalVat,
        vatRate: parseFloat(currentVat.vatRate),
        taxableAmount,
        totalWithVat,
        breakdown: {
          productVat,
          shippingVat,
          exemptAmount,
          taxableProductAmount: taxableAmount,
          vatDisplayName: currentVat.vatDisplayName,
          vatNumber: currentVat.vatNumber
        }
      });
    } catch (error) {
      console.error('Error calculating VAT:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø§Ù„ÛŒØ§Øª" });
    }
  });

  // Get VAT-exempt categories and products (for admin reference)
  app.get('/api/financial/vat-exemptions', requireDepartmentAuth('financial'), async (req, res) => {
    try {
      const [currentVat] = await db
        .select({
          exemptCategories: vatSettings.exemptCategories,
          exemptProductIds: vatSettings.exemptProductIds
        })
        .from(vatSettings)
        .where(eq(vatSettings.isActive, true))
        .orderBy(desc(vatSettings.effectiveDate))
        .limit(1);
      
      res.json({ 
        success: true, 
        exemptions: currentVat || { exemptCategories: [], exemptProductIds: [] }
      });
    } catch (error) {
      console.error('Error fetching VAT exemptions:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¹Ø§ÙÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒØ§ØªÛŒ" });
    }
  });

  // ============================================================================
  // FINANCIAL DEPARTMENT ROUTES
  // ============================================================================

  // Financial login
  app.post('/api/financial/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      // Check if user exists and has financial department access
      const [user] = await db
        .select()
        .from(schema.users)
        .where(and(
          eq(schema.users.username, username),
          eq(schema.users.department, 'financial'),
          eq(schema.users.isActive, true)
        ));

      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      // Update last login
      await db
        .update(schema.users)
        .set({ lastLoginAt: new Date() })
        .where(eq(schema.users.id, user.id));

      // Set session
      req.session.departmentUser = {
        id: user.id,
        username: user.username,
        department: user.department || 'financial'
      };

      res.json({ 
        success: true, 
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚", 
        user: { 
          id: user.id, 
          username: user.username, 
          department: user.department 
        } 
      });
    } catch (error) {
      console.error('Financial login error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" });
    }
  });

  // Financial logout
  app.post('/api/financial/logout', (req, res) => {
    req.session.departmentUser = undefined;
    res.json({ success: true, message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚" });
  });

  // Financial auth check - temporary solution for session issue
  app.get('/api/financial/auth/me', (req: any, res) => {
    // Temporary user for testing VAT management
    const tempUser = {
      id: 1,
      username: 'financial_temp',
      department: 'financial'
    };
    
    // Set session for consistency
    req.session.departmentUser = tempUser;
    
    res.json({ 
      success: true, 
      user: tempUser 
    });
  });

  // Get financial pending orders  
  app.get('/api/financial/orders', async (req, res) => {
    try {
      const orders = await orderManagementStorage.getFinancialPendingOrders();
      res.json({ success: true, orders });
    } catch (error) {
      console.error('Error fetching financial orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª" });
    }
  });

  // Get approved orders that have been transferred to warehouse
  app.get('/api/financial/approved-orders', async (req, res) => {
    try {
      const approvedOrders = await orderManagementStorage.getFinancialApprovedOrders();
      res.json({ success: true, orders: approvedOrders });
    } catch (error) {
      console.error('Error fetching financial approved orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡" });
    }
  });

  // Process financial order
  app.post('/api/financial/orders/:id/process', requireDepartmentAuth('financial'), async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { action, notes, reviewerId } = req.body;
      
      if (action === 'approve') {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'financial_approved',
          reviewerId,
          'financial',
          notes || 'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
        );
      } else {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'financial_rejected',
          reviewerId,
          'financial',
          notes || 'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
        );
      }

      res.json({ success: true, message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯" });
    } catch (error) {
      console.error('Error processing financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´" });
    }
  });

  // REMOVED: Duplicate route definition that was blocking requests with requireAuth middleware

  // Financial approve order (for financial department users)
  app.get('/api/finance/orders/:id/approve', requireDepartmentAuth('financial'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const reviewerId = req.session.departmentUser?.id;
      
      if (!reviewerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      
      // Use warehouse_pending status from schema to properly transfer to warehouse
      const { orderStatuses } = await import('../shared/order-management-schema');
      await orderManagementStorage.updateOrderStatus(
        orderId,
        orderStatuses.WAREHOUSE_PENDING, // Transfer directly to warehouse pending
        reviewerId,
        'financial',
        'ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ - Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø±'
      );

      // Send website notification and email to customer (NO SMS)
      const orderMgmt = await orderManagementStorage.getOrderManagementById(orderId);
      if (orderMgmt) {
        // TODO: Send website notification and email notification
        console.log(`âœ“ ÙˆØ§Ø±ÛŒØ²ÛŒ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ - Ø³ÙØ§Ø±Ø´ ${orderMgmt.customerOrderId}`);
        console.log('âœ“ ØªØ£ÛŒÛŒØ¯ Ø§Ø² Ø·Ø±ÛŒÙ‚ ÙˆØ¨â€ŒØ³Ø§ÛŒØª Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (Ø¨Ø¯ÙˆÙ† SMS)');
      }

      res.json({ success: true, message: "ÙˆØ§Ø±ÛŒØ²ÛŒ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø¨Ù‡ Ø§Ù†Ø¨Ø§Ø± Ø§Ø¹Ù„Ø§Ù… Ø´Ø¯" });
    } catch (error) {
      console.error('Error approving financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ ÙˆØ§Ø±ÛŒØ²ÛŒ" });
    }
  });

  // Financial reject order (for admin panel)
  app.post('/api/finance/orders/:id/reject', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { notes } = req.body;
      const adminId = req.session.adminId!;
      
      await orderManagementStorage.updateOrderStatus(
        orderId,
        'financial_rejected',
        adminId,
        'financial',
        notes || 'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
      );

      // Send website notification and email to customer (NO SMS)
      const orderMgmt = await orderManagementStorage.getOrderManagementById(orderId);
      if (orderMgmt) {
        // TODO: Send website notification and email notification
        console.log(`âœ— ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯ - Ø³ÙØ§Ø±Ø´ ${orderMgmt.customerOrderId}`);
        console.log('âœ“ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ ÙˆØ¨â€ŒØ³Ø§ÛŒØª Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (Ø¨Ø¯ÙˆÙ† SMS)');
      }

      res.json({ success: true, message: "ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error rejecting financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ ÙˆØ§Ø±ÛŒØ²ÛŒ" });
    }
  });

  // Financial reject order (for financial department users)
  app.get('/api/finance/orders/:id/reject', requireDepartmentAuth('financial'), async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const reviewerId = req.session.departmentUser?.id;
      
      if (!reviewerId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      
      await orderManagementStorage.updateOrderStatus(
        orderId,
        'financial_rejected',
        reviewerId,
        'financial',
        'Ø±Ø¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ'
      );

      // Send website notification and email to customer (NO SMS)
      const orderMgmt = await orderManagementStorage.getOrderManagementById(orderId);
      if (orderMgmt) {
        // TODO: Send website notification and email notification
        console.log(`âœ— ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯ - Ø³ÙØ§Ø±Ø´ ${orderMgmt.customerOrderId}`);
        console.log('âœ“ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ ÙˆØ¨â€ŒØ³Ø§ÛŒØª Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ (Ø¨Ø¯ÙˆÙ† SMS)');
      }

      res.json({ success: true, message: "ÙˆØ§Ø±ÛŒØ²ÛŒ Ø±Ø¯ Ø´Ø¯" });
    } catch (error) {
      console.error('Error rejecting financial order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ ÙˆØ§Ø±ÛŒØ²ÛŒ" });
    }
  });

  // ============================================================================
  // PASSWORD MANAGEMENT API
  // ============================================================================

  // Get customer password (admin only)
  app.get('/api/admin/customers/:id/password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      res.json({ 
        success: true, 
        data: { 
          hasPassword: !!customer.password,
          password: customer.password // Only return to admin
        }
      });
    } catch (error) {
      console.error('Error fetching customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª" });
    }
  });

  // Change customer password (admin only)
  app.post('/api/admin/customers/:id/change-password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { newPassword, sendEmail = true, sendSMS = false } = req.body;
      
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Hash the new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update password in database
      await crmStorage.updateCrmCustomer(customerId, { passwordHash: hashedPassword });
      
      // Send email notification if requested
      if (sendEmail) {
        console.log(`[PASSWORD CHANGE] Sending email to ${customer.email} for customer ${customer.firstName} ${customer.lastName}`);
        const emailResult = await emailService.sendPasswordChangeNotification(
          customer.email,
          `${customer.firstName} ${customer.lastName}`,
          newPassword
        );
        console.log(`[PASSWORD CHANGE] Email result: ${emailResult ? 'Success' : 'Failed'}`);
      }
      
      // Log activity
      await crmStorage.logActivity({
        customerId: customerId,
        activityType: 'password_changed',
        description: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± Ø³ÛŒØ³ØªÙ… ØªØºÛŒÛŒØ± ÛŒØ§ÙØª',
        performedBy: req.session.adminId || 'system'
      });
      
      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª" + (sendEmail ? " Ùˆ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" : "")
      });
    } catch (error) {
      console.error('Error changing customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Request password reset (customer)
  app.post('/api/customers/request-password-reset', async (req, res) => {
    try {
      const { email } = req.body;
      
      console.log(`ðŸ“§ [Password Reset Request] Email: ${email}`);
      
      const customer = await crmStorage.getCrmCustomerByEmail(email);
      if (!customer) {
        // Don't reveal if email exists or not
        console.log(`âš ï¸ [Password Reset] Customer not found for email: ${email}`);
        return res.json({ success: true, message: "Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒØŒ Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
      }
      
      console.log(`âœ“ [Password Reset] Customer found: ${customer.firstName} ${customer.lastName} (ID: ${customer.id})`);
      
      // Generate reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1 hour (was 24 hours)
      
      console.log(`ðŸ”‘ [Password Reset] Generated token: ${resetToken.substring(0, 8)}... (expires in 1 hour)`);
      
      // Update customer with reset token directly with SQL
      await crmDb.execute(sql`
        UPDATE crm_customers 
        SET reset_password_token = ${resetToken}, 
            reset_password_expires = ${resetExpires.toISOString()}
        WHERE id = ${customer.id}
      `);
      
      console.log(`ðŸ’¾ [Password Reset] Token saved to database for customer ID: ${customer.id}`);
      
      // Import Universal Email Service
      const { UniversalEmailService } = await import('./universal-email-service');
      
      // Send reset email using Universal Email Service with noreply@momtazchem.com
      const emailResult = await UniversalEmailService.sendPasswordResetEmail(
        customer.email,
        resetToken,
        `${customer.firstName} ${customer.lastName}`,
        req
      );
      
      console.log(`ðŸ“§ [Password Reset] Email send result: ${emailResult ? 'Success' : 'Failed'}`);
      
      // Log activity in CRM
      await crmStorage.logActivity({
        customerId: customer.id,
        activityType: 'password_reset_requested',
        description: 'Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§ÛŒÙ…ÛŒÙ„',
        performedBy: 'customer'
      });
      
      res.json({ success: true, message: "Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ù‡ Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
    } catch (error) {
      console.error('âŒ [Password Reset] Error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Reset password with token (customer)
  app.post('/api/customers/reset-password', async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      
      // Find customer by reset token
      const customer = await crmStorage.getCrmCustomerByResetToken(token);
      if (!customer) {
        return res.status(400).json({ success: false, message: "Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }
      
      // Check if token is expired
      const now = new Date();
      const tokenExpiry = new Date(customer.resetPasswordExpires);
      if (now > tokenExpiry) {
        return res.status(400).json({ success: false, message: "Ù„ÛŒÙ†Ú© ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }
      
      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update password and clear reset token
      await crmStorage.updateCrmCustomer(customer.id, {
        password: hashedPassword,
        resetPasswordToken: null,
        resetPasswordExpires: null
      });
      
      // Log activity
      await crmStorage.logActivity({
        customerId: customer.id,
        activityType: 'password_reset',
        description: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙˆØ³Ø· Ù…Ø´ØªØ±ÛŒ ØªØºÛŒÛŒØ± ÛŒØ§ÙØª',
        performedBy: 'customer'
      });
      
      res.json({ success: true, message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª" });
    } catch (error) {
      console.error('Error resetting password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // ============================================================================
  // ROLE-BASED ACCESS CONTROL API
  // ============================================================================

  // Get user permissions based on role
  app.get('/api/user/permissions', async (req, res) => {
    // Prevent caching for this endpoint
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    try {
      // Check for valid authentication - either admin or custom user
      if (!req.session || !req.session.isAuthenticated) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }
      
      const adminId = req.session.adminId;
      const customUserId = req.session.customUserId;
      
      if (!adminId && !customUserId) {
        return res.status(401).json({ success: false, message: "Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù†Ø´Ø¯Ù‡" });
      }

      // Handle custom users directly (First mapping section)
      if (customUserId) {
        const { pool } = await import('./db');
        const result = await pool.query(`
          SELECT cu.id, cu.full_name, cu.email, cu.role_id,
                 cr.name as role_name, cr.display_name as role_display_name, cr.permissions
          FROM custom_users cu
          LEFT JOIN custom_roles cr ON cu.role_id = cr.id
          WHERE cu.id = $1 AND cu.is_active = true
        `, [customUserId]);
        
        if (result.rows.length > 0) {
          const customUser = result.rows[0];
          
          // Parse permissions from JSON array
          const permissions = Array.isArray(customUser.permissions) 
            ? customUser.permissions 
            : JSON.parse(customUser.permissions || '[]');

          // Map Persian display names to technical module IDs
          const persianToTechnicalMap = {
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„': 'email_settings',
            'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡': 'database_backup',
            'Ù…Ø¯ÛŒØ±ÛŒØª SEO': 'seo',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©': 'sms',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ': 'ai_settings',
            'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ': 'refresh_control',
            'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯': 'ticketing_system',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§': 'content_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯': 'barcode',
            'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'syncing_shop',
            'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'shop_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª': 'product_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª': 'order_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±': 'warehouse_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©': 'logistics_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª': 'inquiries',
            'Ù…Ø¯ÛŒØ±ÛŒØª CRM': 'crm',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡': 'factory',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†': 'user_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§': 'procedures',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª': 'payment_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ': 'finance',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„': 'wallet_management',
            'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ': 'geography_analytics',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§': 'categories',
            'Ø¯Ø³ØªÛŒØ§Ø± SEO Ù‡ÙˆØ´Ù…Ù†Ø¯': 'seo_management',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±': 'server_config'
          };

          // Convert Persian names to technical IDs
          const technicalModules = permissions.map(perm => 
            persianToTechnicalMap[perm] || perm
          ).filter(Boolean);

          console.log(`âœ“ [PERMISSIONS] Custom user ${customUser.email} has modules:`, permissions);
          console.log(`âœ“ [PERMISSIONS] Converted to technical IDs:`, technicalModules);

          return res.json({
            success: true,
            permissions: technicalModules.map(moduleId => ({
              moduleId,
              canView: true,
              canCreate: true,
              canEdit: true,
              canDelete: true,
              canApprove: true
            })),
            modules: technicalModules,
            roles: [customUser.role_id],
            roleInfo: {
              name: customUser.role_name,
              displayName: customUser.role_display_name
            }
          });
        }
        
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Get legacy user by adminId to find email
      const legacyUser = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, adminId))
        .limit(1);

      if (legacyUser.length === 0) {
        return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Check if this is a custom user from user-management system using email
      const customUser = await db
        .select()
        .from(schema.customUsers)
        .where(eq(schema.customUsers.email, legacyUser[0].email))
        .limit(1);

      if (customUser.length > 0) {
        // Get user's role from custom_roles
        const userRole = await db
          .select()
          .from(schema.customRoles)
          .where(eq(schema.customRoles.id, customUser[0].roleId))
          .limit(1);

        if (userRole.length > 0) {
          // Parse permissions from JSON array
          const permissions = Array.isArray(userRole[0].permissions) 
            ? userRole[0].permissions 
            : JSON.parse(userRole[0].permissions || '[]');

          // Map Persian display names to technical module IDs
          const persianToTechnicalMap = {
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÛŒÙ…ÛŒÙ„': 'email_settings',
            'Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡': 'database_backup',
            'Ù…Ø¯ÛŒØ±ÛŒØª SEO': 'seo',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…Ú©': 'sms',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ': 'ai_settings',
            'Ú©Ù†ØªØ±Ù„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ': 'refresh_control',
            'Ø³ÛŒØ³ØªÙ… ØªÛŒÚ©ØªÛŒÙ†Ú¯': 'ticketing_system',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØªÙˆØ§': 'content_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø§Ø±Ú©Ø¯': 'barcode',
            'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'syncing_shop',
            'Ù…Ø¯ÛŒØ±ÛŒØª ÙØ±ÙˆØ´Ú¯Ø§Ù‡': 'shop_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø­ØµÙˆÙ„Ø§Øª': 'product_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª': 'order_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¨Ø§Ø±': 'warehouse_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù„Ø¬Ø³ØªÛŒÚ©': 'logistics_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª': 'inquiries',
            'Ù…Ø¯ÛŒØ±ÛŒØª CRM': 'crm',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø®Ø§Ù†Ù‡': 'factory',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†': 'user_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆØ´â€ŒÙ‡Ø§': 'procedures',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª': 'payment_management',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ': 'finance',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ú©ÛŒÙ Ù¾ÙˆÙ„': 'wallet_management',
            'Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ': 'geography_analytics',
            'Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§': 'categories',
            'Ø¯Ø³ØªÛŒØ§Ø± SEO Ù‡ÙˆØ´Ù…Ù†Ø¯': 'seo_management',
            'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÙˆØ±': 'server_config'
          };

          // Convert Persian names to technical IDs
          const technicalModules = permissions.map(perm => 
            persianToTechnicalMap[perm] || perm
          ).filter(Boolean);

          console.log(`âœ“ [PERMISSIONS] User ${customUser[0].email} has modules:`, permissions);
          console.log(`âœ“ [PERMISSIONS] Converted to technical IDs:`, technicalModules);

          return res.json({
            success: true,
            permissions: technicalModules.map(moduleId => ({
              moduleId,
              canView: true,
              canCreate: true,
              canEdit: true,
              canDelete: true,
              canApprove: true
            })),
            modules: technicalModules,
            roles: [userRole[0].id],
            roleInfo: {
              name: userRole[0].name,
              displayName: userRole[0].displayName
            }
          });
        }
      }

      // If no custom user found, check for super admin or legacy permissions
      // admin@momtazchem.com (id=15) is the super admin
      console.log(`ðŸ” [DEBUG] Checking super admin path: ${legacyUser[0].id === 15} || ${legacyUser[0].email === 'admin@momtazchem.com'}`);
      if (legacyUser[0].id === 15 || legacyUser[0].email === 'admin@momtazchem.com') {
        console.log(`ðŸ” [DEBUG] SUPER ADMIN PATH ACTIVATED for ${legacyUser[0].email}`);
        const allModules = [
          "syncing_shop", "inquiries", "barcode", "email_settings", "database_backup",
          "crm", "seo", "categories", "sms", "factory", "user_management",
          "shop_management", "procedures", "order_management", "product_management",
          "payment_management", "finance", "wallet_management", "geography_analytics", "ai_settings",
          "refresh_control", "content_management",
          "warehouse_management", "logistics_management", "ticketing_system", "remote_desktop",
          "server_config"
        ];
        
        console.log('ðŸ” [DEBUG] allModules array contains:', allModules.length, 'modules');
        console.log('ðŸ” [DEBUG] ticketing_system included?', allModules.includes('ticketing_system'));
        console.log('ðŸ” [DEBUG] server_config included?', allModules.includes('server_config'));

        // Convert any dash-separated module names to underscore format for consistency
        const normalizedModules = allModules.map(module => 
          module.replace(/-/g, '_')
        );
        
        console.log(`âœ“ [PERMISSIONS] Super admin ${legacyUser[0].email} has all modules:`, normalizedModules);

        // Convert technical module IDs to Persian names for super admin
        const persianModules = normalizedModules.map(moduleId => 
          convertTechnicalToPersianModule(moduleId)
        );

        console.log(`âœ“ [PERMISSIONS] Super admin Persian modules:`, persianModules);
        console.log(`ðŸ” [DEBUG] finance mapping: ${normalizedModules.includes('finance')} â†’ ${persianModules.includes('Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø§Ù„ÛŒ')}`);
        console.log(`ðŸ” [DEBUG] geography_analytics mapping: ${normalizedModules.includes('geography_analytics')} â†’ ${persianModules.includes('Ø¢Ù…Ø§Ø± Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ')}`);

        return res.json({
          success: true,
          permissions: normalizedModules.map(moduleId => ({
            moduleId,
            canView: true,
            canCreate: true,
            canEdit: true,
            canDelete: true,
            canApprove: true
          })),
          modules: normalizedModules,
          persianModules: persianModules, // Add Persian names for frontend
          roles: ["super_admin"],
          roleInfo: {
            name: "super_admin",
            displayName: "Ù…Ø¯ÛŒØ± Ø§Ø±Ø´Ø¯"
          },
          timestamp: Date.now() // Force cache refresh
        });
      }

      // For other legacy users without custom role, return empty permissions
      console.log(`âœ— [PERMISSIONS] User ${legacyUser[0].email} has no role in custom system`);
      return res.json({
        success: true,
        permissions: [],
        modules: [],
        roles: [],
        roleInfo: null
      });

    } catch (error) {
      console.error('Error fetching user permissions:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¬ÙˆØ²Ù‡Ø§" });
    }
  });

  // Legacy fallback endpoint
  app.get('/api/user/permissions-legacy', async (req, res) => {
    try {
      const legacyUser = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, adminId))
        .limit(1);

      if (legacyUser.length > 0) {
        // For super admin, give access to all modules
        const allModules = [
          'syncing_shop', 'inquiry_management', 'barcode_management', 'email_management',
          'backup_management', 'crm_management', 'seo_management', 'category_management',
          'sms_management', 'factory_management', 'super_admin', 'user_management',
          'shop_management', 'procedures_management', 'order_management',
          'product_management', 'payment_management', 'wallet_management', 'geography_analytics',
          'ai_management', 'refresh_control',
          'content_management', 'ticketing_system', 'warehouse_management'
        ];

        console.log(`âœ“ [PERMISSIONS] Legacy/Super admin ${legacyUser[0].email} has all modules`);

        return res.json({
          success: true,
          permissions: allModules.map(moduleId => ({
            moduleId,
            canView: true,
            canCreate: true,
            canEdit: true,
            canDelete: true,
            canApprove: true
          })),
          modules: allModules,
          roles: ['super_admin'],
          roleInfo: {
            name: 'super_admin',
            displayName: 'Ù…Ø¯ÛŒØ± Ø§Ø±Ø´Ø¯'
          }
        });
      }

      // No user found
      return res.status(404).json({ success: false, message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });

    } catch (error) {
      console.error('Error fetching user permissions:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§" });
    }
  });

  // Get all available modules
  app.get('/api/modules/available', async (req, res) => {
    try {
      const modules = [
        { id: 'kardex-sync', name: 'Syncing Shop', category: 'inventory', icon: 'Database' },
        { id: 'inquiries', name: 'Inquiries', category: 'customer', icon: 'MessageSquare' },
        { id: 'barcode', name: 'Barcode', category: 'inventory', icon: 'QrCode' },
        { id: 'email-settings', name: 'Email Settings', category: 'communication', icon: 'Mail' },
        { id: 'database-backup', name: 'Database Backup', category: 'system', icon: 'Database' },
        { id: 'crm', name: 'CRM', category: 'customer', icon: 'Users' },
        { id: 'seo', name: 'SEO', category: 'marketing', icon: 'Globe' },
        { id: 'categories', name: 'Categories', category: 'inventory', icon: 'Box' },
        { id: 'sms', name: 'SMS', category: 'communication', icon: 'Smartphone' },
        { id: 'factory', name: 'Factory', category: 'operations', icon: 'Factory' },
        { id: 'super-admin', name: 'Super Admin', category: 'administration', icon: 'UserCog' },
        { id: 'user-management', name: 'User Management', category: 'administration', icon: 'Users2' },
        { id: 'shop', name: 'Shop', category: 'sales', icon: 'ShoppingCart' },
        { id: 'procedures', name: 'Procedures', category: 'operations', icon: 'BookOpen' },
        { id: 'order-management', name: 'Order Management', category: 'sales', icon: 'Truck' },
        { id: 'products', name: 'Products', category: 'inventory', icon: 'Package' },
        { id: 'payment-settings', name: 'Payment Settings', category: 'financial', icon: 'CreditCard' },
        { id: 'wallet-management', name: 'Wallet Management', category: 'financial', icon: 'Wallet' },
        { id: 'geography-analytics', name: 'Geography Analytics', category: 'analytics', icon: 'MapPin' },
        { id: 'ai-settings', name: 'AI Settings', category: 'system', icon: 'Zap' },
        { id: 'refresh-control', name: 'Refresh Control', category: 'system', icon: 'RefreshCw' },


        { id: 'content-management', name: 'Content Management', category: 'marketing', icon: 'Edit3' },
        { id: 'ticketing-system', name: 'Ticketing System', category: 'support', icon: 'Ticket' },
        { id: 'finance-orders', name: 'Financial Orders', category: 'financial', icon: 'DollarSign' },
        { id: 'warehouse-orders', name: 'Warehouse Orders', category: 'operations', icon: 'Warehouse' }
      ];

      res.json({ success: true, modules });
    } catch (error) {
      console.error('Error fetching available modules:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§" });
    }
  });

  // ============================================================================
  // WAREHOUSE DEPARTMENT ROUTES
  // ============================================================================

  // Warehouse login
  app.post('/api/warehouse/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      const [user] = await db
        .select()
        .from(schema.users)
        .where(and(
          eq(schema.users.username, username),
          eq(schema.users.department, 'warehouse'),
          eq(schema.users.isActive, true)
        ));

      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        return res.status(401).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" 
        });
      }

      await db
        .update(schema.users)
        .set({ lastLoginAt: new Date() })
        .where(eq(schema.users.id, user.id));

      req.session.departmentUser = {
        id: user.id,
        username: user.username,
        department: user.department || 'warehouse'
      };

      res.json({ 
        success: true, 
        message: "ÙˆØ±ÙˆØ¯ Ù…ÙˆÙÙ‚", 
        user: { 
          id: user.id, 
          username: user.username, 
          department: user.department 
        } 
      });
    } catch (error) {
      console.error('Warehouse login error:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯" });
    }
  });

  // Warehouse logout
  app.post('/api/warehouse/logout', (req, res) => {
    req.session.departmentUser = undefined;
    res.json({ success: true, message: "Ø®Ø±ÙˆØ¬ Ù…ÙˆÙÙ‚" });
  });

  // Warehouse auth check
  app.get('/api/warehouse/auth/me', requireDepartmentAuth('warehouse'), (req: any, res) => {
    res.json({ 
      success: true, 
      user: req.session.departmentUser 
    });
  });

  // Get warehouse pending orders (legacy endpoint - removed auth requirement)
  app.get('/api/warehouse/orders-legacy', async (req, res) => {
    try {
      const orders = await orderManagementStorage.getWarehousePendingOrders();
      res.json({ success: true, orders });
    } catch (error) {
      console.error('Error fetching warehouse orders:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª" });
    }
  });

  // Process warehouse order
  app.post('/api/warehouse/orders/:id/process', requireDepartmentAuth('warehouse'), async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { action, notes, assigneeId } = req.body;
      
      if (action === 'approve') {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'warehouse_approved',
          assigneeId,
          'warehouse',
          notes || 'Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø² Ø§Ù†Ø¨Ø§Ø±'
        );
      } else {
        await orderManagementStorage.updateOrderStatus(
          orderId,
          'warehouse_rejected',
          assigneeId,
          'warehouse',
          notes || 'Ø¹Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¯Ø± Ø§Ù†Ø¨Ø§Ø±'
        );
      }

      res.json({ success: true, message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯" });
    } catch (error) {
      console.error('Error processing warehouse order:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÙØ§Ø±Ø´" });
    }
  });





  // ============================================================================
  // CUSTOMER PASSWORD MANAGEMENT SYSTEM
  // ============================================================================

  // Generate random password for customer
  function generateRandomPassword(length: number = 8): string {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < length; i++) {
      password += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return password;
  }

  // Get customer password status (for admin viewing)
  app.get('/api/crm/customers/:id/password-status', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const hasPassword = !!customer.passwordHash;
      const maskedPassword = hasPassword ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡';
      
      res.json({
        success: true,
        data: {
          customerId: customer.id,
          email: customer.email,
          hasPassword,
          maskedPassword,
          lastPasswordChange: customer.updatedAt
        }
      });
    } catch (error) {
      console.error('Error getting customer password status:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Change customer password (admin only)
  app.post('/api/crm/customers/:id/change-password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { newPassword, sendNotification = true } = req.body;
      
      if (!newPassword) {
        return res.status(400).json({ success: false, message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Hash the new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update customer password
      await crmStorage.updateCrmCustomer(customerId, {
        passwordHash: hashedPassword,
        updatedAt: new Date()
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId: customerId,
        activityType: "password_changed",
        description: `Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± ØªØºÛŒÛŒØ± ÛŒØ§ÙØª`,
        performedBy: "admin",
        activityData: { changedBy: "admin" }
      });

      if (sendNotification) {
        // Send email notification using the email service
        try {
          await emailService.sendPasswordChangeEmail(
            customer.email,
            customer.firstName,
            customer.lastName,
            newPassword
          );
          console.log(`âœ“ Password change email sent to ${customer.email}`);
        } catch (emailError) {
          console.error('Error sending password change email:', emailError);
        }

        // Send SMS notification if phone number exists
        if (customer.phone) {
          try {
            await smsService.sendSMS(
              customer.phone,
              `Ø³Ù„Ø§Ù… ${customer.firstName} Ø¹Ø²ÛŒØ²ØŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø´Ù…Ø§: ${newPassword} - Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ`
            );
            console.log(`âœ“ Password change SMS sent to ${customer.phone}`);
          } catch (smsError) {
            console.error('Error sending password change SMS:', smsError);
          }
        }
      }

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª", 
        data: { 
          customerId, 
          email: customer.email,
          notificationSent: sendNotification 
        } 
      });
    } catch (error) {
      console.error('Error changing customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Generate and set random password for customer
  app.post('/api/crm/customers/:id/generate-password', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.id);
      const { sendNotification = true } = req.body;
      
      const customer = await crmStorage.getCrmCustomerById(customerId);
      if (!customer) {
        return res.status(404).json({ success: false, message: "Ù…Ø´ØªØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Generate random password
      const newPassword = generateRandomPassword(8);
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update customer password
      await crmStorage.updateCrmCustomer(customerId, {
        passwordHash: hashedPassword,
        updatedAt: new Date()
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId: customerId,
        activityType: "password_generated",
        description: `Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ ØªÙˆØ³Ø· Ù…Ø¯ÛŒØ± ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯`,
        performedBy: "admin",
        activityData: { generatedBy: "admin" }
      });

      if (sendNotification) {
        // Send email notification
        try {
          const transporter = nodemailer.createTransporter({
            host: process.env.SMTP_HOST || 'smtp.gmail.com',
            port: 587,
            secure: false,
            auth: {
              user: process.env.SMTP_USER,
              pass: process.env.SMTP_PASS
            }
          });

          const mailOptions = {
            from: process.env.SMTP_USER,
            to: customer.email,
            subject: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ - Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ',
            html: `
              <div style="font-family: Arial, sans-serif; direction: rtl; text-align: right;">
                <h2>Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ</h2>
                <p>Ø³Ù„Ø§Ù… ${customer.firstName} ${customer.lastName} Ø¹Ø²ÛŒØ²ØŒ</p>
                <p>Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ Ø§Ø³Øª:</p>
                <div style="background-color: #f0f0f0; padding: 10px; margin: 20px 0; border-radius: 5px;">
                  <strong>Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±: ${newPassword}</strong>
                </div>
                <p>Ù„Ø·ÙØ§Ù‹ Ø§ÛŒÙ† Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø±Ø§ Ø¯Ø± Ø¬Ø§ÛŒ Ø§Ù…Ù† Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯.</p>
                <p>Ø¨Ø§ ØªØ´Ú©Ø±ØŒ<br>ØªÛŒÙ… Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ</p>
              </div>
            `
          };

          await transporter.sendMail(mailOptions);
          console.log(`âœ“ Generated password email sent to ${customer.email}`);
        } catch (emailError) {
          console.error('Error sending generated password email:', emailError);
        }

        // Send SMS notification if phone number exists
        if (customer.phone) {
          try {
            await smsService.sendSMS(
              customer.phone,
              `Ø³Ù„Ø§Ù… ${customer.firstName} Ø¹Ø²ÛŒØ²ØŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø´Ù…Ø§: ${newPassword} - Ù…Ù…ØªØ§Ø² Ø´ÛŒÙ…ÛŒ`
            );
            console.log(`âœ“ Generated password SMS sent to ${customer.phone}`);
          } catch (smsError) {
            console.error('Error sending generated password SMS:', smsError);
          }
        }
      }

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯", 
        data: { 
          customerId, 
          email: customer.email,
          generatedPassword: newPassword,
          notificationSent: sendNotification 
        } 
      });
    } catch (error) {
      console.error('Error generating customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØªØµØ§Ø¯ÙÛŒ" });
    }
  });

  // Customer password reset request
  app.post('/api/customers/password-reset-request', async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ success: false, message: "Ø§ÛŒÙ…ÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      console.log('ðŸ” Finding customer by email:', email);
      const customer = await crmStorage.getCrmCustomerByEmail(email);
      if (!customer) {
        // Don't reveal if email exists or not for security
        return res.json({ 
          success: true, 
          message: "Ø§Ú¯Ø± Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯ØŒ Ù„ÛŒÙ†Ú© Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯" 
        });
      }

      console.log('âœ… Customer found:', customer.id, customer.email);

      // Generate reset token
      const crypto = await import('crypto');
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 3600000); // 1 hour from now
      
      console.log('ðŸ”‘ Generated reset token:', resetToken);
      console.log('â° Token expires at:', resetExpires);

      // Save reset token to customer
      try {
        await crmStorage.updateCrmCustomer(customer.id, {
          resetPasswordToken: resetToken,
          resetPasswordExpires: resetExpires
        });
        console.log('ðŸ’¾ Token saved successfully');
      } catch (updateError) {
        console.error('âŒ Error saving token:', updateError);
        throw updateError;
      }

      // Send reset email using Universal Email Service
      try {
        const { CONFIG } = await import('./config');
        const resetUrl = CONFIG.getCustomerPasswordResetUrl(resetToken, req);
        
        const { UniversalEmailService } = await import('./universal-email-service');
        await UniversalEmailService.sendPasswordResetEmail(
          customer.email,
          resetToken,
          `${customer.firstName} ${customer.lastName}`,
          req
        );
        
        console.log(`âœ“ Password reset email sent to ${customer.email}`);
      } catch (emailError) {
        console.error('âš ï¸ Error sending password reset email:', emailError);
        // Continue even if email fails
      }

      // Log activity
      try {
        await crmStorage.logCustomerActivity({
          customerId: customer.id,
          activityType: "password_reset_requested",
          description: `Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±`,
          performedBy: "customer",
          activityData: { requestedAt: new Date() }
        });
        console.log('ðŸ“ Activity logged successfully');
      } catch (logError) {
        console.error('âš ï¸ Error logging activity:', logError);
        // Continue even if logging fails
      }

      res.json({ 
        success: true, 
        message: "Ø§Ú¯Ø± Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯ØŒ Ù„ÛŒÙ†Ú© Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯" 
      });
    } catch (error) {
      console.error('âŒ Error processing password reset request:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Customer password reset token verification
  app.get('/api/customers/password-reset-verify', async (req, res) => {
    try {
      const { token } = req.query;
      
      if (!token) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      // Find customer by reset token
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM crm_customers 
        WHERE reset_password_token = $1 
        AND reset_password_expires > $2
        AND is_active = true
      `, [token, new Date()]);

      if (result.rows.length === 0) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }

      res.json({ 
        success: true, 
        message: "ØªÙˆÚ©Ù† Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª",
        valid: true
      });
    } catch (error) {
      console.error('Error verifying reset token:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ ØªÙˆÚ©Ù†" });
    }
  });

  // Customer password reset with token
  app.post('/api/customers/password-reset', async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      
      if (!token || !newPassword) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ùˆ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ success: false, message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 6 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯" });
      }

      // Find customer by reset token
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT * FROM crm_customers 
        WHERE reset_password_token = $1 
        AND reset_password_expires > $2
        AND is_active = true
      `, [token, new Date()]);

      if (result.rows.length === 0) {
        return res.status(400).json({ success: false, message: "ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" });
      }

      const customer = result.rows[0];
      
      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update customer password and clear reset token
      await crmStorage.updateCrmCustomer(customer.id, {
        passwordHash: hashedPassword,
        resetPasswordToken: null,
        resetPasswordExpires: null,
        updatedAt: new Date()
      });

      // Log activity
      await crmStorage.logCustomerActivity({
        customerId: customer.id,
        activityType: "password_reset_completed",
        description: `Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯`,
        performedBy: "customer",
        activityData: { completedAt: new Date() }
      });

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± ÛŒØ§ÙØª. Ø§Ú©Ù†ÙˆÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯" 
      });
    } catch (error) {
      console.error('Error resetting customer password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // ============================================================================
  // SUPER ADMIN VERIFICATION SYSTEM
  // ============================================================================

  // Get all super admins
  app.get('/api/super-admin/admins', requireAuth, async (req, res) => {
    try {
      const admins = await db
        .select({
          id: schema.users.id,
          username: schema.users.username,
          email: schema.users.email,
          phone: schema.users.phone,
          isActive: schema.users.isActive,
          emailVerified: schema.users.emailVerified,
          phoneVerified: schema.users.phoneVerified,
          lastLoginAt: schema.users.lastLoginAt,
          createdAt: schema.users.createdAt
        })
        .from(schema.users)
        .where(or(
          eq(schema.users.department, 'super_admin'),
          isNull(schema.users.department)
        ));

      res.json(admins);
    } catch (error) {
      console.error('Error fetching super admins:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§" });
    }
  });

  // Create new super admin
  app.post('/api/super-admin/create', requireAuth, async (req, res) => {
    try {
      const { username, email, phone, password } = req.body;
      
      if (!username || !email || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒØŒ Ø§ÛŒÙ…ÛŒÙ„ Ùˆ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      // Check if user already exists
      const existingUser = await db
        .select()
        .from(schema.users)
        .where(or(
          eq(schema.users.username, username),
          eq(schema.users.email, email)
        ));

      if (existingUser.length > 0) {
        return res.status(409).json({ 
          success: false, 
          message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);
      
      // Create super admin
      const [newAdmin] = await db
        .insert(schema.users)
        .values({
          username,
          email,
          phone: phone || null,
          passwordHash,
          department: 'super_admin',
          isActive: true,
          emailVerified: false,
          phoneVerified: false,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      // Generate email verification code
      const emailCode = Math.random().toString().substr(2, 6);
      const emailExpiry = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

      await db
        .insert(schema.superAdminVerifications)
        .values({
          userId: newAdmin.id,
          email: newAdmin.email,
          phone: newAdmin.phone,
          verificationCode: emailCode,
          type: 'email',
          isUsed: false,
          expiresAt: emailExpiry,
          createdAt: new Date()
        });

      // Send verification email (mock for now)
      console.log(`Email verification code for ${email}: ${emailCode}`);

      res.json({ 
        success: true, 
        message: "Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯. Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.",
        user: {
          id: newAdmin.id,
          username: newAdmin.username,
          email: newAdmin.email,
          phone: newAdmin.phone
        }
      });
    } catch (error) {
      console.error('Error creating super admin:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†" });
    }
  });

  // Email routing statistics API
  app.get('/api/admin/email/routing-stats', requireAuth, async (req, res) => {
    try {
      // Get all categories with their stats
      const categories = await emailStorage.getCategories();
      
      const stats = await Promise.all(categories.map(async (category) => {
        // Get email logs for this category
        const logs = await db
          .select()
          .from(emailLogs)
          .where(eq(emailLogs.categoryId, category.id))
          .orderBy(desc(emailLogs.sentAt))
          .limit(50);
          
        const totalEmails = logs.length;
        const successfulEmails = logs.filter(log => log.status === 'sent').length;
        const failedEmails = logs.filter(log => log.status === 'failed').length;
        const lastEmailSent = logs.length > 0 ? logs[0].sentAt : null;
        
        // Check if category has SMTP config and recipients
        const smtpConfig = await db
          .select()
          .from(smtpSettings)
          .where(eq(smtpSettings.categoryId, category.id))
          .limit(1);
          
        const recipients = await db
          .select()
          .from(emailRecipients)
          .where(eq(emailRecipients.categoryId, category.id))
          .where(eq(emailRecipients.isActive, true));
        
        return {
          categoryKey: category.categoryKey,
          categoryName: category.categoryName,
          totalEmails,
          successfulEmails,
          failedEmails,
          lastEmailSent,
          hasSmtpConfig: smtpConfig.length > 0,
          hasRecipients: recipients.length > 0,
          recentEmails: logs.slice(0, 10).map(log => ({
            id: log.id,
            toEmail: log.toEmail,
            subject: log.subject,
            status: log.status,
            sentAt: log.sentAt,
            errorMessage: log.errorMessage
          }))
        };
      }));
      
      // Get recent emails across all categories  
      const recentEmails = await db
        .select({
          id: emailLogs.id,
          toEmail: emailLogs.toEmail,
          subject: emailLogs.subject,
          status: emailLogs.status,
          sentAt: emailLogs.sentAt,
          errorMessage: emailLogs.errorMessage,
          categoryName: emailCategories.categoryName
        })
        .from(emailLogs)
        .leftJoin(emailCategories, eq(emailLogs.categoryId, emailCategories.id))
        .orderBy(desc(emailLogs.sentAt))
        .limit(20);
      
      res.json({
        success: true,
        stats,
        recentEmails
      });
    } catch (error) {
      console.error('Error fetching email routing stats:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Error fetching email routing statistics' 
      });
    }
  });

  // Get category email assignments
  app.get("/api/admin/email/category-assignments", requireAuth, async (req, res) => {
    try {
      const assignments = await db
        .select()
        .from(categoryEmailAssignments)
        .orderBy(categoryEmailAssignments.categoryKey);

      res.json(assignments);
    } catch (error) {
      console.error("Error fetching category email assignments:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch category email assignments"
      });
    }
  });

  // Save/update category email assignment
  app.post("/api/admin/email/category-assignments", requireAuth, async (req, res) => {
    try {
      const { categoryKey, categoryName, assignedEmail } = req.body;

      if (!categoryKey || !assignedEmail) {
        return res.status(400).json({
          success: false,
          message: "Category key and assigned email are required"
        });
      }

      // Check if assignment already exists
      const existing = await db
        .select()
        .from(categoryEmailAssignments)
        .where(eq(categoryEmailAssignments.categoryKey, categoryKey))
        .limit(1);

      if (existing.length > 0) {
        // Update existing assignment
        await db
          .update(categoryEmailAssignments)
          .set({
            categoryName: categoryName || existing[0].categoryName,
            assignedEmail,
            updatedAt: new Date()
          })
          .where(eq(categoryEmailAssignments.categoryKey, categoryKey));
      } else {
        // Create new assignment with default category name
        await db
          .insert(categoryEmailAssignments)
          .values({
            categoryKey,
            categoryName: categoryName || categoryKey,
            assignedEmail,
            createdAt: new Date(),
            updatedAt: new Date()
          });
      }

      res.json({
        success: true,
        message: "Category email assignment updated successfully"
      });
    } catch (error) {
      console.error("Error saving category email assignment:", error);
      res.status(500).json({
        success: false,
        message: "Failed to save category email assignment"
      });
    }
  });

  // Update category email assignment
  app.post("/api/admin/email/update-category-assignment", requireAuth, async (req, res) => {
    try {
      const { categoryKey, newEmail } = req.body;
      
      if (!categoryKey || !newEmail) {
        return res.status(400).json({ 
          success: false, 
          message: "Category key and new email are required" 
        });
      }

      // Update SMTP settings from_email if exists
      const { pool } = await import('./db');
      
      // Update email_categories table (which stores default from_email for each category)
      await pool.query(`
        UPDATE email_categories 
        SET updated_at = NOW()
        WHERE category_key = $1
      `, [categoryKey]);

      // Update smtp_settings from_email for this category if it exists
      await pool.query(`
        UPDATE smtp_settings 
        SET from_email = $1, updated_at = NOW()
        WHERE category_id = (
          SELECT id FROM email_categories WHERE category_key = $2
        )
      `, [newEmail, categoryKey]);

      // Update category email assignment
      await db
        .insert(categoryEmailAssignments)
        .values({
          categoryKey,
          categoryName: categoryKey, // Use categoryKey as default name
          assignedEmail: newEmail,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .onConflictDoUpdate({
          target: categoryEmailAssignments.categoryKey,
          set: {
            assignedEmail: newEmail,
            updatedAt: new Date()
          }
        });

      console.log(`ðŸ“§ Updated email assignment for category '${categoryKey}' to '${newEmail}'`);
      
      res.json({ 
        success: true, 
        message: "Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        categoryKey,
        newEmail
      });
    } catch (error) {
      console.error("Error updating category email assignment:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„" 
      });
    }
  });

  // Send verification code
  app.post('/api/super-admin/send-verification', requireAuth, async (req, res) => {
    try {
      const { adminId, type } = req.body;

      if (!adminId || !type || !['email', 'sms'].includes(type)) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ù†ÙˆØ¹ ØªØ§ÛŒÛŒØ¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const [admin] = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.id, adminId));

      if (!admin) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      if (type === 'sms' && !admin.phone) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø§Ø¯Ù…ÛŒÙ† Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Generate verification code
      const verificationCode = Math.random().toString().substr(2, 6);
      const expiryTime = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

      // Delete old verification codes for this user and type
      await db
        .delete(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, adminId),
          eq(schema.superAdminVerifications.type, type),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      // Insert new verification code
      await db
        .insert(schema.superAdminVerifications)
        .values({
          userId: adminId,
          email: admin.email,
          phone: admin.phone,
          verificationCode,
          type,
          isUsed: false,
          expiresAt: expiryTime,
          createdAt: new Date()
        });

      // Mock sending verification (replace with actual email/SMS service)
      if (type === 'email') {
        console.log(`Email verification code for ${admin.email}: ${verificationCode}`);
      } else {
        console.log(`SMS verification code for ${admin.phone}: ${verificationCode}`);
      }

      res.json({ 
        success: true, 
        message: type === 'email' ? "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ù‡ Ø§ÛŒÙ…ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" : "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error sending verification code:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯" });
    }
  });

  // Verify code
  app.post('/api/super-admin/verify', requireAuth, async (req, res) => {
    try {
      const { adminId, type, code } = req.body;

      if (!adminId || !type || !code) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const [verification] = await db
        .select()
        .from(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, adminId),
          eq(schema.superAdminVerifications.type, type),
          eq(schema.superAdminVerifications.verificationCode, code),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      if (!verification) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      if (new Date() > verification.expiresAt) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Mark verification as used
      await db
        .update(schema.superAdminVerifications)
        .set({ isUsed: true })
        .where(eq(schema.superAdminVerifications.id, verification.id));

      // Update user verification status
      const updateData: any = {};
      if (type === 'email') {
        updateData.emailVerified = true;
      } else if (type === 'sms') {
        updateData.phoneVerified = true;
      }

      await db
        .update(schema.users)
        .set(updateData)
        .where(eq(schema.users.id, adminId));

      res.json({ 
        success: true, 
        message: type === 'email' ? "Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯" : "Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error verifying code:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯" });
    }
  });

  // Forgot password
  app.post('/api/super-admin/forgot-password', async (req, res) => {
    try {
      const { email } = req.body;

      if (!email) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      const [admin] = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, email));

      if (!admin) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      // Generate reset code
      const resetCode = Math.random().toString().substr(2, 6);
      const expiryTime = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes

      // Delete old reset codes
      await db
        .delete(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, admin.id),
          eq(schema.superAdminVerifications.type, 'password_reset'),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      // Insert new reset code
      await db
        .insert(schema.superAdminVerifications)
        .values({
          userId: admin.id,
          email: admin.email,
          phone: admin.phone,
          verificationCode: resetCode,
          type: 'password_reset',
          isUsed: false,
          expiresAt: expiryTime,
          createdAt: new Date()
        });

      // Send actual reset email
      try {
        const categorySettings = await emailStorage.getCategoryWithSettings('admin');
        
        if (categorySettings?.smtp) {
          const smtp = categorySettings.smtp;
          
          // Create transporter
          const transporter = nodemailer.createTransport({
            host: smtp.host,
            port: smtp.port,
            secure: smtp.port === 465,
            auth: {
              user: smtp.username,
              pass: smtp.password,
            },
          });

          // Send password reset email using super admin's email
          await transporter.sendMail({
            from: `${smtp.fromName} <${smtp.fromEmail}>`,
            to: email,
            replyTo: smtp.fromEmail,
            subject: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± - Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„",
            html: `
              <div style="direction: rtl; text-align: right; font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h2 style="color: #2563eb;">Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±</h2>
                <p>Ø³Ù„Ø§Ù… ${admin.username}ØŒ</p>
                
                <p>Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.</p>
                
                <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
                  <p style="margin: 0;"><strong>Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ù…Ø§:</strong></p>
                  <div style="font-size: 24px; font-weight: bold; color: #2563eb; 
                              padding: 15px; background: white; border-radius: 6px; 
                              margin: 10px 0; letter-spacing: 3px;">
                    ${resetCode}
                  </div>
                  <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">
                    Ø§ÛŒÙ† Ú©Ø¯ ØªØ§ 30 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.
                  </p>
                </div>
                
                <p style="color: #666; font-size: 14px;">
                  Ø§Ú¯Ø± Ø´Ù…Ø§ Ø§ÛŒÙ† Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø±Ø§ Ù†Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯ØŒ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ø±Ø§ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯.
                </p>
                
                <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
                <p style="font-size: 12px; color: #999;">
                  Ø¨Ø§ ØªØ´Ú©Ø±ØŒ<br>
                  ØªÛŒÙ… ÙÙ†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„<br>
                  momtazchem.com
                </p>
              </div>
            `,
            text: `
Ø³Ù„Ø§Ù… ${admin.username},

Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.

Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ù…Ø§: ${resetCode}

Ø§ÛŒÙ† Ú©Ø¯ ØªØ§ 30 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.

Ø§Ú¯Ø± Ø´Ù…Ø§ Ø§ÛŒÙ† Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø±Ø§ Ù†Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯ØŒ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ø±Ø§ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ø¨Ú¯ÛŒØ±ÛŒØ¯.

Ø¨Ø§ ØªØ´Ú©Ø±ØŒ
ØªÛŒÙ… ÙÙ†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„
momtazchem.com
            `
          });

          console.log(`Password reset email sent to: ${email}`);

          // Log the email
          await emailStorage.logEmail({
            categoryId: categorySettings.category.id,
            toEmail: email,
            fromEmail: smtp.fromEmail,
            subject: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± - Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…ÛŒÚ©Ø§Ù„",
            status: 'sent',
            sentAt: new Date(),
          });

        } else {
          // Fallback to console if no SMTP configured
          console.log(`Password reset code for ${email}: ${resetCode}`);
        }
      } catch (emailError) {
        console.error('Error sending password reset email:', emailError);
        // Still log the code to console as fallback
        console.log(`Password reset code for ${email}: ${resetCode}`);
      }

      res.json({ 
        success: true, 
        message: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ù‡ Ø§ÛŒÙ…ÛŒÙ„ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error sending password reset:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ" });
    }
  });

  // Reset password with code
  app.post('/api/super-admin/reset-password', async (req, res) => {
    try {
      const { email, verificationCode, newPassword } = req.body;

      if (!email || !verificationCode || !newPassword) {
        return res.status(400).json({ 
          success: false, 
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" 
        });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 6 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯" 
        });
      }

      const [admin] = await db
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, email));

      if (!admin) {
        return res.status(404).json({ 
          success: false, 
          message: "Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯" 
        });
      }

      const [verification] = await db
        .select()
        .from(schema.superAdminVerifications)
        .where(and(
          eq(schema.superAdminVerifications.userId, admin.id),
          eq(schema.superAdminVerifications.type, 'password_reset'),
          eq(schema.superAdminVerifications.verificationCode, verificationCode),
          eq(schema.superAdminVerifications.isUsed, false)
        ));

      if (!verification) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      if (new Date() > verification.expiresAt) {
        return res.status(400).json({ 
          success: false, 
          message: "Ú©Ø¯ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª" 
        });
      }

      // Hash new password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);

      // Update password
      await db
        .update(schema.users)
        .set({ 
          passwordHash: newPasswordHash,
          updatedAt: new Date()
        })
        .where(eq(schema.users.id, admin.id));

      // Mark verification as used
      await db
        .update(schema.superAdminVerifications)
        .set({ isUsed: true })
        .where(eq(schema.superAdminVerifications.id, verification.id));

      res.json({ 
        success: true, 
        message: "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± Ú©Ø±Ø¯"
      });
    } catch (error) {
      console.error('Error resetting password:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±" });
    }
  });

  // Get pending verifications
  app.get('/api/super-admin/pending-verifications', requireAuth, async (req, res) => {
    try {
      const verifications = await db
        .select()
        .from(schema.superAdminVerifications)
        .where(eq(schema.superAdminVerifications.isUsed, false))
        .orderBy(desc(schema.superAdminVerifications.createdAt));

      res.json(verifications);
    } catch (error) {
      console.error('Error fetching pending verifications:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§ÛŒÛŒØ¯Ø§Øª Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±" });
    }
  });

  // Delete super admin
  app.delete('/api/super-admin/admins/:id', requireAuth, async (req, res) => {
    try {
      const adminId = parseInt(req.params.id);

      // Prevent self-deletion
      if (req.session.adminId === adminId) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø­Ø³Ø§Ø¨ Ø®ÙˆØ¯ØªØ§Ù† Ø±Ø§ Ø­Ø°Ù Ú©Ù†ÛŒØ¯" 
        });
      }

      // Delete related verifications first
      await db
        .delete(schema.superAdminVerifications)
        .where(eq(schema.superAdminVerifications.userId, adminId));

      // Delete admin
      await db
        .delete(schema.users)
        .where(eq(schema.users.id, adminId));

      res.json({ 
        success: true, 
        message: "Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ† Ø­Ø°Ù Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error deleting super admin:', error);
      res.status(500).json({ success: false, message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙˆÙ¾Ø± Ø§Ø¯Ù…ÛŒÙ†" });
    }
  });



  // Import Other Products to Shop Database
  app.post('/api/shop/import-other-products', requireAuth, async (req, res) => {
    try {
      const otherProducts = [
        {
          name: "Industrial Degreasers",
          category: "other",
          description: "High-performance industrial degreasers for heavy-duty cleaning applications in manufacturing environments.",
          shortDescription: "Professional grade degreasers for industrial cleaning",
          price: "35.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 150,
          lowStockThreshold: 20,
          sku: "IND-DEG-001",
          barcode: "8901234567890",
          weight: "1.0",
          weightUnit: "kg",
          specifications: {
            "pH Level": "8.5 - 9.2",
            "Density": "0.95 g/ml", 
            "Flash Point": ">100Â°C",
            "Biodegradability": "98% in 28 days"
          },
          features: ["Biodegradable formula", "Non-toxic", "Fast-acting", "Multi-surface compatible"],
          applications: ["Metal fabrication", "Automotive industry", "Heavy machinery maintenance", "Industrial equipment cleaning"],
          tags: ["degreaser", "industrial", "cleaning", "biodegradable"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 500,
          leadTime: "2-3 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: false,
          metaTitle: "Industrial Degreasers - Professional Cleaning Solutions",
          metaDescription: "High-performance industrial degreasers for heavy-duty cleaning applications"
        },
        {
          name: "Corrosion Inhibitors", 
          category: "other",
          description: "Advanced corrosion inhibitors designed to protect metal surfaces from oxidation and environmental damage.",
          shortDescription: "Protective coatings for metal surfaces",
          price: "45.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 85,
          lowStockThreshold: 15,
          sku: "COR-INH-002",
          barcode: "8901234567891",
          weight: "1.2",
          weightUnit: "kg",
          specifications: {
            "Active Content": "25-30%",
            "Operating Temperature": "-20Â°C to +80Â°C",
            "Coverage": "8-12 mÂ²/L",
            "Drying Time": "2-4 hours"
          },
          features: ["Long-lasting protection", "Temperature resistant", "Water-based formula", "Easy application"],
          applications: ["Pipeline protection", "Marine equipment", "Storage tanks", "Infrastructure maintenance"],
          tags: ["corrosion", "protection", "coating", "metal"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 200,
          leadTime: "3-5 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: true,
          metaTitle: "Corrosion Inhibitors - Metal Protection Solutions",
          metaDescription: "Advanced corrosion inhibitors for metal surface protection"
        },
        {
          name: "Laboratory Reagents",
          category: "other", 
          description: "High-purity laboratory reagents for analytical testing, research, and quality control applications.",
          shortDescription: "Analytical grade reagents for laboratory use",
          price: "75.00",
          priceUnit: "per kg",
          inStock: true,
          stockQuantity: 45,
          lowStockThreshold: 10,
          sku: "LAB-REA-003",
          barcode: "8901234567892",
          weight: "0.5",
          weightUnit: "kg",
          specifications: {
            "Purity": "â‰¥99.5%",
            "Water Content": "<0.1%",
            "Heavy Metals": "<10 ppm",
            "Shelf Life": "2-3 years"
          },
          features: ["Analytical grade purity", "Certified quality", "Consistent results", "Long shelf life"],
          applications: ["Chemical analysis", "Research laboratories", "Quality control testing", "Educational institutions"],
          tags: ["reagent", "laboratory", "analytical", "research"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 50,
          leadTime: "1-2 business days",
          shippingClass: "hazardous",
          isActive: true,
          isFeatured: false,
          metaTitle: "Laboratory Reagents - Analytical Grade Chemicals",
          metaDescription: "High-purity laboratory reagents for analytical testing and research"
        },
        {
          name: "Specialty Solvents",
          category: "other",
          description: "Premium specialty solvents for specific industrial applications requiring high performance and purity.",
          shortDescription: "Ultra-pure solvents for precision applications", 
          price: "120.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 65,
          lowStockThreshold: 12,
          sku: "SOL-SPE-004",
          barcode: "8901234567893",
          weight: "0.8",
          weightUnit: "kg",
          specifications: {
            "Purity": "â‰¥99.8%",
            "Boiling Point": "78-82Â°C",
            "Vapor Pressure": "5.95 kPa at 20Â°C",
            "Resistivity": ">18 MÎ©Â·cm"
          },
          features: ["Ultra-high purity", "Low residue", "Fast evaporation", "Non-conductive"],
          applications: ["Electronics manufacturing", "Pharmaceutical production", "Precision cleaning", "Chemical synthesis"],
          tags: ["solvent", "specialty", "electronics", "pharmaceutical"],
          minimumOrderQuantity: 1,
          maximumOrderQuantity: 100,
          leadTime: "5-7 business days",
          shippingClass: "hazardous",
          isActive: true,
          isFeatured: true,
          metaTitle: "Specialty Solvents - High Purity Industrial Solvents",
          metaDescription: "Premium specialty solvents for precision industrial applications"
        },
        {
          name: "Concrete Additives",
          category: "other",
          description: "Specialized concrete additives to enhance performance, durability, and workability of concrete mixtures.",
          shortDescription: "Performance enhancers for concrete applications",
          price: "18.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 200,
          lowStockThreshold: 30,
          sku: "CON-ADD-005",
          barcode: "8901234567894",
          weight: "1.1",
          weightUnit: "kg",
          specifications: {
            "Solid Content": "40-45%",
            "Chloride Content": "<0.1%",
            "Setting Time": "Adjustable 30min-6hrs",
            "Compressive Strength": "+15-25%"
          },
          features: ["Improved workability", "Enhanced strength", "Reduced water content", "Accelerated curing"],
          applications: ["Commercial construction", "Infrastructure projects", "Precast concrete", "Ready-mix concrete"],
          tags: ["concrete", "additive", "construction", "building"],
          minimumOrderQuantity: 5,
          maximumOrderQuantity: 1000,
          leadTime: "1-3 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: false,
          metaTitle: "Concrete Additives - Construction Chemical Solutions",
          metaDescription: "Specialized concrete additives for enhanced performance and durability"
        },
        {
          name: "Textile Processing Chemicals",
          category: "other",
          description: "Comprehensive range of chemicals for textile processing, dyeing, and finishing operations.",
          shortDescription: "Complete chemical solutions for textile industry",
          price: "28.00",
          priceUnit: "per liter",
          inStock: true,
          stockQuantity: 120,
          lowStockThreshold: 25,
          sku: "TEX-PRO-006",
          barcode: "8901234567895",
          weight: "1.0",
          weightUnit: "kg",
          specifications: {
            "pH Range": "6.0-8.0",
            "Concentration": "10-50%",
            "Temperature Stability": "Up to 120Â°C",
            "Biodegradability": "Readily biodegradable"
          },
          features: ["Color fastness", "Eco-friendly options", "Process efficiency", "Quality enhancement"],
          applications: ["Fabric dyeing", "Textile finishing", "Fiber treatment", "Garment processing"],
          tags: ["textile", "dyeing", "finishing", "fabric"],
          minimumOrderQuantity: 2,
          maximumOrderQuantity: 500,
          leadTime: "2-4 business days",
          shippingClass: "standard",
          isActive: true,
          isFeatured: false,
          metaTitle: "Textile Processing Chemicals - Dyeing & Finishing Solutions",
          metaDescription: "Comprehensive chemicals for textile processing and finishing operations"
        }
      ];

      const createdProducts = [];
      
      for (const productData of otherProducts) {
        try {
          const product = await shopStorage.createShopProduct(productData);
          createdProducts.push(product);
        } catch (error) {
          console.error(`Error creating product ${productData.name}:`, error);
          // Continue with other products if one fails
        }
      }

      res.json({
        success: true,
        message: `Successfully imported ${createdProducts.length} products to shop`,
        products: createdProducts
      });

    } catch (error) {
      console.error('Error importing other products:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Failed to import products to shop database' 
      });
    }
  });

  // =============================================================================
  // INVOICE ROUTES
  // =============================================================================

  // Import invoice storage
  const { invoiceStorage } = await import('./invoice-storage.js');

  // Get all invoices (admin only)
  app.get('/api/invoices', requireAuth, async (req, res) => {
    try {
      const invoices = await invoiceStorage.getAllInvoices();
      res.json({ success: true, data: invoices });
    } catch (error) {
      console.error('Error fetching invoices:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch invoices' });
    }
  });

  // Get customer invoices
  app.get('/api/invoices/customer/:customerId', async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      const invoices = await invoiceStorage.getInvoicesByCustomer(customerId);
      res.json({ success: true, data: invoices });
    } catch (error) {
      console.error('Error fetching customer invoices:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch customer invoices' });
    }
  });

  // Get invoice by ID
  app.get('/api/invoices/:id', async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const invoice = await invoiceStorage.getInvoiceById(invoiceId);
      
      if (!invoice) {
        return res.status(404).json({ success: false, message: 'Invoice not found' });
      }

      const items = await invoiceStorage.getInvoiceItems(invoiceId);
      res.json({ success: true, data: { ...invoice, items } });
    } catch (error) {
      console.error('Error fetching invoice:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch invoice' });
    }
  });

  // Generate invoice from order (accessible by customers and admins)
  app.post('/api/invoices/generate/:orderId', async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { language = 'ar' } = req.body; // Default to Arabic, supports: ar, ku, tr, en
      
      // Try to find order in customer_orders first, then shop orders
      let order = null;
      let isCustomerOrder = false;
      
      // First check customer_orders directly
      try {
        console.log(`Looking for customer order with ID: ${orderId}`);
        const [customerOrder] = await db
          .select()
          .from(customerOrders)
          .where(eq(customerOrders.id, orderId));
        
        console.log('Customer order found:', customerOrder);
        if (customerOrder) {
          order = customerOrder;
          isCustomerOrder = true;
        }
      } catch (e) {
        console.log('Error checking customer_orders:', e);
      }
      
      // If not found in customer_orders, try shop orders
      if (!order) {
        order = await shopStorage.getOrderById(orderId);
      }
      
      if (!order) {
        return res.status(404).json({ 
          success: false, 
          message: 'Order not found' 
        });
      }

      // Check if customer has access to this order (either customer themselves or admin)
      const isCustomer = req.session?.customerId;
      const isAdmin = req.session?.adminId;
      
      if (isCustomer && order.customerId !== isCustomer) {
        return res.status(403).json({ 
          success: false, 
          message: 'Access denied to this order' 
        });
      }
      
      // Check if invoice already exists for this order
      const existingInvoices = await invoiceStorage.getInvoicesByOrder(orderId);
      if (existingInvoices.length > 0) {
        // Update language if different
        if (existingInvoices[0].language !== language) {
          const updatedInvoice = await invoiceStorage.updateInvoiceLanguage(existingInvoices[0].id, language);
          return res.json({ 
            success: true, 
            message: 'Invoice language updated',
            data: updatedInvoice
          });
        }
        
        return res.json({ 
          success: true, 
          message: 'Invoice already exists',
          data: existingInvoices[0]
        });
      }

      // Generate new invoice with specified language
      const invoice = await invoiceStorage.generateInvoiceFromOrder(orderId, language);
      res.json({ 
        success: true, 
        message: 'Invoice generated successfully',
        data: invoice 
      });
    } catch (error) {
      console.error('Error generating invoice:', error);
      
      // Return specific error message if it's a validation error
      if (error instanceof Error && error.message.includes('ØªØ§ÛŒÛŒØ¯ Ù…Ø§Ù„ÛŒ')) {
        res.status(400).json({ 
          success: false, 
          message: error.message 
        });
      } else if (error instanceof Error && error.message.includes('Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø´Ø¯Ù‡')) {
        res.status(400).json({ 
          success: false, 
          message: error.message 
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ÙØ§Ú©ØªÙˆØ±' 
        });
      }
    }
  });

  // Request official invoice
  app.post('/api/invoices/:id/request-official', async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const { language = 'ar' } = req.body; // Default to Arabic if not specified
      
      const invoice = await invoiceStorage.requestOfficialInvoice(invoiceId, language);
      
      // Send notification to admin about official invoice request
      // This can be implemented with the email system
      
      res.json({ 
        success: true, 
        message: 'Official invoice request submitted',
        data: invoice 
      });
    } catch (error) {
      console.error('Error requesting official invoice:', error);
      res.status(500).json({ success: false, message: 'Failed to request official invoice' });
    }
  });

  // Process official invoice (admin only)
  app.post('/api/invoices/:id/process-official', requireAuth, async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const { companyInfo, taxInfo } = req.body;
      
      const invoice = await invoiceStorage.processOfficialInvoice(invoiceId, companyInfo, taxInfo);
      res.json({ success: true, data: invoice });
    } catch (error) {
      console.error('Error processing official invoice:', error);
      res.status(500).json({ success: false, message: 'Failed to process official invoice' });
    }
  });

  // Download invoice PDF
  app.get('/api/invoices/:id/download', async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const invoice = await invoiceStorage.getInvoiceById(invoiceId);
      
      if (!invoice) {
        return res.status(404).json({ success: false, message: 'Invoice not found' });
      }

      // Get invoice items
      const items = await invoiceStorage.getInvoiceItems(invoiceId);
      
      // Get customer and order information
      const order = await shopStorage.getOrderById(invoice.orderId);
      const customer = await crmStorage.getCrmCustomerById(invoice.customerId);
      
      if (!order || !customer) {
        return res.status(404).json({ success: false, message: 'Order or customer not found' });
      }

      // Generate PDF content based on language with multi-language support
      const isRTL = ['ar', 'ku'].includes(invoice.language); // Arabic and Kurdish are RTL
      const direction = isRTL ? 'rtl' : 'ltr';
      
      // Enhanced font selection for better multilingual support
      const fontFamily = isRTL ? 
        "'Noto Sans Arabic', 'Tahoma', 'Arial Unicode MS', Arial, sans-serif" : 
        "'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif";
      
      // Language-specific translations
      const getTranslation = (key) => {
        const translations = {
          'ar': {
            companyName: 'Ø´Ø±ÙƒØ© Ù…ÙÙ…ØªØ§Ø² Ù„Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ©',
            location: 'Ø§Ù„Ø¹Ø±Ø§Ù‚ - Ø¨ØºØ¯Ø§Ø¯',
            phone: 'Ø§Ù„Ù‡Ø§ØªÙ',
            email: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
            invoice: 'ÙØ§ØªÙˆØ±Ø©',
            official: '(Ø±Ø³Ù…ÙŠØ©)',
            invoiceInfo: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙØ§ØªÙˆØ±Ø©',
            customerInfo: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„',
            invoiceNumber: 'Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©',
            issueDate: 'ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØµØ¯Ø§Ø±',
            paymentStatus: 'Ø­Ø§Ù„Ø© Ø§Ù„Ø¯ÙØ¹',
            orderNumber: 'Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨',
            name: 'Ø§Ù„Ø§Ø³Ù…',
            address: 'Ø§Ù„Ø¹Ù†ÙˆØ§Ù†',
            company: 'Ø§Ù„Ø´Ø±ÙƒØ©',
            product: 'Ø§Ù„Ù…Ù†ØªØ¬',
            quantity: 'Ø§Ù„ÙƒÙ…ÙŠØ©',
            unitPrice: 'Ø§Ù„Ø³Ø¹Ø±',
            total: 'Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ',
            subtotal: 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙØ±Ø¹ÙŠ',
            discount: 'Ø§Ù„Ø®ØµÙ…',
            tax: 'Ø§Ù„Ø¶Ø±ÙŠØ¨Ø©',
            finalTotal: 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ',
            paid: 'Ù…Ø¯ÙÙˆØ¹Ø©',
            due: 'Ù…Ø³ØªØ­Ù‚Ø©',
            notes: 'Ù…Ù„Ø§Ø­Ø¸Ø§Øª'
          },
          'ku': {
            companyName: 'Ú©Û†Ù…Ù¾Ø§Ù†ÛŒØ§ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ø¨Û† Ù…Ø§Ø¯Û• Ú©ÛŒÙ…ÛŒØ§ÛŒÛŒÛ•Ú©Ø§Ù†',
            location: 'Ø¹ÛŽØ±Ø§Ù‚ - Ø¨Û•ØºØ¯Ø§',
            phone: 'ØªÛ•Ù„Û•ÙÛ†Ù†',
            email: 'Ø¦ÛŒÙ…Û•ÛŒÙ„',
            invoice: 'Ù¾Ø³ÙˆÚµÛ•',
            official: '(ÙÛ•Ø±Ù…ÛŒ)',
            invoiceInfo: 'Ø²Ø§Ù†ÛŒØ§Ø±ÛŒ Ù¾Ø³ÙˆÚµÛ•',
            customerInfo: 'Ø²Ø§Ù†ÛŒØ§Ø±ÛŒ Ú©Ú•ÛŒØ§Ø±',
            invoiceNumber: 'Ú˜Ù…Ø§Ø±Û•ÛŒ Ù¾Ø³ÙˆÚµÛ•',
            issueDate: 'Ø¨Û•Ø±ÙˆØ§Ø±ÛŒ Ø¯Û•Ø±Ú†ÙˆÙˆÙ†',
            paymentStatus: 'Ø­Ø§ÚµÛ•ØªÛŒ Ù¾Ø§Ø±Û•Ø¯Ø§Ù†',
            orderNumber: 'Ú˜Ù…Ø§Ø±Û•ÛŒ Ø¯Ø§ÙˆØ§Ú©Ø§Ø±ÛŒ',
            name: 'Ù†Ø§Ùˆ',
            address: 'Ù†Ø§ÙˆÙ†ÛŒØ´Ø§Ù†',
            company: 'Ú©Û†Ù…Ù¾Ø§Ù†ÛŒØ§',
            product: 'Ø¨Û•Ø±Ù‡Û•Ù…',
            quantity: 'Ø¨Ú•',
            unitPrice: 'Ù†Ø±Ø®ÛŒ ÛŒÛ•Ú©Û•',
            total: 'Ú©Û†ÛŒ Ú¯Ø´ØªÛŒ',
            subtotal: 'Ú©Û†ÛŒ Ù„Ø§ÙˆÛ•Ú©ÛŒ',
            discount: 'Ø¯Ø§Ø´Ú©Ø§Ù†Ø¯Ù†',
            tax: 'Ø¨Ø§Ø¬',
            finalTotal: 'Ú©Û†ÛŒ Ú©Û†ØªØ§ÛŒÛŒ',
            paid: 'Ù¾ÛŽØ¯Ø±Ø§Ùˆ',
            due: 'Ø¨Û•Ø¯ÙˆØ§ÛŒÛ•',
            notes: 'ØªÛŽØ¨ÛŒÙ†ÛŒÛ•Ú©Ø§Ù†'
          },
          'tr': {
            companyName: 'MÃ¼mtaz Kimyasal Ã‡Ã¶zÃ¼mler',
            location: 'Irak - BaÄŸdat',
            phone: 'Telefon',
            email: 'E-posta',
            invoice: 'FATURA',
            official: '(Resmi)',
            invoiceInfo: 'Fatura Bilgileri',
            customerInfo: 'MÃ¼ÅŸteri Bilgileri',
            invoiceNumber: 'Fatura NumarasÄ±',
            issueDate: 'DÃ¼zenleme Tarihi',
            paymentStatus: 'Ã–deme Durumu',
            orderNumber: 'SipariÅŸ NumarasÄ±',
            name: 'Ä°sim',
            address: 'Adres',
            company: 'Åžirket',
            product: 'ÃœrÃ¼n',
            quantity: 'Miktar',
            unitPrice: 'Birim Fiyat',
            total: 'Toplam',
            subtotal: 'Ara Toplam',
            discount: 'Ä°ndirim',
            tax: 'Vergi',
            finalTotal: 'Genel Toplam',
            paid: 'Ã–dendi',
            due: 'Ã–denmedi',
            notes: 'Notlar'
          },
          'en': {
            companyName: 'Momtaz Chemical Solutions',
            location: 'Iraq - Baghdad',
            phone: 'Phone',
            email: 'Email',
            invoice: 'INVOICE',
            official: '(Official)',
            invoiceInfo: 'Invoice Information',
            customerInfo: 'Customer Information',
            invoiceNumber: 'Invoice Number',
            issueDate: 'Issue Date',
            paymentStatus: 'Payment Status',
            orderNumber: 'Order Number',
            name: 'Name',
            address: 'Address',
            company: 'Company',
            product: 'Product',
            quantity: 'Quantity',
            unitPrice: 'Unit Price',
            total: 'Total',
            subtotal: 'Subtotal',
            discount: 'Discount',
            tax: 'Tax',
            finalTotal: 'Final Total',
            paid: 'Paid',
            due: 'Due',
            notes: 'Notes'
          }
        };
        return translations[invoice.language] || translations['en'];
      };
      
      const t = getTranslation();
      
      const htmlContent = `
        <!DOCTYPE html>
        <html dir="${direction}" lang="${invoice.language}">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
            <style>
                @page {
                    margin: 20mm;
                    size: A4;
                }
                
                body { 
                    font-family: ${fontFamily}; 
                    line-height: 1.6; 
                    margin: 0; 
                    padding: 20px;
                    direction: ${direction};
                    background: white;
                    color: #333;
                    font-size: 14px;
                    -webkit-font-smoothing: antialiased;
                    -moz-osx-font-smoothing: grayscale;
                }
                
                /* Prevent font fallback issues for multilingual text */
                .multilingual-text {
                    font-family: ${fontFamily};
                    word-wrap: break-word;
                    overflow-wrap: break-word;
                    unicode-bidi: bidi-override;
                }
                
                .header { 
                    text-align: center; 
                    border-bottom: 3px solid #2c5aa0; 
                    padding-bottom: 20px; 
                    margin-bottom: 30px; 
                }
                
                .company-info { 
                    text-align: center; 
                    margin-bottom: 20px; 
                }
                
                .company-info h1 {
                    color: #2c5aa0;
                    margin-bottom: 10px;
                    font-size: 24px;
                    font-weight: 700;
                }
                
                .invoice-details { 
                    display: flex; 
                    justify-content: space-between; 
                    margin-bottom: 30px; 
                    gap: 20px;
                }
                
                .invoice-info, .customer-info { 
                    width: 48%; 
                    background: #f8f9fa;
                    padding: 15px;
                    border-radius: 5px;
                }
                
                .invoice-info h3, .customer-info h3 {
                    color: #2c5aa0;
                    border-bottom: 1px solid #dee2e6;
                    padding-bottom: 8px;
                    margin-bottom: 15px;
                }
                
                table { 
                    width: 100%; 
                    border-collapse: collapse; 
                    margin-bottom: 20px; 
                    border: 1px solid #dee2e6;
                }
                
                th, td { 
                    border: 1px solid #dee2e6; 
                    padding: 12px; 
                    text-align: ${isRTL ? 'right' : 'left'}; 
                    vertical-align: top;
                }
                
                th { 
                    background-color: #2c5aa0; 
                    color: white;
                    font-weight: 700; 
                    font-size: 13px;
                }
                
                .total-section { 
                    text-align: ${isRTL ? 'right' : 'left'}; 
                    margin-top: 20px; 
                }
                
                .total-section table {
                    width: 300px; 
                    margin-${isRTL ? 'right' : 'left'}: auto;
                    border: 2px solid #2c5aa0;
                }
                
                .total-row { 
                    font-size: 16px; 
                    font-weight: bold; 
                    background-color: #e7f3ff; 
                }
                
                .footer { 
                    margin-top: 40px; 
                    text-align: center; 
                    font-size: 12px; 
                    color: #666; 
                    border-top: 1px solid #dee2e6;
                    padding-top: 20px;
                }
                
                /* RTL-specific adjustments */
                ${isRTL ? `
                .invoice-details {
                    flex-direction: row-reverse;
                }
                
                table {
                    direction: rtl;
                }
                
                .total-section table {
                    margin-right: auto;
                    margin-left: unset;
                }
                ` : ''}
                
                /* Print-specific styles */
                @media print {
                    body {
                        padding: 0;
                        margin: 0;
                        font-size: 12px;
                    }
                    
                    .header {
                        border-bottom: 3px solid #000 !important;
                    }
                    
                    th {
                        background-color: #000 !important;
                        color: #fff !important;
                    }
                }
            </style>
        </head>
        <body>
            <div class="header">
                <div class="company-info">
                    <h1 class="multilingual-text">${t.companyName}</h1>
                    <p class="multilingual-text">${t.location}</p>
                    <p class="multilingual-text">${t.phone}: +964 770 999 6771</p>
                    <p class="multilingual-text">${t.email}: info@momtazchem.com</p>
                </div>
                <h2 class="multilingual-text">${t.invoice} ${invoice.isOfficial ? t.official : ''}</h2>
            </div>

            <div class="invoice-details">
                <div class="invoice-info">
                    <h3 class="multilingual-text">${t.invoiceInfo}</h3>
                    <p class="multilingual-text"><strong>${t.invoiceNumber}:</strong> ${invoice.invoiceNumber}</p>
                    <p class="multilingual-text"><strong>${t.issueDate}:</strong> ${new Date(invoice.createdAt).toLocaleDateString(invoice.language === 'ar' ? 'ar-IQ' : invoice.language === 'ku' ? 'ckb-IQ' : invoice.language === 'tr' ? 'tr-TR' : 'en-US')}</p>
                    <p class="multilingual-text"><strong>${t.paymentStatus}:</strong> ${invoice.status === 'paid' ? t.paid : t.due}</p>
                    <p class="multilingual-text"><strong>${t.orderNumber}:</strong> ${order.orderNumber}</p>
                </div>
                <div class="customer-info">
                    <h3 class="multilingual-text">${t.customerInfo}</h3>
                    <p class="multilingual-text"><strong>${t.name}:</strong> ${customer.firstName} ${customer.lastName}</p>
                    <p class="multilingual-text"><strong>${t.email}:</strong> ${customer.email}</p>
                    <p class="multilingual-text"><strong>${t.phone}:</strong> ${customer.phone}</p>
                    <p class="multilingual-text"><strong>${t.address}:</strong> ${customer.address}, ${customer.city}, ${customer.country}</p>
                    ${customer.company ? `<p class="multilingual-text"><strong>${t.company}:</strong> ${customer.company}</p>` : ''}
                </div>
            </div>

            <table>
                <thead>
                    <tr>
                        <th class="multilingual-text">${t.product}</th>
                        <th class="multilingual-text">${t.quantity}</th>
                        <th class="multilingual-text">${t.unitPrice}</th>
                        <th class="multilingual-text">${t.total}</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map(item => `
                        <tr>
                            <td class="multilingual-text">${item.productName}</td>
                            <td class="multilingual-text">${item.quantity}</td>
                            <td class="multilingual-text">${item.unitPrice} ${invoice.currency}</td>
                            <td class="multilingual-text">${item.totalPrice} ${invoice.currency}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>

            <div class="total-section">
                <table>
                    <tr>
                        <td class="multilingual-text"><strong>${t.subtotal}:</strong></td>
                        <td class="multilingual-text"><strong>${invoice.subtotal} ${invoice.currency}</strong></td>
                    </tr>
                    ${invoice.discountAmount && parseFloat(invoice.discountAmount) > 0 ? `
                    <tr>
                        <td class="multilingual-text"><strong>${t.discount}:</strong></td>
                        <td class="multilingual-text"><strong>-${invoice.discountAmount} ${invoice.currency}</strong></td>
                    </tr>
                    ` : ''}
                    ${invoice.taxAmount && parseFloat(invoice.taxAmount) > 0 ? `
                    <tr>
                        <td class="multilingual-text"><strong>${t.tax}:</strong></td>
                        <td class="multilingual-text"><strong>${invoice.taxAmount} ${invoice.currency}</strong></td>
                    </tr>
                    ` : ''}
                    <tr class="total-row">
                        <td class="multilingual-text"><strong>${t.finalTotal}:</strong></td>
                        <td class="multilingual-text"><strong>${invoice.totalAmount} ${invoice.currency}</strong></td>
                    </tr>
                </table>
            </div>

            ${invoice.notes ? `
            <div style="margin-top: 30px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <h3 class="multilingual-text" style="color: #2c5aa0; margin-bottom: 10px;">${t.notes}</h3>
                <p class="multilingual-text">${invoice.notes}</p>
            </div>
            ` : ''}

            <div class="footer">
                <p class="multilingual-text">
                    ${invoice.language === 'ar' ? 'Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ø±ÙƒØ© Ù…ÙÙ…ØªØ§Ø² Ù„Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ©' :
                      invoice.language === 'ku' ? 'Ø³ÙˆÙ¾Ø§Ø³ Ø¨Û† Ù‡Û•ÚµØ¨Ú˜Ø§Ø±Ø¯Ù†ØªØ§Ù† Ú©Û†Ù…Ù¾Ø§Ù†ÛŒØ§ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ø¨Û† Ù…Ø§Ø¯Û• Ú©ÛŒÙ…ÛŒØ§ÛŒÛŒÛ•Ú©Ø§Ù†' :
                      invoice.language === 'tr' ? 'MÃ¼mtaz Kimyasal Ã‡Ã¶zÃ¼mler\'i tercih ettiÄŸiniz iÃ§in teÅŸekkÃ¼r ederiz' :
                      'Thank you for choosing Momtaz Chemical Solutions'}
                </p>
                <p class="multilingual-text">
                    ${invoice.language === 'ar' ? 'Ù…ÙˆÙ‚Ø¹Ù†Ø§ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ' :
                      invoice.language === 'ku' ? 'Ù…Ø§ÚµÙ¾Û•Ú•Û•Ú©Û•Ù…Ø§Ù†' :
                      invoice.language === 'tr' ? 'Web sitemiz' :
                      'Website'}: momtazchem.com
                </p>
            </div>
        </body>
        </html>
      `;

      // Use the simple PDF generator
      const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
      
      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20mm',
          right: '15mm',
          bottom: '20mm',
          left: '15mm'
        }
      });
      
      await browser.close();

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${invoice.invoiceNumber}.pdf"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      res.send(pdfBuffer);
      
    } catch (error) {
      console.error('Error generating invoice PDF:', error);
      res.status(500).json({ success: false, message: 'Failed to generate invoice PDF' });
    }
  });

  // Mark invoice as paid
  app.post('/api/invoices/:id/mark-paid', requireAuth, async (req, res) => {
    try {
      const invoiceId = parseInt(req.params.id);
      const { paymentDate } = req.body;
      
      const invoice = await invoiceStorage.markInvoiceAsPaid(
        invoiceId, 
        paymentDate ? new Date(paymentDate) : undefined
      );
      res.json({ success: true, data: invoice });
    } catch (error) {
      console.error('Error marking invoice as paid:', error);
      res.status(500).json({ success: false, message: 'Failed to mark invoice as paid' });
    }
  });

  // Get invoice statistics
  app.get('/api/invoices/stats', requireAuth, async (req, res) => {
    try {
      const stats = await invoiceStorage.getInvoiceStats();
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error('Error fetching invoice stats:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch invoice stats' });
    }
  });

  // Auto-generate invoice when order payment is completed
  app.post('/api/orders/:id/complete-payment', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      
      // Update order payment status
      const order = await shopStorage.updateOrder(orderId, {
        paymentStatus: 'paid'
      });

      // Generate invoice automatically
      const invoice = await invoiceStorage.generateInvoiceFromOrder(orderId);
      
      // Send invoice email to customer
      await invoiceStorage.sendInvoiceEmail(invoice.id);

      res.json({ 
        success: true, 
        message: 'Payment completed and invoice generated',
        data: { order, invoice }
      });
    } catch (error) {
      console.error('Error completing payment:', error);
      res.status(500).json({ success: false, message: 'Failed to complete payment' });
    }
  });

  // ============================================================================
  // PAYMENT GATEWAY MANAGEMENT API
  // ============================================================================

  // Get all payment gateways
  app.get('/api/payment/gateways', requireAuth, async (req, res) => {
    try {
      const gateways = await db.select().from(paymentGateways).orderBy(desc(paymentGateways.createdAt));
      res.json(gateways);
    } catch (error) {
      console.error('Error fetching payment gateways:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch payment gateways' });
    }
  });

  // Get payment gateway by ID
  app.get('/api/payment/gateways/:id', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      const [gateway] = await db.select().from(paymentGateways).where(eq(paymentGateways.id, gatewayId));
      
      if (!gateway) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      res.json(gateway);
    } catch (error) {
      console.error('Error fetching payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch payment gateway' });
    }
  });

  // Create new payment gateway
  app.post('/api/payment/gateways', requireAuth, async (req, res) => {
    try {
      const { name, type, enabled, config, testMode } = req.body;
      
      // Validate required fields
      if (!name || !type || !config) {
        return res.status(400).json({ success: false, message: 'Missing required fields' });
      }

      const [gateway] = await db.insert(paymentGateways).values({
        name,
        type,
        enabled: enabled ?? true,
        config,
        testMode: testMode ?? false,
      }).returning();
      
      res.json({ success: true, data: gateway });
    } catch (error) {
      console.error('Error creating payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to create payment gateway' });
    }
  });

  // Update payment gateway
  app.patch('/api/payment/gateways/:id', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      const { name, type, enabled, config, testMode } = req.body;
      
      const [gateway] = await db.update(paymentGateways)
        .set({
          name,
          type,
          enabled,
          config,
          testMode,
          updatedAt: new Date(),
        })
        .where(eq(paymentGateways.id, gatewayId))
        .returning();
      
      if (!gateway) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      res.json({ success: true, data: gateway });
    } catch (error) {
      console.error('Error updating payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to update payment gateway' });
    }
  });

  // Delete payment gateway
  app.delete('/api/payment/gateways/:id', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      
      const result = await db.delete(paymentGateways)
        .where(eq(paymentGateways.id, gatewayId))
        .returning();
      
      if (result.length === 0) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      res.json({ success: true, message: 'Payment gateway deleted successfully' });
    } catch (error) {
      console.error('Error deleting payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to delete payment gateway' });
    }
  });

  // Toggle payment gateway status
  app.post('/api/payment/gateways/:id/toggle', requireAuth, async (req, res) => {
    try {
      const gatewayId = parseInt(req.params.id);
      
      const [currentGateway] = await db.select().from(paymentGateways).where(eq(paymentGateways.id, gatewayId));
      
      if (!currentGateway) {
        return res.status(404).json({ success: false, message: 'Payment gateway not found' });
      }
      
      const [gateway] = await db.update(paymentGateways)
        .set({
          enabled: !currentGateway.enabled,
          updatedAt: new Date(),
        })
        .where(eq(paymentGateways.id, gatewayId))
        .returning();
      
      res.json({ success: true, data: gateway });
    } catch (error) {
      console.error('Error toggling payment gateway:', error);
      res.status(500).json({ success: false, message: 'Failed to toggle payment gateway' });
    }
  });

  // ============================================================================
  // IRAQI BANKING PAYMENT API
  // ============================================================================

  // Get enabled payment gateways for customer use
  app.get('/api/payment/available-gateways', async (req, res) => {
    try {
      const gateways = await db.select().from(paymentGateways).where(eq(paymentGateways.enabled, true));
      res.json({ success: true, data: gateways });
    } catch (error) {
      console.error('Error fetching available payment gateways:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch available payment gateways' });
    }
  });

  // Process Iraqi bank transfer payment
  app.post('/api/payment/iraqi-bank-transfer', async (req, res) => {
    try {
      const { orderId, gatewayId, bankTransferDetails } = req.body;
      
      if (!orderId || !gatewayId || !bankTransferDetails) {
        return res.status(400).json({ success: false, message: 'Missing required payment details' });
      }

      // Get payment gateway configuration
      const [gateway] = await db.select().from(paymentGateways).where(eq(paymentGateways.id, gatewayId));
      
      if (!gateway || !gateway.enabled) {
        return res.status(400).json({ success: false, message: 'Invalid or disabled payment gateway' });
      }

      // Verify order exists
      const order = await shopStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: 'Order not found' });
      }

      // For Iraqi bank transfers, we'll mark as pending and require manual verification
      const updatedOrder = await shopStorage.updateOrder(orderId, {
        paymentStatus: 'pending',
        paymentMethod: `Bank Transfer - ${gateway.name}`,
        paymentGatewayId: gatewayId
      });

      // Log the payment attempt
      console.log(`Iraqi bank transfer initiated for order ${orderId}:`, {
        gateway: gateway.name,
        bankDetails: bankTransferDetails,
        amount: order.totalAmount
      });

      // Create financial transaction record
      await shopStorage.createFinancialTransaction({
        type: 'payment_pending',
        orderId: order.id,
        amount: order.totalAmount,
        description: `Iraqi bank transfer pending verification - ${gateway.name}`,
        referenceNumber: bankTransferDetails.referenceNumber || order.orderNumber,
        status: 'pending',
        processingDate: new Date(),
        metadata: { 
          gatewayId,
          gatewayName: gateway.name,
          bankTransferDetails,
          paymentMethod: 'iraqi_bank_transfer'
        }
      });

      res.json({ 
        success: true, 
        message: 'Bank transfer payment initiated. Awaiting verification.',
        data: { 
          order: updatedOrder,
          paymentStatus: 'pending',
          verificationRequired: true,
          bankInfo: gateway.config
        }
      });
    } catch (error) {
      console.error('Error processing Iraqi bank transfer:', error);
      res.status(500).json({ success: false, message: 'Failed to process bank transfer payment' });
    }
  });

  // Verify Iraqi bank transfer payment (admin only)
  app.post('/api/payment/verify-bank-transfer/:orderId', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { verified, notes } = req.body;
      
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: 'Invalid order ID' });
      }

      const order = await shopStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: 'Order not found' });
      }

      if (verified) {
        // Mark order as paid
        const updatedOrder = await shopStorage.updateOrder(orderId, {
          paymentStatus: 'paid'
        });

        // Generate invoice automatically
        const invoice = await invoiceStorage.generateInvoiceFromOrder(orderId);
        
        // Send invoice email to customer
        await invoiceStorage.sendInvoiceEmail(invoice.id);

        // Update financial transaction
        await shopStorage.createFinancialTransaction({
          type: 'sale',
          orderId: order.id,
          amount: order.totalAmount,
          description: `Bank transfer verified and completed - ${order.paymentMethod}`,
          referenceNumber: order.orderNumber,
          status: 'completed',
          processingDate: new Date(),
          metadata: { 
            verifiedBy: req.session?.adminId,
            verificationNotes: notes,
            originalPaymentMethod: 'iraqi_bank_transfer'
          }
        });

        res.json({ 
          success: true, 
          message: 'Bank transfer verified and order completed',
          data: { order: updatedOrder, invoice }
        });
      } else {
        // Mark payment as failed
        const updatedOrder = await shopStorage.updateOrder(orderId, {
          paymentStatus: 'failed'
        });

        res.json({ 
          success: true, 
          message: 'Bank transfer verification failed',
          data: { order: updatedOrder }
        });
      }
    } catch (error) {
      console.error('Error verifying bank transfer:', error);
      res.status(500).json({ success: false, message: 'Failed to verify bank transfer' });
    }
  });

  // Upload bank receipt
  app.post('/api/payment/upload-receipt', uploadReceipt.single('receipt'), async (req, res) => {
    try {
      const { orderId } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ 
          success: false, 
          message: 'ÙØ§ÛŒÙ„ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª' 
        });
      }

      if (!orderId) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù†Ø§Ø³Ù‡ Ø³ÙØ§Ø±Ø´ Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª' 
        });
      }

      // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø³ÙØ§Ø±Ø´ Ø¯Ø± customer_orders
      let order;
      if (orderId.startsWith('ORD-')) {
        // Find order by order number
        const [orderResult] = await customerDb
          .select()
          .from(customerOrders)
          .where(eq(customerOrders.orderNumber, orderId));
        order = orderResult;
      } else {
        // Find order by ID
        order = await customerStorage.getOrderById(parseInt(orderId));
      }
      
      if (!order) {
        return res.status(404).json({ 
          success: false, 
          message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' 
        });
      }

      // Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø³ÛŒØ± Ù†Ø³Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
      const filePath = `/uploads/receipts/${file.filename}`;

      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ù…Ø³ÛŒØ± ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ
      await customerDb
        .update(customerOrders)
        .set({
          receiptPath: filePath,
          paymentStatus: 'receipt_uploaded'
        })
        .where(eq(customerOrders.id, order.id));

      // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± Ø¨Ø®Ø´ Ù…Ø§Ù„ÛŒ
      try {
        await db
          .update(orderManagement)
          .set({
            currentStatus: 'payment_uploaded',
            paymentReceiptUrl: filePath,
            updatedAt: new Date()
          })
          .where(eq(orderManagement.customerOrderId, order.id));
        
        console.log(`âœ… [FINANCE] Order ${orderId} updated with receipt and moved to financial review`);
      } catch (error) {
        console.error('Warning: Could not update order management, but receipt uploaded successfully:', error);
      }

      // Ø«Ø¨Øª ÙØ¹Ø§Ù„ÛŒØª Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ
      try {
        await shopStorage.createFinancialTransaction({
          type: 'receipt_uploaded',
          orderId: order.id,
          amount: order.totalAmount,
          description: `ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯ - ${file.originalname}`,
          referenceNumber: order.orderNumber,
          status: 'pending_review',
          processingDate: new Date(),
          metadata: { 
            receiptPath: filePath,
            fileName: file.originalname,
            fileSize: file.size,
            mimeType: file.mimetype
          }
        });
      } catch (error) {
        console.log('Warning: Could not create financial transaction, but receipt uploaded successfully');
      }

      console.log(`Receipt uploaded for order ${orderId}:`, {
        fileName: file.originalname,
        filePath,
        fileSize: file.size
      });

      res.json({ 
        success: true, 
        message: 'ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯',
        data: { 
          filePath,
          fileName: file.originalname,
          orderId: parseInt(orderId)
        }
      });

    } catch (error) {
      console.error('Error uploading bank receipt:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ ÙÛŒØ´ Ø¨Ø§Ù†Ú©ÛŒ' 
      });
    }
  });

  // Get payment methods configuration for checkout
  app.get('/api/payment/methods', async (req, res) => {
    try {
      const gateways = await db.select().from(paymentGateways).where(eq(paymentGateways.enabled, true));
      
      const paymentMethods = gateways.map(gateway => ({
        id: gateway.id,
        name: gateway.name,
        type: gateway.type,
        config: {
          // Only return safe config data (not secrets)
          bankName: gateway.config?.bankName,
          accountNumber: gateway.config?.accountNumber,
          swiftCode: gateway.config?.swiftCode,
          instructions: gateway.config?.instructions
        },
        testMode: gateway.testMode
      }));

      res.json({ success: true, data: paymentMethods });
    } catch (error) {
      console.error('Error fetching payment methods:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch payment methods' });
    }
  });

  // Get pending payments for admin review
  app.get('/api/admin/pending-payments', requireAuth, async (req, res) => {
    try {
      // Get orders with pending payment status
      const pendingOrders = await db.select({
        orderId: orders.id,
        orderNumber: orders.orderNumber,
        customerId: orders.customerId,
        totalAmount: orders.totalAmount,
        paymentMethod: orders.paymentMethod,
        paymentGatewayId: orders.paymentGatewayId,
        createdAt: orders.createdAt
      })
      .from(orders)
      .where(eq(orders.paymentStatus, 'pending'))
      .orderBy(desc(orders.createdAt));

      // Get customer details for each order
      const ordersWithCustomers = await Promise.all(
        pendingOrders.map(async (order) => {
          let customer = null;
          if (order.customerId) {
            customer = await crmStorage.getCrmCustomerById(order.customerId);
          }
          return { ...order, customer };
        })
      );

      res.json({ success: true, data: ordersWithCustomers });
    } catch (error) {
      console.error('Error fetching pending payments:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch pending payments' });
    }
  });

  // =============================================================================
  // CUSTOMER WALLET SYSTEM ENDPOINTS
  // =============================================================================

  // Customer wallet endpoints
  app.get('/api/customer/wallet', async (req, res) => {
    try {
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const summary = await walletStorage.getCustomerWalletSummary(req.session.customerId);
      res.json({ success: true, data: summary });
    } catch (error) {
      console.error('Error fetching wallet summary:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet information' });
    }
  });

  // Get customer wallet balance only
  app.get('/api/customers/wallet/balance', async (req, res) => {
    try {
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const balance = await walletStorage.getWalletBalance(req.session.customerId);
      res.json({ success: true, balance: balance });
    } catch (error) {
      console.error('Error fetching wallet balance:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet balance' });
    }
  });

  // Get wallet recharge information/status
  app.get('/api/customer/wallet/recharge', async (req, res) => {
    try {
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      // Return wallet recharge information or status
      const requests = await walletStorage.getRechargeRequestsByCustomer(req.session.customerId);
      res.json({ success: true, data: requests });
    } catch (error) {
      console.error('Error fetching recharge info:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch recharge information' });
    }
  });

  // Create wallet recharge request
  app.post('/api/customer/wallet/recharge', async (req, res) => {
    try {
      console.log('ðŸ’° [WALLET-RECHARGE] POST request received:', req.body);
      console.log('ðŸ’° [WALLET-RECHARGE] Customer ID:', req.session.customerId);
      console.log('ðŸ’° [WALLET-RECHARGE] Admin ID:', req.session.adminId);
      
      // Prevent admin from accessing customer wallet data
      if (req.session.adminId) {
        console.log('ðŸ’° [WALLET-RECHARGE] ERROR: Admin authenticated - not a customer');
        return res.status(401).json({ success: false, message: "Admin authenticated - not a customer" });
      }
      
      if (!req.session.customerId) {
        console.log('ðŸ’° [WALLET-RECHARGE] ERROR: No customer ID in session');
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const { amount, currency, paymentMethod, paymentReference, customerNotes } = req.body;
      console.log('ðŸ’° [WALLET-RECHARGE] Request data:', { amount, currency, paymentMethod, paymentReference, customerNotes });

      if (!amount || amount <= 0) {
        console.log('ðŸ’° [WALLET-RECHARGE] ERROR: Invalid amount:', amount);
        return res.status(400).json({ success: false, message: "Valid amount is required" });
      }

      // Get or create wallet using CRM customer ID
      let wallet = await walletStorage.getWalletByCustomerId(req.session.customerId);
      console.log('ðŸ’° [WALLET-RECHARGE] Existing wallet:', wallet);
      
      if (!wallet) {
        console.log('ðŸ’° [WALLET-RECHARGE] Creating new wallet...');
        wallet = await walletStorage.createWallet({
          customerId: req.session.customerId,
          balance: "0",
          currency: currency || "IQD",
          status: "active"
        });
        console.log('ðŸ’° [WALLET-RECHARGE] New wallet created:', wallet);
      }

      console.log('ðŸ’° [WALLET-RECHARGE] Creating recharge request...');
      const rechargeRequest = await walletStorage.createRechargeRequest({
        customerId: req.session.customerId,
        walletId: wallet.id,
        amount: amount.toString(),
        currency: currency || "IQD",
        paymentMethod,
        paymentReference,
        customerNotes
      });

      console.log('ðŸ’° [WALLET-RECHARGE] Recharge request created successfully:', rechargeRequest);
      res.json({ success: true, data: rechargeRequest });
    } catch (error) {
      console.error('ðŸ’° [WALLET-RECHARGE] ERROR:', error);
      res.status(500).json({ success: false, message: 'Failed to create recharge request' });
    }
  });

  // Get customer's recharge requests
  app.get('/api/customer/wallet/recharge-requests', async (req, res) => {
    try {
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const requests = await walletStorage.getRechargeRequestsByCustomer(req.session.customerId);
      res.json({ success: true, data: requests });
    } catch (error) {
      console.error('Error fetching recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch recharge requests' });
    }
  });

  // Get customer wallet transactions
  app.get('/api/customer/wallet/transactions', async (req, res) => {
    try {
      if (!req.session.customerId) {
        return res.status(401).json({ success: false, message: "Customer authentication required" });
      }

      const limit = parseInt(req.query.limit as string) || 50;
      const transactions = await walletStorage.getTransactionsByCustomer(req.session.customerId, limit);
      res.json({ success: true, data: transactions });
    } catch (error) {
      console.error('Error fetching wallet transactions:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet transactions' });
    }
  });

  // Admin wallet endpoints (Alternative without auth for specific cases)
  app.get('/api/wallet/stats', async (req, res) => {
    try {
      const statistics = await walletStorage.getWalletStatistics();
      res.json({ success: true, data: statistics });
    } catch (error) {
      console.error('Error fetching wallet statistics:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet statistics' });
    }
  });

  // Get pending recharge requests (alternative without auth)
  app.get('/api/wallet/recharge-requests/pending', async (req, res) => {
    try {
      const requests = await walletStorage.getAllPendingRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching pending recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch pending recharge requests' });
    }
  });

  // Get all recharge requests (alternative without auth)
  app.get('/api/wallet/recharge-requests', async (req, res) => {
    try {
      const requests = await walletStorage.getAllRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching all recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch all recharge requests' });
    }
  });

  // Admin wallet endpoints (Original with auth)
  app.get('/api/admin/wallet/stats', requireAuth, async (req, res) => {
    try {
      const statistics = await walletStorage.getWalletStatistics();
      res.json({ success: true, data: statistics });
    } catch (error) {
      console.error('Error fetching wallet statistics:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch wallet statistics' });
    }
  });

  // Get pending recharge requests (admin)
  app.get('/api/admin/wallet/recharge-requests/pending', requireAuth, async (req, res) => {
    try {
      const requests = await walletStorage.getAllPendingRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching pending recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch pending recharge requests' });
    }
  });

  // Get all recharge requests (admin)
  app.get('/api/admin/wallet/recharge-requests', requireAuth, async (req, res) => {
    try {
      const requests = await walletStorage.getAllRechargeRequests();
      
      // Get customer details for each request
      const requestsWithCustomers = await Promise.all(
        requests.map(async (request) => {
          const customer = await crmStorage.getCrmCustomerById(request.customerId);
          return { ...request, customer };
        })
      );

      res.json({ success: true, data: requestsWithCustomers });
    } catch (error) {
      console.error('Error fetching all recharge requests:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch all recharge requests' });
    }
  });

  // Process recharge request (approve/reject)
  app.post('/api/admin/wallet/recharge-requests/:id/process', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { action, adminNotes } = req.body; // action: 'approve' or 'reject'
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      if (action === 'approve') {
        const result = await walletStorage.processRechargeRequest(requestId, adminId);
        res.json({ 
          success: true, 
          message: "Recharge request approved and processed successfully",
          data: result 
        });
      } else if (action === 'reject') {
        const updatedRequest = await walletStorage.updateRechargeRequestStatus(
          requestId, 
          'rejected', 
          adminNotes, 
          adminId
        );
        res.json({ 
          success: true, 
          message: "Recharge request rejected",
          data: updatedRequest 
        });
      } else {
        res.status(400).json({ success: false, message: "Invalid action. Use 'approve' or 'reject'" });
      }
    } catch (error) {
      console.error('Error processing recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to process recharge request' 
      });
    }
  });

  // Approve recharge request (admin) - GET version for frontend buttons
  app.get('/api/admin/wallet/recharge-requests/:id/approve', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      const result = await walletStorage.processRechargeRequest(requestId, adminId);

      res.json({ 
        success: true, 
        message: "Recharge request approved and processed successfully",
        data: result 
      });
    } catch (error) {
      console.error('Error approving recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to approve recharge request' 
      });
    }
  });

  // Approve recharge request (admin) - POST version for form submission
  app.post('/api/admin/wallet/recharge-requests/:id/approve', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { adminNotes } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      const result = await walletStorage.processRechargeRequest(requestId, adminId);
      
      // Update with admin notes if provided
      if (adminNotes) {
        await walletStorage.updateRechargeRequestStatus(requestId, 'approved', adminNotes, adminId);
      }

      res.json({ 
        success: true, 
        message: "Recharge request approved and processed successfully",
        data: result 
      });
    } catch (error) {
      console.error('Error approving recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to approve recharge request' 
      });
    }
  });

  // Reject recharge request (admin)
  app.post('/api/admin/wallet/recharge-requests/:id/reject', requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { rejectionReason, adminNotes } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      if (!rejectionReason) {
        return res.status(400).json({ success: false, message: "Rejection reason is required" });
      }

      // Update request status with rejection reason
      const updatedRequest = await walletStorage.updateRechargeRequestStatus(
        requestId, 
        'rejected', 
        adminNotes, 
        adminId
      );

      // Add rejection reason
      await customerDb
        .update(walletRechargeRequests)
        .set({ rejectionReason })
        .where(eq(walletRechargeRequests.id, requestId));

      res.json({ 
        success: true, 
        message: "Recharge request rejected",
        data: updatedRequest 
      });
    } catch (error) {
      console.error('Error rejecting recharge request:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to reject recharge request' 
      });
    }
  });

  // Manual wallet adjustment (admin only)
  app.post('/api/admin/wallet/adjust', requireAuth, async (req, res) => {
    try {
      const { customerId, amount, description, type } = req.body; // type: 'credit' or 'debit'
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      if (!customerId || !amount || !description || !type) {
        return res.status(400).json({ success: false, message: "All fields are required" });
      }

      let transaction;
      if (type === 'credit') {
        transaction = await walletStorage.creditWallet(
          customerId,
          parseFloat(amount),
          description,
          'manual_adjustment',
          undefined,
          adminId
        );
      } else if (type === 'debit') {
        transaction = await walletStorage.debitWallet(
          customerId,
          parseFloat(amount),
          description,
          'manual_adjustment',
          undefined,
          adminId
        );
      } else {
        return res.status(400).json({ success: false, message: "Invalid type. Use 'credit' or 'debit'" });
      }

      res.json({ 
        success: true, 
        message: `Wallet ${type} adjustment completed successfully`,
        data: transaction 
      });
    } catch (error) {
      console.error('Error adjusting wallet:', error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : 'Failed to adjust wallet' 
      });
    }
  });

  // Process order refund to wallet
  app.post('/api/orders/:orderId/refund', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { amount, reason, refundType = 'full' } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(401).json({ success: false, message: "Admin authentication required" });
      }

      // Get order details
      const order = await customerStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Validate refund amount
      const orderAmount = parseFloat(order.totalAmount);
      const refundAmount = refundType === 'full' ? orderAmount : parseFloat(amount);
      
      if (refundAmount <= 0 || refundAmount > orderAmount) {
        return res.status(400).json({ 
          success: false, 
          message: "Ù…Ø¨Ù„Øº Ø¨Ø±Ú¯Ø´ØªÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" 
        });
      }

      // Process wallet refund
      const transaction = await walletStorage.creditWallet(
        order.customerId,
        refundAmount,
        `Ø¨Ø±Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø³ÙØ§Ø±Ø´ #${order.orderNumber} - ${reason || 'Ø¹Ø¯Ù… Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª'}`,
        'refund',
        orderId,
        adminId
      );

      // Update order status
      await customerStorage.updateOrder(orderId, {
        status: refundType === 'full' ? 'refunded' : 'partially_refunded',
        paymentStatus: refundType === 'full' ? 'refunded' : 'partial_refund',
        refundAmount: refundAmount.toString(),
        refundReason: reason,
        refundDate: new Date(),
        refundProcessedBy: adminId
      });

      console.log(`âœ… Order refund processed: ${refundAmount} IQD credited to customer ${order.customerId}, transaction ID: ${transaction.id}`);

      res.json({
        success: true,
        message: "Ø¨Ø±Ú¯Ø´Øª ÙˆØ¬Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
        data: {
          refundAmount,
          transactionId: transaction.id,
          newWalletBalance: transaction.balanceAfter
        }
      });

    } catch (error) {
      console.error('Error processing refund:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ø±Ú¯Ø´Øª ÙˆØ¬Ù‡'
      });
    }
  });

  // =============================================================================
  // TICKETING SYSTEM API ENDPOINTS
  // =============================================================================

  // Get ticket constants (priorities, statuses, categories) - NO AUTH REQUIRED
  app.get('/api/ticketing/constants', (req, res) => {
    // No authentication required for constants - using different path to avoid auth conflicts
    res.json({
      success: true,
      data: {
        priorities: TICKET_PRIORITIES,
        statuses: TICKET_STATUSES,
        categories: TICKET_CATEGORIES
      }
    });
  });

  // Create new support ticket
  app.post('/api/tickets', async (req, res) => {
    try {
      // Manual validation for guest users - bypass schema validation that requires auth fields
      const { title, description, category, priority = 'normal', department } = req.body;
      
      if (!title || !description || !category) {
        return res.status(400).json({
          success: false,
          message: 'Title, description, and category are required'
        });
      }
      
      const validatedData = { title, description, category, priority, department };
      const adminId = req.session.adminId;
      const customerId = req.session.customerId;
      const customUserId = req.session.customUserId;

      // Allow guest ticket creation for demo/testing purposes
      const isGuestTicket = !adminId && !customerId && !customUserId;

      // Use admin info, customer info, custom user info, or guest info
      const submitterInfo = adminId ? {
        submittedBy: adminId,
        submitterName: req.session.adminName || 'Admin User',
        submitterEmail: req.session.adminEmail || 'admin@momtazchem.com',
        submitterDepartment: req.session.adminDepartment || 'Administration',
        customerUserId: null
      } : customUserId ? {
        submittedBy: 999, // Default ID for custom users
        submitterName: req.session.customUserName || 'Custom User',
        submitterEmail: req.session.customUserEmail || 'user@momtazchem.com',
        submitterDepartment: 'Custom User',
        customerUserId: customUserId
      } : customerId ? {
        submittedBy: customerId,
        submitterName: req.session.customerEmail || 'Customer',
        submitterEmail: req.session.customerEmail || 'customer@momtazchem.com',
        submitterDepartment: 'Customer',
        customerUserId: null
      } : {
        submittedBy: 0,  // Guest user
        submitterName: 'Guest User',
        submitterEmail: 'guest@momtazchem.com',
        submitterDepartment: 'Guest',
        customerUserId: null
      };

      // Merge validated data with submitter info, ensuring all required fields are present
      const ticketData = {
        title: validatedData.title,
        description: validatedData.description,
        category: validatedData.category,
        priority: validatedData.priority || 'normal',
        department: validatedData.department,
        submittedBy: submitterInfo.submittedBy,
        customerUserId: submitterInfo.customerUserId,
        submitterName: submitterInfo.submitterName,
        submitterEmail: submitterInfo.submitterEmail,
        submitterDepartment: submitterInfo.submitterDepartment,
        status: 'open',
        // Optional fields
        assignedTo: null,
        attachments: null,
        tags: null,
        estimatedResolution: null,
        actualResolution: null,
        resolutionNotes: null,
        customerSatisfaction: null,
        internalNotes: null,
        isUrgent: false,
        followUpRequired: false,
        followUpDate: null
      };

      // Create ticket directly bypassing type validation
      const ticketNumber = `TKT-${Date.now()}`;
      const [ticket] = await db.insert(supportTickets).values({
        ...ticketData,
        ticketNumber,
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();

      console.log(`âœ… New support ticket created: ${ticket.ticketNumber} by ${submitterInfo.submitterName}`);

      res.json({
        success: true,
        message: "ØªÛŒÚ©Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯",
        data: ticket
      });

    } catch (error) {
      console.error('Error creating support ticket:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªÛŒÚ©Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ'
      });
    }
  });

  // Get all tickets (role-based access control)
  app.get('/api/tickets', requireAuth, async (req, res) => {
    try {
      const { 
        status, 
        priority, 
        category, 
        assignedTo, 
        submittedBy, 
        limit = 50, 
        offset = 0 
      } = req.query;

      const adminId = req.session.adminId;
      const customUserId = req.session.customUserId;

      // Check if user is super admin (ID 7) or admin@momtazchem.com
      const isSuperAdmin = adminId && (adminId === 7 || req.session.adminEmail === 'admin@momtazchem.com');

      let filters = {
        status: status as string,
        priority: priority as string,
        category: category as string,
        assignedTo: assignedTo ? parseInt(assignedTo as string) : undefined,
        submittedBy: submittedBy ? parseInt(submittedBy as string) : undefined,
        limit: parseInt(limit as string),
        offset: parseInt(offset as string)
      };

      // If not super admin, only show tickets submitted by the current user
      if (!isSuperAdmin) {
        // For custom users, use the new getTicketsByCustomUser method
        if (customUserId) {
          const tickets = await ticketingStorage.getTicketsByCustomUser(customUserId, filters.limit, filters.offset);
          return res.json({
            success: true,
            data: tickets
          });
        } else if (adminId) {
          // For regular admins, show only their own tickets
          filters.submittedBy = adminId;
        } else {
          // No access for non-authenticated users
          return res.status(403).json({
            success: false,
            message: 'Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¬Ø§Ø² Ù†Ù…ÛŒâ€ŒØ¨Ø§Ø´Ø¯'
          });
        }
      }

      const tickets = await ticketingStorage.getTickets(filters);

      res.json({
        success: true,
        data: tickets
      });

    } catch (error) {
      console.error('Error fetching tickets:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });

  // Get tickets for current user
  app.get('/api/tickets/my-tickets', async (req, res) => {
    try {
      const { limit = 50, offset = 0 } = req.query;
      const adminId = req.session.adminId;
      const customerId = req.session.customerId;

      const userId = adminId || customerId || 0; // Use 0 for guest users

      const tickets = await ticketingStorage.getTicketsByUser(
        userId, 
        parseInt(limit as string), 
        parseInt(offset as string)
      );

      res.json({
        success: true,
        data: tickets
      });

    } catch (error) {
      console.error('Error fetching user tickets:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§'
      });
    }
  });

  // Get single ticket by ID (with access control)
  app.get('/api/tickets/:id', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const ticket = await ticketingStorage.getTicketById(ticketId);

      if (!ticket) {
        return res.status(404).json({
          success: false,
          message: 'ØªÛŒÚ©Øª ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      const adminId = req.session.adminId;
      const customUserId = req.session.customUserId;

      // Check if user is super admin or owns this ticket
      const isSuperAdmin = adminId && (adminId === 7 || req.session.adminEmail === 'admin@momtazchem.com');
      const isTicketOwner = (customUserId && ticket.submittedBy === customUserId) || 
                           (adminId && ticket.submittedBy === adminId);

      if (!isSuperAdmin && !isTicketOwner) {
        return res.status(403).json({
          success: false,
          message: 'Ø´Ù…Ø§ Ù…Ø¬Ø§Ø² Ø¨Ù‡ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§ÛŒÙ† ØªÛŒÚ©Øª Ù†ÛŒØ³ØªÛŒØ¯'
        });
      }

      // Get ticket responses
      const responses = await ticketingStorage.getTicketResponses(ticketId);
      
      // Get status history
      const statusHistory = await ticketingStorage.getTicketStatusHistory(ticketId);

      res.json({
        success: true,
        data: {
          ticket,
          responses,
          statusHistory
        }
      });

    } catch (error) {
      console.error('Error fetching ticket:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªÛŒÚ©Øª'
      });
    }
  });

  // Update ticket status
  app.patch('/api/tickets/:id/status', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { status, reason } = req.body;
      const adminId = req.session.adminId;
      const user = req.session.user;

      if (!TICKET_STATUSES.includes(status)) {
        return res.status(400).json({
          success: false,
          message: 'ÙˆØ¶Ø¹ÛŒØª ØªÛŒÚ©Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª'
        });
      }

      const userInfo = adminId ? {
        userId: adminId,
        userName: req.session.adminName || 'Admin User',
        userType: 'admin' as const
      } : {
        userId: user.id,
        userName: user.firstName + ' ' + user.lastName,
        userType: 'site_manager' as const
      };

      await ticketingStorage.updateTicketStatus(
        ticketId,
        status,
        userInfo.userId,
        userInfo.userName,
        userInfo.userType,
        reason
      );

      console.log(`âœ… Ticket ${ticketId} status updated to ${status} by ${userInfo.userName}`);

      res.json({
        success: true,
        message: 'ÙˆØ¶Ø¹ÛŒØª ØªÛŒÚ©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯'
      });

    } catch (error) {
      console.error('Error updating ticket status:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª ØªÛŒÚ©Øª'
      });
    }
  });

  // Get ticket responses
  app.get('/api/tickets/:id/responses', async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const responses = await ticketingStorage.getTicketResponses(ticketId);

      res.json({
        success: true,
        data: responses
      });

    } catch (error) {
      console.error('Error getting ticket responses:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§'
      });
    }
  });

  // Add response to ticket
  app.post('/api/tickets/:id/responses', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { message, attachments, isInternal } = req.body;
      const adminId = req.session.adminId;
      const user = req.session.user;

      const senderInfo = adminId ? {
        senderId: adminId,
        senderName: req.session.adminName || 'Admin User',
        senderType: 'admin' as const
      } : {
        senderId: user.id,
        senderName: user.firstName + ' ' + user.lastName,
        senderType: 'site_manager' as const
      };

      const responseData = {
        ticketId,
        message,
        attachments: attachments || [],
        isInternal: isInternal || false,
        ...senderInfo
      };

      const response = await ticketingStorage.createTicketResponse(responseData);

      console.log(`âœ… New response added to ticket ${ticketId} by ${senderInfo.senderName}`);

      res.json({
        success: true,
        message: 'Ù¾Ø§Ø³Ø® Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯',
        data: response
      });

    } catch (error) {
      console.error('Error adding ticket response:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø³Ø®'
      });
    }
  });

  // Assign ticket to admin
  app.post('/api/tickets/:id/assign', requireAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { assignedTo, notes } = req.body;
      const adminId = req.session.adminId;

      if (!adminId) {
        return res.status(403).json({
          success: false,
          message: 'ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªÛŒÚ©Øª Ø±Ø§ ÙˆØ§Ú¯Ø°Ø§Ø± Ú©Ù†Ø¯'
        });
      }

      const assignment = await ticketingStorage.assignTicket(
        ticketId,
        assignedTo,
        adminId,
        notes
      );

      console.log(`âœ… Ticket ${ticketId} assigned to admin ${assignedTo} by admin ${adminId}`);

      res.json({
        success: true,
        message: 'ØªÛŒÚ©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ú¯Ø°Ø§Ø± Ø´Ø¯',
        data: assignment
      });

    } catch (error) {
      console.error('Error assigning ticket:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ÙˆØ§Ú¯Ø°Ø§Ø±ÛŒ ØªÛŒÚ©Øª'
      });
    }
  });

  // Get ticket statistics
  app.get('/api/tickets/stats/overview', async (req, res) => {
    // Allow guest access for demo purposes
    try {
      const stats = await ticketingStorage.getTicketStats();

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      console.error('Error fetching ticket stats:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });

  // Get user ticket statistics
  app.get('/api/tickets/stats/user', async (req, res) => {
    try {
      const adminId = req.session.adminId;
      const customerId = req.session.customerId;
      const userId = adminId || customerId || 0; // Use 0 for guest users

      const stats = await ticketingStorage.getUserTicketStats(userId);

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      console.error('Error fetching user ticket stats:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±'
      });
    }
  });

  // Get ticket categories
  app.get('/api/tickets/categories', async (req, res) => {
    // Allow guest access for demo purposes
    try {
      const categories = await ticketingStorage.getTicketCategories();

      res.json({
        success: true,
        data: categories
      });

    } catch (error) {
      console.error('Error fetching ticket categories:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });

  // Search tickets
  app.get('/api/tickets/search', async (req, res) => {
    // Allow guest access for demo purposes
    try {
      const { q: query, status, priority, category } = req.query;

      if (!query) {
        return res.status(400).json({
          success: false,
          message: 'Query parameter is required'
        });
      }

      const filters = {
        status: status as string,
        priority: priority as string,
        category: category as string
      };

      const tickets = await ticketingStorage.searchTickets(query as string, filters);

      res.json({
        success: true,
        data: tickets
      });

    } catch (error) {
      console.error('Error searching tickets:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§'
      });
    }
  });



  // Process automatic refund for failed payments
  app.post('/api/orders/:orderId/auto-refund', async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { reason = 'Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚' } = req.body;

      // Get order details
      const order = await customerStorage.getOrderById(orderId);
      if (!order) {
        return res.status(404).json({ success: false, message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // Check if wallet was used for this order
      if (order.paymentMethod === 'wallet_full' || order.paymentMethod === 'wallet_partial') {
        const orderAmount = parseFloat(order.totalAmount);
        
        // Get wallet amount used (if stored in order data)
        const walletAmountUsed = order.walletAmountUsed ? parseFloat(order.walletAmountUsed) : orderAmount;
        
        if (walletAmountUsed > 0) {
          // Refund to wallet
          const transaction = await walletStorage.creditWallet(
            order.customerId,
            walletAmountUsed,
            `Ø¨Ø±Ú¯Ø´Øª Ø®ÙˆØ¯Ú©Ø§Ø± ÙˆØ¬Ù‡ Ø³ÙØ§Ø±Ø´ #${order.orderNumber} - ${reason}`,
            'auto_refund',
            orderId,
            null // System processing
          );

          // Update order status
          await customerStorage.updateOrder(orderId, {
            status: 'payment_failed',
            paymentStatus: 'failed_refunded',
            refundAmount: walletAmountUsed.toString(),
            refundReason: reason,
            refundDate: new Date()
          });

          console.log(`âœ… Automatic refund processed: ${walletAmountUsed} IQD credited back to customer ${order.customerId}`);

          res.json({
            success: true,
            message: "Ø¨Ø±Ú¯Ø´Øª Ø®ÙˆØ¯Ú©Ø§Ø± ÙˆØ¬Ù‡ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯",
            data: {
              refundAmount: walletAmountUsed,
              transactionId: transaction.id,
              newWalletBalance: transaction.balanceAfter
            }
          });
        } else {
          res.json({
            success: true,
            message: "Ù‡ÛŒÚ† Ù…Ø¨Ù„ØºÛŒ Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ø´Ø¯Ù‡ Ø¨ÙˆØ¯"
          });
        }
      } else {
        res.json({
          success: true,
          message: "Ø³ÙØ§Ø±Ø´ Ø¨Ø§ Ú©ÛŒÙ Ù¾ÙˆÙ„ Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø´Ø¯Ù‡ Ø¨ÙˆØ¯"
        });
      }

    } catch (error) {
      console.error('Error processing automatic refund:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ú¯Ø´Øª Ø®ÙˆØ¯Ú©Ø§Ø± ÙˆØ¬Ù‡'
      });
    }
  });

  // Get customer wallet details (admin)
  app.get('/api/admin/wallet/customer/:customerId', requireAuth, async (req, res) => {
    try {
      const customerId = parseInt(req.params.customerId);
      const summary = await walletStorage.getCustomerWalletSummary(customerId);
      
      // Get customer details
      const customer = await crmStorage.getCrmCustomerById(customerId);
      
      res.json({ 
        success: true, 
        data: { 
          ...summary, 
          customer 
        } 
      });
    } catch (error) {
      console.error('Error fetching customer wallet details:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch customer wallet details' });
    }
  });

  // =============================================================================
  // GEOGRAPHIC ANALYTICS API - TEST ENDPOINT
  // =============================================================================

  // Test endpoint for geographic data
  app.get('/api/test/geographic', async (req, res) => {
    try {
      console.log('ðŸ§ª [TEST] Testing geographic data endpoint');
      
      const testData = await customerDb.select({
        country: sql`${customerOrders.shippingAddress}->>'country'`.as('country'),
        city: sql`${customerOrders.shippingAddress}->>'city'`.as('city'),
        count: sql`count(*)::int`.as('count')
      })
      .from(customerOrders)
      .where(
        and(
          isNotNull(sql`${customerOrders.shippingAddress}->>'country'`),
          isNotNull(sql`${customerOrders.shippingAddress}->>'city'`)
        )
      )
      .groupBy(sql`${customerOrders.shippingAddress}->>'country'`, sql`${customerOrders.shippingAddress}->>'city'`)
      .orderBy(sql`count(*) desc`)
      .limit(5);
      
      console.log('ðŸ§ª [TEST] Query result:', testData.length, 'records found');
      
      res.json({
        success: true,
        message: 'Test endpoint working',
        data: testData
      });
    } catch (error) {
      console.error('ðŸ§ª [TEST] Error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Test endpoint failed',
        error: error.message 
      });
    }
  });

  // =============================================================================
  // GEOGRAPHIC ANALYTICS API
  // =============================================================================

  // Geographic Analytics API endpoints
  app.get('/api/analytics/geographic', async (req, res) => {
    try {
      console.log('ðŸŒ [GEO] Starting geographic analytics endpoint');
      const { period = '30d', region = 'all' } = req.query;
      
      // Calculate date range based on period
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Get total unique customers count across all regions
      const totalCustomersResult = await customerDb.select({
        totalUniqueCustomers: sql`count(distinct ${customerOrders.customerId})::int`.as('totalUniqueCustomers')
      })
      .from(customerOrders)
      .where(
        and(
          isNotNull(sql`${customerOrders.shippingAddress}->>'country'`),
          isNotNull(sql`${customerOrders.shippingAddress}->>'city'`)
        )
      );

      const totalUniqueCustomers = totalCustomersResult[0]?.totalUniqueCustomers || 0;

      // Get orders with geographic data from shipping_address JSON
      const geoData = await customerDb.select({
        country: sql`${customerOrders.shippingAddress}->>'country'`.as('country'),
        city: sql`${customerOrders.shippingAddress}->>'city'`.as('city'),
        totalOrders: sql`count(*)::int`.as('totalOrders'),
        totalRevenue: sql`sum(${customerOrders.totalAmount})::numeric`.as('totalRevenue'),
        customerCount: sql`count(distinct ${customerOrders.customerId})::int`.as('customerCount')
      })
      .from(customerOrders)
      .where(
        and(
          isNotNull(sql`${customerOrders.shippingAddress}->>'country'`),
          isNotNull(sql`${customerOrders.shippingAddress}->>'city'`)
        )
      )
      .groupBy(sql`${customerOrders.shippingAddress}->>'country'`, sql`${customerOrders.shippingAddress}->>'city'`)
      .orderBy(sql`sum(${customerOrders.totalAmount}) desc`)
      .limit(20);
      
      console.log('ðŸŒ [GEO] Query result:', geoData.length, 'records found');
      console.log('ðŸŒ [GEO] Total unique customers:', totalUniqueCustomers);
      
      // Process data to add calculated fields and match frontend expectations
      const processedData = geoData.map((region) => {
        const totalRevenue = Number(region.totalRevenue) || 0;
        const avgOrderValue = region.totalOrders > 0 ? totalRevenue / region.totalOrders : 0;
        
        return {
          region: `${region.country}, ${region.city}`, // Combined region field for frontend
          country: region.country,
          city: region.city,
          totalOrders: region.totalOrders,
          totalRevenue: totalRevenue,
          customerCount: region.customerCount,
          avgOrderValue: Number(avgOrderValue.toFixed(2)),
          topProducts: [] // Simplified for now
        };
      });

      console.log('ðŸŒ [GEO] Processed data sample:', processedData.slice(0, 2));
      res.json({ 
        success: true, 
        data: processedData,
        summary: {
          totalUniqueCustomers: totalUniqueCustomers
        }
      });
    } catch (error) {
      console.error('Geographic analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch geographic analytics data' });
    }
  });

  app.get('/api/analytics/products', async (req, res) => {
    try {
      const { period = '30d', product = 'all' } = req.query;
      
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Get all shop products with their sales data (LEFT JOIN to include products with zero sales)
      const allProductsQuery = await customerDb.select({
        id: shopProducts.id,
        name: shopProducts.name,
        category: shopProducts.category
      })
      .from(shopProducts)
      .where(eq(shopProducts.inStock, true));

      console.log('ðŸ“Š [PRODUCTS] Found', allProductsQuery.length, 'products in shop');

      // For each product, calculate sales data
      const productData = await Promise.all(allProductsQuery.map(async (product) => {
        const salesData = await customerDb.select({
          totalSales: sql`COALESCE(sum(${orderItems.quantity}), 0)::int`.as('totalSales'),
          revenue: sql`COALESCE(sum(${orderItems.quantity} * ${orderItems.unitPrice}), 0)::numeric`.as('revenue')
        })
        .from(orderItems)
        .innerJoin(customerOrders, eq(orderItems.orderId, customerOrders.id))
        .where(and(
          eq(orderItems.productId, product.id),
          gte(customerOrders.createdAt, startDate)
        ));

        const sales = salesData[0] || { totalSales: 0, revenue: 0 };
        
        return {
          name: product.name,
          category: product.category,
          totalSales: Number(sales.totalSales) || 0,
          revenue: Number(sales.revenue) || 0
        };
      }));

      // Sort by revenue descending
      productData.sort((a, b) => b.revenue - a.revenue);

      // Filter by specific product if requested
      const filteredProductData = product && product !== 'all' 
        ? productData.filter(p => p.name === product)
        : productData;
      
      // Get regional breakdown for each product
      const processedData = await Promise.all(filteredProductData.map(async (productInfo) => {
        try {
          const regionsQuery = await customerDb.execute(sql`
            SELECT 
              COALESCE(
                (shipping_address->>'country'),
                CASE 
                  WHEN shipping_address::text LIKE '%Iran%' THEN 'Iran'
                  WHEN shipping_address::text LIKE '%Iraq%' THEN 'Iraq' 
                  WHEN shipping_address::text LIKE '%Turkey%' THEN 'Turkey'
                  ELSE 'Unknown'
                END
              ) as region,
              COALESCE(
                (shipping_address->>'city'),
                CASE 
                  WHEN shipping_address::text LIKE '%ØªÙ‡Ø±Ø§Ù†%' OR shipping_address::text LIKE '%Tehran%' THEN 'Tehran'
                  WHEN shipping_address::text LIKE '%Ø¨ØºØ¯Ø§Ø¯%' OR shipping_address::text LIKE '%Baghdad%' THEN 'Baghdad'
                  WHEN shipping_address::text LIKE '%Ø§Ø±Ø¨ÛŒÙ„%' OR shipping_address::text LIKE '%Erbil%' THEN 'Erbil'
                  ELSE 'Unknown'
                END
              ) as city,
              sum(oi.quantity)::int as quantity,
              sum(oi.quantity * oi.unit_price)::numeric as revenue
            FROM order_items oi
            INNER JOIN customer_orders co ON oi.order_id = co.id
            INNER JOIN shop_products sp ON oi.product_id = sp.id
            WHERE sp.name = ${productInfo.name}
              AND co.created_at >= ${startDate.toISOString()}
              AND co.shipping_address IS NOT NULL
            GROUP BY 
              COALESCE(
                (shipping_address->>'country'),
                CASE 
                  WHEN shipping_address::text LIKE '%Iran%' THEN 'Iran'
                  WHEN shipping_address::text LIKE '%Iraq%' THEN 'Iraq' 
                  WHEN shipping_address::text LIKE '%Turkey%' THEN 'Turkey'
                  ELSE 'Unknown'
                END
              ),
              COALESCE(
                (shipping_address->>'city'),
                CASE 
                  WHEN shipping_address::text LIKE '%ØªÙ‡Ø±Ø§Ù†%' OR shipping_address::text LIKE '%Tehran%' THEN 'Tehran'
                  WHEN shipping_address::text LIKE '%Ø¨ØºØ¯Ø§Ø¯%' OR shipping_address::text LIKE '%Baghdad%' THEN 'Baghdad'
                  WHEN shipping_address::text LIKE '%Ø§Ø±Ø¨ÛŒÙ„%' OR shipping_address::text LIKE '%Erbil%' THEN 'Erbil'
                  ELSE 'Unknown'
                END
              )
            ORDER BY sum(oi.quantity * oi.unit_price) DESC
            LIMIT 10
          `);

          const regions = regionsQuery.rows.map((row: any) => ({
            region: row.region,
            city: row.city,
            quantity: parseInt(row.quantity) || 0,
            revenue: parseFloat(row.revenue) || 0
          }));

          console.log(`ðŸ“ [PRODUCT-REGIONS] Product: ${productInfo.name}, Found ${regions.length} regions:`, regions);

          return {
            name: productInfo.name,
            category: productInfo.category,
            totalSales: productInfo.totalSales,
            revenue: Number(productInfo.revenue),
            regions: regions
          };
        } catch (error) {
          console.error(`Error fetching regions for product ${productInfo.name}:`, error);
          return {
            name: productInfo.name,
            category: productInfo.category,
            totalSales: productInfo.totalSales,
            revenue: Number(productInfo.revenue),
            regions: [] // Fallback to empty array
          };
        }
      }));

      res.json({ success: true, data: processedData });
    } catch (error) {
      console.error('Product analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch product analytics data' });
    }
  });

  app.get('/api/analytics/timeseries', async (req, res) => {
    try {
      console.log('ðŸ• [TIMESERIES] Starting timeseries analytics endpoint');
      
      const { period = '30d' } = req.query;
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Use simple aggregation without complex GROUP BY
      const orders = await customerDb.select()
        .from(customerOrders)
        .where(gte(customerOrders.createdAt, startDate));

      console.log(`ðŸ• [TIMESERIES] Found ${orders.length} orders since ${startDate.toISOString()}`);

      // Group by date in JavaScript to avoid SQL GROUP BY issues
      const dateGroups: { [key: string]: { orders: number, revenue: number } } = {};
      
      orders.forEach(order => {
        const dateKey = order.createdAt.toISOString().split('T')[0]; // YYYY-MM-DD format
        if (!dateGroups[dateKey]) {
          dateGroups[dateKey] = { orders: 0, revenue: 0 };
        }
        dateGroups[dateKey].orders += 1;
        dateGroups[dateKey].revenue += Number(order.totalAmount || 0);
      });

      // Convert to array and sort by date
      const processedData = Object.entries(dateGroups)
        .map(([date, stats]) => ({
          date,
          orders: stats.orders,
          revenue: stats.revenue,
          regions: {}
        }))
        .sort((a, b) => a.date.localeCompare(b.date));

      console.log(`ðŸ• [TIMESERIES] Processed data: ${processedData.length} date groups`);
      res.json({ success: true, data: processedData });
    } catch (error) {
      console.error('Time series analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch time series analytics data' });
    }
  });

  app.get('/api/analytics/product-trends', async (req, res) => {
    try {
      console.log('ðŸ“ˆ [PRODUCT-TRENDS] Starting product trends analytics endpoint');
      
      const { period = '30d', product = 'all' } = req.query;
      const now = new Date();
      let startDate = new Date();
      
      switch (period) {
        case '7d':
          startDate.setDate(now.getDate() - 7);
          break;
        case '30d':
          startDate.setDate(now.getDate() - 30);
          break;
        case '3m':
          startDate.setMonth(now.getMonth() - 3);
          break;
        case '1y':
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate.setDate(now.getDate() - 30);
      }

      // Get order items with related data using simple joins
      const orderItemsData = await customerDb.select({
        orderId: orderItems.orderId,
        productId: orderItems.productId,
        quantity: orderItems.quantity,
        unitPrice: orderItems.unitPrice,
        createdAt: customerOrders.createdAt,
        productName: shopProducts.name
      })
      .from(orderItems)
      .innerJoin(customerOrders, eq(orderItems.orderId, customerOrders.id))
      .innerJoin(shopProducts, eq(orderItems.productId, shopProducts.id))
      .where(gte(customerOrders.createdAt, startDate));

      console.log(`ðŸ“ˆ [PRODUCT-TRENDS] Found ${orderItemsData.length} order items since ${startDate.toISOString()}`);

      // Filter by product if specified
      let filteredData = orderItemsData;
      if (product && product !== 'all') {
        filteredData = orderItemsData.filter(item => item.productName === product);
        console.log(`ðŸ“ˆ [PRODUCT-TRENDS] Filtered to ${filteredData.length} items for product: ${product}`);
      }

      // Group by date and product in JavaScript
      const trends: { [key: string]: { date: string, productName: string, quantity: number, revenue: number } } = {};
      
      filteredData.forEach(item => {
        const dateKey = item.createdAt.toISOString().split('T')[0]; // YYYY-MM-DD format
        const key = `${dateKey}-${item.productName}`;
        
        if (!trends[key]) {
          trends[key] = {
            date: dateKey,
            productName: item.productName,
            quantity: 0,
            revenue: 0
          };
        }
        
        trends[key].quantity += item.quantity;
        trends[key].revenue += item.quantity * Number(item.unitPrice || 0);
      });

      // Convert to array and sort
      const processedData = Object.values(trends)
        .sort((a, b) => {
          const dateCompare = a.date.localeCompare(b.date);
          if (dateCompare !== 0) return dateCompare;
          return b.revenue - a.revenue; // Sort by revenue desc within same date
        });

      console.log(`ðŸ“ˆ [PRODUCT-TRENDS] Processed data: ${processedData.length} product-date combinations`);
      res.json({ success: true, data: processedData });
    } catch (error) {
      console.error('Product trends analytics API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch product trends analytics data' });
    }
  });

  // GEOGRAPHIC DISTRIBUTION REPORTS API
  // =============================================================================

  // Geographic Distribution Reports API
  app.get('/api/reports/geographic-distribution', async (req, res) => {
    try {
      // Get customer geographic distribution data
      const countries = await crmDb.select({
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(isNotNull(crmCustomers.country))
      .groupBy(crmCustomers.country)
      .orderBy(sql`count(*) desc`);

      const totalCustomers = await crmDb.select({ count: sql`count(*)::int`.as('count') })
        .from(crmCustomers)
        .then(result => result[0]?.count || 0);

      // Calculate percentages for countries
      const countriesWithPercentage = countries.map(country => ({
        ...country,
        percentage: totalCustomers > 0 ? (country.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(country.totalRevenue)
      }));

      // Get cities distribution
      const cities = await crmDb.select({
        city: crmCustomers.city,
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(and(isNotNull(crmCustomers.city), isNotNull(crmCustomers.country)))
      .groupBy(crmCustomers.city, crmCustomers.country)
      .orderBy(sql`count(*) desc`)
      .limit(50);

      const citiesWithPercentage = cities.map(city => ({
        ...city,
        percentage: totalCustomers > 0 ? (city.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(city.totalRevenue)
      }));

      // Get top regions summary
      const topRegions = countriesWithPercentage.slice(0, 10).map(country => ({
        region: country.country,
        customers: country.count,
        revenue: country.totalRevenue,
        averageOrderValue: country.count > 0 ? country.totalRevenue / country.count : 0
      }));

      const geoStats = {
        totalCustomers,
        countries: countriesWithPercentage,
        cities: citiesWithPercentage,
        topRegions
      };

      res.json(geoStats);
    } catch (error) {
      console.error('Geographic distribution API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch geographic distribution data' });
    }
  });

  // Customer locations API
  app.get('/api/reports/customer-locations', async (req, res) => {
    try {
      const { country } = req.query;
      
      let query = crmDb.select({
        id: crmCustomers.id,
        name: sql`concat(${crmCustomers.firstName}, ' ', ${crmCustomers.lastName})`.as('name'),
        email: crmCustomers.email,
        country: crmCustomers.country,
        city: crmCustomers.city,
        address: crmCustomers.address,
        totalOrders: crmCustomers.totalOrders,
        totalSpent: crmCustomers.totalSpent
      })
      .from(crmCustomers)
      .where(and(
        isNotNull(crmCustomers.address),
        isNotNull(crmCustomers.city),
        isNotNull(crmCustomers.country)
      ));

      if (country && country !== 'all') {
        query = query.where(eq(crmCustomers.country, country as string));
      }

      const customerLocations = await query
        .orderBy(desc(crmCustomers.totalSpent))
        .limit(100);

      res.json(customerLocations);
    } catch (error) {
      console.error('Customer locations API error:', error);
      res.status(500).json({ success: false, message: 'Failed to fetch customer locations' });
    }
  });

  // Geographic distribution PDF export
  app.post('/api/reports/geographic-distribution/export', async (req, res) => {
    try {
      const { country, metric } = req.body;
      
      // Get the geographic distribution data directly
      const countries = await crmDb.select({
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(isNotNull(crmCustomers.country))
      .groupBy(crmCustomers.country)
      .orderBy(sql`count(*) desc`);

      const totalCustomers = await crmDb.select({ count: sql`count(*)::int`.as('count') })
        .from(crmCustomers)
        .then(result => result[0]?.count || 0);

      const countriesWithPercentage = countries.map(country => ({
        ...country,
        percentage: totalCustomers > 0 ? (country.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(country.totalRevenue)
      }));

      const cities = await crmDb.select({
        city: crmCustomers.city,
        country: crmCustomers.country,
        count: sql`count(*)::int`.as('count'),
        totalRevenue: sql`coalesce(sum(${crmCustomers.totalSpent}), 0)::numeric`.as('totalRevenue')
      })
      .from(crmCustomers)
      .where(and(isNotNull(crmCustomers.city), isNotNull(crmCustomers.country)))
      .groupBy(crmCustomers.city, crmCustomers.country)
      .orderBy(sql`count(*) desc`)
      .limit(50);

      const citiesWithPercentage = cities.map(city => ({
        ...city,
        percentage: totalCustomers > 0 ? (city.count / totalCustomers) * 100 : 0,
        totalRevenue: Number(city.totalRevenue)
      }));

      const geoData = {
        totalCustomers,
        countries: countriesWithPercentage,
        cities: citiesWithPercentage
      };
      
      // Generate PDF report
      const html = `
        <!DOCTYPE html>
        <html dir="rtl">
        <head>
          <meta charset="UTF-8">
          <title>Ú¯Ø²Ø§Ø±Ø´ ØªÙˆØ²ÛŒØ¹ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†</title>
          <style>
            body { font-family: 'Tahoma', Arial, sans-serif; margin: 20px; direction: rtl; }
            .header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #333; padding-bottom: 20px; }
            .stats { display: flex; justify-content: space-around; margin: 20px 0; }
            .stat-card { text-align: center; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .table { width: 100%; border-collapse: collapse; margin: 20px 0; }
            .table th, .table td { border: 1px solid #ddd; padding: 12px; text-align: right; }
            .table th { background-color: #f5f5f5; font-weight: bold; }
            .section { margin: 30px 0; }
            .section h2 { color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>Ú¯Ø²Ø§Ø±Ø´ ØªÙˆØ²ÛŒØ¹ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†</h1>
            <p>ØªØ§Ø±ÛŒØ® ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´: ${new Date().toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            })}</p>
          </div>
          
          <div class="stats">
            <div class="stat-card">
              <h3>Ú©Ù„ Ù…Ø´ØªØ±ÛŒØ§Ù†</h3>
              <p style="font-size: 24px; font-weight: bold;">${geoData.totalCustomers.toLocaleString()}</p>
            </div>
            <div class="stat-card">
              <h3>ØªØ¹Ø¯Ø§Ø¯ Ú©Ø´ÙˆØ±Ù‡Ø§</h3>
              <p style="font-size: 24px; font-weight: bold;">${geoData.countries.length}</p>
            </div>
            <div class="stat-card">
              <h3>ØªØ¹Ø¯Ø§Ø¯ Ø´Ù‡Ø±Ù‡Ø§</h3>
              <p style="font-size: 24px; font-weight: bold;">${geoData.cities.length}</p>
            </div>
          </div>

          <div class="section">
            <h2>ØªÙˆØ²ÛŒØ¹ Ù…Ø´ØªØ±ÛŒØ§Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ø´ÙˆØ±</h2>
            <table class="table">
              <thead>
                <tr>
                  <th>Ø±ØªØ¨Ù‡</th>
                  <th>Ú©Ø´ÙˆØ±</th>
                  <th>ØªØ¹Ø¯Ø§Ø¯ Ù…Ø´ØªØ±ÛŒ</th>
                  <th>Ø¯Ø±ØµØ¯</th>
                  <th>Ú©Ù„ ÙØ±ÙˆØ´</th>
                </tr>
              </thead>
              <tbody>
                ${geoData.countries.map((country: any, index: number) => `
                  <tr>
                    <td>${index + 1}</td>
                    <td>${country.country}</td>
                    <td>${country.count.toLocaleString()}</td>
                    <td>${country.percentage.toFixed(1)}%</td>
                    <td>$${country.totalRevenue.toLocaleString()}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>

          <div class="section">
            <h2>ØªÙˆØ²ÛŒØ¹ Ù…Ø´ØªØ±ÛŒØ§Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ø´Ù‡Ø± (Û²Û° Ø´Ù‡Ø± Ø¨Ø±ØªØ±)</h2>
            <table class="table">
              <thead>
                <tr>
                  <th>Ø±ØªØ¨Ù‡</th>
                  <th>Ø´Ù‡Ø±</th>
                  <th>Ú©Ø´ÙˆØ±</th>
                  <th>ØªØ¹Ø¯Ø§Ø¯ Ù…Ø´ØªØ±ÛŒ</th>
                  <th>Ú©Ù„ ÙØ±ÙˆØ´</th>
                </tr>
              </thead>
              <tbody>
                ${geoData.cities.slice(0, 20).map((city: any, index: number) => `
                  <tr>
                    <td>${index + 1}</td>
                    <td>${city.city}</td>
                    <td>${city.country}</td>
                    <td>${city.count.toLocaleString()}</td>
                    <td>$${city.totalRevenue.toLocaleString()}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        </body>
        </html>
      `;

      const browser = await puppeteer.launch({
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      await page.setContent(html, { waitUntil: 'networkidle0' });
      
      const pdf = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: { top: '20px', bottom: '20px', left: '20px', right: '20px' }
      });
      
      await browser.close();

      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename=geographic-distribution-${new Date().toISOString().split('T')[0]}.pdf`);
      res.send(pdf);
      
    } catch (error) {
      console.error('PDF export error:', error);
      res.status(500).json({ success: false, message: 'Failed to generate PDF report' });
    }
  });

  // Geographic Analytics Endpoints
  app.get("/api/analytics/geographic", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d', region = 'all' } = req.query;
      
      // Calculate date range
      const daysMap: { [key: string]: number } = { '7d': 7, '30d': 30, '90d': 90, '1y': 365 };
      const days = daysMap[period as string] || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // Query orders with customer location data using raw SQL
      const query = sql`
        SELECT 
          COALESCE(c.country, 'Unknown') as country,
          COALESCE(c.city, 'Unknown') as city,
          COUNT(DISTINCT o.id) as total_orders,
          COUNT(DISTINCT o.customer_id) as customer_count,
          SUM(CAST(o.total_amount AS DECIMAL)) as total_revenue,
          AVG(CAST(o.total_amount AS DECIMAL)) as avg_order_value
        FROM orders o
        LEFT JOIN crm_customers c ON o.customer_id = c.id
        WHERE o.created_at >= ${startDate}
        ${region !== 'all' ? sql` AND c.country = ${region}` : sql``}
        GROUP BY c.country, c.city
        ORDER BY total_revenue DESC
      `;

      const result = await db.execute(query);

      // Get top products for each region
      const geoData = await Promise.all(result.rows.map(async (row: any) => {
        const topProductsQuery = sql`
          SELECT 
            p.name,
            SUM(oi.quantity) as quantity,
            SUM(CAST(oi.total_price AS DECIMAL)) as revenue
          FROM orders o
          LEFT JOIN crm_customers c ON o.customer_id = c.id
          LEFT JOIN order_items oi ON o.id = oi.order_id
          LEFT JOIN products p ON oi.product_id = p.id
          WHERE o.created_at >= ${startDate}
            AND c.country = ${row.country}
            AND c.city = ${row.city}
          GROUP BY p.id, p.name
          ORDER BY revenue DESC
          LIMIT 5
        `;

        const topProducts = await db.execute(topProductsQuery);

        return {
          region: `${row.city}, ${row.country}`,
          country: row.country,
          city: row.city,
          totalOrders: Number(row.total_orders),
          totalRevenue: Number(row.total_revenue) || 0,
          customerCount: Number(row.customer_count),
          avgOrderValue: Number(row.avg_order_value) || 0,
          topProducts: topProducts.rows.map((p: any) => ({
            name: p.name,
            quantity: Number(p.quantity),
            revenue: Number(p.revenue) || 0
          }))
        };
      }));

      res.json({
        success: true,
        data: geoData
      });

    } catch (error) {
      console.error("Error fetching geographic analytics:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching geographic analytics"
      });
    }
  });

  app.get("/api/analytics/products", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d', product = 'all' } = req.query;
      
      const daysMap: { [key: string]: number } = { '7d': 7, '30d': 30, '90d': 90, '1y': 365 };
      const days = daysMap[period as string] || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const query = sql`
        SELECT 
          p.name,
          p.category,
          SUM(oi.quantity) as total_sales,
          SUM(CAST(oi.total_price AS DECIMAL)) as revenue
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        LEFT JOIN products p ON oi.product_id = p.id
        WHERE o.created_at >= ${startDate}
        ${product !== 'all' ? sql` AND p.id = ${product}` : sql``}
        GROUP BY p.id, p.name, p.category
        ORDER BY revenue DESC
      `;

      const result = await db.execute(query);

      // Get regional breakdown for each product
      const productData = await Promise.all(result.rows.map(async (row: any) => {
        const regionsQuery = sql`
          SELECT 
            COALESCE(c.country, 'Unknown') as region,
            COALESCE(c.city, 'Unknown') as city,
            SUM(oi.quantity) as quantity,
            SUM(CAST(oi.total_price AS DECIMAL)) as revenue
          FROM orders o
          LEFT JOIN crm_customers c ON o.customer_id = c.id
          LEFT JOIN order_items oi ON o.id = oi.order_id
          LEFT JOIN products p ON oi.product_id = p.id
          WHERE o.created_at >= ${startDate} AND p.name = ${row.name}
          GROUP BY c.country, c.city
          ORDER BY revenue DESC
        `;

        const regions = await db.execute(regionsQuery);

        return {
          name: row.name,
          category: row.category,
          totalSales: Number(row.total_sales),
          revenue: Number(row.revenue) || 0,
          regions: regions.rows.map((r: any) => ({
            region: r.region,
            city: r.city,
            quantity: Number(r.quantity),
            revenue: Number(r.revenue) || 0
          }))
        };
      }));

      res.json({
        success: true,
        data: productData
      });

    } catch (error) {
      console.error("Error fetching product analytics:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching product analytics"
      });
    }
  });

  app.get("/api/analytics/timeseries", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d' } = req.query;
      
      const daysMap: { [key: string]: number } = { '7d': 7, '30d': 30, '90d': 90, '1y': 365 };
      const days = daysMap[period as string] || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const query = sql`
        SELECT 
          DATE(o.created_at) as date,
          COUNT(DISTINCT o.id) as orders,
          SUM(CAST(o.total_amount AS DECIMAL)) as revenue
        FROM orders o
        WHERE o.created_at >= ${startDate}
        GROUP BY DATE(o.created_at)
        ORDER BY date ASC
      `;

      const result = await db.execute(query);

      const timeData = result.rows.map((row: any) => ({
        date: row.date,
        orders: Number(row.orders),
        revenue: Number(row.revenue) || 0,
        regions: {} // Can be expanded to include regional breakdown per day
      }));

      res.json({
        success: true,
        data: timeData
      });

    } catch (error) {
      console.error("Error fetching time series analytics:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching time series analytics"
      });
    }
  });

  // Product Sales Trends Over Time API
  app.get("/api/analytics/product-trends", requireAuth, async (req: Request, res: Response) => {
    try {
      const { period = '30d', product = 'all' } = req.query;
      
      let dateCondition = '';
      const now = new Date();
      let startDate: Date;
      
      switch (period) {
        case '7d':
          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case '30d':
          startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
          break;
        case '3m':
          startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
          break;
        case '1y':
          startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
          break;
        default:
          startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      }

      const query = sql`
        SELECT 
          p.name as product_name,
          p.category,
          DATE(o.created_at) as date,
          SUM(oi.quantity) as daily_sales,
          SUM(CAST(oi.total_price AS DECIMAL)) as daily_revenue,
          COUNT(DISTINCT o.id) as daily_orders
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        LEFT JOIN products p ON oi.product_id = p.id
        WHERE o.created_at >= ${startDate}
        ${product !== 'all' ? sql`AND p.name = ${product}` : sql``}
        GROUP BY p.name, p.category, DATE(o.created_at)
        ORDER BY date ASC, daily_sales DESC
      `;

      const result = await db.execute(query);
      
      // Group data by product
      const productTrends: { [key: string]: any } = {};
      
      result.rows.forEach((row: any) => {
        const productName = row.product_name;
        if (!productTrends[productName]) {
          productTrends[productName] = {
            name: productName,
            category: row.category,
            dailyData: [],
            totalSales: 0,
            totalRevenue: 0,
            totalOrders: 0
          };
        }
        
        const dailyData = {
          date: row.date,
          sales: Number(row.daily_sales),
          revenue: Number(row.daily_revenue) || 0,
          orders: Number(row.daily_orders)
        };
        
        productTrends[productName].dailyData.push(dailyData);
        productTrends[productName].totalSales += dailyData.sales;
        productTrends[productName].totalRevenue += dailyData.revenue;
        productTrends[productName].totalOrders += dailyData.orders;
      });

      const responseData = Object.values(productTrends);

      res.json({
        success: true,
        data: responseData
      });

    } catch (error) {
      console.error("Error fetching product trends:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching product trends"
      });
    }
  });

  // =============================================================================
  // CENTRALIZED BARCODE MANAGEMENT API ENDPOINTS
  // =============================================================================
  
  // Generate EAN-13 barcode for product
  app.post("/api/barcode/generate", requireAuth, async (req: Request, res: Response) => {
    try {
      const { productName, category } = req.body;
      
      if (!productName || !category) {
        return res.status(400).json({
          success: false,
          message: "Product name and category are required"
        });
      }
      
      const barcode = generateEAN13Barcode(productName, category);
      const parsed = parseEAN13Barcode(barcode);
      
      res.json({
        success: true,
        data: {
          barcode,
          details: parsed,
          productName,
          category
        }
      });
    } catch (error) {
      console.error("Error generating barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error generating barcode"
      });
    }
  });
  
  // Validate EAN-13 barcode
  app.post("/api/barcode/validate", requireAuth, async (req: Request, res: Response) => {
    try {
      const { barcode } = req.body;
      
      if (!barcode) {
        return res.status(400).json({
          success: false,
          message: "Barcode is required"
        });
      }
      
      const isValid = validateEAN13(barcode);
      const parsed = parseEAN13Barcode(barcode);
      const isMomtazchemProduct = isMomtazchemBarcode(barcode);
      
      res.json({
        success: true,
        data: {
          barcode,
          isValid,
          isMomtazchemProduct,
          details: parsed
        }
      });
    } catch (error) {
      console.error("Error validating barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error validating barcode"
      });
    }
  });
  
  // Get product barcode (check if product already has barcode, if not generate one)
  app.get("/api/barcode/product/:productId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { productId } = req.params;
      
      // Try to get from showcase_products first
      const showcaseProduct = await shopStorage.getShopProductById(parseInt(productId));
      if (showcaseProduct) {
        let barcode = showcaseProduct.barcode;
        
        // If no barcode exists, generate one
        if (!barcode) {
          barcode = generateEAN13Barcode(showcaseProduct.name, showcaseProduct.category);
          
          // Update product with generated barcode
          await shopStorage.updateShopProduct(showcaseProduct.id, { barcode });
        }
        
        const parsed = parseEAN13Barcode(barcode);
        
        return res.json({
          success: true,
          data: {
            productId: showcaseProduct.id,
            productName: showcaseProduct.name,
            category: showcaseProduct.category,
            barcode,
            details: parsed,
            source: 'showcase'
          }
        });
      }
      
      // Try to get from shop_products if not found in showcase
      try {
        const shopProduct = await shopStorage.getShopProductById(parseInt(productId));
        if (shopProduct) {
          let barcode = shopProduct.barcode;
          
          // If no barcode exists, generate one
          if (!barcode) {
            barcode = generateEAN13Barcode(shopProduct.name, shopProduct.category);
            
            // Update product with generated barcode
            await shopStorage.updateShopProduct(shopProduct.id, { barcode });
          }
          
          const parsed = parseEAN13Barcode(barcode);
          
          return res.json({
            success: true,
            data: {
              productId: shopProduct.id,
              productName: shopProduct.name,
              category: shopProduct.category,
              barcode,
              details: parsed,
              source: 'shop'
            }
          });
        }
      } catch (error) {
        // Shop product not found, continue
      }
      
      res.status(404).json({
        success: false,
        message: "Product not found"
      });
      
    } catch (error) {
      console.error("Error getting product barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error getting product barcode"
      });
    }
  });
  
  // Search products by barcode
  app.get("/api/barcode/search/:barcode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { barcode } = req.params;
      
      if (!validateEAN13(barcode)) {
        return res.status(400).json({
          success: false,
          message: "Invalid EAN-13 barcode format"
        });
      }
      
      const results = [];
      
      // Search in showcase_products
      try {
        const showcaseProducts = await shopStorage.getShopProducts();
        const showcaseMatch = showcaseProducts.find((p: any) => p.barcode === barcode);
        if (showcaseMatch) {
          results.push({
            ...showcaseMatch,
            source: 'showcase'
          });
        }
      } catch (error) {
        console.error("Error searching showcase products:", error);
      }
      
      // Search in shop_products
      try {
        const shopProducts = await shopStorage.getShopProducts();
        const shopMatch = shopProducts.find((p: any) => p.barcode === barcode);
        if (shopMatch) {
          results.push({
            ...shopMatch,
            source: 'shop'
          });
        }
      } catch (error) {
        console.error("Error searching shop products:", error);
      }
      
      const parsed = parseEAN13Barcode(barcode);
      const isMomtazchemProduct = isMomtazchemBarcode(barcode);
      
      res.json({
        success: true,
        data: {
          barcode,
          details: parsed,
          isMomtazchemProduct,
          products: results
        }
      });
      
    } catch (error) {
      console.error("Error searching by barcode:", error);
      res.status(500).json({
        success: false,
        message: "Error searching by barcode"
      });
    }
  });

  // Check if barcode is unique/duplicate
  app.get("/api/barcode/check-duplicate/:barcode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { barcode } = req.params;
      const { excludeProductId } = req.query;
      
      // Search in showcase_products
      const showcaseProducts = await shopStorage.getShopProducts();
      const showcaseMatch = showcaseProducts.find((p: any) => 
        p.barcode === barcode && 
        (excludeProductId ? p.id !== parseInt(excludeProductId as string) : true)
      );
      
      // Search in shop_products (if exists)
      let shopMatch = null;
      try {
        const shopProducts = await shopStorage.getShopProducts();
        shopMatch = shopProducts.find((p: any) => 
          p.barcode === barcode && 
          (excludeProductId ? p.id !== parseInt(excludeProductId as string) : true)
        );
      } catch (error) {
        // Shop products table might not exist, ignore error
      }
      
      const isDuplicate = !!(showcaseMatch || shopMatch);
      const duplicateProduct = showcaseMatch || shopMatch;
      
      res.json({
        success: true,
        data: {
          barcode,
          isDuplicate,
          isUnique: !isDuplicate,
          duplicateProduct: duplicateProduct ? {
            id: duplicateProduct.id,
            name: duplicateProduct.name,
            source: showcaseMatch ? 'showcase' : 'shop'
          } : null
        }
      });
    } catch (error) {
      console.error("Error checking barcode duplicate:", error);
      res.status(500).json({
        success: false,
        message: "Error checking barcode uniqueness"
      });
    }
  });

  // Check if 5-digit product code is unique
  app.get("/api/barcode/check-product-code/:productCode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { productCode } = req.params;
      
      // Search in showcase_products for product codes within barcodes
      const showcaseProducts = await shopStorage.getShopProducts();
      const showcaseMatch = showcaseProducts.find((p: any) => {
        if (!p.barcode || p.barcode.length !== 13) return false;
        // Extract 5-digit product code from position 8-12 in EAN-13: 846-96771-XXXXX-C
        const extractedCode = p.barcode.substring(8, 13);
        return extractedCode === productCode;
      });
      
      // Search in shop_products (if exists)
      let shopMatch = null;
      try {
        const shopProducts = await shopStorage.getShopProducts();
        shopMatch = shopProducts.find((p: any) => {
          if (!p.barcode || p.barcode.length !== 13) return false;
          const extractedCode = p.barcode.substring(8, 13);
          return extractedCode === productCode;
        });
      } catch (error) {
        // Shop products table might not exist, ignore error
      }
      
      const isDuplicate = !!(showcaseMatch || shopMatch);
      
      res.json({
        success: true,
        data: {
          productCode,
          isDuplicate,
          isUnique: !isDuplicate
        }
      });
    } catch (error) {
      console.error("Error checking product code uniqueness:", error);
      res.status(500).json({
        success: false,
        message: "Error checking product code uniqueness"
      });
    }
  });



  // Generate barcodes with new Iraq format for all products
  app.post("/api/barcode/generate-iraq-format", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log("Starting Iraq format barcode generation...");
      
      // Get all showcase products
      const showcaseProductsData = await db.select().from(showcaseProducts);
      console.log(`Found ${showcaseProductsData.length} showcase products`);
      
      // Get all shop products  
      const shopProductsData = await db.select().from(shopProducts);
      console.log(`Found ${shopProductsData.length} shop products`);
      
      const results = [];
      
      // Process showcase products
      for (const product of showcaseProductsData) {
        try {
          // Generate new barcode with Iraq format: 864-96771-XXXXX-C
          const countryCode = '864'; // Iraq
          const companyCode = '96771'; // Momtazchem
          const productCode = Math.floor(10000 + Math.random() * 90000).toString(); // 5-digit random
          const barcode12 = countryCode + companyCode + productCode;
          
          // Calculate check digit
          let oddSum = 0;
          let evenSum = 0;
          for (let i = 0; i < 12; i++) {
            const digit = parseInt(barcode12[i]);
            if (i % 2 === 0) {
              oddSum += digit;
            } else {
              evenSum += digit;
            }
          }
          const total = oddSum + (evenSum * 3);
          const checkDigit = (10 - (total % 10)) % 10;
          const fullBarcode = barcode12 + checkDigit.toString();
          
          // Update product with new barcode
          await db.update(showcaseProducts)
            .set({ barcode: fullBarcode })
            .where(eq(showcaseProducts.id, product.id));
          
          results.push({
            id: product.id,
            name: product.name,
            type: 'showcase',
            oldBarcode: product.barcode,
            newBarcode: fullBarcode,
            formatted: `${countryCode}-${companyCode}-${productCode}-${checkDigit}`,
            success: true
          });
          
          console.log(`âœ“ Generated Iraq barcode for showcase product ${product.name}: ${fullBarcode}`);
        } catch (error) {
          console.error(`âœ— Failed to generate barcode for showcase product ${product.name}:`, error);
          results.push({
            id: product.id,
            name: product.name,
            type: 'showcase',
            oldBarcode: product.barcode,
            error: error.message,
            success: false
          });
        }
      }
      
      // Process shop products
      for (const product of shopProductsData) {
        try {
          // Generate new barcode with Iraq format: 864-96771-XXXXX-C
          const countryCode = '864'; // Iraq
          const companyCode = '96771'; // Momtazchem
          const productCode = Math.floor(10000 + Math.random() * 90000).toString(); // 5-digit random
          const barcode12 = countryCode + companyCode + productCode;
          
          // Calculate check digit
          let oddSum = 0;
          let evenSum = 0;
          for (let i = 0; i < 12; i++) {
            const digit = parseInt(barcode12[i]);
            if (i % 2 === 0) {
              oddSum += digit;
            } else {
              evenSum += digit;
            }
          }
          const total = oddSum + (evenSum * 3);
          const checkDigit = (10 - (total % 10)) % 10;
          const fullBarcode = barcode12 + checkDigit.toString();
          
          // Update product with new barcode
          await db.update(shopProducts)
            .set({ barcode: fullBarcode })
            .where(eq(shopProducts.id, product.id));
          
          results.push({
            id: product.id,
            name: product.name,
            type: 'shop',
            oldBarcode: product.barcode,
            newBarcode: fullBarcode,
            formatted: `${countryCode}-${companyCode}-${productCode}-${checkDigit}`,
            success: true
          });
          
          console.log(`âœ“ Generated Iraq barcode for shop product ${product.name}: ${fullBarcode}`);
        } catch (error) {
          console.error(`âœ— Failed to generate barcode for shop product ${product.name}:`, error);
          results.push({
            id: product.id,
            name: product.name,
            type: 'shop',
            oldBarcode: product.barcode,
            error: error.message,
            success: false
          });
        }
      }
      
      const successCount = results.filter(r => r.success).length;
      const totalCount = results.length;
      
      console.log(`Iraq format barcode generation complete: ${successCount}/${totalCount} successful`);
      
      res.json({
        success: true,
        results,
        summary: `Generated Iraq format barcodes: ${successCount}/${totalCount} successful`,
        format: "864-96771-XXXXX-C (Iraq country code + Momtazchem company code + product code + check digit)"
      });
    } catch (error) {
      console.error("Error in Iraq format barcode generation:", error);
      res.status(500).json({
        success: false,
        message: "Error generating Iraq format barcodes",
        error: error.message
      });
    }
  });

  // Bulk barcode download endpoint
  app.get("/api/barcode/download-all", requireAuth, async (req: Request, res: Response) => {
    try {
      const { format = 'zip' } = req.query;
      
      // Get all products with barcodes from shop_products table
      const shopProductsWithBarcodes = await db
        .select({
          id: shopProducts.id,
          name: shopProducts.name,
          sku: shopProducts.sku,
          barcode: shopProducts.barcode,
          category: shopProducts.category,
          type: sql<string>`'shop'`
        })
        .from(shopProducts)
        .where(and(
          isNotNull(shopProducts.barcode),
          sql`LENGTH(${shopProducts.barcode}) = 13`
        ));

      if (shopProductsWithBarcodes.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No products with valid EAN-13 barcodes found"
        });
      }

      if (format === 'csv') {
        // CSV format for bulk import into label printers
        const csvData = [
          'Name,SKU,Barcode,Category',
          ...shopProductsWithBarcodes.map(p => 
            `"${p.name}","${p.sku || ''}","${p.barcode}","${p.category}"`
          )
        ].join('\n');

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="all-barcodes.csv"');
        res.send(csvData);
      } else {
        // JSON format
        res.json({
          success: true,
          data: {
            totalProducts: shopProductsWithBarcodes.length,
            products: shopProductsWithBarcodes
          },
          exportedAt: new Date().toISOString()
        });
      }

    } catch (error) {
      console.error("Error downloading all barcodes:", error);
      res.status(500).json({
        success: false,
        message: "Failed to download barcodes",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // AI-powered SKU generation endpoint
  app.post("/api/products/generate-sku", requireAuth, async (req: Request, res: Response) => {
    try {
      const productData = req.body;
      
      if (!productData.name || !productData.category) {
        return res.status(400).json({
          success: false,
          message: "Product name and category are required"
        });
      }

      console.log("Generating smart SKU for product:", productData.name);
      
      const skuResult = await generateSmartSKU(productData);
      
      // Check if SKU is unique in both showcase and shop products
      const existingShowcase = await db.select().from(showcaseProducts).where(eq(showcaseProducts.sku, skuResult.sku));
      const existingShop = await db.select().from(shopProducts).where(eq(shopProducts.sku, skuResult.sku));
      
      if (existingShowcase.length > 0 || existingShop.length > 0) {
        // If SKU exists, append a unique suffix
        const timestamp = Date.now().toString().slice(-4);
        skuResult.sku = `${skuResult.sku}-${timestamp}`;
        skuResult.reasoning += ` (Added unique suffix ${timestamp} to ensure uniqueness)`;
      }

      console.log("Generated SKU:", skuResult.sku);
      
      res.json({
        success: true,
        data: skuResult
      });
      
    } catch (error) {
      console.error("Error generating SKU:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate SKU",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Generate barcode endpoint
  app.post("/api/products/generate-barcode", requireAuth, async (req: Request, res: Response) => {
    try {
      const { name, category } = req.body;
      
      if (!name || !category) {
        return res.status(400).json({
          success: false,
          message: "Product name and category are required"
        });
      }

      console.log("Generating EAN-13 barcode for product:", name);
      
      // Generate barcode server-side with database access
      const barcode = await generateServerSideEAN13Barcode(name, category);
      
      console.log("Generated barcode:", barcode);
      
      res.json({
        success: true,
        data: { barcode }
      });
      
    } catch (error) {
      console.error("Error generating barcode:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate barcode",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Server-side EAN-13 barcode generation with database access
  const generateServerSideEAN13Barcode = async (productName: string, category: string): Promise<string> => {
    // Iraq GS1 country code
    const countryCode = '864';
    
    // Momtazchem company code
    const companyCode = '96771';
    
    // Generate unique 4-digit product code
    let attempts = 0;
    const maxAttempts = 100;
    let productCode = '';
    
    while (attempts < maxAttempts) {
      // Generate random 4-digit code (1000-9999)
      const randomCode = Math.floor(1000 + Math.random() * 9000).toString();
      
      // Check if this barcode would be unique
      const testBarcode12 = countryCode + companyCode + randomCode;
      const testCheckDigit = calculateEAN13CheckDigit(testBarcode12);
      const testBarcode = testBarcode12 + testCheckDigit;
      
      // Check both showcase and shop products for uniqueness
      const existingShowcase = await db.select().from(showcaseProducts).where(eq(showcaseProducts.barcode, testBarcode));
      const existingShop = await db.select().from(shopProducts).where(eq(shopProducts.barcode, testBarcode));
      
      if (existingShowcase.length === 0 && existingShop.length === 0) {
        productCode = randomCode;
        break;
      }
      
      attempts++;
    }
    
    // If all random attempts failed, use timestamp-based code
    if (!productCode) {
      productCode = Date.now().toString().slice(-4);
    }
    
    // Build 12-digit code: 864 + 96771 + XXXX
    const barcode12 = countryCode + companyCode + productCode;
    
    // Calculate and append check digit
    const checkDigit = calculateEAN13CheckDigit(barcode12);
    const fullBarcode = barcode12 + checkDigit;
    
    console.log('Server-side barcode generation:', {
      productName,
      category,
      countryCode,
      companyCode,
      productCode,
      barcode12,
      checkDigit,
      fullBarcode,
      length: fullBarcode.length
    });
    
    return fullBarcode;
  };

  // Calculate EAN-13 check digit
  const calculateEAN13CheckDigit = (barcode12: string): string => {
    let sum = 0;
    for (let i = 0; i < 12; i++) {
      const digit = parseInt(barcode12[i]);
      sum += i % 2 === 0 ? digit : digit * 3;
    }
    const checkDigit = (10 - (sum % 10)) % 10;
    return checkDigit.toString();
  };

  // AI Test Connection endpoint
  app.post("/api/ai/test-connection", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log("Testing OpenAI API connection...");
      
      // Simple test request to OpenAI
      const testResult = await generateSmartSKU({
        name: "Test Product",
        category: "commercial",
        description: "This is a test product for API validation"
      });

      console.log("OpenAI API test successful");
      
      res.json({
        success: true,
        model: "gpt-4o",
        status: "connected",
        testResult: testResult.sku
      });
      
    } catch (error) {
      console.error("OpenAI API test failed:", error);
      res.status(500).json({
        success: false,
        message: "Failed to connect to OpenAI API",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Force inventory refresh endpoint - to be called after order completion
  app.post("/api/inventory/force-refresh", async (req: Request, res: Response) => {
    try {
      console.log("Force refreshing inventory data...");
      
      // Trigger inventory sync from shop to showcase
      const { syncFromShopToShowcase } = await import("./unified-inventory-manager");
      await syncFromShopToShowcase();
      
      console.log("âœ“ Inventory force refresh completed");
      
      res.json({
        success: true,
        message: "Inventory refreshed successfully",
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error("âœ— Error force refreshing inventory:", error);
      res.status(500).json({
        success: false,
        message: "Failed to refresh inventory",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // DEPARTMENT ORDER MANAGEMENT ENDPOINTS
  // =============================================================================



  // Finance Department - Approve payment
  app.post("/api/finance/orders/:orderId/approve", requireAuth, attachUserDepartments, requireDepartment('financial'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      // Get customer information for notification
      const [customerInfo] = await db
        .select({
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          orderNumber: customerOrders.orderNumber,
          total: customerOrders.totalAmount
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.customerOrderId, orderId));

      // Update order status to warehouse_pending (approved by financial, ready for warehouse)
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'warehouse_pending',
          financialReviewerId: adminId,
          financialReviewedAt: new Date(),
          financialNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'payment_uploaded',
        toStatus: 'warehouse_pending',
        changedBy: adminId,
        changedByDepartment: 'financial',
        notes: notes
      });

      // Send approval notification to customer
      if (customerInfo) {
        try {
          // Send email notification
          const { customerCommunicationStorage } = await import("./customer-communication-storage");
          await customerCommunicationStorage.sendMessage({
            categoryId: 2, // Order Updates category
            customerEmail: customerInfo.customerEmail,
            subject: `ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${customerInfo.orderNumber}`,
            message: `Ø³Ù„Ø§Ù… ${customerInfo.customerName} ${customerInfo.customerLastName}ØŒ\n\nÙ¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§Ø±Ù‡ ${customerInfo.orderNumber} Ø¨Ù‡ Ù…Ø¨Ù„Øº ${customerInfo.total} Ø¯ÛŒÙ†Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯.\n\nØ³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø§Ú©Ù†ÙˆÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ù†Ø¨Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡ Ø§Ø³Øª.\n\n${notes ? 'ÛŒØ§Ø¯Ø¯Ø§Ø´Øª: ' + notes : ''}\n\nØ¨Ø§ ØªØ´Ú©Ø±ØŒ\nØªÛŒÙ… Ù…Ù…ØªØ§Ø²Ø´ÛŒÙ…ÛŒ`,
            messageType: 'outbound',
            priority: 'high',
            messageSource: 'system'
          });

          // Website and email notification sent (NO SMS per user requirement)
          
        } catch (notificationError) {
          console.error("Error sending approval notifications:", notificationError);
          // Don't fail the approval if notification fails
        }
      }

      res.json({ success: true, message: "Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯ Ùˆ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
    } catch (error) {
      console.error("Error approving finance order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Finance Department - Reject payment
  app.post("/api/finance/orders/:orderId/reject", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      // Get customer information for notification
      const [customerInfo] = await db
        .select({
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          orderNumber: customerOrders.orderNumber,
          total: customerOrders.totalAmount
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.customerOrderId, orderId));

      // Update order status to financial_rejected
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'financial_rejected',
          financialReviewerId: adminId,
          financialReviewedAt: new Date(),
          financialNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'payment_uploaded',
        toStatus: 'financial_rejected',
        changedBy: adminId,
        changedByDepartment: 'financial',
        notes: notes
      });

      // Send rejection notification to customer
      if (customerInfo) {
        try {
          // Send email notification
          const { customerCommunicationStorage } = await import("./customer-communication-storage");
          await customerCommunicationStorage.sendMessage({
            categoryId: 2, // Order Updates category
            customerEmail: customerInfo.customerEmail,
            subject: `Ø¹Ø¯Ù… ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ ${customerInfo.orderNumber}`,
            message: `Ø³Ù„Ø§Ù… ${customerInfo.customerName} ${customerInfo.customerLastName}ØŒ\n\nÙ…ØªØ£Ø³ÙØ§Ù†Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§Ø±Ù‡ ${customerInfo.orderNumber} Ø¨Ù‡ Ù…Ø¨Ù„Øº ${customerInfo.total} Ø¯ÛŒÙ†Ø§Ø± ØªØ§ÛŒÛŒØ¯ Ù†Ø´Ø¯.\n\nØ¯Ù„ÛŒÙ„ Ø¹Ø¯Ù… ØªØ§ÛŒÛŒØ¯: ${notes || 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª'}\n\nÙ„Ø·ÙØ§Ù‹ Ø¨Ø±Ø§ÛŒ Ø§ØµÙ„Ø§Ø­ Ù…Ø´Ú©Ù„ Ø¨Ø§ Ù…Ø§ ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯ ÛŒØ§ ÙÛŒØ´ ÙˆØ§Ø±ÛŒØ²ÛŒ ØµØ­ÛŒØ­ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ù†Ù…Ø§ÛŒÛŒØ¯.\n\nØ¨Ø§ ØªØ´Ú©Ø±ØŒ\nØªÛŒÙ… Ù…Ù…ØªØ§Ø²Ø´ÛŒÙ…ÛŒ`,
            messageType: 'outbound',
            priority: 'high',
            messageSource: 'system'
          });

          // Website and email notification sent (NO SMS per user requirement)
          
        } catch (notificationError) {
          console.error("Error sending rejection notifications:", notificationError);
          // Don't fail the rejection if notification fails
        }
      }

      res.json({ success: true, message: "Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø¯ Ø´Ø¯ Ùˆ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" });
    } catch (error) {
      console.error("Error rejecting finance order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Get orders approved by finance (NO AUTHENTICATION)
  app.get("/api/warehouse/orders-noauth", async (req: Request, res: Response) => {
    try {
      console.log('ðŸ“¦ [WAREHOUSE-NOAUTH] Getting warehouse orders...');
      
      // Use the getOrdersByDepartment method to get warehouse orders
      const orders = await orderManagementStorage.getOrdersByDepartment('warehouse');
      
      console.log('ðŸ“¦ [WAREHOUSE-NOAUTH] Retrieved', orders.length, 'orders for warehouse');
      if (orders.length > 0) {
        console.log('ðŸ“¦ [WAREHOUSE-NOAUTH] First order sample:', JSON.stringify(orders[0], null, 2));
      }
      
      res.json({ success: true, orders });
    } catch (error) {
      console.error('ðŸ“¦ [WAREHOUSE-NOAUTH] Error fetching orders:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Get product waste amounts
  app.get("/api/warehouse/waste", async (req: Request, res: Response) => {
    try {
      const { pool } = await import('./db');
      
      // Get the latest waste amount for each product
      const result = await pool.query(`
        SELECT 
          product_id,
          waste_amount,
          reason,
          reported_at
        FROM product_waste pw1
        WHERE pw1.reported_at = (
          SELECT MAX(pw2.reported_at) 
          FROM product_waste pw2 
          WHERE pw2.product_id = pw1.product_id
        )
        ORDER BY pw1.product_id
      `);
      
      // Convert to key-value format for frontend
      const wasteAmounts: { [key: string]: number } = {};
      result.rows.forEach(row => {
        wasteAmounts[row.product_id.toString()] = parseFloat(row.waste_amount) || 0;
      });
      
      res.json({ success: true, wasteAmounts });
    } catch (error) {
      console.error('Error fetching waste amounts:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¶Ø§ÛŒØ¹Ø§Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Update product waste amount
  app.post("/api/warehouse/waste/:productId", async (req: Request, res: Response) => {
    try {
      const { pool } = await import('./db');
      const productId = parseInt(req.params.productId);
      const { wasteAmount, reason } = req.body;
      
      if (isNaN(productId) || wasteAmount < 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù†Ø§Ø³Ù‡ Ù…Ø­ØµÙˆÙ„ ÛŒØ§ Ù…Ù‚Ø¯Ø§Ø± Ø¶Ø§ÛŒØ¹Ø§Øª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }
      
      // Insert new waste record
      await pool.query(`
        INSERT INTO product_waste (product_id, waste_amount, reason, reported_by)
        VALUES ($1, $2, $3, $4)
      `, [productId, wasteAmount, reason || 'ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÛŒ', req.session?.adminId || null]);
      
      res.json({ 
        success: true, 
        message: "Ø¶Ø§ÛŒØ¹Ø§Øª Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error('Error updating waste amount:', error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¶Ø§ÛŒØ¹Ø§Øª",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Approve order (items ready)
  app.post("/api/warehouse/orders/:orderId/approve", requireAuth, attachUserDepartments, requireDepartment('warehouse'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      console.log(`ðŸ“¦ [WAREHOUSE] Processing approval for order ${orderId}`);

      // Get order details with customer information first
      const { customerOrders } = await import("../shared/customer-schema");
      const { crmCustomers } = await import("../shared/crm-schema");
      
      const orderDetailsQuery = await db
        .select({
          // Order Management fields
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          
          // Customer info from CRM
          customerFirstName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          
          // Order total for context
          totalAmount: customerOrders.totalAmount,
          currency: customerOrders.currency,
        })
        .from(orderManagement)
        .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.customerOrderId, orderId))
        .limit(1);

      if (orderDetailsQuery.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const order = orderDetailsQuery[0];
      console.log(`ðŸ“‹ [WAREHOUSE] Order details: Customer ${order.customerFirstName} ${order.customerLastName}, Phone: ${order.customerPhone}`);
      
      if (!order.customerPhone) {
        console.log(`âš ï¸ [WAREHOUSE] Warning: Order ${orderId} has no customer phone number for SMS`);
      }

      // Update order status to warehouse_approved
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'warehouse_approved',
          warehouseAssigneeId: adminId,
          warehouseProcessedAt: new Date(),
          warehouseNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'financial_approved',
        toStatus: 'warehouse_approved',
        changedBy: adminId,
        changedByDepartment: 'warehouse',
        notes: notes
      });

      console.log(`âœ… [WAREHOUSE] Order ${orderId} approved successfully`);

      // AUTOMATIC DELIVERY CODE GENERATION AND SMS SENDING
      try {
        console.log(`ðŸš€ [WAREHOUSE] Triggering automatic delivery code generation for order ${orderId}`);
        
        // Check if delivery code already exists
        const existingCode = await logisticsStorage.getDeliveryCodeByOrderId(orderId);
        
        let deliveryCodeData;
        let isNewCode = false;
        
        if (existingCode) {
          // Use existing code
          deliveryCodeData = existingCode;
          console.log(`ðŸ”„ [WAREHOUSE] Reusing existing delivery code ${existingCode.verificationCode} for order ${orderId}`);
        } else {
          // Generate new delivery code with proper customer details
          const customerName = `${order.customerFirstName || ''} ${order.customerLastName || ''}`.trim() || 'Ù…Ø´ØªØ±ÛŒ';
          const customerPhone = order.customerPhone || '09000000000';
          
          deliveryCodeData = await logisticsStorage.generateVerificationCode(
            orderId,
            customerPhone,
            customerName
          );
          isNewCode = true;
          console.log(`ðŸ†• [WAREHOUSE] Generated new delivery code ${deliveryCodeData.verificationCode} for order ${orderId}, customer: ${customerName}`);
        }

        // Send SMS notification automatically with proper customer details
        try {
          const customerName = `${order.customerFirstName || ''} ${order.customerLastName || ''}`.trim() || 'Ù…Ø´ØªØ±ÛŒ';
          const customerPhone = order.customerPhone || '09000000000';
          
          const smsResult = await smsService.sendDeliveryVerificationSms(
            customerPhone,
            deliveryCodeData.verificationCode,
            customerName,
            deliveryCodeData.id
          );

          if (smsResult.success) {
            await logisticsStorage.updateSmsStatus(deliveryCodeData.id, 'sent', { 
              messageId: smsResult.messageId,
              provider: 'kavenegar'
            });
            console.log(`ðŸ“± [WAREHOUSE] SMS sent successfully for order ${orderId}, code: ${deliveryCodeData.verificationCode}`);
          } else {
            console.log(`âš ï¸ [WAREHOUSE] SMS sending failed for order ${orderId}: ${smsResult.error}`);
          }
        } catch (smsError) {
          console.error(`âŒ [WAREHOUSE] SMS error for order ${orderId}:`, smsError);
        }

      } catch (codeError) {
        console.error(`âŒ [WAREHOUSE] Error generating delivery code for order ${orderId}:`, codeError);
        // Continue without failing the warehouse approval
      }

      res.json({ 
        success: true, 
        message: "Ú©Ø§Ù„Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯ Ùˆ Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        deliveryCodeGenerated: true
      });
    } catch (error) {
      console.error("Error approving warehouse order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse Department - Reject order (out of stock)
  app.post("/api/warehouse/orders/:orderId/reject", requireAuth, attachUserDepartments, requireDepartment('warehouse'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes } = req.body;
      const adminId = req.session.adminId;

      // Update order status to warehouse_rejected
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'warehouse_rejected',
          warehouseAssigneeId: adminId,
          warehouseProcessedAt: new Date(),
          warehouseNotes: notes
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'financial_approved',
        toStatus: 'warehouse_rejected',
        changedBy: adminId,
        changedByDepartment: 'warehouse',
        notes: notes
      });

      res.json({ success: true, message: "Ú©Ø§Ù„Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª" });
    } catch (error) {
      console.error("Error rejecting warehouse order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø±Ø¯ Ø³ÙØ§Ø±Ø´ Ø§Ù†Ø¨Ø§Ø±",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Warehouse inventory synchronization endpoint - receives stock updates from Ú©Ø§Ø±Ø¯Ú©Ø³
  app.post("/api/warehouse/inventory-sync", async (req, res) => {
    try {
      const movementData = req.body;
      console.log("ðŸ“¦ [WAREHOUSE-INVENTORY-SYNC] Received inventory movement from Ú©Ø§Ø±Ø¯Ú©Ø³:", {
        productName: movementData.productName,
        movementType: movementData.movementType,
        quantity: movementData.quantity,
        previousStock: movementData.previousStock,
        newStock: movementData.newStock,
        source: movementData.source
      });
      
      // Store the inventory movement for warehouse staff to see
      // In a production system, you might want to store this in a proper inventory_movements table
      const movementRecord = {
        id: Date.now(), // Simple ID generation
        timestamp: new Date().toISOString(),
        productId: movementData.productId,
        productName: movementData.productName,
        productSku: movementData.productSku,
        productBarcode: movementData.productBarcode,
        movementType: movementData.movementType,
        quantity: movementData.quantity,
        previousStock: movementData.previousStock,
        newStock: movementData.newStock,
        reason: movementData.reason,
        source: movementData.source,
        notes: movementData.notes,
        status: 'active'
      };
      
      console.log(`âœ… [WAREHOUSE-INVENTORY-SYNC] Successfully recorded inventory movement for ${movementData.productName}`);
      console.log(`ðŸ“Š [WAREHOUSE-INVENTORY-SYNC] Movement details:`, {
        type: movementData.movementType,
        change: `${movementData.previousStock} â†’ ${movementData.newStock}`,
        difference: movementData.movementType.includes('Ø§ÙØ²Ø§ÛŒØ´') ? `+${movementData.quantity}` : `-${movementData.quantity}`
      });
      
      res.json({
        success: true,
        message: "Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ù†Ø¨Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯",
        movement: movementRecord
      });
    } catch (error) {
      console.error("âŒ [WAREHOUSE-INVENTORY-SYNC] Error:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ù†Ø¨Ø§Ø±"
      });
    }
  });

  // Logistics Department - Get orders approved by warehouse
  app.get("/api/logistics/orders", requireAuth, attachUserDepartments, requireDepartment('logistics'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { orderItems } = await import("../shared/shop-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq, inArray } = await import("drizzle-orm");

      // Get orders approved by warehouse, pending logistics processing
      const orders = await db
        .select({
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          warehouseNotes: orderManagement.warehouseNotes,
          warehouseProcessedAt: orderManagement.warehouseProcessedAt,
          logisticsNotes: orderManagement.logisticsNotes,
          logisticsProcessedAt: orderManagement.logisticsProcessedAt,
          deliveryCode: orderManagement.deliveryCode,
          trackingNumber: orderManagement.trackingNumber,
          deliveryPersonName: orderManagement.deliveryPersonName,
          deliveryPersonPhone: orderManagement.deliveryPersonPhone,
          estimatedDeliveryDate: orderManagement.estimatedDeliveryDate,
          createdAt: orderManagement.createdAt,
          orderTotal: customerOrders.total,
          orderDate: customerOrders.createdAt,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerAddress: crmCustomers.address,
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(eq(orderManagement.currentStatus, 'warehouse_approved'))
        .orderBy(orderManagement.warehouseProcessedAt); // Oldest warehouse-approved first

      // Get order items for each order
      const ordersWithItems = await Promise.all(orders.map(async (order) => {
        const items = await db
          .select()
          .from(orderItems)
          .where(eq(orderItems.orderId, order.customerOrderId));

        return {
          ...order,
          customerName: `${order.customerName} ${order.customerLastName}`,
          orderItems: items
        };
      }));

      res.json({ success: true, orders: ordersWithItems });
    } catch (error) {
      console.error("Error fetching logistics orders:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ù„Ø¬Ø³ØªÛŒÚ©",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Logistics Department - Dispatch order (generate delivery code and send SMS)
  app.post("/api/logistics/orders/:orderId/dispatch", requireAuth, attachUserDepartments, requireDepartment('logistics'), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement, orderStatusHistory } = await import("../shared/order-management-schema");
      const { eq } = await import("drizzle-orm");
      
      const orderId = parseInt(req.params.orderId);
      const { notes, trackingNumber, deliveryPersonName, deliveryPersonPhone, estimatedDeliveryDate } = req.body;
      const adminId = req.session.adminId;

      // Generate unique 4-digit delivery code
      const deliveryCode = Math.floor(1000 + Math.random() * 9000).toString();

      // Update order status to logistics_dispatched
      await db
        .update(orderManagement)
        .set({
          currentStatus: 'logistics_dispatched',
          logisticsAssigneeId: adminId,
          logisticsProcessedAt: new Date(),
          logisticsNotes: notes,
          deliveryCode: deliveryCode,
          trackingNumber: trackingNumber,
          deliveryPersonName: deliveryPersonName,
          deliveryPersonPhone: deliveryPersonPhone,
          estimatedDeliveryDate: estimatedDeliveryDate ? new Date(estimatedDeliveryDate) : null,
        })
        .where(eq(orderManagement.customerOrderId, orderId));

      // Add status history
      await db.insert(orderStatusHistory).values({
        orderManagementId: orderId,
        fromStatus: 'warehouse_approved',
        toStatus: 'logistics_dispatched',
        changedBy: adminId,
        changedByDepartment: 'logistics',
        notes: `${notes} | Ú©Ø¯ ØªØ­ÙˆÛŒÙ„: ${deliveryCode} | ØªØ­ÙˆÛŒÙ„â€ŒØ¯Ù‡Ù†Ø¯Ù‡: ${deliveryPersonName}`
      });

      // Get customer phone number for SMS
      const { crmCustomers } = await import("../shared/schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const orderResult = await db
        .select()
        .from(customerOrders)
        .where(eq(customerOrders.id, orderId))
        .limit(1);
      
      if (orderResult.length > 0 && orderResult[0].customerId) {
        const customerResult = await db
          .select({ phone: crmCustomers.phone, firstName: crmCustomers.firstName })
          .from(crmCustomers)
          .where(eq(crmCustomers.id, orderResult[0].customerId))
          .limit(1);
        
        if (customerResult.length > 0) {
          const customerPhone = customerResult[0].phone;
          const customerName = customerResult[0].firstName;
          
          // Send SMS notification
          const smsMessage = `Ø³Ù„Ø§Ù… ${customerName}ØŒ Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. Ú©Ø¯ ØªØ­ÙˆÛŒÙ„: ${deliveryCode}. ØªØ­ÙˆÛŒÙ„â€ŒØ¯Ù‡Ù†Ø¯Ù‡: ${deliveryPersonName} (${deliveryPersonPhone}). Ø´Ø±Ú©Øª Ù…ÙˆÙ…ØªØ§Ø² Ú©ÛŒÙ…`;
          
          try {
            // Log SMS for now (can be integrated with actual SMS service later)
            console.log(`SMS sent to ${customerPhone}: ${smsMessage}`);
            
            // Store SMS in database for tracking
            const { smsLogs } = await import("../shared/schema");
            await db.insert(smsLogs).values({
              phoneNumber: customerPhone,
              message: smsMessage,
              purpose: 'delivery_notification',
              relatedOrderId: orderId,
              deliveryCode: deliveryCode,
              status: 'sent'
            });
          } catch (smsError) {
            console.error("Error sending SMS:", smsError);
          }
        }
      }

      res.json({ 
        success: true, 
        message: "Ø³ÙØ§Ø±Ø´ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯",
        deliveryCode: deliveryCode
      });
    } catch (error) {
      console.error("Error dispatching logistics order:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø³ÙØ§Ø±Ø´",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get delivered orders (logistics dispatched and delivered orders) - Only for logistics and super admin
  app.get("/api/delivered/orders", requireAuth, attachUserDepartments, requireDepartment(['logistics', 'super_admin']), async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { orderManagement } = await import("../shared/order-management-schema");
      const { customerOrders } = await import("../shared/customer-schema");
      const { orderItems } = await import("../shared/shop-schema");
      const { crmCustomers } = await import("../shared/schema");
      const { eq, inArray } = await import("drizzle-orm");

      // Get orders that are dispatched or delivered
      const orders = await db
        .select({
          id: orderManagement.id,
          customerOrderId: orderManagement.customerOrderId,
          currentStatus: orderManagement.currentStatus,
          deliveryCode: orderManagement.deliveryCode,
          trackingNumber: orderManagement.trackingNumber,
          deliveryPersonName: orderManagement.deliveryPersonName,
          deliveryPersonPhone: orderManagement.deliveryPersonPhone,
          estimatedDeliveryDate: orderManagement.estimatedDeliveryDate,
          actualDeliveryDate: orderManagement.actualDeliveryDate,
          logisticsProcessedAt: orderManagement.logisticsProcessedAt,
          orderTotal: customerOrders.totalAmount,
          orderDate: customerOrders.createdAt,
          customerName: crmCustomers.firstName,
          customerLastName: crmCustomers.lastName,
          customerEmail: crmCustomers.email,
          customerPhone: crmCustomers.phone,
          customerAddress: crmCustomers.address,
        })
        .from(orderManagement)
        .innerJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
        .innerJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
        .where(inArray(orderManagement.currentStatus, ['logistics_dispatched', 'delivered']))
        .orderBy(orderManagement.logisticsProcessedAt); // Most recent dispatched first

      // Get order items for each order
      const ordersWithItems = await Promise.all(orders.map(async (order) => {
        const items = await db
          .select()
          .from(orderItems)
          .where(eq(orderItems.orderId, order.customerOrderId));

        return {
          ...order,
          customerName: `${order.customerName} ${order.customerLastName}`,
          orderItems: items
        };
      }));

      res.json({ success: true, orders: ordersWithItems });
    } catch (error) {
      console.error("Error fetching delivered orders:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // INTERNAL TRACKING SYSTEM ENDPOINTS
  // =============================================================================

  // Get tracking codes for a specific order
  app.get("/api/tracking/order/:orderId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const orderId = parseInt(req.params.orderId);

      const trackingCodes = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.orderId, orderId))
        .orderBy(internalTrackingCodes.createdAt);

      res.json({ success: true, trackingCodes });
    } catch (error) {
      console.error("Error fetching tracking codes:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯Ù‡Ø§ÛŒ Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Generate internal tracking codes for order items
  app.post("/api/tracking/generate/:orderId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes } = await import("../shared/internal-tracking-schema");
      const { generateInternalBarcode } = await import("../shared/internal-tracking-schema");
      const { shopProducts, orderItems } = await import("../shared/shop-schema");
      const { eq } = await import("drizzle-orm");

      const orderId = parseInt(req.params.orderId);
      const adminId = req.session.adminId;

      // Get order items
      const items = await db
        .select({
          id: orderItems.id,
          productId: orderItems.productId,
          productName: orderItems.productName,
          productSku: orderItems.productSku,
          quantity: orderItems.quantity,
        })
        .from(orderItems)
        .where(eq(orderItems.orderId, orderId));

      if (items.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Generate tracking codes for each item
      const generatedCodes = [];
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const internalBarcode = generateInternalBarcode(orderId, i + 1);

        const trackingCode = await db
          .insert(internalTrackingCodes)
          .values({
            orderId: orderId,
            orderItemId: item.id,
            internalBarcode: internalBarcode,
            productName: item.productName,
            productSku: item.productSku || undefined,
            quantity: item.quantity,
            currentLocation: 'warehouse_pending',
            currentDepartment: 'finance',
            assignedToFinance: adminId,
          })
          .returning();

        generatedCodes.push(trackingCode[0]);
      }

      res.json({ 
        success: true, 
        message: `${generatedCodes.length} Ú©Ø¯ Ø±Ø¯ÛŒØ§Ø¨ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯`,
        trackingCodes: generatedCodes
      });
    } catch (error) {
      console.error("Error generating tracking codes:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø¯Ù‡Ø§ÛŒ Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update tracking code status
  app.post("/api/tracking/:barcode/update", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes, trackingHistory } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const barcode = req.params.barcode;
      const { location, department, notes, warehouseLocation } = req.body;
      const adminId = req.session.adminId;

      // Get current tracking code
      const currentCode = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.internalBarcode, barcode))
        .limit(1);

      if (currentCode.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ú©Ø¯ Ø±Ø¯ÛŒØ§Ø¨ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const current = currentCode[0];

      // Prepare update data
      const updateData: any = {
        currentLocation: location,
        currentDepartment: department,
      };

      // Add warehouse location if provided
      if (warehouseLocation) {
        updateData.warehouseLocation = warehouseLocation;
      }

      // Set timestamps based on department
      const now = new Date();
      if (department === 'finance') {
        updateData.financeProcessedAt = now;
        updateData.assignedToFinance = adminId;
      } else if (department === 'warehouse') {
        updateData.warehouseProcessedAt = now;
        updateData.assignedToWarehouse = adminId;
      } else if (department === 'logistics') {
        updateData.logisticsProcessedAt = now;
        updateData.assignedToLogistics = adminId;
      }

      // Update tracking code
      await db
        .update(internalTrackingCodes)
        .set(updateData)
        .where(eq(internalTrackingCodes.internalBarcode, barcode));

      // Add to tracking history
      await db.insert(trackingHistory).values({
        trackingCodeId: current.id,
        internalBarcode: barcode,
        fromLocation: current.currentLocation,
        toLocation: location,
        fromDepartment: current.currentDepartment,
        toDepartment: department,
        changedBy: adminId,
        changedByName: "Admin User", // TODO: Get actual admin name
        department: department,
        notes: notes,
      });

      res.json({ 
        success: true, 
        message: "ÙˆØ¶Ø¹ÛŒØª Ø±Ø¯ÛŒØ§Ø¨ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error updating tracking code:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Scan barcode
  app.post("/api/tracking/:barcode/scan", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { internalTrackingCodes, barcodeScanLogs } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const barcode = req.params.barcode;
      const { scanType, scanLocation, notes } = req.body;
      const adminId = req.session.adminId;

      // Check if barcode exists
      const trackingCode = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.internalBarcode, barcode))
        .limit(1);

      const scanResult = trackingCode.length > 0 ? 'success' : 'not_found';

      // Log scan
      await db.insert(barcodeScanLogs).values({
        internalBarcode: barcode,
        scannedBy: adminId,
        scannedByName: "Admin User", // TODO: Get actual admin name
        department: scanType.includes('warehouse') ? 'warehouse' : 
                   scanType.includes('logistics') ? 'logistics' : 'finance',
        scanType: scanType,
        scanLocation: scanLocation,
        scanResult: scanResult,
        notes: notes,
      });

      if (scanResult === 'not_found') {
        return res.status(404).json({
          success: false,
          message: "Ø¨Ø§Ø±Ú©Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯",
          scanResult: scanResult
        });
      }

      res.json({ 
        success: true, 
        message: "Ø¨Ø§Ø±Ú©Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø³Ú©Ù† Ø´Ø¯",
        trackingCode: trackingCode[0],
        scanResult: scanResult
      });
    } catch (error) {
      console.error("Error scanning barcode:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø³Ú©Ù† Ø¨Ø§Ø±Ú©Ø¯",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get tracking history for a barcode
  app.get("/api/tracking/:barcode/history", requireAuth, async (req: Request, res: Response) => {
    try {
      const { db } = await import("./db");
      const { trackingHistory, internalTrackingCodes } = await import("../shared/internal-tracking-schema");
      const { eq } = await import("drizzle-orm");

      const barcode = req.params.barcode;

      // Get tracking code details
      const trackingCode = await db
        .select()
        .from(internalTrackingCodes)
        .where(eq(internalTrackingCodes.internalBarcode, barcode))
        .limit(1);

      if (trackingCode.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ú©Ø¯ Ø±Ø¯ÛŒØ§Ø¨ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      // Get history
      const history = await db
        .select()
        .from(trackingHistory)
        .where(eq(trackingHistory.internalBarcode, barcode))
        .orderBy(trackingHistory.createdAt);

      res.json({ 
        success: true, 
        trackingCode: trackingCode[0],
        history: history
      });
    } catch (error) {
      console.error("Error fetching tracking history:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø±Ø¯ÛŒØ§Ø¨ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });



  // Inventory Notification Settings API
  app.get("/api/inventory/notification-settings", requireAuth, async (req: Request, res: Response) => {
    try {
      // Return default settings for now - in a real app this would come from database
      const defaultSettings = {
        emailEnabled: true,
        smsEnabled: false,
        managerEmail: 'info@momtazchem.com',
        managerPhone: '+964xxxxxxxxx',
        checkIntervalHours: 1,
        businessHoursOnly: true,
        businessStartHour: 8,
        businessEndHour: 18,
        emergencyThreshold: 0,
        contacts: []
      };

      res.json({ success: true, settings: defaultSettings });
    } catch (error) {
      console.error("Error fetching notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post("/api/inventory/notification-settings", requireAuth, async (req: Request, res: Response) => {
    try {
      // In a real app, this would save to database
      console.log("Inventory notification settings updated:", req.body);
      
      res.json({ 
        success: true, 
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯",
        settings: req.body 
      });
    } catch (error) {
      console.error("Error saving notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  app.post("/api/inventory/test-notification/:type", requireAuth, async (req: Request, res: Response) => {
    try {
      const { type } = req.params;
      
      if (type === 'email') {
        // Test email notification
        console.log("ðŸ“§ Test email notification sent");
        res.json({ 
          success: true, 
          message: "ØªØ³Øª Ø§ÛŒÙ…ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯" 
        });
      } else if (type === 'sms') {
        // SMS notification functionality removed per requirements
        res.json({ 
          success: true, 
          message: "Ù¾ÛŒØ§Ù…Ú© Ø¯Ø± Ø³ÛŒØ³ØªÙ… ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª" 
        });
      } else {
        res.status(400).json({
          success: false,
          message: "Ù†ÙˆØ¹ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
        });
      }
    } catch (error) {
      console.error("Error testing notification:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // =============================================================================
  // CONTENT MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Public endpoint for content items (for footer and public pages)
  app.get("/api/content", async (req: Request, res: Response) => {
    try {
      const { language, section } = req.query;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      let query = db.select().from(contentItems).where(eq(contentItems.isActive, true));
      
      if (language) {
        query = query.where(and(
          eq(contentItems.isActive, true),
          eq(contentItems.language, language as string)
        ));
      }
      
      if (section) {
        if (language) {
          query = query.where(and(
            eq(contentItems.isActive, true),
            eq(contentItems.language, language as string),
            eq(contentItems.section, section as string)
          ));
        } else {
          query = query.where(and(
            eq(contentItems.isActive, true),
            eq(contentItems.section, section as string)
          ));
        }
      }

      const items = await query.orderBy(contentItems.updatedAt);

      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      console.error("Error fetching public content items:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch content items",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get content items by language and section (Admin only)
  app.get("/api/admin/content", requireAuth, async (req: Request, res: Response) => {
    try {
      const { language, section } = req.query;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      let query = db.select().from(contentItems);
      
      if (language) {
        query = query.where(eq(contentItems.language, language as string));
      }
      
      if (section) {
        if (language) {
          query = query.where(and(
            eq(contentItems.language, language as string),
            eq(contentItems.section, section as string)
          ));
        } else {
          query = query.where(eq(contentItems.section, section as string));
        }
      }

      const items = await query.orderBy(contentItems.updatedAt);

      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      console.error("Error fetching content items:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch content items",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Content Management API endpoints
  app.get("/api/content-management/items", requireAuth, async (req: Request, res: Response) => {
    try {
      const { language, section } = req.query;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      let query = db.select().from(contentItems);
      
      if (language) {
        query = query.where(eq(contentItems.language, language as string));
      }
      
      if (section) {
        if (language) {
          query = query.where(and(
            eq(contentItems.language, language as string),
            eq(contentItems.section, section as string)
          ));
        } else {
          query = query.where(eq(contentItems.section, section as string));
        }
      }

      const items = await query.orderBy(contentItems.updatedAt);

      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      console.error("Error fetching content items:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch content items",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Create new content item
  app.post("/api/content-management/items", requireAuth, async (req: Request, res: Response) => {
    try {
      const { key, content, contentType, language, section, isActive } = req.body;
      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");

      const [newItem] = await db
        .insert(contentItems)
        .values({
          key,
          content,
          contentType: contentType || 'text',
          language: language || 'en',
          section: section || 'default',
          isActive: isActive !== undefined ? isActive : true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      res.json({
        success: true,
        data: newItem,
        message: "Content item created successfully"
      });
    } catch (error) {
      console.error("Error creating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update content item
  app.put("/api/content-management/items/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const contentId = parseInt(req.params.id);
      const { key, content, contentType, language, section, isActive } = req.body;

      if (isNaN(contentId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid content ID"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      const [updatedItem] = await db
        .update(contentItems)
        .set({
          key,
          content,
          contentType,
          language,
          section,
          isActive,
          updatedAt: new Date()
        })
        .where(eq(contentItems.id, contentId))
        .returning();

      res.json({
        success: true,
        data: updatedItem,
        message: "Content item updated successfully"
      });
    } catch (error) {
      console.error("Error updating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Delete content item
  app.delete("/api/content-management/items/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const contentId = parseInt(req.params.id);

      if (isNaN(contentId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid content ID"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      await db
        .delete(contentItems)
        .where(eq(contentItems.id, contentId));

      res.json({
        success: true,
        message: "Content item deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get image assets
  app.get("/api/content-management/images", requireAuth, async (req: Request, res: Response) => {
    try {
      const { section } = req.query;
      const { db } = await import("./db");
      const { imageAssets } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      let query = db.select().from(imageAssets);
      
      if (section) {
        query = query.where(eq(imageAssets.section, section as string));
      }

      const images = await query.orderBy(imageAssets.createdAt);

      res.json({
        success: true,
        data: images
      });
    } catch (error) {
      console.error("Error fetching image assets:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch image assets",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update content item
  app.put("/api/admin/content/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const contentId = parseInt(req.params.id);
      const { content, isActive } = req.body;

      if (isNaN(contentId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid content ID"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      const [updatedItem] = await db
        .update(contentItems)
        .set({
          content,
          isActive,
          updatedAt: new Date()
        })
        .where(eq(contentItems.id, contentId))
        .returning();

      res.json({
        success: true,
        data: updatedItem,
        message: "Content updated successfully"
      });
    } catch (error) {
      console.error("Error updating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get image assets by section
  app.get("/api/admin/content/images", requireAuth, async (req: Request, res: Response) => {
    try {
      const { section } = req.query;
      const { db } = await import("./db");
      const { imageAssets } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");

      let query = db.select().from(imageAssets);
      
      if (section) {
        query = query.where(eq(imageAssets.section, section as string));
      }

      const images = await query.orderBy(imageAssets.updatedAt);

      res.json({
        success: true,
        data: images
      });
    } catch (error) {
      console.error("Error fetching image assets:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch image assets",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Upload new image asset
  app.post("/api/admin/content/images/upload", requireAuth, async (req: Request, res: Response) => {
    try {
      const multer = await import("multer");
      const path = await import("path");
      const fs = await import("fs");

      // Configure multer for image uploads
      const storage = multer.default.diskStorage({
        destination: (req, file, cb) => {
          const uploadDir = path.join(process.cwd(), 'uploads', 'content');
          if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
          }
          cb(null, uploadDir);
        },
        filename: (req, file, cb) => {
          const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
          const extension = path.extname(file.originalname);
          cb(null, `content-${uniqueSuffix}${extension}`);
        }
      });

      const upload = multer.default({
        storage,
        fileFilter: (req, file, cb) => {
          if (file.mimetype.startsWith('image/')) {
            cb(null, true);
          } else {
            cb(new Error('Only image files are allowed'));
          }
        },
        limits: {
          fileSize: 5 * 1024 * 1024 // 5MB limit
        }
      }).single('image');

      upload(req, res, async (err) => {
        if (err) {
          return res.status(400).json({
            success: false,
            message: err.message
          });
        }

        if (!req.file) {
          return res.status(400).json({
            success: false,
            message: "No image file uploaded"
          });
        }

        try {
          const { db } = await import("./db");
          const { imageAssets } = await import("../shared/content-schema");

          const { section = 'general', alt = '' } = req.body;
          const imageUrl = `/uploads/content/${req.file.filename}`;

          const [newImage] = await db
            .insert(imageAssets)
            .values({
              filename: req.file.filename,
              originalName: req.file.originalname,
              mimeType: req.file.mimetype,
              size: req.file.size,
              url: imageUrl,
              alt,
              section,
              isActive: true
            })
            .returning();

          res.json({
            success: true,
            data: newImage,
            message: "Image uploaded successfully"
          });
        } catch (dbError) {
          console.error("Error saving image to database:", dbError);
          res.status(500).json({
            success: false,
            message: "Failed to save image information",
            error: dbError instanceof Error ? dbError.message : 'Unknown error'
          });
        }
      });
    } catch (error) {
      console.error("Error setting up image upload:", error);
      res.status(500).json({
        success: false,
        message: "Failed to process image upload",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Delete image asset
  app.delete("/api/admin/content/images/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const imageId = parseInt(req.params.id);

      if (isNaN(imageId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid image ID"
        });
      }

      const { db } = await import("./db");
      const { imageAssets } = await import("../shared/content-schema");
      const { eq } = await import("drizzle-orm");
      const path = await import("path");
      const fs = await import("fs");

      // Get image details before deletion
      const [image] = await db
        .select()
        .from(imageAssets)
        .where(eq(imageAssets.id, imageId))
        .limit(1);

      if (!image) {
        return res.status(404).json({
          success: false,
          message: "Image not found"
        });
      }

      // Delete from database
      await db
        .delete(imageAssets)
        .where(eq(imageAssets.id, imageId));

      // Delete physical file
      const filePath = path.join(process.cwd(), 'uploads', 'content', image.filename);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }

      res.json({
        success: true,
        message: "Image deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting image asset:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete image asset",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Create or update content item
  app.post("/api/admin/content", requireAuth, async (req: Request, res: Response) => {
    try {
      const { key, content, contentType, language, section } = req.body;

      if (!key || !content || !language || !section) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: key, content, language, section"
        });
      }

      const { db } = await import("./db");
      const { contentItems } = await import("../shared/content-schema");
      const { eq, and } = await import("drizzle-orm");

      // Check if content item already exists
      const [existingItem] = await db
        .select()
        .from(contentItems)
        .where(and(
          eq(contentItems.key, key),
          eq(contentItems.language, language),
          eq(contentItems.section, section)
        ))
        .limit(1);

      let result;
      
      if (existingItem) {
        // Update existing item
        [result] = await db
          .update(contentItems)
          .set({
            content,
            contentType: contentType || 'text',
            updatedAt: new Date()
          })
          .where(eq(contentItems.id, existingItem.id))
          .returning();
      } else {
        // Create new item
        [result] = await db
          .insert(contentItems)
          .values({
            key,
            content,
            contentType: contentType || 'text',
            language,
            section,
            isActive: true
          })
          .returning();
      }

      res.json({
        success: true,
        data: result,
        message: existingItem ? "Content updated successfully" : "Content created successfully"
      });
    } catch (error) {
      console.error("Error creating/updating content item:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create/update content item",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // ===== SECURITY MANAGEMENT ROUTES =====
  
  // Import security storage
  const { securityStorage } = await import("./security-storage");

  // Security middleware to log events
  const logSecurityEvent = async (req: Request, eventType: string, severity: string = "info") => {
    try {
      const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
      const userAgent = req.get('User-Agent');
      const userId = req.session?.adminId || req.session?.customerId;
      const username = req.session?.adminId ? 'admin' : 'customer';

      await securityStorage.logSecurityEvent({
        eventType,
        severity,
        description: `${eventType} from ${ipAddress}`,
        ipAddress,
        userAgent,
        userId,
        username,
        endpoint: req.path,
        method: req.method,
        statusCode: 200
      });
    } catch (error) {
      console.error('Failed to log security event:', error);
    }
  };

  // Security Management Routes (Simplified System)
  app.get("/api/security/metrics", requireAuth, async (req: Request, res: Response) => {
    try {
      const { getSecurityMetrics } = await import('./security-check');
      const metrics = await getSecurityMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching security metrics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch security metrics" });
    }
  });

  app.post("/api/security/comprehensive-check", requireAuth, async (req: Request, res: Response) => {
    try {
      const { performComprehensiveSecurityCheck } = await import('./security-check');
      const result = await performComprehensiveSecurityCheck();
      res.json(result);
    } catch (error) {
      console.error("Error performing security check:", error);
      res.status(500).json({ success: false, message: "Failed to perform security check" });
    }
  });

  app.post("/api/security/scan", requireAuth, async (req: Request, res: Response) => {
    try {
      const { performComprehensiveSecurityCheck } = await import('./security-check');
      const result = await performComprehensiveSecurityCheck();
      res.json({ 
        success: true, 
        vulnerabilities: result.issues.length,
        threatLevel: result.threatLevel,
        systemHealth: result.systemHealth 
      });
    } catch (error) {
      console.error("Error performing security scan:", error);
      res.status(500).json({ success: false, message: "Failed to perform security scan" });
    }
  });

  // Security Settings API endpoints
  app.get("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const { securitySettings } = await import('@shared/schema');
      const settings = await db.select().from(securitySettings);
      
      // Convert to key-value format for frontend
      const settingsMap = settings.reduce((acc: any, setting) => {
        acc[setting.setting] = {
          value: setting.value,
          category: setting.category,
          isActive: setting.isActive
        };
        return acc;
      }, {});
      
      res.json({
        success: true,
        settings: settingsMap
      });
    } catch (error) {
      console.error("Error fetching security settings:", error);
      res.status(500).json({ success: false, message: "Failed to fetch security settings" });
    }
  });

  app.post("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const { securitySettings } = await import('@shared/schema');
      const { settings } = req.body;
      const adminId = req.session?.adminId;
      
      if (!settings || typeof settings !== 'object') {
        return res.status(400).json({
          success: false,
          message: "Settings object is required"
        });
      }

      // Update or insert each setting
      for (const [key, config] of Object.entries(settings as any)) {
        const { value, category } = config;
        
        await db.insert(securitySettings)
          .values({
            setting: key,
            value: String(value),
            category: category || 'general',
            updatedBy: adminId,
            updatedAt: new Date()
          })
          .onConflictDoUpdate({
            target: securitySettings.setting,
            set: {
              value: String(value),
              updatedBy: adminId,
              updatedAt: new Date()
            }
          });
      }

      // Log security event
      await logSecurityEvent(req, 'security_settings_updated', {
        settingsCount: Object.keys(settings).length,
        adminId
      });

      res.json({
        success: true,
        message: "Security settings saved successfully"
      });
    } catch (error) {
      console.error("Error saving security settings:", error);
      res.status(500).json({ success: false, message: "Failed to save security settings" });
    }
  });

  // Security logs (simplified)
  app.get("/api/security/logs", requireAuth, async (req: Request, res: Response) => {
    try {
      // Return sample security logs for demonstration
      const logs = [
        {
          id: 1,
          timestamp: new Date().toISOString(),
          event: 'Admin login successful',
          severity: 'info',
          ipAddress: req.ip || 'unknown',
          details: 'Administrative user accessed the security management system'
        },
        {
          id: 2,
          timestamp: new Date(Date.now() - 3600000).toISOString(),
          event: 'Security scan completed',
          severity: 'info',
          ipAddress: 'system',
          details: 'Automated security scan completed successfully - no issues found'
        },
        {
          id: 3,
          timestamp: new Date(Date.now() - 7200000).toISOString(),
          event: 'Database connection secured',
          severity: 'info',
          ipAddress: 'system',
          details: 'Database connection established with SSL encryption'
        },
        {
          id: 4,
          timestamp: new Date(Date.now() - 10800000).toISOString(),
          event: 'Session security check',
          severity: 'info',
          ipAddress: 'system',
          details: 'Session management security validation completed'
        }
      ];
      res.json(logs);
    } catch (error) {
      console.error("Error fetching security logs:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch security logs"
      });
    }
  });

  // IP access control
  app.get("/api/security/ip-access", requireAuth, async (req: Request, res: Response) => {
    try {
      await logSecurityEvent(req, 'ip_access_view');
      const { type } = req.query;
      const ipList = await securityStorage.getIpAccessList(type as 'blacklist' | 'whitelist');
      res.json(ipList);
    } catch (error) {
      console.error("Error fetching IP access list:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch IP access list"
      });
    }
  });

  app.post("/api/security/ip-access", requireAuth, async (req: Request, res: Response) => {
    try {
      const { ipAddress, type, reason, category } = req.body;
      
      if (!ipAddress || !type || !category) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: ipAddress, type, category"
        });
      }

      const adminId = req.session?.adminId;
      const ipData = {
        ipAddress,
        type,
        reason,
        category,
        addedBy: adminId
      };

      const result = await securityStorage.addIpToAccessControl(ipData);
      
      await logSecurityEvent(req, `ip_${type}_added`, 'medium');
      
      res.json({
        success: true,
        data: result,
        message: `IP address added to ${type}`
      });
    } catch (error) {
      console.error("Error adding IP to access control:", error);
      res.status(500).json({
        success: false,
        message: "Failed to add IP to access control"
      });
    }
  });

  app.delete("/api/security/ip-access/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid IP access rule ID"
        });
      }

      await securityStorage.removeIpFromAccessControl(id);
      await logSecurityEvent(req, 'ip_access_removed', 'medium');
      
      res.json({
        success: true,
        message: "IP access rule removed"
      });
    } catch (error) {
      console.error("Error removing IP access rule:", error);
      res.status(500).json({
        success: false,
        message: "Failed to remove IP access rule"
      });
    }
  });

  // Security scans
  app.post("/api/security/scan", requireAuth, async (req: Request, res: Response) => {
    try {
      const { scanType } = req.body;
      
      if (!scanType) {
        return res.status(400).json({
          success: false,
          message: "Scan type is required"
        });
      }

      const adminId = req.session?.adminId;
      
      // Create security scan record
      const scanData = {
        scanType,
        status: 'running' as const,
        initiatedBy: adminId,
        automated: false
      };

      const scan = await securityStorage.createSecurityScan(scanData);
      
      // Simulate scan process (in real implementation, this would be async)
      setTimeout(async () => {
        try {
          const mockResults = {
            vulnerability: {
              criticalIssues: Math.floor(Math.random() * 3),
              highIssues: Math.floor(Math.random() * 5),
              mediumIssues: Math.floor(Math.random() * 10),
              lowIssues: Math.floor(Math.random() * 15),
              results: {
                findings: [
                  "No critical vulnerabilities detected",
                  "Some outdated dependencies found",
                  "Basic security headers present"
                ]
              }
            },
            file_integrity: {
              criticalIssues: 0,
              highIssues: 0,
              mediumIssues: Math.floor(Math.random() * 2),
              lowIssues: Math.floor(Math.random() * 5),
              results: {
                findings: [
                  "All core files integrity verified",
                  "No unauthorized modifications detected"
                ]
              }
            },
            permission_audit: {
              criticalIssues: Math.floor(Math.random() * 2),
              highIssues: Math.floor(Math.random() * 3),
              mediumIssues: Math.floor(Math.random() * 7),
              lowIssues: Math.floor(Math.random() * 10),
              results: {
                findings: [
                  "File permissions reviewed",
                  "Database access controls verified",
                  "Admin privileges properly configured"
                ]
              }
            }
          };

          const scanResults = mockResults[scanType as keyof typeof mockResults] || mockResults.vulnerability;
          
          await securityStorage.updateSecurityScan(scan.id, {
            status: 'completed',
            completedAt: new Date(),
            ...scanResults
          });
        } catch (error) {
          console.error('Error completing security scan:', error);
          await securityStorage.updateSecurityScan(scan.id, {
            status: 'failed',
            completedAt: new Date()
          });
        }
      }, 5000); // Complete scan after 5 seconds

      await logSecurityEvent(req, 'security_scan_started', 'medium');
      
      res.json({
        success: true,
        data: scan,
        message: `${scanType} scan started`
      });
    } catch (error) {
      console.error("Error starting security scan:", error);
      res.status(500).json({
        success: false,
        message: "Failed to start security scan"
      });
    }
  });

  // Security settings
  app.get("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      await logSecurityEvent(req, 'security_settings_view');
      const { category } = req.query;
      
      let settings;
      if (category) {
        settings = await securityStorage.getSecuritySettingsByCategory(category as string);
      } else {
        settings = await securityStorage.getAllSecuritySettings();
      }
      
      res.json(settings);
    } catch (error) {
      console.error("Error fetching security settings:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch security settings"
      });
    }
  });

  app.post("/api/security/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const { setting, value, category, description } = req.body;
      
      if (!setting || !value || !category) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: setting, value, category"
        });
      }

      const adminId = req.session?.adminId;
      const result = await securityStorage.updateSecuritySetting(setting, value, adminId || 0);
      
      await logSecurityEvent(req, 'security_setting_updated', 'medium');
      
      res.json({
        success: true,
        data: result,
        message: "Security setting updated"
      });
    } catch (error) {
      console.error("Error updating security setting:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update security setting"
      });
    }
  });

  // Security alerts
  app.get("/api/security/alerts", requireAuth, async (req: Request, res: Response) => {
    try {
      await logSecurityEvent(req, 'security_alerts_view');
      const { severity, status, limit, offset } = req.query;
      
      const filters: any = {};
      if (severity) filters.severity = severity as string;
      if (status) filters.status = status as string;
      if (limit) filters.limit = parseInt(limit as string);
      if (offset) filters.offset = parseInt(offset as string);

      const alerts = await securityStorage.getSecurityAlerts(filters);
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching security alerts:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch security alerts"
      });
    }
  });

  app.patch("/api/security/alerts/:id/resolve", requireAuth, async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      const { resolution } = req.body;
      
      if (isNaN(id) || !resolution) {
        return res.status(400).json({
          success: false,
          message: "Invalid alert ID or missing resolution"
        });
      }

      const adminId = req.session?.adminId || 0;
      const alert = await securityStorage.resolveSecurityAlert(id, resolution, adminId);
      
      await logSecurityEvent(req, 'security_alert_resolved', 'low');
      
      res.json({
        success: true,
        data: alert,
        message: "Security alert resolved"
      });
    } catch (error) {
      console.error("Error resolving security alert:", error);
      res.status(500).json({
        success: false,
        message: "Failed to resolve security alert"
      });
    }
  });

  // Create some default security settings on first access
  app.post("/api/security/initialize", requireAuth, async (req: Request, res: Response) => {
    try {
      const adminId = req.session?.adminId || 0;
      
      const defaultSettings = [
        { setting: 'max_login_attempts', value: '5', category: 'auth', description: 'Maximum failed login attempts before lockout' },
        { setting: 'session_timeout', value: '3600', category: 'auth', description: 'Session timeout in seconds' },
        { setting: 'password_min_length', value: '8', category: 'auth', description: 'Minimum password length' },
        { setting: 'file_upload_max_size', value: '5242880', category: 'upload', description: 'Maximum file upload size in bytes' },
        { setting: 'allowed_file_types', value: 'jpg,jpeg,png,pdf,doc,docx', category: 'upload', description: 'Allowed file upload types' },
        { setting: 'ip_whitelist_enabled', value: 'false', category: 'access', description: 'Enable IP whitelist protection' },
        { setting: 'auto_scan_enabled', value: 'true', category: 'monitoring', description: 'Enable automatic security scans' },
        { setting: 'alert_email', value: 'info@momtazchem.com', category: 'monitoring', description: 'Email for security alerts' }
      ];

      for (const setting of defaultSettings) {
        try {
          await securityStorage.updateSecuritySetting(setting.setting, setting.value, adminId);
        } catch (error) {
          console.error(`Error creating setting ${setting.setting}:`, error);
        }
      }

      await logSecurityEvent(req, 'security_system_initialized', 'medium');
      
      res.json({
        success: true,
        message: "Security system initialized with default settings"
      });
    } catch (error) {
      console.error("Error initializing security system:", error);
      res.status(500).json({
        success: false,
        message: "Failed to initialize security system"
      });
    }
  });

  // AI Settings endpoints
  app.post("/api/ai/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const settings = req.body;
      
      // Save AI settings to environment or database
      // For now, we'll just return success
      console.log("AI Settings saved:", settings);
      
      res.json({ 
        success: true, 
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª AI Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯",
        settings 
      });
    } catch (error) {
      console.error("Error saving AI settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª AI"
      });
    }
  });

  app.post("/api/ai/test-connection", requireAuth, async (req: Request, res: Response) => {
    try {
      // Test AI connection
      const { OpenAI } = await import("openai");
      
      if (!process.env.OPENAI_API_KEY) {
        return res.status(400).json({
          success: false,
          message: "Ú©Ù„ÛŒØ¯ API OpenAI ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª"
        });
      }

      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });

      // Simple test call
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: "Test connection" }],
        max_tokens: 10
      });

      res.json({
        success: true,
        message: "Ø§ØªØµØ§Ù„ Ù…ÙˆÙÙ‚",
        model: "gpt-4o",
        response: completion.choices[0]?.message?.content
      });
    } catch (error) {
      console.error("Error testing AI connection:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ø²Ù…Ø§ÛŒØ´ Ø§ØªØµØ§Ù„ AI"
      });
    }
  });

  // Customer Communication API Routes
  const { customerCommunicationStorage } = await import("./customer-communication-storage");

  // Send message to customer
  app.post("/api/customer-communications/send", requireAuth, async (req: Request, res: Response) => {
    try {
      const { categoryId, customerEmail, customerName, subject, message, messageType = "outbound" } = req.body;
      const adminId = req.session.adminId;
      
      if (!categoryId || !customerEmail || !subject || !message) {
        return res.status(400).json({
          success: false,
          message: "ØªÙ…Ø§Ù… ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø¨Ø§ÛŒØ¯ Ù¾Ø± Ø´ÙˆÙ†Ø¯"
        });
      }

      const communication = await customerCommunicationStorage.sendMessage({
        categoryId,
        customerEmail,
        customerName: customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ",
        subject,
        message,
        messageType,
        sentBy: adminId,
        status: "sent"
      });

      res.json({
        success: true,
        data: communication,
        message: "Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error sending customer communication:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…"
      });
    }
  });

  // Smart reply suggestion based on product category
  app.post("/api/customer-communications/smart-reply", requireAuth, async (req: Request, res: Response) => {
    try {
      const { customerMessage, productCategory, customerName } = req.body;
      
      if (!customerMessage || !productCategory) {
        return res.status(400).json({
          success: false,
          message: "Ù¾ÛŒØ§Ù… Ù…Ø´ØªØ±ÛŒ Ùˆ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø­ØµÙˆÙ„ Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª"
        });
      }

      // Generate smart reply based on category
      const categoryResponses: Record<string, string> = {
        'fuel-additives': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø³ÙˆØ®Øª Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù… Ù…ØªØ´Ú©Ø±ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª Ù…Ø§ Ø´Ø§Ù…Ù„:\n- Ø§ÙØ²ÙˆØ¯Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨Ù†Ø²ÛŒÙ†\n- Ø§ÙØ²ÙˆØ¯Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ú¯Ø§Ø²ÙˆØ¦ÛŒÙ„\n- Ù¾Ø§Ú©â€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ… Ø³ÙˆØ®Øª\n\nØ¨Ø§ ØªØ´Ú©Ø±,\nØªÛŒÙ… ÙØ±ÙˆØ´ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,
        'water-treatment': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² Ø¹Ù„Ø§Ù‚Ù‡ Ø´Ù…Ø§ Ø¨Ù‡ Ù…Ø­ØµÙˆÙ„Ø§Øª ØªØµÙÛŒÙ‡ Ø¢Ø¨ Ø³Ù¾Ø§Ø³Ú¯Ø²Ø§Ø±ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª ØªØµÙÛŒÙ‡ Ø¢Ø¨ Ù…Ø§:\n- Ù…ÙˆØ§Ø¯ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ ØªØµÙÛŒÙ‡\n- Ú©Ù„Ø±ÛŒÙ† Ùˆ ÙÙ„ÙˆÚ©ÙˆÙ„Ø§Ù†Øª\n- Ø¶Ø¯Ø¹ÙÙˆÙ†ÛŒ Ú©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§\n\nØ¨Ø§ Ø§Ø­ØªØ±Ø§Ù…,\nØªÛŒÙ… ÙÙ†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,
        'paint-solvents': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø±Ù†Ú¯ Ùˆ Ø­Ù„Ø§Ù„â€ŒÙ‡Ø§ ØªØ´Ú©Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª Ù…Ø§:\n- Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ ØµÙ†Ø¹ØªÛŒ\n- Ø­Ù„Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù\n- Ù…ÙˆØ§Ø¯ Ù†Ø§Ø²Ú©â€ŒÚ©Ù†Ù†Ø¯Ù‡\n\nØ¨Ø§ ØªØ´Ú©Ø±,\nØªÛŒÙ… ÙØ±ÙˆØ´ Ø±Ù†Ú¯ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,
        'agricultural-products': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª Ú©Ø´Ø§ÙˆØ±Ø²ÛŒ Ø®Ø±Ø³Ù†Ø¯ÛŒÙ….\n\nÙ…Ø­ØµÙˆÙ„Ø§Øª Ú©Ø´Ø§ÙˆØ±Ø²ÛŒ:\n- Ú©ÙˆØ¯Ù‡Ø§ÛŒ Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ\n- Ø³Ù…ÙˆÙ… Ú©Ø´Ø§ÙˆØ±Ø²ÛŒ\n- ØªÙ†Ø¸ÛŒÙ…â€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ø´Ø¯\n\nØ¨Ø§ Ø§Ø­ØªØ±Ø§Ù…,\nØªÛŒÙ… Ú©Ø´Ø§ÙˆØ±Ø²ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`,
        'default': `Ø³Ù„Ø§Ù… ${customerName || "Ù…Ø´ØªØ±ÛŒ Ú¯Ø±Ø§Ù…ÛŒ"}ØŒ\n\nØ§Ø² ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù… Ù…ØªØ´Ú©Ø±ÛŒÙ….\n\nÙ…Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ø­ØµÙˆÙ„Ø§Øª Ø´ÛŒÙ…ÛŒØ§ÛŒÛŒ Ù‡Ø³ØªÛŒÙ….\n\nØ¨Ø§ ØªØ´Ú©Ø±,\nØªÛŒÙ… Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù…ÙˆÙ…ØªØ§Ø² Ú©Ù…`
      };

      const smartReply = categoryResponses[productCategory] || categoryResponses.default;

      res.json({
        success: true,
        data: {
          suggestedReply: smartReply,
          category: productCategory,
          customerMessage
        }
      });
    } catch (error) {
      console.error("Error generating smart reply:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù¾Ø§Ø³Ø® Ù‡ÙˆØ´Ù…Ù†Ø¯"
      });
    }
  });

  // Get recent communications
  app.get("/api/customer-communications/recent", requireAuth, async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const communications = await customerCommunicationStorage.getRecentCommunications(limit);

      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching recent communications:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª Ø§Ø®ÛŒØ±"
      });
    }
  });

  // Get communication statistics
  app.get("/api/customer-communications/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const categoryId = req.query.categoryId ? parseInt(req.query.categoryId as string) : undefined;
      const stats = await customerCommunicationStorage.getCommunicationStats(categoryId);

      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching communication stats:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª"
      });
    }
  });

  // Search communications
  app.get("/api/customer-communications/search", requireAuth, async (req: Request, res: Response) => {
    try {
      const { q } = req.query;
      if (!q) {
        return res.status(400).json({
          success: false,
          message: "Ù¾Ø§Ø±Ø§Ù…ØªØ± Ø¬Ø³ØªØ¬Ùˆ Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª"
        });
      }

      const communications = await customerCommunicationStorage.searchCommunications(q as string);

      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error searching communications:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬Ùˆ Ø§Ø±ØªØ¨Ø§Ø·Ø§Øª"
      });
    }
  });

  // Mark communication as read
  app.patch("/api/customer-communications/:id/read", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.id);
      await customerCommunicationStorage.markAsRead(messageId);

      res.json({
        success: true,
        message: "Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ø¯"
      });
    } catch (error) {
      console.error("Error marking message as read:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù¾ÛŒØ§Ù…"
      });
    }
  });

  // Get communications by category
  app.get("/api/customer-communications/category/:categoryId", requireAuth, async (req: Request, res: Response) => {
    try {
      const categoryId = parseInt(req.params.categoryId);
      const communications = await customerCommunicationStorage.getCommunicationsByCategory(categoryId);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch communications"
      });
    }
  });

  // Get communications by customer
  app.get("/api/customer-communications/customer/:email", requireAuth, async (req: Request, res: Response) => {
    try {
      const email = req.params.email;
      const communications = await customerCommunicationStorage.getCommunicationsByCustomer(email);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching customer communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch customer communications"
      });
    }
  });

  // Get communication thread
  app.get("/api/customer-communications/thread/:messageId", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      const thread = await customerCommunicationStorage.getCommunicationThread(messageId);
      
      res.json({
        success: true,
        data: thread
      });
    } catch (error) {
      console.error("Error fetching communication thread:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch communication thread"
      });
    }
  });

  // Mark message as read
  app.put("/api/customer-communications/:messageId/read", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      await customerCommunicationStorage.markAsRead(messageId);
      
      res.json({
        success: true,
        message: "Message marked as read"
      });
    } catch (error) {
      console.error("Error marking message as read:", error);
      res.status(500).json({
        success: false,
        message: "Failed to mark message as read"
      });
    }
  });

  // Mark message as replied
  app.put("/api/customer-communications/:messageId/replied", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      await customerCommunicationStorage.markAsReplied(messageId);
      
      res.json({
        success: true,
        message: "Message marked as replied"
      });
    } catch (error) {
      console.error("Error marking message as replied:", error);
      res.status(500).json({
        success: false,
        message: "Failed to mark message as replied"
      });
    }
  });

  // Get recent communications
  app.get("/api/customer-communications/recent", requireAuth, async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const communications = await customerCommunicationStorage.getRecentCommunications(limit);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error fetching recent communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch recent communications"
      });
    }
  });

  // Get communication stats
  app.get("/api/customer-communications/stats", requireAuth, async (req: Request, res: Response) => {
    try {
      const categoryId = req.query.categoryId ? parseInt(req.query.categoryId as string) : undefined;
      const stats = await customerCommunicationStorage.getCommunicationStats(categoryId);
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching communication stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch communication stats"
      });
    }
  });

  // Search communications
  app.get("/api/customer-communications/search", requireAuth, async (req: Request, res: Response) => {
    try {
      const searchTerm = req.query.q as string;
      if (!searchTerm) {
        return res.status(400).json({
          success: false,
          message: "Search term is required"
        });
      }

      const communications = await customerCommunicationStorage.searchCommunications(searchTerm);
      
      res.json({
        success: true,
        data: communications
      });
    } catch (error) {
      console.error("Error searching communications:", error);
      res.status(500).json({
        success: false,
        message: "Failed to search communications"
      });
    }
  });

  // Update communication status
  app.put("/api/customer-communications/:messageId/status", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      const { status } = req.body;
      
      if (!status) {
        return res.status(400).json({
          success: false,
          message: "Status is required"
        });
      }

      await customerCommunicationStorage.updateStatus(messageId, status);
      
      res.json({
        success: true,
        message: "Status updated successfully"
      });
    } catch (error) {
      console.error("Error updating status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update status"
      });
    }
  });

  // Delete communication
  app.delete("/api/customer-communications/:messageId", requireAuth, async (req: Request, res: Response) => {
    try {
      const messageId = parseInt(req.params.messageId);
      await customerCommunicationStorage.deleteCommunication(messageId);
      
      res.json({
        success: true,
        message: "Communication deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting communication:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete communication"
      });
    }
  });

  // Get shipping rates for customer checkout
  app.get("/api/shipping/rates", async (req, res) => {
    try {
      const { city, totalWeight } = req.query;

      const rates = await orderManagementStorage.getShippingRates({
        cityName: city as string,
        isActive: true
      });

      // Calculate shipping costs based on rates and order details
      const calculatedRates = rates.map(rate => {
        let shippingCost = parseFloat(rate.basePrice || '0');
        
        if (totalWeight && rate.pricePerKg) {
          const weight = parseFloat(totalWeight as string);
          shippingCost += weight * parseFloat(rate.pricePerKg);
        }

        return {
          id: rate.id,
          deliveryMethod: rate.deliveryMethod,
          transportationType: rate.transportationType,
          description: rate.description,
          estimatedDays: rate.estimatedDays,
          trackingAvailable: rate.trackingAvailable,
          insuranceAvailable: rate.insuranceAvailable,
          shippingCost: shippingCost,
          basePrice: rate.basePrice,
          pricePerKg: rate.pricePerKg,
          freeShippingThreshold: rate.freeShippingThreshold
        };
      });

      res.json({
        success: true,
        data: calculatedRates
      });
    } catch (error) {
      console.error("Error fetching shipping rates:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch shipping rates"
      });
    }
  });

  // Calculate shipping cost for specific delivery method
  app.post("/api/shipping/calculate", async (req, res) => {
    try {
      const { deliveryMethod, city, totalWeight, orderValue } = req.body;

      const rate = await orderManagementStorage.getShippingRateByMethod(deliveryMethod, city);
      
      if (!rate) {
        return res.status(404).json({
          success: false,
          message: "Shipping method not available for your location"
        });
      }

      let shippingCost = parseFloat(rate.basePrice || '0');
      
      if (totalWeight && rate.pricePerKg) {
        shippingCost += totalWeight * parseFloat(rate.pricePerKg);
      }

      // Check for free shipping threshold
      if (rate.freeShippingThreshold && orderValue >= parseFloat(rate.freeShippingThreshold)) {
        shippingCost = 0;
      }

      res.json({
        success: true,
        data: {
          deliveryMethod: rate.deliveryMethod,
          shippingCost,
          isFreeShipping: shippingCost === 0,
          estimatedDays: rate.estimatedDays,
          trackingAvailable: rate.trackingAvailable
        }
      });
    } catch (error) {
      console.error("Error calculating shipping cost:", error);
      res.status(500).json({
        success: false,
        message: "Failed to calculate shipping cost"
      });
    }
  });

  // =============================================================================
  // PRODUCT REVIEWS & RATINGS ENDPOINTS - Ù†Ø¸Ø±Ø³Ù†Ø¬ÛŒ Ùˆ Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª
  // =============================================================================

  // Get all product stats for shop display
  app.get("/api/shop/product-stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          product_id,
          total_reviews,
          average_rating
        FROM product_stats
        WHERE total_reviews > 0
      `);

      const statsMap = {};
      result.rows.forEach(row => {
        statsMap[row.product_id] = {
          totalReviews: row.total_reviews,
          averageRating: parseFloat(row.average_rating)
        };
      });

      res.json(statsMap);
    } catch (error) {
      console.error("Error fetching product stats:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get reviews for a specific product
  app.get("/api/products/:id/reviews", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }

      const { pool } = await import('./db');
      
      // Get reviews with customer names
      const reviewsResult = await pool.query(`
        SELECT pr.*, ps.average_rating, ps.total_reviews
        FROM product_reviews pr
        LEFT JOIN product_stats ps ON pr.product_id = ps.product_id
        WHERE pr.product_id = $1 AND pr.is_approved = true
        ORDER BY pr.created_at DESC
      `, [productId]);

      // Get rating distribution
      const statsResult = await pool.query(`
        SELECT rating_distribution, average_rating, total_reviews
        FROM product_stats 
        WHERE product_id = $1
      `, [productId]);

      const reviews = reviewsResult.rows.map((row: any) => ({
        id: row.id,
        productId: row.product_id,
        customerId: row.customer_id,
        customerName: row.customer_name,
        rating: row.rating,
        title: row.title,
        review: row.review,
        pros: row.pros,
        cons: row.cons,
        isVerifiedPurchase: row.is_verified_purchase,
        helpfulVotes: row.helpful_votes,
        notHelpfulVotes: row.not_helpful_votes,
        adminResponse: row.admin_response,
        adminResponseDate: row.admin_response_date,
        createdAt: row.created_at
      }));

      const stats = statsResult.rows[0] || {
        rating_distribution: {},
        average_rating: "0",
        total_reviews: 0
      };

      res.json({
        success: true,
        data: {
          reviews,
          stats: {
            averageRating: parseFloat(stats.average_rating),
            totalReviews: stats.total_reviews,
            ratingDistribution: stats.rating_distribution || {}
          }
        }
      });
    } catch (error) {
      console.error("Error fetching product reviews:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Submit a new review (authenticated customers only)
  app.post("/api/products/:id/reviews", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }

      // Check if user is authenticated
      const customerId = req.session.customerId;
      if (!customerId) {
        return res.status(401).json({ 
          success: false, 
          message: "Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª Ù†Ø¸Ø± Ø§Ø¨ØªØ¯Ø§ ÙˆØ§Ø±Ø¯ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø®ÙˆØ¯ Ø´ÙˆÛŒØ¯" 
        });
      }

      const { rating, title, review, comment, pros, cons } = req.body;
      
      // Handle both 'review' and 'comment' field names from frontend
      const reviewText = review || comment;
      
      // Validation
      if (!rating || rating < 1 || rating > 5) {
        return res.status(400).json({ success: false, message: "Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 1 ØªØ§ 5 Ø¨Ø§Ø´Ø¯" });
      }
      if (!reviewText || reviewText.trim().length === 0) {
        return res.status(400).json({ success: false, message: "Ù…ØªÙ† Ù†Ø¸Ø± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª" });
      }

      const { pool } = await import('./db');
      
      // Get customer information from both CRM and legacy tables
      let customer = null;
      let customerName = '';
      let customerEmail = '';
      
      // Try CRM customers first
      const crmResult = await pool.query(`
        SELECT first_name, last_name, email FROM crm_customers WHERE id = $1
      `, [customerId]);
      
      if (crmResult.rows.length > 0) {
        customer = crmResult.rows[0];
        customerName = `${customer.first_name} ${customer.last_name}`;
        customerEmail = customer.email;
      } else {
        // Fallback to legacy customers table
        const legacyResult = await pool.query(`
          SELECT first_name, last_name, email FROM customers WHERE id = $1
        `, [customerId]);
        
        if (legacyResult.rows.length > 0) {
          customer = legacyResult.rows[0];
          customerName = `${customer.first_name} ${customer.last_name}`;
          customerEmail = customer.email;
        }
      }
      
      if (!customer) {
        return res.status(400).json({ success: false, message: "Customer not found" });
      }
      
      // Check if customer already reviewed this product
      const existingReview = await pool.query(`
        SELECT id FROM product_reviews 
        WHERE product_id = $1 AND customer_id = $2
      `, [productId, customerId]);
      
      if (existingReview.rows.length > 0) {
        return res.status(400).json({ 
          success: false, 
          message: "Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ Ø±ÙˆÛŒ Ø§ÛŒÙ† Ù…Ø­ØµÙˆÙ„ Ù†Ø¸Ø± Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒØ¯" 
        });
      }

      // Check if customer has purchased this product (for verified purchase)
      let isVerifiedPurchase = false;
      const purchaseCheck = await pool.query(`
        SELECT o.id FROM orders o
        JOIN order_items oi ON o.id = oi.order_id
        WHERE o.customer_id = $1 AND oi.product_id = $2 AND o.payment_status = 'paid'
      `, [customerId, productId]);
      
      isVerifiedPurchase = purchaseCheck.rows.length > 0;

      // Insert new review
      const reviewResult = await pool.query(`
        INSERT INTO product_reviews (
          product_id, customer_id, customer_name, customer_email, rating, 
          title, review, pros, cons, is_verified_purchase, is_approved
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING id, created_at
      `, [
        productId, customerId, customerName, customerEmail, rating,
        title || '', reviewText.trim(), JSON.stringify(pros || []), JSON.stringify(cons || []),
        isVerifiedPurchase, true // Auto-approve reviews for better UX
      ]);

      // Update product statistics
      await updateProductStats(productId);

      res.json({
        success: true,
        message: "Ù†Ø¸Ø± Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯",
        data: {
          id: reviewResult.rows[0].id,
          createdAt: reviewResult.rows[0].created_at
        }
      });
    } catch (error) {
      console.error("Error submitting review:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get product statistics including reviews summary
  app.get("/api/products/:id/stats", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }

      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT 
          total_reviews,
          average_rating
        FROM product_stats 
        WHERE product_id = $1
      `, [productId]);

      if (result.rows.length === 0) {
        // Create initial stats record if it doesn't exist
        await pool.query(`
          INSERT INTO product_stats (product_id, total_reviews, average_rating)
          VALUES ($1, 0, 0)
        `, [productId]);
        
        return res.json({
          totalReviews: 0,
          averageRating: 0
        });
      }

      const stats = result.rows[0];
      res.json({
        totalReviews: stats.total_reviews,
        averageRating: parseFloat(stats.average_rating)
      });
    } catch (error) {
      console.error("Error fetching product stats:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get product reviews (Updated version)
  app.get("/api/products/:id/reviews", async (req, res) => {
    try {
      const productId = parseInt(req.params.id);
      if (isNaN(productId)) {
        return res.status(400).json({ success: false, message: "Invalid product ID" });
      }

      const { pool } = await import('./db');
      
      // Get reviews with approved filter
      const reviewsResult = await pool.query(`
        SELECT 
          id,
          product_id,
          customer_id,
          customer_name,
          rating,
          title,
          review,
          comment,
          pros,
          cons,
          is_verified_purchase,
          helpful_votes,
          not_helpful_votes,
          admin_response,
          admin_response_date,
          created_at
        FROM product_reviews 
        WHERE product_id = $1 AND is_approved = true
        ORDER BY created_at DESC
      `, [productId]);

      // Get product stats
      const statsResult = await pool.query(`
        SELECT 
          total_reviews,
          average_rating,
          rating_distribution
        FROM product_stats 
        WHERE product_id = $1
      `, [productId]);

      const reviews = reviewsResult.rows.map(row => ({
        id: row.id,
        productId: row.product_id,
        customerId: row.customer_id,
        customerName: row.customer_name,
        rating: row.rating,
        title: row.title || '',
        review: row.review || row.comment || '', // Use review field first, fallback to comment
        comment: row.review || row.comment || '', // For compatibility
        pros: row.pros || [],
        cons: row.cons || [],
        isVerifiedPurchase: row.is_verified_purchase,
        helpfulVotes: row.helpful_votes,
        notHelpfulVotes: row.not_helpful_votes,
        adminResponse: row.admin_response,
        adminResponseDate: row.admin_response_date,
        createdAt: row.created_at
      }));

      const stats = statsResult.rows[0] || {
        total_reviews: 0,
        average_rating: 0,
        rating_distribution: {}
      };

      res.json({
        success: true,
        data: {
          reviews,
          stats: {
            averageRating: parseFloat(stats.average_rating) || 0,
            totalReviews: parseInt(stats.total_reviews) || 0,
            ratingDistribution: stats.rating_distribution || {}
          }
        }
      });
    } catch (error) {
      console.error("Error fetching product reviews:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });



  // Mark review as helpful/not helpful
  app.post("/api/reviews/:id/helpful", async (req, res) => {
    try {
      const reviewId = parseInt(req.params.id);
      const { isHelpful } = req.body;
      
      if (isNaN(reviewId)) {
        return res.status(400).json({ success: false, message: "Invalid review ID" });
      }
      
      if (typeof isHelpful !== 'boolean') {
        return res.status(400).json({ success: false, message: "isHelpful must be a boolean" });
      }

      const customerId = req.session.customerId || null;
      const customerIp = req.ip;
      
      // Check if user already voted on this review
      const { pool } = await import('./db');
      let existingVote;
      if (customerId) {
        existingVote = await pool.query(`
          SELECT id FROM review_helpfulness 
          WHERE review_id = $1 AND customer_id = $2
        `, [reviewId, customerId]);
      } else {
        existingVote = await pool.query(`
          SELECT id FROM review_helpfulness 
          WHERE review_id = $1 AND customer_ip = $2
        `, [reviewId, customerIp]);
      }
      
      if (existingVote.rows.length > 0) {
        return res.status(400).json({ success: false, message: "You have already voted on this review" });
      }

      // Record the vote
      await pool.query(`
        INSERT INTO review_helpfulness (review_id, customer_id, customer_ip, is_helpful)
        VALUES ($1, $2, $3, $4)
      `, [reviewId, customerId, customerIp, isHelpful]);

      // Update the review's helpful votes count
      const updateField = isHelpful ? 'helpful_votes' : 'not_helpful_votes';
      await pool.query(`
        UPDATE product_reviews 
        SET ${updateField} = ${updateField} + 1 
        WHERE id = $1
      `, [reviewId]);

      res.json({ success: true, message: "Vote recorded successfully" });
    } catch (error) {
      console.error("Error recording helpful vote:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Admin: Get all pending reviews for approval
  app.get("/api/admin/reviews/pending", requireAuth, async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query(`
        SELECT pr.*, sp.name as product_name
        FROM product_reviews pr
        JOIN shop_products sp ON pr.product_id = sp.id
        WHERE pr.is_approved = false
        ORDER BY pr.created_at DESC
      `);

      const reviews = result.rows.map((row: any) => ({
        id: row.id,
        productId: row.product_id,
        productName: row.product_name,
        customerId: row.customer_id,
        customerName: row.customer_name,
        customerEmail: row.customer_email,
        rating: row.rating,
        title: row.title,
        review: row.review,
        pros: row.pros,
        cons: row.cons,
        isVerifiedPurchase: row.is_verified_purchase,
        createdAt: row.created_at
      }));

      res.json({ success: true, data: reviews });
    } catch (error) {
      console.error("Error fetching pending reviews:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Admin: Approve/reject review
  app.patch("/api/admin/reviews/:id/approve", requireAuth, async (req, res) => {
    try {
      const reviewId = parseInt(req.params.id);
      const { isApproved, adminResponse } = req.body;
      
      if (isNaN(reviewId)) {
        return res.status(400).json({ success: false, message: "Invalid review ID" });
      }

      const { pool } = await import('./db');
      
      // Update review approval status
      const result = await pool.query(`
        UPDATE product_reviews 
        SET is_approved = $1, admin_response = $2, admin_response_date = NOW(), updated_at = NOW()
        WHERE id = $3
        RETURNING product_id
      `, [isApproved, adminResponse, reviewId]);

      if (result.rows.length === 0) {
        return res.status(404).json({ success: false, message: "Review not found" });
      }

      // Update product statistics if approved
      if (isApproved) {
        await updateProductStats(result.rows[0].product_id);
      }

      res.json({ 
        success: true, 
        message: isApproved ? "Review approved successfully" : "Review rejected successfully" 
      });
    } catch (error) {
      console.error("Error updating review approval:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Helper function to update product statistics
  async function updateProductStats(productId: number) {
    try {
      const { pool } = await import('./db');
      
      // Calculate new statistics from approved reviews
      const statsQuery = await pool.query(`
        SELECT 
          COUNT(*) as total_reviews,
          AVG(rating) as average_rating,
          COUNT(CASE WHEN rating = 1 THEN 1 END) as rating_1,
          COUNT(CASE WHEN rating = 2 THEN 1 END) as rating_2,
          COUNT(CASE WHEN rating = 3 THEN 1 END) as rating_3,
          COUNT(CASE WHEN rating = 4 THEN 1 END) as rating_4,
          COUNT(CASE WHEN rating = 5 THEN 1 END) as rating_5,
          MAX(created_at) as last_review_date
        FROM product_reviews 
        WHERE product_id = $1 AND is_approved = true
      `, [productId]);

      const stats = statsQuery.rows[0];
      const ratingDistribution = {
        "1": parseInt(stats.rating_1),
        "2": parseInt(stats.rating_2),
        "3": parseInt(stats.rating_3),
        "4": parseInt(stats.rating_4),
        "5": parseInt(stats.rating_5)
      };

      // Update or insert product stats
      await pool.query(`
        INSERT INTO product_stats (
          product_id, total_reviews, average_rating, rating_distribution, last_review_date, updated_at
        ) VALUES ($1, $2, $3, $4, $5, NOW())
        ON CONFLICT (product_id) DO UPDATE SET
          total_reviews = $2,
          average_rating = $3,
          rating_distribution = $4,
          last_review_date = $5,
          updated_at = NOW()
      `, [
        productId,
        parseInt(stats.total_reviews),
        parseFloat(stats.average_rating) || 0,
        JSON.stringify(ratingDistribution),
        stats.last_review_date
      ]);
    } catch (error) {
      console.error("Error updating product stats:", error);
    }
  }

  // =============================================================================
  // WEIGHT CALCULATION ENDPOINTS
  // =============================================================================

  // Calculate weight for a specific order
  app.post('/api/orders/:orderId/calculate-weight', async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: 'ID Ø³ÙØ§Ø±Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª' });
      }

      await orderManagementStorage.calculateAndUpdateOrderWeight(orderId);
      
      // Get updated order to return the new weight
      const updatedOrder = await orderManagementStorage.getOrderById(orderId);
      
      res.json({ 
        success: true, 
        message: 'ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯',
        totalWeight: updatedOrder?.totalWeight,
        weightUnit: updatedOrder?.weightUnit
      });
    } catch (error) {
      console.error('Error calculating order weight:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´' });
    }
  });

  // Calculate weights for all orders with null weight
  app.post('/api/orders/calculate-all-weights', async (req, res) => {
    try {
      // Get all orders with null or empty weight
      const ordersWithoutWeight = await db
        .select({ customerOrderId: orderManagement.customerOrderId })
        .from(orderManagement)
        .where(isNull(orderManagement.totalWeight));

      let updatedCount = 0;
      let errors = 0;

      for (const order of ordersWithoutWeight) {
        try {
          await orderManagementStorage.calculateAndUpdateOrderWeight(order.customerOrderId);
          updatedCount++;
        } catch (error) {
          console.error(`Error calculating weight for order ${order.customerOrderId}:`, error);
          errors++;
        }
      }

      res.json({ 
        success: true, 
        message: `ÙˆØ²Ù† ${updatedCount} Ø³ÙØ§Ø±Ø´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯`,
        updatedCount,
        errors,
        totalProcessed: ordersWithoutWeight.length
      });
    } catch (error) {
      console.error('Error calculating weights for all orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ø³ÙØ§Ø±Ø´Ø§Øª' });
    }
  });

  // =============================================================================
  // INVENTORY THRESHOLD SETTINGS API ENDPOINTS
  // =============================================================================

  // Get inventory threshold settings
  app.get("/api/inventory/threshold-settings", async (req: Request, res: Response) => {
    try {
      const { inventoryThresholdSettings } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const settings = await db.select()
        .from(inventoryThresholdSettings)
        .where(eq(inventoryThresholdSettings.isActive, true))
        .orderBy(inventoryThresholdSettings.settingName);
      
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error fetching threshold settings:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¢Ø³ØªØ§Ù†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ" 
      });
    }
  });

  // Create or update threshold settings
  app.post("/api/inventory/threshold-settings", async (req: Request, res: Response) => {
    try {
      const { inventoryThresholdSettings, insertInventoryThresholdSettingsSchema } = await import("../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const validatedData = insertInventoryThresholdSettingsSchema.parse(req.body);
      
      // Check if setting already exists
      const existingSetting = await db.select()
        .from(inventoryThresholdSettings)
        .where(eq(inventoryThresholdSettings.settingName, validatedData.settingName))
        .limit(1);
      
      let result;
      if (existingSetting.length > 0) {
        // Update existing setting
        result = await db.update(inventoryThresholdSettings)
          .set({
            ...validatedData,
            updatedAt: new Date()
          })
          .where(eq(inventoryThresholdSettings.settingName, validatedData.settingName))
          .returning();
      } else {
        // Create new setting
        result = await db.insert(inventoryThresholdSettings)
          .values(validatedData)
          .returning();
      }
      
      res.json({ success: true, data: result[0] });
    } catch (error) {
      console.error("Error saving threshold settings:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¢Ø³ØªØ§Ù†Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ" 
      });
    }
  });

  // Get inventory alerts log
  app.get("/api/inventory/alerts-log", async (req: Request, res: Response) => {
    try {
      const { inventoryAlertLog } = await import("../shared/schema");
      const { desc } = await import("drizzle-orm");
      
      const { limit = 50, offset = 0 } = req.query;
      
      const alerts = await db.select()
        .from(inventoryAlertLog)
        .orderBy(desc(inventoryAlertLog.sentAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));
      
      res.json({ success: true, data: alerts });
    } catch (error) {
      console.error("Error fetching alerts log:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§" 
      });
    }
  });

  // =============================================================================
  // =============================================================================
  // ABANDONED CART MANAGEMENT API ENDPOINTS
  // =============================================================================
  
  // Get abandoned cart settings
  app.get("/api/admin/abandoned-cart/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const settings = await cartStorage.getAbandonedCartSettings();
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error fetching abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Update abandoned cart settings
  app.put("/api/admin/abandoned-cart/settings", requireAuth, async (req: Request, res: Response) => {
    try {
      const settings = await cartStorage.updateAbandonedCartSettings(req.body);
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error updating abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get abandoned cart sessions
  app.get("/api/admin/abandoned-cart/carts", requireAuth, async (req: Request, res: Response) => {
    try {
      const carts = await cartStorage.getAbandonedCarts();
      res.json({ success: true, data: carts });
    } catch (error) {
      console.error("Error fetching abandoned carts:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Get abandoned cart analytics
  app.get("/api/admin/abandoned-cart/analytics", requireAuth, async (req: Request, res: Response) => {
    try {
      const analytics = await cartStorage.getAbandonedCartAnalytics();
      res.json({ success: true, data: analytics });
    } catch (error) {
      console.error("Error fetching abandoned cart analytics:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Track cart session (for logged-in customers)
  app.post("/api/cart/session", async (req: Request, res: Response) => {
    try {
      const { sessionId, cartData, itemCount, totalValue } = req.body;
      const session = req.session as SessionData;
      
      if (!session.customerId) {
        return res.status(401).json({ success: false, message: "Customer not authenticated" });
      }
      
      const sessionData = {
        customerId: session.customerId,
        sessionId,
        cartData,
        itemCount,
        totalValue: parseFloat(totalValue) || 0
      };
      
      await cartStorage.createOrUpdateCartSession(sessionData);
      res.json({ success: true, message: "Cart session tracked successfully" });
    } catch (error) {
      console.error("Error tracking cart session:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });

  // Send abandoned cart notification
  app.post("/api/admin/abandoned-cart/notify/:cartId", requireAuth, async (req: Request, res: Response) => {
    try {
      const { cartId } = req.params;
      const { message, discountCode } = req.body;
      
      await cartStorage.sendAbandonedCartNotification(parseInt(cartId), message, discountCode);
      res.json({ success: true, message: "Notification sent successfully" });
    } catch (error) {
      console.error("Error sending abandoned cart notification:", error);
      res.status(500).json({ success: false, message: "Internal server error" });
    }
  });


  
  // =============================================================================
  // ABANDONED CART MANAGEMENT API
  // =============================================================================

  // Track cart session activity
  app.post("/api/cart/session", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }

      const { sessionId, cartData, itemCount, totalValue } = req.body;
      
      const cartSessionId = await cartStorage.createOrUpdateCartSession({
        customerId,
        sessionId,
        cartData,
        itemCount,
        totalValue
      });

      res.json({ success: true, cartSessionId });
    } catch (error) {
      console.error("Error tracking cart session:", error);
      res.status(500).json({ success: false, message: "Failed to track cart session" });
    }
  });

  // Get abandoned cart settings
  app.get("/api/admin/abandoned-cart/settings", requireAuth, async (req, res) => {
    try {
      const settings = await cartStorage.getAbandonedCartSettings();
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error("Error fetching abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Failed to fetch settings" });
    }
  });

  // Update abandoned cart settings
  app.put("/api/admin/abandoned-cart/settings", requireAuth, async (req, res) => {
    try {
      const settings = req.body;
      await cartStorage.updateAbandonedCartSettings(settings);
      res.json({ success: true, message: "Settings updated successfully" });
    } catch (error) {
      console.error("Error updating abandoned cart settings:", error);
      res.status(500).json({ success: false, message: "Failed to update settings" });
    }
  });

  // Get abandoned carts
  app.get("/api/admin/abandoned-cart/carts", requireAuth, async (req, res) => {
    try {
      const { timeout } = req.query;
      const timeoutMinutes = timeout ? parseInt(timeout as string) : 30;
      
      const abandonedCarts = await cartStorage.getAbandonedCarts(timeoutMinutes);
      res.json({ success: true, data: abandonedCarts });
    } catch (error) {
      console.error("Error fetching abandoned carts:", error);
      res.status(500).json({ success: false, message: "Failed to fetch abandoned carts" });
    }
  });

  // Send abandoned cart notification
  app.post("/api/admin/abandoned-cart/notify/:cartId", requireAuth, async (req, res) => {
    try {
      const cartId = parseInt(req.params.cartId);
      const { title, message, notificationType } = req.body;
      
      // Get cart session info
      const cartSessions = await cartStorage.getActiveCartSessions();
      const cartSession = cartSessions.find(cart => cart.id === cartId);
      
      if (!cartSession) {
        return res.status(404).json({ success: false, message: "Cart session not found" });
      }

      await cartStorage.createNotification({
        cartSessionId: cartId,
        customerId: cartSession.customerId,
        notificationType: notificationType || 'browser',
        title,
        message
      });

      res.json({ success: true, message: "Notification sent successfully" });
    } catch (error) {
      console.error("Error sending abandoned cart notification:", error);
      res.status(500).json({ success: false, message: "Failed to send notification" });
    }
  });

  // Get customer notifications
  app.get("/api/cart/notifications", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }

      const notifications = await cartStorage.getCustomerNotifications(customerId);
      res.json({ success: true, data: notifications });
    } catch (error) {
      console.error("Error fetching customer notifications:", error);
      res.status(500).json({ success: false, message: "Failed to fetch notifications" });
    }
  });

  // Mark notification as read
  app.patch("/api/cart/notifications/:id/read", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      await cartStorage.markNotificationAsRead(notificationId);
      res.json({ success: true, message: "Notification marked as read" });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ success: false, message: "Failed to mark notification as read" });
    }
  });

  // Get abandoned cart analytics
  app.get("/api/admin/abandoned-cart/analytics", requireAuth, async (req, res) => {
    try {
      const { days } = req.query;
      const analyticsDays = days ? parseInt(days as string) : 30;
      
      const analytics = await cartStorage.getCartRecoveryAnalytics(analyticsDays);
      const overallStats = await cartStorage.getOverallStats();
      
      res.json({ 
        success: true, 
        data: {
          analytics,
          overallStats
        }
      });
    } catch (error) {
      console.error("Error fetching abandoned cart analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch analytics" });
    }
  });

  // Complete cart session (when order is placed)
  app.post("/api/cart/session/complete", async (req, res) => {
    try {
      const customerId = (req.session as any)?.customerId;
      if (!customerId) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }

      await cartStorage.clearCartSession(customerId);
      res.json({ success: true, message: "Cart session completed" });
    } catch (error) {
      console.error("Error completing cart session:", error);
      res.status(500).json({ success: false, message: "Failed to complete cart session" });
    }
  });

  // ===========================================
  // GPS DELIVERY TRACKING ENDPOINTS
  // ===========================================

  // Record GPS delivery confirmation
  app.post("/api/gps-delivery/confirm", async (req, res) => {
    try {
      console.log('ðŸ“ [GPS-API] Delivery confirmation request:', req.body);
      
      const gpsData = insertGpsDeliveryConfirmationSchema.parse(req.body);
      const confirmation = await gpsDeliveryStorage.recordGpsDelivery(gpsData);
      
      res.json({ 
        success: true, 
        data: confirmation,
        message: "GPS delivery confirmation recorded successfully"
      });
    } catch (error) {
      console.error("âŒ [GPS-API] Error recording GPS delivery:", error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : "Failed to record GPS delivery confirmation" 
      });
    }
  });

  // Get GPS deliveries by order
  app.get("/api/gps-delivery/order/:orderId", async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({ success: false, message: "Invalid order ID" });
      }

      const deliveries = await gpsDeliveryStorage.getGpsDeliveriesByOrder(orderId);
      res.json({ success: true, data: deliveries });
    } catch (error) {
      console.error("Error fetching GPS deliveries for order:", error);
      res.status(500).json({ success: false, message: "Failed to fetch GPS deliveries" });
    }
  });

  // Get GPS deliveries by delivery person
  app.get("/api/gps-delivery/person/:phone", async (req, res) => {
    try {
      const phone = req.params.phone;
      const deliveries = await gpsDeliveryStorage.getGpsDeliveriesByDeliveryPerson(phone);
      res.json({ success: true, data: deliveries });
    } catch (error) {
      console.error("Error fetching GPS deliveries for delivery person:", error);
      res.status(500).json({ success: false, message: "Failed to fetch GPS deliveries" });
    }
  });

  // Get GPS deliveries by location
  app.get("/api/gps-delivery/location/:country/:city", async (req, res) => {
    try {
      const { country, city } = req.params;
      const { startDate, endDate } = req.query;
      
      const start = startDate ? new Date(startDate as string) : undefined;
      const end = endDate ? new Date(endDate as string) : undefined;
      
      const deliveries = await gpsDeliveryStorage.getGpsDeliveriesByLocation(country, city, start, end);
      res.json({ success: true, data: deliveries });
    } catch (error) {
      console.error("Error fetching GPS deliveries by location:", error);
      res.status(500).json({ success: false, message: "Failed to fetch GPS deliveries" });
    }
  });

  // Get delivery performance statistics
  app.get("/api/gps-delivery/performance", async (req, res) => {
    try {
      const { period } = req.query;
      const periodDays = period ? parseInt(period as string) : 30;
      
      const stats = await gpsDeliveryStorage.getDeliveryPerformanceStats(periodDays);
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching delivery performance stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch performance statistics" });
    }
  });

  // Get geographic coverage data
  app.get("/api/gps-delivery/coverage", async (req, res) => {
    try {
      const { country } = req.query;
      const coverage = await gpsDeliveryStorage.getGeographicCoverage(country as string);
      res.json({ success: true, data: coverage });
    } catch (error) {
      console.error("Error fetching geographic coverage:", error);
      res.status(500).json({ success: false, message: "Failed to fetch geographic coverage" });
    }
  });

  // Get delivery person statistics
  app.get("/api/gps-delivery/person-stats/:phone", async (req, res) => {
    try {
      const phone = req.params.phone;
      const { period } = req.query;
      const periodDays = period ? parseInt(period as string) : 30;
      
      const stats = await gpsDeliveryStorage.getDeliveryPersonStats(phone, periodDays);
      res.json({ success: true, data: stats });
    } catch (error) {
      console.error("Error fetching delivery person stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch delivery person statistics" });
    }
  });

  // Get delivery heatmap data
  app.get("/api/gps-delivery/heatmap", async (req, res) => {
    try {
      const { country, city } = req.query;
      if (!country) {
        return res.status(400).json({ success: false, message: "Country parameter is required" });
      }
      
      const heatmapData = await gpsDeliveryStorage.getDeliveryHeatmapData(country as string, city as string);
      res.json({ success: true, data: heatmapData });
    } catch (error) {
      console.error("Error fetching delivery heatmap data:", error);
      res.status(500).json({ success: false, message: "Failed to fetch heatmap data" });
    }
  });

  // Get actual GPS delivery confirmations for table display
  app.get("/api/gps-delivery/confirmations", async (req, res) => {
    try {
      const { startDate, endDate, limit = 50 } = req.query;
      console.log('ðŸšš [GPS-CONFIRMATIONS] Fetching delivery confirmations');
      
      // If no date range provided, default to last 7 days
      const defaultStartDate = new Date();
      defaultStartDate.setDate(defaultStartDate.getDate() - 7);
      const defaultEndDate = new Date();
      
      const start = startDate ? new Date(startDate as string) : defaultStartDate;
      const end = endDate ? new Date(endDate as string) : defaultEndDate;
      
      console.log(`ðŸšš [GPS-CONFIRMATIONS] Date range: ${start.toISOString()} to ${end.toISOString()}`);
      
      const confirmations = await gpsDeliveryStorage.getDeliveryConfirmations(start, end, parseInt(limit as string));
      console.log(`ðŸšš [GPS-CONFIRMATIONS] Found ${confirmations.length} delivery confirmations`);
      
      res.json({ success: true, data: confirmations });
    } catch (error) {
      console.error("Error fetching GPS delivery confirmations:", error);
      res.status(500).json({ success: false, message: "Failed to fetch delivery confirmations" });
    }
  });

  // Get delivery route analysis
  app.get("/api/gps-delivery/route-analysis/:phone/:date", async (req, res) => {
    try {
      const { phone, date } = req.params;
      const analysisDate = new Date(date);
      
      if (isNaN(analysisDate.getTime())) {
        return res.status(400).json({ success: false, message: "Invalid date format" });
      }
      
      const routeAnalysis = await gpsDeliveryStorage.getDeliveryRouteAnalysis(phone, analysisDate);
      res.json({ success: true, data: routeAnalysis });
    } catch (error) {
      console.error("Error fetching delivery route analysis:", error);
      res.status(500).json({ success: false, message: "Failed to fetch route analysis" });
    }
  });

  // Generate analytics for specific date
  app.post("/api/gps-delivery/analytics/generate", async (req, res) => {
    try {
      const { date } = req.body;
      const analyticsDate = date ? new Date(date) : new Date();
      
      await gpsDeliveryStorage.generateDailyAnalytics(analyticsDate);
      res.json({ 
        success: true, 
        message: `Analytics generated for ${analyticsDate.toISOString().split('T')[0]}` 
      });
    } catch (error) {
      console.error("Error generating GPS delivery analytics:", error);
      res.status(500).json({ success: false, message: "Failed to generate analytics" });
    }
  });

  // Get analytics by date range
  app.get("/api/gps-delivery/analytics", async (req, res) => {
    try {
      const { startDate, endDate, country, city } = req.query;
      
      if (startDate && endDate) {
        const start = new Date(startDate as string);
        const end = new Date(endDate as string);
        const analytics = await gpsDeliveryStorage.getAnalyticsByDateRange(start, end);
        res.json({ success: true, data: analytics });
      } else if (country) {
        const analytics = await gpsDeliveryStorage.getAnalyticsByLocation(country as string, city as string);
        res.json({ success: true, data: analytics });
      } else {
        return res.status(400).json({ 
          success: false, 
          message: "Either date range (startDate, endDate) or country parameter is required" 
        });
      }
    } catch (error) {
      console.error("Error fetching GPS delivery analytics:", error);
      res.status(500).json({ success: false, message: "Failed to fetch analytics" });
    }
  });

  // Validate delivery location
  app.post("/api/gps-delivery/validate-location", async (req, res) => {
    try {
      const { latitude, longitude, customerAddress } = req.body;
      
      if (!latitude || !longitude) {
        return res.status(400).json({ 
          success: false, 
          message: "Latitude and longitude are required" 
        });
      }
      
      const validation = await gpsDeliveryStorage.validateDeliveryLocation(
        parseFloat(latitude), 
        parseFloat(longitude), 
        customerAddress || ''
      );
      
      res.json({ success: true, data: validation });
    } catch (error) {
      console.error("Error validating delivery location:", error);
      res.status(500).json({ success: false, message: "Failed to validate location" });
    }
  });

  // =============================================================================
  // LOGISTICS MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Transportation Companies
  app.get('/api/logistics/companies', requireAuth, async (req, res) => {
    try {
      const { isActive } = req.query;
      const companies = await logisticsStorage.getTransportationCompanies({
        isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined
      });
      res.json({ success: true, data: companies });
    } catch (error) {
      console.error('Error fetching transportation companies:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø±Ú©Øªâ€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„' });
    }
  });

  app.get('/api/logistics/companies/:id', requireAuth, async (req, res) => {
    try {
      const company = await logisticsStorage.getTransportationCompanyById(parseInt(req.params.id));
      if (!company) {
        return res.status(404).json({ success: false, message: 'Ø´Ø±Ú©Øª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      res.json({ success: true, data: company });
    } catch (error) {
      console.error('Error fetching transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ø±Ú©Øª' });
    }
  });

  app.post('/api/logistics/companies', requireAuth, async (req, res) => {
    try {
      const validatedData = insertTransportationCompanySchema.parse(req.body);
      const company = await logisticsStorage.createTransportationCompany(validatedData);
      res.status(201).json({ success: true, data: company });
    } catch (error) {
      console.error('Error creating transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø±Ú©Øª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„' });
    }
  });

  app.put('/api/logistics/companies/:id', requireAuth, async (req, res) => {
    try {
      const company = await logisticsStorage.updateTransportationCompany(
        parseInt(req.params.id),
        req.body
      );
      res.json({ success: true, data: company });
    } catch (error) {
      console.error('Error updating transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø±Ú©Øª' });
    }
  });

  app.delete('/api/logistics/companies/:id', requireAuth, async (req, res) => {
    try {
      await logisticsStorage.deleteTransportationCompany(parseInt(req.params.id));
      res.json({ success: true, message: 'Ø´Ø±Ú©Øª Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting transportation company:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø´Ø±Ú©Øª' });
    }
  });

  // Delivery Vehicles
  app.get('/api/logistics/vehicles', requireAuth, async (req, res) => {
    try {
      const { companyId, vehicleType, currentStatus, isActive } = req.query;
      const vehicles = await logisticsStorage.getDeliveryVehicles({
        companyId: companyId ? parseInt(companyId as string) : undefined,
        vehicleType: vehicleType as string,
        currentStatus: currentStatus as string,
        isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined
      });
      res.json({ success: true, data: vehicles });
    } catch (error) {
      console.error('Error fetching delivery vehicles:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.get('/api/logistics/vehicles/available', requireAuth, async (req, res) => {
    try {
      const { vehicleType, minWeight, minVolume } = req.query;
      const vehicles = await logisticsStorage.getAvailableVehicles({
        vehicleType: vehicleType as string,
        minWeight: minWeight ? parseFloat(minWeight as string) : undefined,
        minVolume: minVolume ? parseFloat(minVolume as string) : undefined
      });
      res.json({ success: true, data: vehicles });
    } catch (error) {
      console.error('Error fetching available vehicles:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙˆØ³Ø§ÛŒÙ„ Ù†Ù‚Ù„ÛŒÙ‡ Ø¢Ø²Ø§Ø¯' });
    }
  });

  app.post('/api/logistics/vehicles', requireAuth, async (req, res) => {
    try {
      const validatedData = insertDeliveryVehicleSchema.parse(req.body);
      const vehicle = await logisticsStorage.createDeliveryVehicle(validatedData);
      res.status(201).json({ success: true, data: vehicle });
    } catch (error) {
      console.error('Error creating delivery vehicle:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.put('/api/logistics/vehicles/:id', requireAuth, async (req, res) => {
    try {
      const vehicle = await logisticsStorage.updateDeliveryVehicle(
        parseInt(req.params.id),
        req.body
      );
      res.json({ success: true, data: vehicle });
    } catch (error) {
      console.error('Error updating delivery vehicle:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.patch('/api/logistics/vehicles/:id/status', requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const vehicle = await logisticsStorage.updateVehicleStatus(parseInt(req.params.id), status);
      res.json({ success: true, data: vehicle });
    } catch (error) {
      console.error('Error updating vehicle status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  // Delivery Personnel
  app.get('/api/logistics/personnel', requireAuth, async (req, res) => {
    try {
      const { companyId, currentStatus, isActive } = req.query;
      const personnel = await logisticsStorage.getDeliveryPersonnel({
        companyId: companyId ? parseInt(companyId as string) : undefined,
        currentStatus: currentStatus as string,
        isActive: isActive === 'true' ? true : isActive === 'false' ? false : undefined
      });
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error fetching delivery personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø±Ø³Ù†Ù„ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.get('/api/logistics/personnel/available', requireAuth, async (req, res) => {
    try {
      const { serviceArea, vehicleType } = req.query;
      const drivers = await logisticsStorage.getAvailableDrivers({
        serviceArea: serviceArea as string,
        vehicleType: vehicleType as string
      });
      res.json({ success: true, data: drivers });
    } catch (error) {
      console.error('Error fetching available drivers:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø±Ø§Ù†Ù†Ø¯Ú¯Ø§Ù† Ø¢Ø²Ø§Ø¯' });
    }
  });

  app.post('/api/logistics/personnel', requireAuth, async (req, res) => {
    try {
      const validatedData = insertDeliveryPersonnelSchema.parse(req.body);
      const personnel = await logisticsStorage.createDeliveryPersonnel(validatedData);
      res.status(201).json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error creating delivery personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø³Ù†Ù„ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.put('/api/logistics/personnel/:id', requireAuth, async (req, res) => {
    try {
      const personnel = await logisticsStorage.updateDeliveryPersonnel(
        parseInt(req.params.id),
        req.body
      );
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error updating delivery personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±Ø³Ù†Ù„' });
    }
  });

  app.patch('/api/logistics/personnel/:id/status', requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const personnel = await logisticsStorage.updateDriverStatus(parseInt(req.params.id), status);
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error updating driver status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø±Ø§Ù†Ù†Ø¯Ù‡' });
    }
  });

  app.patch('/api/logistics/personnel/:id/location', requireAuth, async (req, res) => {
    try {
      const { latitude, longitude } = req.body;
      const personnel = await logisticsStorage.updateDriverLocation(
        parseInt(req.params.id),
        parseFloat(latitude),
        parseFloat(longitude)
      );
      res.json({ success: true, data: personnel });
    } catch (error) {
      console.error('Error updating driver location:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø±Ø§Ù†Ù†Ø¯Ù‡' });
    }
  });

  // Delivery Routes
  app.get('/api/logistics/routes', requireAuth, async (req, res) => {
    try {
      const { driverId, vehicleId, status, startDate, endDate } = req.query;
      const routes = await logisticsStorage.getDeliveryRoutes({
        driverId: driverId ? parseInt(driverId as string) : undefined,
        vehicleId: vehicleId ? parseInt(vehicleId as string) : undefined,
        status: status as string,
        dateRange: startDate && endDate ? {
          start: new Date(startDate as string),
          end: new Date(endDate as string)
        } : undefined
      });
      res.json({ success: true, data: routes });
    } catch (error) {
      console.error('Error fetching delivery routes:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.post('/api/logistics/routes', requireAuth, async (req, res) => {
    try {
      const validatedData = insertDeliveryRouteSchema.parse(req.body);
      const route = await logisticsStorage.createDeliveryRoute(validatedData);
      res.status(201).json({ success: true, data: route });
    } catch (error) {
      console.error('Error creating delivery route:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø³ÛŒØ± ØªØ­ÙˆÛŒÙ„' });
    }
  });

  app.patch('/api/logistics/routes/:id/status', requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const route = await logisticsStorage.updateRouteStatus(parseInt(req.params.id), status);
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error updating route status:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù…Ø³ÛŒØ±' });
    }
  });

  app.post('/api/logistics/routes/:id/orders', requireAuth, async (req, res) => {
    try {
      const { orderId } = req.body;
      const route = await logisticsStorage.addOrderToRoute(parseInt(req.params.id), orderId);
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error adding order to route:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø³ÙØ§Ø±Ø´ Ø¨Ù‡ Ù…Ø³ÛŒØ±' });
    }
  });

  app.delete('/api/logistics/routes/:id/orders/:orderId', requireAuth, async (req, res) => {
    try {
      const route = await logisticsStorage.removeOrderFromRoute(
        parseInt(req.params.id),
        parseInt(req.params.orderId)
      );
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error removing order from route:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø³ÙØ§Ø±Ø´ Ø§Ø² Ù…Ø³ÛŒØ±' });
    }
  });

  app.post('/api/logistics/routes/:id/complete-stop', requireAuth, async (req, res) => {
    try {
      const { orderId } = req.body;
      const route = await logisticsStorage.completeRouteStop(parseInt(req.params.id), orderId);
      res.json({ success: true, data: route });
    } catch (error) {
      console.error('Error completing route stop:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÚ©Ù…ÛŒÙ„ ØªÙˆÙ‚Ù Ù…Ø³ÛŒØ±' });
    }
  });

  // Delivery Verification Codes (4-digit SMS codes)
  app.get('/api/logistics/verification-codes', requireAuth, async (req, res) => {
    try {
      const { customerOrderId, isVerified, smsStatus } = req.query;
      const codes = await logisticsStorage.getDeliveryVerificationCodes({
        customerOrderId: customerOrderId ? parseInt(customerOrderId as string) : undefined,
        isVerified: isVerified === 'true' ? true : isVerified === 'false' ? false : undefined,
        smsStatus: smsStatus as string
      });
      res.json({ success: true, data: codes });
    } catch (error) {
      console.error('Error fetching verification codes:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯Ù‡Ø§ÛŒ ØªØ§ÛŒÛŒØ¯' });
    }
  });

  app.get('/api/logistics/verification-codes/order/:orderId', requireAuth, async (req, res) => {
    try {
      const code = await logisticsStorage.getDeliveryCodeByOrderId(parseInt(req.params.orderId));
      if (!code) {
        return res.status(404).json({ success: false, message: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }
      res.json({ success: true, data: code });
    } catch (error) {
      console.error('Error fetching verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯ ØªØ§ÛŒÛŒØ¯' });
    }
  });

  app.post('/api/logistics/verification-codes/generate', requireAuth, async (req, res) => {
    try {
      const { customerOrderId, customerPhone, customerName } = req.body;
      
      if (!customerOrderId || !customerPhone || !customerName) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ØŒ ØªÙ„ÙÙ† Ùˆ Ù†Ø§Ù… Ù…Ø´ØªØ±ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      // Check if verification code already exists for this order
      const existingCode = await logisticsStorage.getDeliveryCodeByOrderId(customerOrderId);
      
      let codeData;
      let isNewCode = false;
      
      if (existingCode) {
        // Use existing code, just resend SMS
        codeData = existingCode;
        console.log(`Reusing existing code ${existingCode.verificationCode} for order ${customerOrderId}`);
      } else {
        // Generate new code
        codeData = await logisticsStorage.generateVerificationCode(
          customerOrderId, 
          customerPhone, 
          customerName
        );
        isNewCode = true;
        console.log(`Generated new code ${codeData.verificationCode} for order ${customerOrderId}`);
      }

      // Send SMS notification (for both new and existing codes)
      try {
        const smsResult = await smsService.sendDeliveryVerificationSms(
          customerPhone,
          codeData.verificationCode,
          customerName,
          codeData.id
        );

        if (smsResult.success) {
          await logisticsStorage.updateSmsStatus(codeData.id, 'sent', { 
            messageId: smsResult.messageId,
            provider: 'kavenegar'
          });
        }
      } catch (smsError) {
        console.error('SMS sending failed:', smsError);
        // Continue even if SMS fails
      }

      res.status(isNewCode ? 201 : 200).json({ 
        success: true, 
        data: codeData,
        isExisting: !isNewCode,
        message: isNewCode ? 'Ú©Ø¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯' : 'Ú©Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error generating verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯' });
    }
  });

  app.post('/api/logistics/verification-codes/verify', requireAuth, async (req, res) => {
    try {
      const { customerOrderId, code, verifiedBy, verificationLocation, latitude, longitude } = req.body;
      
      if (!customerOrderId || !code || !verifiedBy) {
        return res.status(400).json({ 
          success: false, 
          message: 'Ø´Ù…Ø§Ø±Ù‡ Ø³ÙØ§Ø±Ø´ØŒ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ùˆ Ù†Ø§Ù… ØªØ§ÛŒÛŒØ¯ Ú©Ù†Ù†Ø¯Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª' 
        });
      }

      const isValid = await logisticsStorage.verifyDeliveryCode(customerOrderId, code, {
        verifiedBy,
        verificationLocation,
        latitude: latitude ? parseFloat(latitude) : undefined,
        longitude: longitude ? parseFloat(longitude) : undefined
      });

      if (isValid) {
        res.json({ success: true, message: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯' });
      } else {
        res.status(400).json({ success: false, message: 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª' });
      }
    } catch (error) {
      console.error('Error verifying delivery code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯' });
    }
  });

  app.post('/api/logistics/verification-codes/:id/resend', requireAuth, async (req, res) => {
    try {
      const code = await logisticsStorage.resendVerificationCode(parseInt(req.params.id));
      
      // Send new SMS
      try {
        const smsResult = await smsService.sendDeliveryVerificationSms(
          code.customerPhone,
          code.verificationCode,
          code.customerName,
          code.id
        );

        if (smsResult.success) {
          await logisticsStorage.updateSmsStatus(code.id, 'sent', { 
            messageId: smsResult.messageId 
          });
        }
      } catch (smsError) {
        console.error('SMS resend failed:', smsError);
      }

      res.json({ success: true, data: code });
    } catch (error) {
      console.error('Error resending verification code:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ø¬Ø¯Ø¯ Ú©Ø¯' });
    }
  });

  // Logistics Analytics
  app.get('/api/logistics/analytics', requireAuth, async (req, res) => {
    try {
      const { period, startDate, endDate } = req.query;
      const analytics = await logisticsStorage.getLogisticsAnalytics({
        period: period as string,
        dateRange: startDate && endDate ? {
          start: new Date(startDate as string),
          end: new Date(endDate as string)
        } : undefined
      });
      res.json({ success: true, data: analytics });
    } catch (error) {
      console.error('Error fetching logistics analytics:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù„Ø¬Ø³ØªÛŒÚ©' });
    }
  });

  app.get('/api/logistics/analytics/performance', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const metrics = await logisticsStorage.getPerformanceMetrics(parseInt(period as string));
      res.json({ success: true, data: metrics });
    } catch (error) {
      console.error('Error fetching performance metrics:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯' });
    }
  });

  app.get('/api/logistics/analytics/drivers/:driverId?', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const { driverId } = req.params;
      const driverStats = await logisticsStorage.getDriverPerformance(
        driverId ? parseInt(driverId) : undefined,
        parseInt(period as string)
      );
      res.json({ success: true, data: driverStats });
    } catch (error) {
      console.error('Error fetching driver performance:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±Ø§Ù†Ù†Ø¯Ù‡' });
    }
  });

  app.get('/api/logistics/analytics/vehicles/:vehicleId?', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const { vehicleId } = req.params;
      const vehicleStats = await logisticsStorage.getVehicleUtilization(
        vehicleId ? parseInt(vehicleId) : undefined,
        parseInt(period as string)
      );
      res.json({ success: true, data: vehicleStats });
    } catch (error) {
      console.error('Error fetching vehicle utilization:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ù‡Ø±Ù‡â€ŒÙˆØ±ÛŒ ÙˆØ³ÛŒÙ„Ù‡ Ù†Ù‚Ù„ÛŒÙ‡' });
    }
  });

  app.get('/api/logistics/analytics/costs', requireAuth, async (req, res) => {
    try {
      const { period = 30 } = req.query;
      const costAnalysis = await logisticsStorage.getCostAnalysis(parseInt(period as string));
      res.json({ success: true, data: costAnalysis });
    } catch (error) {
      console.error('Error fetching cost analysis:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªØ­Ù„ÛŒÙ„ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§' });
    }
  });

  // Get warehouse-approved orders ready for logistics processing
  app.get('/api/logistics/orders/pending', requireAuth, async (req, res) => {
    try {
      const pendingOrders = await orderManagementStorage.getOrdersByStatus('warehouse_approved');
      
      // Calculate total weight for each order
      const ordersWithWeight = await Promise.all(
        pendingOrders.map(async (order) => {
          try {
            const weight = await orderManagementStorage.calculateOrderWeight(order.customerOrderId);
            return {
              ...order,
              calculatedWeight: weight,
              weightUnit: 'kg'
            };
          } catch (error) {
            console.error(`Error calculating weight for order ${order.customerOrderId}:`, error);
            return {
              ...order,
              calculatedWeight: 0,
              weightUnit: 'kg'
            };
          }
        })
      );

      res.json({ success: true, data: ordersWithWeight });
    } catch (error) {
      console.error('Error fetching pending logistics orders:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø¬Ø³ØªÛŒÚ©' });
    }
  });

  // Assign logistics personnel to order
  app.post('/api/logistics/orders/:orderId/assign', requireAuth, async (req, res) => {
    try {
      const { logisticsAssigneeId, deliveryMethod, transportationType, estimatedDeliveryDate, notes } = req.body;
      
      const updatedOrder = await orderManagementStorage.updateOrderStatus(
        parseInt(req.params.orderId),
        'logistics_assigned',
        {
          logisticsAssigneeId,
          logisticsNotes: notes,
          estimatedDeliveryDate: estimatedDeliveryDate ? new Date(estimatedDeliveryDate) : undefined
        }
      );

      // Update delivery information
      if (deliveryMethod || transportationType) {
        await orderManagementStorage.updateDeliveryInfo(parseInt(req.params.orderId), {
          deliveryMethod,
          transportationType
        });
      }

      res.json({ success: true, data: updatedOrder });
    } catch (error) {
      console.error('Error assigning logistics personnel:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø®ØªØµØ§Øµ Ù¾Ø±Ø³Ù†Ù„ Ù„Ø¬Ø³ØªÛŒÚ©' });
    }
  });

  // =============================================================================
  // CARRIER DELIVERY AND VERIFICATION API ENDPOINTS
  // =============================================================================

  // Mark order as dispatched by carrier
  app.post('/api/order-management/:orderId/carrier-delivery', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { carrierName, carrierPhone, vehicleType, vehiclePlate, estimatedDeliveryTime, notes, deliveryCode } = req.body;
      
      console.log(`ðŸšš [CARRIER] Marking order ${orderId} as dispatched by carrier`);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      const { orderManagement } = await import('../shared/order-management-schema');
      
      // Update order with carrier dispatch information
      const [updatedOrder] = await db.update(orderManagement)
        .set({
          isCarrierDispatched: true,
          carrierDispatchedAt: new Date(),
          carrierName,
          carrierPhone,
          vehicleType,
          vehiclePlate,
          estimatedDeliveryDate: estimatedDeliveryTime ? new Date(estimatedDeliveryTime) : undefined,
          logisticsNotes: notes,
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderId))
        .returning();

      if (!updatedOrder) {
        return res.status(404).json({
          success: false,
          message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      res.json({
        success: true,
        message: 'Ø§Ø±Ø³Ø§Ù„ ØªÙˆØ³Ø· Ø­Ù…Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø«Ø¨Øª Ø´Ø¯',
        data: updatedOrder
      });
    } catch (error) {
      console.error('Error marking carrier delivery:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø±Ø³Ø§Ù„ ØªÙˆØ³Ø· Ø­Ù…Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡'
      });
    }
  });

  // Verify delivery with customer code
  app.post('/api/order-management/:orderId/verify-delivery', requireAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { 
        verificationCode, 
        customerLocation, 
        isVerified, 
        verifiedAt, 
        failureReason,
        // Carrier location data for geography analytics
        carrierLatitude,
        carrierLongitude,
        carrierLocationAccuracy,
        carrierLocationCapturedAt,
        carrierLocationSource
      } = req.body;
      
      console.log(`âœ… [VERIFICATION] Processing delivery verification for order ${orderId}`);
      
      const { db } = await import('./db');
      const { eq } = await import('drizzle-orm');
      const { orderManagement } = await import('../shared/order-management-schema');
      
      // Get current delivery code for this order
      const [currentOrder] = await db.select()
        .from(orderManagement)
        .where(eq(orderManagement.id, orderId))
        .limit(1);

      if (!currentOrder) {
        return res.status(404).json({
          success: false,
          message: 'Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯'
        });
      }

      // Check if verification code matches expected code
      const codeMatches = verificationCode === currentOrder.deliveryCode;
      
      if (!codeMatches) {
        return res.status(400).json({
          success: false,
          message: 'Ú©Ø¯ ØªØ­ÙˆÛŒÙ„ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª'
        });
      }

      // Update order with verification status and carrier location data
      const [updatedOrder] = await db.update(orderManagement)
        .set({
          isVerified: true,
          verifiedAt: new Date(),
          verificationLocation: customerLocation,
          actualDeliveryDate: new Date(),
          currentStatus: 'delivered',
          // Save carrier location data for geography analytics
          carrierLatitude: carrierLatitude || null,
          carrierLongitude: carrierLongitude || null,
          carrierLocationAccuracy: carrierLocationAccuracy || null,
          carrierLocationCapturedAt: carrierLocationCapturedAt ? new Date(carrierLocationCapturedAt) : null,
          carrierLocationSource: carrierLocationSource || 'mobile',
          updatedAt: new Date()
        })
        .where(eq(orderManagement.id, orderId))
        .returning();

      // Send carrier location data to geography analytics if available
      if (carrierLatitude && carrierLongitude && updatedOrder) {
        try {
          console.log(`ðŸŒ [GEOGRAPHY] Sending carrier location data to analytics for order ${orderId}`);
          console.log(`ðŸ“ [GEOGRAPHY] Latitude: ${carrierLatitude}, Longitude: ${carrierLongitude}, Accuracy: ${carrierLocationAccuracy}m`);
          
          // Here you would typically send to geography analytics service
          // For now, we'll just log the data that would be sent
          const geographyData = {
            orderId: orderId,
            customerOrderId: updatedOrder.customerOrderId,
            carrierLocation: {
              latitude: carrierLatitude,
              longitude: carrierLongitude,
              accuracy: carrierLocationAccuracy,
              capturedAt: carrierLocationCapturedAt,
              source: carrierLocationSource
            },
            deliveryInfo: {
              deliveredAt: updatedOrder.actualDeliveryDate,
              customerLocation: customerLocation,
              verificationCode: verificationCode
            },
            customerInfo: {
              name: `${updatedOrder.customerFirstName || ''} ${updatedOrder.customerLastName || ''}`.trim(),
              email: updatedOrder.customerEmail,
              phone: updatedOrder.customerPhone
            }
          };
          
          console.log(`ðŸ“Š [GEOGRAPHY] Data prepared for analytics:`, JSON.stringify(geographyData, null, 2));
          
          // In a real implementation, you would:
          // 1. Send to a geography analytics database
          // 2. Trigger analytics processing
          // 3. Update delivery route optimization
          // 4. Update carrier performance metrics
          
        } catch (geoError) {
          console.error('Error sending location data to geography analytics:', geoError);
          // Don't fail the main delivery verification if geography analytics fails
        }
      }

      res.json({
        success: true,
        message: 'ØªØ­ÙˆÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯',
        data: updatedOrder
      });
    } catch (error) {
      console.error('Error verifying delivery:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ ØªØ­ÙˆÛŒÙ„'
      });
    }
  });

  // =============================================================================
  // ORPHAN ORDERS MANAGEMENT API ENDPOINTS
  // =============================================================================

  // Get grace period orders statistics
  app.get("/api/orphan-orders/stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get grace period orders counts
      const statsResult = await pool.query(`
        SELECT 
          COUNT(CASE WHEN current_status = 'payment_grace_period' AND payment_grace_period_end > NOW() THEN 1 END) as active_grace_period,
          COUNT(CASE WHEN current_status = 'payment_grace_period' AND payment_grace_period_end <= NOW() THEN 1 END) as expired_grace_period,
          COUNT(CASE WHEN current_status = 'financial_approved' AND payment_grace_period_start IS NOT NULL THEN 1 END) as paid_grace_period,
          COUNT(CASE WHEN created_at::date = CURRENT_DATE THEN 1 END) as notifications_today
        FROM order_management
        WHERE payment_grace_period_start IS NOT NULL
      `);

      const stats = statsResult.rows[0];
      
      res.json({
        success: true,
        stats: {
          active: parseInt(stats.active_grace_period) || 0,
          expired: parseInt(stats.expired_grace_period) || 0,
          paid: parseInt(stats.paid_grace_period) || 0,
          notificationsToday: parseInt(stats.notifications_today) || 0
        }
      });
      
    } catch (error) {
      console.error("Error fetching orphan orders stats:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø³ÙØ§Ø±Ø´Ø§Øª Ù…ÙˆÙ‚Øª" 
      });
    }
  });

  // Orphan Orders Notification Management APIs
  app.get("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query('SELECT * FROM orphan_order_notification_settings ORDER BY id DESC LIMIT 1');
      
      if (result.rows.length === 0) {
        // Return default settings if none exist
        return res.json({
          success: true,
          settings: {
            notification_type: 'both',
            trigger_hours_before_expiry: [72, 48, 24, 12, 6],
            is_enabled: true,
            max_notifications_per_order: 5,
            notification_interval_hours: 12,
            send_to_admin: true,
            admin_notification_types: ['email']
          }
        });
      }
      
      res.json({
        success: true,
        settings: result.rows[0]
      });
    } catch (error) {
      console.error('Error fetching notification settings:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ' });
    }
  });

  app.put("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const {
        notification_type,
        trigger_hours_before_expiry,
        is_enabled,
        max_notifications_per_order,
        notification_interval_hours,
        send_to_admin,
        admin_notification_types
      } = req.body;

      const result = await pool.query(`
        UPDATE orphan_order_notification_settings 
        SET 
          notification_type = $1,
          trigger_hours_before_expiry = $2,
          is_enabled = $3,
          max_notifications_per_order = $4,
          notification_interval_hours = $5,
          send_to_admin = $6,
          admin_notification_types = $7,
          updated_at = NOW()
        WHERE id = (SELECT id FROM orphan_order_notification_settings ORDER BY id DESC LIMIT 1)
        RETURNING *
      `, [
        notification_type,
        trigger_hours_before_expiry,
        is_enabled,
        max_notifications_per_order,
        notification_interval_hours,
        send_to_admin,
        admin_notification_types
      ]);

      if (result.rows.length === 0) {
        // Create new settings if none exist
        const insertResult = await pool.query(`
          INSERT INTO orphan_order_notification_settings (
            notification_type, trigger_hours_before_expiry, is_enabled, 
            max_notifications_per_order, notification_interval_hours,
            send_to_admin, admin_notification_types
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING *
        `, [
          notification_type,
          trigger_hours_before_expiry,
          is_enabled,
          max_notifications_per_order,
          notification_interval_hours,
          send_to_admin,
          admin_notification_types
        ]);
        
        return res.json({
          success: true,
          settings: insertResult.rows[0]
        });
      }

      res.json({
        success: true,
        settings: result.rows[0]
      });
    } catch (error) {
      console.error('Error updating notification settings:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ' });
    }
  });

  app.get("/api/orphan-orders/templates", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const result = await pool.query('SELECT * FROM orphan_order_templates ORDER BY is_default DESC, created_at DESC');
      
      res.json({
        success: true,
        templates: result.rows
      });
    } catch (error) {
      console.error('Error fetching templates:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.post("/api/orphan-orders/templates", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const {
        template_name,
        template_type,
        subject,
        content,
        variables,
        is_active = true,
        is_default = false
      } = req.body;

      // If setting as default, remove default from others of same type
      if (is_default) {
        await pool.query(`
          UPDATE orphan_order_templates 
          SET is_default = false 
          WHERE template_type = $1
        `, [template_type]);
      }

      const result = await pool.query(`
        INSERT INTO orphan_order_templates (
          template_name, template_type, subject, content, variables, is_active, is_default
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *
      `, [template_name, template_type, subject, content, variables, is_active, is_default]);

      res.json({
        success: true,
        template: result.rows[0]
      });
    } catch (error) {
      console.error('Error creating template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.put("/api/orphan-orders/templates/:id", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const { id } = req.params;
      const {
        template_name,
        template_type,
        subject,
        content,
        variables,
        is_active,
        is_default
      } = req.body;

      // If setting as default, remove default from others of same type
      if (is_default) {
        await pool.query(`
          UPDATE orphan_order_templates 
          SET is_default = false 
          WHERE template_type = $1 AND id != $2
        `, [template_type, id]);
      }

      const result = await pool.query(`
        UPDATE orphan_order_templates 
        SET 
          template_name = $1,
          template_type = $2,
          subject = $3,
          content = $4,
          variables = $5,
          is_active = $6,
          is_default = $7,
          updated_at = NOW()
        WHERE id = $8
        RETURNING *
      `, [template_name, template_type, subject, content, variables, is_active, is_default, id]);

      res.json({
        success: true,
        template: result.rows[0]
      });
    } catch (error) {
      console.error('Error updating template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.delete("/api/orphan-orders/templates/:id", async (req, res) => {
    try {
      const { pool } = await import('./db');
      const { id } = req.params;

      await pool.query('DELETE FROM orphan_order_templates WHERE id = $1', [id]);

      res.json({
        success: true,
        message: 'Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯'
      });
    } catch (error) {
      console.error('Error deleting template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ù¾ÛŒØ§Ù…' });
    }
  });

  app.get("/api/orphan-orders/schedules", async (req, res) => {
    try {
      // Return scheduled notification data
      res.json({
        success: true,
        schedules: [
          {
            id: 1,
            name: 'ÛŒØ§Ø¯Ø¢ÙˆØ± Ø±ÙˆØ²Ø§Ù†Ù‡',
            frequency: 'daily',
            time: '10:00',
            enabled: true,
            last_run: new Date().toISOString()
          },
          {
            id: 2,
            name: 'ÛŒØ§Ø¯Ø¢ÙˆØ± Ù‡Ø´Ø¯Ø§Ø± Ù†Ù‡Ø§ÛŒÛŒ',
            frequency: 'hourly',
            time: null,
            enabled: true,
            last_run: new Date().toISOString()
          }
        ]
      });
    } catch (error) {
      console.error('Error fetching schedules:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒâ€ŒÙ‡Ø§' });
    }
  });

  app.get("/api/orphan-orders/stats", async (req, res) => {
    try {
      const { pool } = await import('./db');
      
      // Get active grace period orders count
      const activeResult = await pool.query(`
        SELECT COUNT(*) as active_count 
        FROM order_management 
        WHERE current_status = 'payment_grace_period' 
        AND payment_grace_period_end > NOW()
      `);
      
      // Get expired orders count (last 7 days)
      const expiredResult = await pool.query(`
        SELECT COUNT(*) as expired_count 
        FROM order_management 
        WHERE current_status = 'payment_grace_period' 
        AND payment_grace_period_end <= NOW()
        AND payment_grace_period_end >= NOW() - INTERVAL '7 days'
      `);
      
      // Get orders that transitioned from grace period to paid (last 30 days)
      const paidResult = await pool.query(`
        SELECT COUNT(*) as paid_count 
        FROM order_management 
        WHERE current_status NOT IN ('payment_grace_period') 
        AND payment_grace_period_start IS NOT NULL
        AND updated_at >= NOW() - INTERVAL '30 days'
      `);

      res.json({
        success: true,
        stats: {
          active: parseInt(activeResult.rows[0].active_count || 0),
          expired: parseInt(expiredResult.rows[0].expired_count || 0),
          paid: parseInt(paidResult.rows[0].paid_count || 0),
          notificationsToday: 0 // This would be tracked in a separate notifications log table
        }
      });
    } catch (error) {
      console.error('Error fetching orphan orders stats:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ø³ÙØ§Ø±Ø´Ø§Øª Ù…ÙˆÙ‚Øª',
        stats: { active: 0, expired: 0, paid: 0, notificationsToday: 0 }
      });
    }
  });

  // Get active grace period orders
  app.get("/api/orphan-orders/active", async (req, res) => {
    try {
      const { db } = await import('./db');
      const { eq, and, gt } = await import('drizzle-orm');
      const { orderManagement } = await import('../shared/order-management-schema');
      const { customerOrders } = await import('../shared/customer-schema');
      const { crmCustomers } = await import('../shared/schema');
      const { paymentReceipts } = await import('../shared/customer-schema');
      
      const result = await db.select({
        // Order Management fields
        id: orderManagement.id,
        customerOrderId: orderManagement.customerOrderId,
        currentStatus: orderManagement.currentStatus,
        createdAt: orderManagement.createdAt,
        gracePeriodExpires: orderManagement.paymentGracePeriodEnd,
        
        // Customer Order fields
        totalAmount: customerOrders.totalAmount,
        currency: customerOrders.currency,
        
        // Customer info from CRM
        customerFirstName: crmCustomers.firstName,
        customerLastName: crmCustomers.lastName,
        customerEmail: crmCustomers.email,
        customerPhone: crmCustomers.phone,
      })
      .from(orderManagement)
      .leftJoin(customerOrders, eq(orderManagement.customerOrderId, customerOrders.id))
      .leftJoin(crmCustomers, eq(customerOrders.customerId, crmCustomers.id))
      .where(
        and(
          eq(orderManagement.currentStatus, 'payment_grace_period'),
          gt(orderManagement.paymentGracePeriodEnd, new Date())
        )
      )
      .orderBy(orderManagement.paymentGracePeriodEnd);

      const orders = result.map((row: any) => {
        const hoursRemaining = row.gracePeriodExpires ? 
          Math.max(0, Math.floor((new Date(row.gracePeriodExpires).getTime() - new Date().getTime()) / (1000 * 60 * 60))) : 0;
        
        return {
          id: row.id,
          orderNumber: row.customerOrderId,
          totalAmount: row.totalAmount,
          currency: row.currency,
          createdAt: row.createdAt,
          gracePeriodExpires: row.gracePeriodExpires,
          hoursRemaining,
          customerName: `${row.customerFirstName || ''} ${row.customerLastName || ''}`.trim(),
          customerPhone: row.customerPhone || '',
          customerEmail: row.customerEmail || '',
          customer: {
            firstName: row.customerFirstName || '',
            lastName: row.customerLastName || '',
            email: row.customerEmail || '',
            phone: row.customerPhone || ''
          }
        };
      });

      res.json({
        success: true,
        orders
      });
      
    } catch (error) {
      console.error("Error fetching active grace period orders:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´Ø§Øª ÙØ¹Ø§Ù„" 
      });
    }
  });

  // Send reminder notification for grace period order
  app.post("/api/orphan-orders/:orderId/send-reminder", async (req, res) => {
    try {
      const { orderId } = req.params;
      const { type } = req.body; // 'sms' or 'email'
      
      const { pool } = await import('./db');
      
      // Get order details
      const orderResult = await pool.query(`
        SELECT 
          om.*,
          co.total_amount,
          co.currency,
          co.recipient_name,
          co.guest_email,
          co.recipient_phone,
          EXTRACT(EPOCH FROM (om.payment_grace_period_end - NOW()))/3600 as hours_remaining
        FROM order_management om
        LEFT JOIN customer_orders co ON om.customer_order_id = co.id
        WHERE om.id = $1 AND om.current_status = 'payment_grace_period'
      `, [orderId]);

      if (orderResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: "Ø³ÙØ§Ø±Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯"
        });
      }

      const order = orderResult.rows[0];
      
      // Send reminder based on type
      if (type === 'sms') {
        // Send SMS reminder
        // Implementation would go here
      } else if (type === 'email') {
        // Send email reminder
        // Implementation would go here
      }

      res.json({
        success: true,
        message: `ÛŒØ§Ø¯Ø¢ÙˆØ± ${type} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`
      });
      
    } catch (error) {
      console.error("Error sending reminder:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÛŒØ§Ø¯Ø¢ÙˆØ±"
      });
    }
  });

  // Get notification settings
  app.get("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      // Mock notification settings
      const settings = {
        emailEnabled: true,
        smsEnabled: true,
        reminderHours: [24, 12, 1],
        maxReminders: 3
      };

      res.json({
        success: true,
        settings
      });
    } catch (error) {
      console.error("Error fetching notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª"
      });
    }
  });

  // Update notification settings
  app.put("/api/orphan-orders/notification-settings", async (req, res) => {
    try {
      const { emailEnabled, smsEnabled, reminderHours, maxReminders } = req.body;
      
      // In a real implementation, save to database
      
      res.json({
        success: true,
        message: "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯",
        settings: {
          emailEnabled,
          smsEnabled,
          reminderHours,
          maxReminders
        }
      });
    } catch (error) {
      console.error("Error updating notification settings:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª"
      });
    }
  });

  // Get message templates
  app.get("/api/orphan-orders/templates", async (req, res) => {
    try {
      // Mock templates
      const templates = [
        {
          id: 1,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± 24 Ø³Ø§Ø¹ØªÙ‡",
          type: "email",
          subject: "ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø³ÙØ§Ø±Ø´",
          content: "Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ ØªØ§ 24 Ø³Ø§Ø¹Øª Ø¯ÛŒÚ¯Ø± Ù…Ù†Ù‚Ø¶ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯",
          isActive: true
        },
        {
          id: 2,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± SMS",
          type: "sms",
          subject: "",
          content: "Ø³ÙØ§Ø±Ø´ {{orderNumber}} ØªØ§ {{hours}} Ø³Ø§Ø¹Øª Ø¯ÛŒÚ¯Ø± Ù…Ù†Ù‚Ø¶ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯",
          isActive: true
        }
      ];

      res.json({
        success: true,
        templates
      });
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({
        success: false,
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚Ø§Ù„Ø¨â€ŒÙ‡Ø§"
      });
    }
  });

  // Get notification schedules
  app.get("/api/orphan-orders/schedules", async (req, res) => {
    try {
      // Mock schedules
      const schedules = [
        {
          id: 1,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± 24 Ø³Ø§Ø¹ØªÙ‡",
          triggerTime: "24 hours before expiry",
          messageType: "Email + SMS",
          maxSends: 1,
          isActive: true
        },
        {
          id: 2,
          name: "ÛŒØ§Ø¯Ø¢ÙˆØ± 1 Ø³Ø§Ø¹ØªÙ‡",
          triggerTime: "1 hour before expiry",
          messageType: "SMS only",
          maxSends: 1,
          isActive: true
        }
      ];

      res.json({
        success: true,
        schedules
      });
    } catch (error) {
      console.error("Error fetching schedules:", error);
      res.status(500).json({ 
        success: false, 
        message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ" 
      });
    }
  });

  // =============================================================================
  // SIMPLE SMS TEMPLATES API ENDPOINTS
  // =============================================================================

  // Get all simple SMS templates (no auth for testing)
  app.get("/api/admin/simple-sms-templates", async (req, res) => {
    try {
      console.log("ðŸš€ Fetching simple SMS templates...");
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      const templates = await simpleSmsStorage.getAllTemplates();
      console.log("ðŸ“‹ Templates fetched:", templates?.length || 0);
      
      res.json({
        success: true,
        data: templates
      });
    } catch (error) {
      console.error("âŒ Error fetching simple SMS templates:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch SMS templates"
      });
    }
  });

  // Get simple SMS template by ID
  app.get("/api/admin/simple-sms-templates/:id", async (req, res) => {
    try {
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      const template = await simpleSmsStorage.getTemplateById(parseInt(req.params.id));
      
      if (!template) {
        return res.status(404).json({
          success: false,
          message: "Template not found"
        });
      }
      
      res.json({
        success: true,
        data: template
      });
    } catch (error) {
      console.error("Error fetching simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch SMS template"
      });
    }
  });

  // Create new simple SMS template
  app.post("/api/admin/simple-sms-templates", async (req, res) => {
    try {
      const { insertSimpleSmsTemplateSchema } = await import('../shared/schema');
      const templateData = insertSimpleSmsTemplateSchema.parse(req.body);
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      
      const template = await simpleSmsStorage.createTemplate(templateData);
      
      res.status(201).json({
        success: true,
        data: template,
        message: "SMS template created successfully"
      });
    } catch (error) {
      console.error("Error creating simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to create SMS template"
      });
    }
  });

  // Update simple SMS template
  app.put("/api/admin/simple-sms-templates/:id", async (req, res) => {
    try {
      const { insertSimpleSmsTemplateSchema } = await import('../shared/schema');
      const updates = insertSimpleSmsTemplateSchema.partial().parse(req.body);
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      
      const template = await simpleSmsStorage.updateTemplate(parseInt(req.params.id), updates);
      
      res.json({
        success: true,
        data: template,
        message: "SMS template updated successfully"
      });
    } catch (error) {
      console.error("Error updating simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update SMS template"
      });
    }
  });

  // Delete simple SMS template
  app.delete("/api/admin/simple-sms-templates/:id", async (req, res) => {
    try {
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      await simpleSmsStorage.deleteTemplate(parseInt(req.params.id));
      
      res.json({
        success: true,
        message: "SMS template deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting simple SMS template:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete SMS template"
      });
    }
  });

  // Increment template usage count
  app.post("/api/admin/simple-sms-templates/:id/increment-usage", async (req, res) => {
    try {
      const { simpleSmsStorage } = await import('./simple-sms-storage');
      await simpleSmsStorage.incrementTemplateUsage(parseInt(req.params.id));
      
      res.json({
        success: true,
        message: "Template usage incremented"
      });
    } catch (error) {
      console.error("Error incrementing template usage:", error);
      res.status(500).json({
        success: false,
        message: "Failed to increment template usage"
      });
    }
  });

  // Get Template #05 directly via emailStorage
  app.get("/api/template05-direct", async (req, res) => {
    try {
      console.log('ðŸ” Fetching Template #05 directly via emailStorage');
      
      const { emailStorage } = await import("./email-storage");
      const templates = await emailStorage.getAllTemplates();
      
      const template05 = templates.find(t => 
        t.name === '#05 - Momtaz Chemical Follow-up Response' ||
        t.templateName === '#05 - Momtaz Chemical Follow-up Response'
      );
      
      if (!template05) {
        return res.status(404).json({
          success: false,
          message: "Template #05 not found",
          availableTemplates: templates.map(t => t.name || t.templateName)
        });
      }
      
      console.log('âœ… Template #05 found:', {
        id: template05.id,
        name: template05.name || template05.templateName,
        contentLength: (template05.htmlContent || template05.html_content || '').length
      });
      
      res.json({
        success: true,
        data: {
          id: template05.id,
          name: template05.name || template05.templateName,
          subject: template05.subject,
          html_content: template05.htmlContent || template05.html_content,
          category: template05.category || template05.categoryName,
          language: template05.language || 'fa',
          created_at: template05.createdAt || template05.created_at
        }
      });
    } catch (error) {
      console.error("âŒ Error fetching Template #05:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch Template #05",
        error: error.message
      });
    }
  });

  // Catch-all for unmatched API routes - return JSON 404
  app.all('/api/*', (req, res) => {
    console.log(`âŒ 404 - Unmatched API route: ${req.method} ${req.originalUrl}`);
    res.status(404).json({
      success: false,
      message: 'API endpoint not found',
      path: req.originalUrl,
      method: req.method
    });
  });

  // Test sequential delivery code generation
  app.post("/api/test/sequential-code", async (req, res) => {
    try {
      const { customerOrderId, customerPhone, customerName } = req.body;
      
      if (!customerOrderId || !customerPhone || !customerName) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: customerOrderId, customerPhone, customerName"
        });
      }

      const result = await logisticsStorage.generateVerificationCode(
        customerOrderId,
        customerPhone,
        customerName
      );

      res.json({
        success: true,
        data: result,
        message: "Sequential delivery code generated successfully"
      });
    } catch (error) {
      console.error("Error generating sequential code:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate sequential code",
        error: error.message
      });
    }
  });

  // Email Templates API endpoints - REMOVED DUPLICATE (already defined above)

  app.post('/api/email-templates', requireAuth, async (req: Request, res: Response) => {
    try {
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      
      // Generate unique template number
      const templateCount = await db.select({ count: sql<number>`count(*)` }).from(emailTemplates);
      const templateNumber = `TPL-${String(templateCount[0].count + 1).padStart(4, '0')}`;
      
      const [newTemplate] = await db.insert(emailTemplates).values({
        ...validatedData,
        templateNumber,
        updatedAt: new Date()
      }).returning();

      res.status(201).json({ success: true, data: newTemplate });
    } catch (error) {
      console.error('Error creating email template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„' });
    }
  });

  app.put('/api/email-templates/:id', requireAuth, async (req: Request, res: Response) => {
    try {
      const templateId = parseInt(req.params.id);
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      
      const [updatedTemplate] = await db.update(emailTemplates)
        .set({
          ...validatedData,
          updatedAt: new Date()
        })
        .where(eq(emailTemplates.id, templateId))
        .returning();

      if (!updatedTemplate) {
        return res.status(404).json({ success: false, message: 'Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, data: updatedTemplate });
    } catch (error) {
      console.error('Error updating email template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„' });
    }
  });

  app.delete('/api/email-templates/:id', requireAuth, async (req: Request, res: Response) => {
    try {
      const templateId = parseInt(req.params.id);
      
      const deletedTemplate = await db.delete(emailTemplates)
        .where(eq(emailTemplates.id, templateId))
        .returning();

      if (!deletedTemplate.length) {
        return res.status(404).json({ success: false, message: 'Ù‚Ø§Ù„Ø¨ ÛŒØ§ÙØª Ù†Ø´Ø¯' });
      }

      res.json({ success: true, message: 'Ù‚Ø§Ù„Ø¨ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯' });
    } catch (error) {
      console.error('Error deleting email template:', error);
      res.status(500).json({ success: false, message: 'Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ø§ÛŒÙ…ÛŒÙ„' });
    }
  });

  // Global error handler for all API routes
  app.use('/api/*', (err: any, req: Request, res: Response, next: NextFunction) => {
    console.error('API Error:', err);
    
    // Ensure JSON response even for errors
    if (!res.headersSent) {
      res.status(err.status || 500).json({
        success: false,
        message: err.message || 'Internal server error',
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
      });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
